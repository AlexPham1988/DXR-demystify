# 1 "<built-in>"
# 1 "CpfRetentionStrategy.cc"
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author : Rajaditya Mukherjee

#if 0 /* expanded by -frewrite-includes */
#include <list>
#endif /* expanded by -frewrite-includes */
# 8 "CpfRetentionStrategy.cc"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 1 3
// <list> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/list
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_LIST
#define _GLIBCXX_LIST 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 1 3
// Core algorithmic facilities -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_algobase.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */

#ifndef _STL_ALGOBASE_H
#define _STL_ALGOBASE_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 1 3
// Predefined symbols and macros -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/c++config.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */

#ifndef _GLIBCXX_CXX_CONFIG_H
#define _GLIBCXX_CXX_CONFIG_H 1

// The current version of the C++ library in compressed ISO date format.
#define __GLIBCXX__ 20150716

// Macros for various attributes.
//   _GLIBCXX_PURE
//   _GLIBCXX_CONST
//   _GLIBCXX_NORETURN
//   _GLIBCXX_NOTHROW
//   _GLIBCXX_VISIBILITY
#ifndef _GLIBCXX_PURE
# define _GLIBCXX_PURE __attribute__ ((__pure__))
#endif
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_CONST
# define _GLIBCXX_CONST __attribute__ ((__const__))
#endif
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_NORETURN
# define _GLIBCXX_NORETURN __attribute__ ((__noreturn__))
#endif
# 53 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// See below for C++
#ifndef _GLIBCXX_NOTHROW
# ifndef __cplusplus
#  define _GLIBCXX_NOTHROW __attribute__((__nothrow__))
# endif
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#endif
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macros for visibility attributes.
//   _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY
//   _GLIBCXX_VISIBILITY
# define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY 1

#if _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY
# define _GLIBCXX_VISIBILITY(V) __attribute__ ((__visibility__ (#V)))
#else
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
// If this is not supplied by the OS-specific or CPU-specific
// headers included below, it will be defined to an empty default.
# define _GLIBCXX_VISIBILITY(V) _GLIBCXX_PSEUDO_VISIBILITY(V)
#endif
# 73 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macros for deprecated attributes.
//   _GLIBCXX_USE_DEPRECATED
//   _GLIBCXX_DEPRECATED
#ifndef _GLIBCXX_USE_DEPRECATED
# define _GLIBCXX_USE_DEPRECATED 1
#endif
# 80 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined(__DEPRECATED) && (__cplusplus >= 201103L)
# define _GLIBCXX_DEPRECATED __attribute__ ((__deprecated__))
#else
# 84 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# define _GLIBCXX_DEPRECATED
#endif
# 86 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macros for ABI tag attributes.
#ifndef _GLIBCXX_ABI_TAG_CXX11
# define _GLIBCXX_ABI_TAG_CXX11 __attribute ((__abi_tag__ ("cxx11")))
#endif
# 91 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3


#if __cplusplus

// Macro for constexpr, to support in mixed 03/0x mode.
#ifndef _GLIBCXX_CONSTEXPR
# if __cplusplus >= 201103L
#  define _GLIBCXX_CONSTEXPR constexpr
#  define _GLIBCXX_USE_CONSTEXPR constexpr
# else
# 101 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#  define _GLIBCXX_CONSTEXPR
#  define _GLIBCXX_USE_CONSTEXPR const
# endif
# 104 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#endif
# 105 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX14_CONSTEXPR
# if __cplusplus >= 201402L
#  define _GLIBCXX14_CONSTEXPR constexpr
# else
# 110 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#  define _GLIBCXX14_CONSTEXPR
# endif
# 112 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#endif
# 113 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macro for noexcept, to support in mixed 03/0x mode.
#ifndef _GLIBCXX_NOEXCEPT
# if __cplusplus >= 201103L
#  define _GLIBCXX_NOEXCEPT noexcept
#  define _GLIBCXX_USE_NOEXCEPT noexcept
#  define _GLIBCXX_THROW(_EXC)
# else
# 121 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#  define _GLIBCXX_NOEXCEPT
#  define _GLIBCXX_USE_NOEXCEPT throw()
#  define _GLIBCXX_THROW(_EXC) throw(_EXC)
# endif
# 125 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#endif
# 126 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_NOTHROW
# define _GLIBCXX_NOTHROW _GLIBCXX_USE_NOEXCEPT
#endif
# 130 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_THROW_OR_ABORT
# if __cpp_exceptions
#  define _GLIBCXX_THROW_OR_ABORT(_EXC) (throw (_EXC))
# else
# 135 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#  define _GLIBCXX_THROW_OR_ABORT(_EXC) (__builtin_abort())
# endif
# 137 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#endif
# 138 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macro for extern template, ie controling template linkage via use
// of extern keyword on template declaration. As documented in the g++
// manual, it inhibits all implicit instantiations and is used
// throughout the library to avoid multiple weak definitions for
// required types that are already explicitly instantiated in the
// library binary. This substantially reduces the binary size of
// resulting executables.
// Special case: _GLIBCXX_EXTERN_TEMPLATE == -1 disallows extern
// templates only in basic_string, thus activating its debug-mode
// checks even at -O0.
# define _GLIBCXX_EXTERN_TEMPLATE 1

/*
  Outline of libstdc++ namespaces.

  namespace std
  {
    namespace __debug { }
    namespace __parallel { }
    namespace __profile { }
    namespace __cxx1998 { }

    namespace __detail { }

    namespace rel_ops { }

    namespace tr1
    {
      namespace placeholders { }
      namespace regex_constants { }
      namespace __detail { }
    }

    namespace tr2 { }
    
    namespace decimal { }

    namespace chrono { }
    namespace placeholders { }
    namespace regex_constants { }
    namespace this_thread { }

    namespace experimental { }
  }

  namespace abi { }

  namespace __gnu_cxx
  {
    namespace __detail { }
  }

  For full details see:
  http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespaces.html
*/
namespace std
{
  typedef __SIZE_TYPE__ 	size_t;
  typedef __PTRDIFF_TYPE__	ptrdiff_t;

#if __cplusplus >= 201103L
  typedef decltype(nullptr)	nullptr_t;
#endif
# 202 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
}

# define _GLIBCXX_USE_DUAL_ABI 1

#if ! _GLIBCXX_USE_DUAL_ABI
// Ignore any pre-defined value of _GLIBCXX_USE_CXX11_ABI
# undef _GLIBCXX_USE_CXX11_ABI
#endif
# 210 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_USE_CXX11_ABI
# define _GLIBCXX_USE_CXX11_ABI 1
#endif
# 214 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if _GLIBCXX_USE_CXX11_ABI
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# define _GLIBCXX_NAMESPACE_CXX11 __cxx11::
# define _GLIBCXX_BEGIN_NAMESPACE_CXX11 namespace __cxx11 {
# define _GLIBCXX_END_NAMESPACE_CXX11 }
# define _GLIBCXX_DEFAULT_ABI_TAG _GLIBCXX_ABI_TAG_CXX11
#else
# 229 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# define _GLIBCXX_NAMESPACE_CXX11
# define _GLIBCXX_BEGIN_NAMESPACE_CXX11
# define _GLIBCXX_END_NAMESPACE_CXX11
# define _GLIBCXX_DEFAULT_ABI_TAG
#endif
# 234 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3


// Defined if inline namespaces are used for versioning.
# define _GLIBCXX_INLINE_VERSION 0 

// Inline namespace for symbol versioning.
#if _GLIBCXX_INLINE_VERSION

namespace std
{
  inline namespace __7 { }

  namespace rel_ops { inline namespace __7 { } }

  namespace tr1
  {
    inline namespace __7 { }
    namespace placeholders { inline namespace __7 { } }
    namespace regex_constants { inline namespace __7 { } }
    namespace __detail { inline namespace __7 { } }
  }

  namespace tr2
  { inline namespace __7 { } }

  namespace decimal { inline namespace __7 { } }

  namespace chrono { inline namespace __7 { } }
  namespace placeholders { inline namespace __7 { } }
  namespace regex_constants { inline namespace __7 { } }
  namespace this_thread { inline namespace __7 { } }

  namespace experimental { inline namespace __7 { } }

  namespace __detail { inline namespace __7 { } }
}

namespace __gnu_cxx
{
  inline namespace __7 { }
  namespace __detail { inline namespace __7 { } }
}
# define _GLIBCXX_BEGIN_NAMESPACE_VERSION namespace __7 {
# define _GLIBCXX_END_NAMESPACE_VERSION }
#else
# 279 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# define _GLIBCXX_BEGIN_NAMESPACE_VERSION
# define _GLIBCXX_END_NAMESPACE_VERSION
#endif
# 282 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3


// Inline namespaces for special modes: debug, parallel, profile.
#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL) \
    || defined(_GLIBCXX_PROFILE)
namespace std
{
  // Non-inline namespace for components replaced by alternates in active mode.
  namespace __cxx1998
  {
# if _GLIBCXX_INLINE_VERSION
  inline namespace __7 { }
# endif
# 295 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

# if _GLIBCXX_USE_CXX11_ABI
  inline namespace __cxx11 __attribute__((__abi_tag__)) { }
# endif
# 299 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
  }

  // Inline namespace for debug mode.
# ifdef _GLIBCXX_DEBUG
  inline namespace __debug { }
# endif
# 305 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

  // Inline namespaces for parallel mode.
# ifdef _GLIBCXX_PARALLEL
  inline namespace __parallel { }
# endif
# 310 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

  // Inline namespaces for profile mode
# ifdef _GLIBCXX_PROFILE
  inline namespace __profile { }
# endif
# 315 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
}

// Check for invalid usage and unsupported mixed-mode use.
# if defined(_GLIBCXX_DEBUG) && defined(_GLIBCXX_PARALLEL)
#  error illegal use of multiple inlined namespaces
# endif
# 321 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# if defined(_GLIBCXX_PROFILE) && defined(_GLIBCXX_DEBUG)
#  error illegal use of multiple inlined namespaces
# endif
# 324 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# if defined(_GLIBCXX_PROFILE) && defined(_GLIBCXX_PARALLEL)
#  error illegal use of multiple inlined namespaces
# endif
# 327 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Check for invalid use due to lack for weak symbols.
# if __NO_INLINE__ && !__GXX_WEAK__
#  warning currently using inlined namespace mode which may fail \
   without inlining due to lack of weak symbols
# endif
# 333 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#endif
# 334 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macros for namespace scope. Either namespace std:: or the name
// of some nested namespace within it corresponding to the active mode.
// _GLIBCXX_STD_A
// _GLIBCXX_STD_C
//
// Macros for opening/closing conditional namespaces.
// _GLIBCXX_BEGIN_NAMESPACE_ALGO
// _GLIBCXX_END_NAMESPACE_ALGO
// _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
// _GLIBCXX_END_NAMESPACE_CONTAINER
#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PROFILE)
# define _GLIBCXX_STD_C __cxx1998
# define _GLIBCXX_BEGIN_NAMESPACE_CONTAINER \
	 namespace _GLIBCXX_STD_C { _GLIBCXX_BEGIN_NAMESPACE_VERSION
# define _GLIBCXX_END_NAMESPACE_CONTAINER \
	 _GLIBCXX_END_NAMESPACE_VERSION }
# undef _GLIBCXX_EXTERN_TEMPLATE
# define _GLIBCXX_EXTERN_TEMPLATE -1
#endif
# 354 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifdef _GLIBCXX_PARALLEL
# define _GLIBCXX_STD_A __cxx1998
# define _GLIBCXX_BEGIN_NAMESPACE_ALGO \
	 namespace _GLIBCXX_STD_A { _GLIBCXX_BEGIN_NAMESPACE_VERSION
# define _GLIBCXX_END_NAMESPACE_ALGO \
	 _GLIBCXX_END_NAMESPACE_VERSION }
#endif
# 362 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_STD_A
# define _GLIBCXX_STD_A std
#endif
# 366 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_STD_C
# define _GLIBCXX_STD_C std
#endif
# 370 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_BEGIN_NAMESPACE_ALGO
# define _GLIBCXX_BEGIN_NAMESPACE_ALGO
#endif
# 374 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_END_NAMESPACE_ALGO
# define _GLIBCXX_END_NAMESPACE_ALGO
#endif
# 378 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
# define _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
#endif
# 382 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#ifndef _GLIBCXX_END_NAMESPACE_CONTAINER
# define _GLIBCXX_END_NAMESPACE_CONTAINER
#endif
# 386 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// GLIBCXX_ABI Deprecated
// Define if compatibility should be provided for -mlong-double-64.
#undef _GLIBCXX_LONG_DOUBLE_COMPAT

// Inline namespace for long double 128 mode.
#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
namespace std
{
  inline namespace __gnu_cxx_ldbl128 { }
}
# define _GLIBCXX_NAMESPACE_LDBL __gnu_cxx_ldbl128::
# define _GLIBCXX_BEGIN_NAMESPACE_LDBL namespace __gnu_cxx_ldbl128 {
# define _GLIBCXX_END_NAMESPACE_LDBL }
#else
# 401 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# define _GLIBCXX_NAMESPACE_LDBL
# define _GLIBCXX_BEGIN_NAMESPACE_LDBL
# define _GLIBCXX_END_NAMESPACE_LDBL
#endif
# 405 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#if _GLIBCXX_USE_CXX11_ABI
# define _GLIBCXX_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_NAMESPACE_CXX11
# define _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_BEGIN_NAMESPACE_CXX11
# define _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_END_NAMESPACE_CXX11
#else
# 410 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# define _GLIBCXX_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_NAMESPACE_LDBL
# define _GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_BEGIN_NAMESPACE_LDBL
# define _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11 _GLIBCXX_END_NAMESPACE_LDBL
#endif
# 414 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Assert.
#if !defined(_GLIBCXX_DEBUG) && !defined(_GLIBCXX_PARALLEL)
# define __glibcxx_assert(_Condition)
#else
# 419 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
namespace std
{
  // Avoid the use of assert, because we're trying to keep the <cassert>
  // include out of the mix.
  inline void
  __replacement_assert(const char* __file, int __line,
		       const char* __function, const char* __condition)
  {
    __builtin_printf("%s:%d: %s: Assertion '%s' failed.\n", __file, __line,
		     __function, __condition);
    __builtin_abort();
  }
}
#define __glibcxx_assert(_Condition)				   	 \
  do 									 \
  {							      		 \
    if (! (_Condition))                                                  \
      std::__replacement_assert(__FILE__, __LINE__, __PRETTY_FUNCTION__, \
				#_Condition);				 \
  } while (false)
#endif
# 440 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macros for race detectors.
// _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) and
// _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) should be used to explain
// atomic (lock-free) synchronization to race detectors:
// the race detector will infer a happens-before arc from the former to the
// latter when they share the same argument pointer.
//
// The most frequent use case for these macros (and the only case in the
// current implementation of the library) is atomic reference counting:
//   void _M_remove_reference()
//   {
//     _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
//     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) <= 0)
//       {
//         _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
//         _M_destroy(__a);
//       }
//   }
// The annotations in this example tell the race detector that all memory
// accesses occurred when the refcount was positive do not race with
// memory accesses which occurred after the refcount became zero.
#ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE
# define  _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A)
#endif
# 465 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
#ifndef _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER
# define  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A)
#endif
# 468 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Macros for C linkage: define extern "C" linkage only when using C++.
# define _GLIBCXX_BEGIN_EXTERN_C extern "C" {
# define _GLIBCXX_END_EXTERN_C }

#else // !__cplusplus
# 474 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# define _GLIBCXX_BEGIN_EXTERN_C
# define _GLIBCXX_END_EXTERN_C
#endif
# 477 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3


// First includes.

// Pick up any OS-specific definitions.
#if 0 /* expanded by -frewrite-includes */
#include <bits/os_defines.h>
#endif /* expanded by -frewrite-includes */
# 482 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/os_defines.h" 1 3
// Specific definitions for GNU/Linux  -*- C++ -*-

// Copyright (C) 2000-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/os_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */

#ifndef _GLIBCXX_OS_DEFINES
#define _GLIBCXX_OS_DEFINES 1

// System-specific #define, typedefs, corrections, etc, go here.  This
// file will come before all others.

// This keeps isanum, et al from being propagated as macros.
#define __NO_CTYPE 1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
/* Copyright (C) 1991-1993,1995-2007,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef	_FEATURES_H
#define	_FEATURES_H	1

/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
   _SVID_SOURCE		ISO C, POSIX, and SVID things.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _REENTRANT		Select additionally reentrant object.
   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
			measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
   If none of these are defined, the default is to have _SVID_SOURCE,
   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200112L.  If more than one of these are defined, they accumulate.
   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
   together give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_BSD		Define 4.3BSD things.
   __USE_SVID		Define SVID things.
   __USE_MISC		Define things common to BSD and System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
   __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
#undef	__USE_ISOC99
#undef	__USE_ISOC95
#undef	__USE_POSIX
#undef	__USE_POSIX2
#undef	__USE_POSIX199309
#undef	__USE_POSIX199506
#undef	__USE_XOPEN
#undef	__USE_XOPEN_EXTENDED
#undef	__USE_UNIX98
#undef	__USE_XOPEN2K
#undef	__USE_XOPEN2KXSI
#undef	__USE_XOPEN2K8
#undef	__USE_XOPEN2K8XSI
#undef	__USE_LARGEFILE
#undef	__USE_LARGEFILE64
#undef	__USE_FILE_OFFSET64
#undef	__USE_BSD
#undef	__USE_SVID
#undef	__USE_MISC
#undef	__USE_ATFILE
#undef	__USE_GNU
#undef	__USE_REENTRANT
#undef	__USE_FORTIFY_LEVEL
#undef	__FAVOR_BSD
#undef	__KERNEL_STRICT_NAMES

/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */
#ifndef _LOOSE_KERNEL_NAMES
# define __KERNEL_STRICT_NAMES
#endif
# 127 "/usr/include/features.h" 3 4

/* Always use ISO C things.  */
#define	__USE_ANSI	1

/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */
#if defined __GNUC__ && defined __GNUC_MINOR__
# define __GNUC_PREREQ(maj, min) \
	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
#else
# 142 "/usr/include/features.h" 3 4
# define __GNUC_PREREQ(maj, min) 0
#endif
# 144 "/usr/include/features.h" 3 4


/* If _BSD_SOURCE was defined by the user, favor BSD over POSIX.  */
#if defined _BSD_SOURCE && \
    !(defined _POSIX_SOURCE || defined _POSIX_C_SOURCE || \
      defined _XOPEN_SOURCE || defined _GNU_SOURCE || defined _SVID_SOURCE)
# define __FAVOR_BSD	1
#endif
# 152 "/usr/include/features.h" 3 4

/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
#ifdef _GNU_SOURCE
# undef  _ISOC95_SOURCE
# define _ISOC95_SOURCE	1
# undef  _ISOC99_SOURCE
# define _ISOC99_SOURCE	1
# undef  _POSIX_SOURCE
# define _POSIX_SOURCE	1
# undef  _POSIX_C_SOURCE
# define _POSIX_C_SOURCE	200809L
# undef  _XOPEN_SOURCE
# define _XOPEN_SOURCE	700
# undef  _XOPEN_SOURCE_EXTENDED
# define _XOPEN_SOURCE_EXTENDED	1
# undef	 _LARGEFILE64_SOURCE
# define _LARGEFILE64_SOURCE	1
# undef  _BSD_SOURCE
# define _BSD_SOURCE	1
# undef  _SVID_SOURCE
# define _SVID_SOURCE	1
# undef  _ATFILE_SOURCE
# define _ATFILE_SOURCE	1
#endif
# 176 "/usr/include/features.h" 3 4

/* If nothing (other than _GNU_SOURCE) is defined,
   define _BSD_SOURCE and _SVID_SOURCE.  */
#if (!defined __STRICT_ANSI__ && !defined _ISOC99_SOURCE && \
     !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE && \
     !defined _XOPEN_SOURCE && !defined _BSD_SOURCE && !defined _SVID_SOURCE)
# define _BSD_SOURCE	1
# define _SVID_SOURCE	1
#endif
# 185 "/usr/include/features.h" 3 4

/* This is to enable the ISO C99 extension.  Also recognize the old macro
   which was used prior to the standard acceptance.  This macro will
   eventually go away and the features enabled by default once the ISO C99
   standard is widely adopted.  */
#if (defined _ISOC99_SOURCE || defined _ISOC9X_SOURCE \
     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))
# define __USE_ISOC99	1
#endif
# 194 "/usr/include/features.h" 3 4

/* This is to enable the ISO C90 Amendment 1:1995 extension.  */
#if (defined _ISOC99_SOURCE || defined _ISOC9X_SOURCE \
     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199409L))
# define __USE_ISOC95	1
#endif
# 200 "/usr/include/features.h" 3 4

/* If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2
   (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).  */
#if ((!defined __STRICT_ANSI__ || (_XOPEN_SOURCE - 0) >= 500) && \
     !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE)
# define _POSIX_SOURCE	1
# if defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500
#  define _POSIX_C_SOURCE	2
# elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600
# 209 "/usr/include/features.h" 3 4
#  define _POSIX_C_SOURCE	199506L
# elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 700
# 211 "/usr/include/features.h" 3 4
#  define _POSIX_C_SOURCE	200112L
# else
# 213 "/usr/include/features.h" 3 4
#  define _POSIX_C_SOURCE	200809L
# endif
# 215 "/usr/include/features.h" 3 4
# define __USE_POSIX_IMPLICITLY	1
#endif
# 217 "/usr/include/features.h" 3 4

#if defined _POSIX_SOURCE || _POSIX_C_SOURCE >= 1 || defined _XOPEN_SOURCE
# define __USE_POSIX	1
#endif
# 221 "/usr/include/features.h" 3 4

#if defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCE
# define __USE_POSIX2	1
#endif
# 225 "/usr/include/features.h" 3 4

#if (_POSIX_C_SOURCE - 0) >= 199309L
# define __USE_POSIX199309	1
#endif
# 229 "/usr/include/features.h" 3 4

#if (_POSIX_C_SOURCE - 0) >= 199506L
# define __USE_POSIX199506	1
#endif
# 233 "/usr/include/features.h" 3 4

#if (_POSIX_C_SOURCE - 0) >= 200112L
# define __USE_XOPEN2K		1
# undef __USE_ISOC95
# define __USE_ISOC95		1
# undef __USE_ISOC99
# define __USE_ISOC99		1
#endif
# 241 "/usr/include/features.h" 3 4

#if (_POSIX_C_SOURCE - 0) >= 200809L
# define __USE_XOPEN2K8		1
# undef  _ATFILE_SOURCE
# define _ATFILE_SOURCE	1
#endif
# 247 "/usr/include/features.h" 3 4

#ifdef	_XOPEN_SOURCE
# define __USE_XOPEN	1
# if (_XOPEN_SOURCE - 0) >= 500
#  define __USE_XOPEN_EXTENDED	1
#  define __USE_UNIX98	1
#  undef _LARGEFILE_SOURCE
#  define _LARGEFILE_SOURCE	1
#  if (_XOPEN_SOURCE - 0) >= 600
#   if (_XOPEN_SOURCE - 0) >= 700
#    define __USE_XOPEN2K8	1
#    define __USE_XOPEN2K8XSI	1
#   endif
# 260 "/usr/include/features.h" 3 4
#   define __USE_XOPEN2K	1
#   define __USE_XOPEN2KXSI	1
#   undef __USE_ISOC95
#   define __USE_ISOC95		1
#   undef __USE_ISOC99
#   define __USE_ISOC99		1
#  endif
# 267 "/usr/include/features.h" 3 4
# else
# 268 "/usr/include/features.h" 3 4
#  ifdef _XOPEN_SOURCE_EXTENDED
#   define __USE_XOPEN_EXTENDED	1
#  endif
# 271 "/usr/include/features.h" 3 4
# endif
# 272 "/usr/include/features.h" 3 4
#endif
# 273 "/usr/include/features.h" 3 4

#ifdef _LARGEFILE_SOURCE
# define __USE_LARGEFILE	1
#endif
# 277 "/usr/include/features.h" 3 4

#ifdef _LARGEFILE64_SOURCE
# define __USE_LARGEFILE64	1
#endif
# 281 "/usr/include/features.h" 3 4

#if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
# define __USE_FILE_OFFSET64	1
#endif
# 285 "/usr/include/features.h" 3 4

#if defined _BSD_SOURCE || defined _SVID_SOURCE
# define __USE_MISC	1
#endif
# 289 "/usr/include/features.h" 3 4

#ifdef	_BSD_SOURCE
# define __USE_BSD	1
#endif
# 293 "/usr/include/features.h" 3 4

#ifdef	_SVID_SOURCE
# define __USE_SVID	1
#endif
# 297 "/usr/include/features.h" 3 4

#ifdef	_ATFILE_SOURCE
# define __USE_ATFILE	1
#endif
# 301 "/usr/include/features.h" 3 4

#ifdef	_GNU_SOURCE
# define __USE_GNU	1
#endif
# 305 "/usr/include/features.h" 3 4

#if defined _REENTRANT || defined _THREAD_SAFE
# define __USE_REENTRANT	1
#endif
# 309 "/usr/include/features.h" 3 4

#if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0 \
    && defined __OPTIMIZE__ && __OPTIMIZE__ > 0
# if !__GNUC_PREREQ (4, 1)
#  ifdef __GNUC_RH_RELEASE__
#   warning _FORTIFY_SOURCE supported only with GCC 4.1 and later
#  endif
# 316 "/usr/include/features.h" 3 4
#  define __USE_FORTIFY_LEVEL 0
# elif _FORTIFY_SOURCE > 1
# 318 "/usr/include/features.h" 3 4
#  define __USE_FORTIFY_LEVEL 2
# else
# 320 "/usr/include/features.h" 3 4
#  define __USE_FORTIFY_LEVEL 1
# endif
# 322 "/usr/include/features.h" 3 4
#else
# 323 "/usr/include/features.h" 3 4
# define __USE_FORTIFY_LEVEL 0
#endif
# 325 "/usr/include/features.h" 3 4

/* We do support the IEC 559 math functionality, real and complex.  */
#define __STDC_IEC_559__		1
#define __STDC_IEC_559_COMPLEX__	1

/* wchar_t uses ISO 10646-1 (2nd ed., published 2000-09-15) / Unicode 3.1.  */
#define __STDC_ISO_10646__		200009L

/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */
#undef  __GNU_LIBRARY__
#define __GNU_LIBRARY__ 6

/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */
#define	__GLIBC__	2
#define	__GLIBC_MINOR__	12

#define __GLIBC_PREREQ(maj, min) \
	((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))

/* Decide whether a compiler supports the long long datatypes.  */
#if defined __GNUC__ \
    || (defined __PGI && defined __i386__ ) \
    || (defined __INTEL_COMPILER && (defined __i386__ || defined __ia64__)) \
    || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)
# define __GLIBC_HAVE_LONG_LONG	1
#endif
# 357 "/usr/include/features.h" 3 4

/* This is here only because every header file already includes this one.  */
#ifndef __ASSEMBLER__
# ifndef _SYS_CDEFS_H
#if 0 /* expanded by -frewrite-includes */
#  include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 361 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2001, 2002, 2004, 2005, 2006, 2007, 2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef	_SYS_CDEFS_H
#define	_SYS_CDEFS_H	1

/* We are almost always included from features.h. */
#ifndef _FEATURES_H
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 25 "/usr/include/sys/cdefs.h" 3 4
# 26 "/usr/include/sys/cdefs.h" 3 4
#endif
# 27 "/usr/include/sys/cdefs.h" 3 4

/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */
#if defined __GNUC__ && !defined __STDC__
# error "You need a ISO C conforming compiler to use the glibc headers"
#endif
# 34 "/usr/include/sys/cdefs.h" 3 4

/* Some user header file might have defined this before.  */
#undef	__P
#undef	__PMT

#ifdef __GNUC__

/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */
# if !defined __cplusplus && __GNUC_PREREQ (3, 3)
#  define __THROW	__attribute__ ((__nothrow__))
#  define __NTH(fct)	__attribute__ ((__nothrow__)) fct
# else
# 50 "/usr/include/sys/cdefs.h" 3 4
#  if defined __cplusplus && __GNUC_PREREQ (2,8)
#   define __THROW	throw ()
#   define __NTH(fct)	fct throw ()
#  else
# 54 "/usr/include/sys/cdefs.h" 3 4
#   define __THROW
#   define __NTH(fct)	fct
#  endif
# 57 "/usr/include/sys/cdefs.h" 3 4
# endif
# 58 "/usr/include/sys/cdefs.h" 3 4

#else	/* Not GCC.  */
# 60 "/usr/include/sys/cdefs.h" 3 4

# define __inline		/* No inline functions.  */

# define __THROW
# define __NTH(fct)	fct

# define __const	const
# define __signed	signed
# define __volatile	volatile

#endif	/* GCC.  */
# 71 "/usr/include/sys/cdefs.h" 3 4

/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */
#define __P(args)	args
#define __PMT(args)	args

/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */

#define __CONCAT(x,y)	x ## y
#define __STRING(x)	#x

/* This is not a typedef so `const __ptr_t' does the right thing.  */
#define __ptr_t void *
#define __long_double_t  long double


/* C++ needs to know that types and declarations are C, not C++.  */
#ifdef	__cplusplus
# define __BEGIN_DECLS	extern "C" {
# define __END_DECLS	}
#else
# 93 "/usr/include/sys/cdefs.h" 3 4
# define __BEGIN_DECLS
# define __END_DECLS
#endif
# 96 "/usr/include/sys/cdefs.h" 3 4


/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
#if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES
# define __BEGIN_NAMESPACE_STD	namespace std {
# define __END_NAMESPACE_STD	}
# define __USING_NAMESPACE_STD(name) using std::name;
# define __BEGIN_NAMESPACE_C99	namespace __c99 {
# define __END_NAMESPACE_C99	}
# define __USING_NAMESPACE_C99(name) using __c99::name;
#else
# 111 "/usr/include/sys/cdefs.h" 3 4
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
# define __BEGIN_NAMESPACE_STD
# define __END_NAMESPACE_STD
# define __USING_NAMESPACE_STD(name)
# define __BEGIN_NAMESPACE_C99
# define __END_NAMESPACE_C99
# define __USING_NAMESPACE_C99(name)
#endif
# 121 "/usr/include/sys/cdefs.h" 3 4


/* Support for bounded pointers.  */
#ifndef __BOUNDED_POINTERS__
# define __bounded	/* nothing */
# define __unbounded	/* nothing */
# define __ptrvalue	/* nothing */
#endif
# 129 "/usr/include/sys/cdefs.h" 3 4


/* Fortify support.  */
#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
#define __bos0(ptr) __builtin_object_size (ptr, 0)

#if __GNUC_PREREQ (4,3) \
    || (defined __GNUC_RH_RELEASE__ && __GNUC__ == 4 \
	&& __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ == 2 \
	&& __GNUC_RH_RELEASE__ >= 31)
# define __warndecl(name, msg) \
  extern void name (void) __attribute__((__warning__ (msg)))
# define __warnattr(msg) __attribute__((__warning__ (msg)))
# define __errordecl(name, msg) \
  extern void name (void) __attribute__((__error__ (msg)))
#else
# 145 "/usr/include/sys/cdefs.h" 3 4
# define __warndecl(name, msg) extern void name (void)
# define __warnattr(msg)
# define __errordecl(name, msg) extern void name (void)
#endif
# 149 "/usr/include/sys/cdefs.h" 3 4

/* Support for flexible arrays.  */
#if __GNUC_PREREQ (2,97)
/* GCC 2.97 supports C99 flexible array members.  */
# define __flexarr	[]
#else
# 155 "/usr/include/sys/cdefs.h" 3 4
# ifdef __GNUC__
#  define __flexarr	[0]
# else
# 158 "/usr/include/sys/cdefs.h" 3 4
#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#   define __flexarr	[]
#  else
# 161 "/usr/include/sys/cdefs.h" 3 4
/* Some other non-C99 compiler.  Approximate with [1].  */
#   define __flexarr	[1]
#  endif
# 164 "/usr/include/sys/cdefs.h" 3 4
# endif
# 165 "/usr/include/sys/cdefs.h" 3 4
#endif
# 166 "/usr/include/sys/cdefs.h" 3 4


/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */

#if defined __GNUC__ && __GNUC__ >= 2

# define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))
# ifdef __cplusplus
#  define __REDIRECT_NTH(name, proto, alias) \
     name proto __THROW __asm__ (__ASMNAME (#alias))
# else
# 185 "/usr/include/sys/cdefs.h" 3 4
#  define __REDIRECT_NTH(name, proto, alias) \
     name proto __asm__ (__ASMNAME (#alias)) __THROW
# endif
# 188 "/usr/include/sys/cdefs.h" 3 4
# define __ASMNAME(cname)  __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
# define __ASMNAME2(prefix, cname) __STRING (prefix) cname

/*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; \
	_Pragma("let " #name " = " #alias)
*/
#endif
# 198 "/usr/include/sys/cdefs.h" 3 4

/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */
#if !defined __GNUC__ || __GNUC__ < 2
# define __attribute__(xyz)	/* Ignore */
#endif
# 205 "/usr/include/sys/cdefs.h" 3 4

/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
#if __GNUC_PREREQ (2,96)
# define __attribute_malloc__ __attribute__ ((__malloc__))
#else
# 212 "/usr/include/sys/cdefs.h" 3 4
# define __attribute_malloc__ /* Ignore */
#endif
# 214 "/usr/include/sys/cdefs.h" 3 4

/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
#if __GNUC_PREREQ (2,96)
# define __attribute_pure__ __attribute__ ((__pure__))
#else
# 221 "/usr/include/sys/cdefs.h" 3 4
# define __attribute_pure__ /* Ignore */
#endif
# 223 "/usr/include/sys/cdefs.h" 3 4

/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
#if __GNUC_PREREQ (3,1)
# define __attribute_used__ __attribute__ ((__used__))
# define __attribute_noinline__ __attribute__ ((__noinline__))
#else
# 231 "/usr/include/sys/cdefs.h" 3 4
# define __attribute_used__ __attribute__ ((__unused__))
# define __attribute_noinline__ /* Ignore */
#endif
# 234 "/usr/include/sys/cdefs.h" 3 4

/* gcc allows marking deprecated functions.  */
#if __GNUC_PREREQ (3,2)
# define __attribute_deprecated__ __attribute__ ((__deprecated__))
#else
# 239 "/usr/include/sys/cdefs.h" 3 4
# define __attribute_deprecated__ /* Ignore */
#endif
# 241 "/usr/include/sys/cdefs.h" 3 4

/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */
#if __GNUC_PREREQ (2,8)
# define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))
#else
# 251 "/usr/include/sys/cdefs.h" 3 4
# define __attribute_format_arg__(x) /* Ignore */
#endif
# 253 "/usr/include/sys/cdefs.h" 3 4

/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */
#if __GNUC_PREREQ (2,97)
# define __attribute_format_strfmon__(a,b) \
  __attribute__ ((__format__ (__strfmon__, a, b)))
#else
# 262 "/usr/include/sys/cdefs.h" 3 4
# define __attribute_format_strfmon__(a,b) /* Ignore */
#endif
# 264 "/usr/include/sys/cdefs.h" 3 4

/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */
#if __GNUC_PREREQ (3,3)
# define __nonnull(params) __attribute__ ((__nonnull__ params))
#else
# 270 "/usr/include/sys/cdefs.h" 3 4
# define __nonnull(params)
#endif
# 272 "/usr/include/sys/cdefs.h" 3 4

/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */
#if __GNUC_PREREQ (3,4)
# define __attribute_warn_unused_result__ \
   __attribute__ ((__warn_unused_result__))
# if __USE_FORTIFY_LEVEL > 0
#  define __wur __attribute_warn_unused_result__
# endif
# 281 "/usr/include/sys/cdefs.h" 3 4
#else
# 282 "/usr/include/sys/cdefs.h" 3 4
# define __attribute_warn_unused_result__ /* empty */
#endif
# 284 "/usr/include/sys/cdefs.h" 3 4
#ifndef __wur
# define __wur /* Ignore */
#endif
# 287 "/usr/include/sys/cdefs.h" 3 4

/* Forces a function to be always inlined.  */
#if __GNUC_PREREQ (3,2)
# define __always_inline __inline __attribute__ ((__always_inline__))
#else
# 292 "/usr/include/sys/cdefs.h" 3 4
# define __always_inline __inline
#endif
# 294 "/usr/include/sys/cdefs.h" 3 4

/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */
#if !defined __cplusplus || __GNUC_PREREQ (4,3) \
    || (defined __GNUC_RH_RELEASE__ && __GNUC__ == 4 \
	&& __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ == 2 \
	&& __GNUC_RH_RELEASE__ >= 31)
# if defined __GNUC_STDC_INLINE__ || defined __cplusplus
#  define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
#  if __GNUC_PREREQ (4,3) \
	|| (defined __GNUC_RH_RELEASE__ && __GNUC__ == 4 \
	    && __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ == 2 \
	    && __GNUC_RH_RELEASE__ >= 31)
#   define __extern_always_inline \
  extern __always_inline __attribute__ ((__gnu_inline__, __artificial__))
#  else
# 310 "/usr/include/sys/cdefs.h" 3 4
#   define __extern_always_inline \
  extern __always_inline __attribute__ ((__gnu_inline__))
#  endif
# 313 "/usr/include/sys/cdefs.h" 3 4
# else
# 314 "/usr/include/sys/cdefs.h" 3 4
#  define __extern_inline extern __inline
#  if __GNUC_PREREQ (4,3)
#   define __extern_always_inline \
  extern __always_inline __attribute__ ((__artificial__))
#  else
# 319 "/usr/include/sys/cdefs.h" 3 4
#   define __extern_always_inline extern __always_inline
#  endif
# 321 "/usr/include/sys/cdefs.h" 3 4
# endif
# 322 "/usr/include/sys/cdefs.h" 3 4
#endif
# 323 "/usr/include/sys/cdefs.h" 3 4

/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */
#if __GNUC_PREREQ (4,3) \
    || (defined __GNUC_RH_RELEASE__ && __GNUC__ == 4 \
	&& __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ == 2 \
	&& __GNUC_RH_RELEASE__ >= 31)
# define __va_arg_pack() __builtin_va_arg_pack ()
# define __va_arg_pack_len() __builtin_va_arg_pack_len ()
#endif
# 333 "/usr/include/sys/cdefs.h" 3 4

/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */
#if !__GNUC_PREREQ (2,8)
# define __extension__		/* Ignore */
#endif
# 341 "/usr/include/sys/cdefs.h" 3 4

/* __restrict is known in EGCS 1.2 and above. */
#if !__GNUC_PREREQ (2,92)
# define __restrict	/* Ignore */
#endif
# 346 "/usr/include/sys/cdefs.h" 3 4

/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */
#if __GNUC_PREREQ (3,1) && !defined __GNUG__
# define __restrict_arr	__restrict
#else
# 353 "/usr/include/sys/cdefs.h" 3 4
# ifdef __GNUC__
#  define __restrict_arr	/* Not supported in old GCC.  */
# else
# 356 "/usr/include/sys/cdefs.h" 3 4
#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#   define __restrict_arr	restrict
#  else
# 359 "/usr/include/sys/cdefs.h" 3 4
/* Some other non-C99 compiler.  */
#   define __restrict_arr	/* Not supported.  */
#  endif
# 362 "/usr/include/sys/cdefs.h" 3 4
# endif
# 363 "/usr/include/sys/cdefs.h" 3 4
#endif
# 364 "/usr/include/sys/cdefs.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 365 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 366 "/usr/include/sys/cdefs.h" 2 3 4

#if defined __LONG_DOUBLE_MATH_OPTIONAL && defined __NO_LONG_DOUBLE_MATH
# define __LDBL_COMPAT 1
# ifdef __REDIRECT
#  define __LDBL_REDIR1(name, proto, alias) __REDIRECT (name, proto, alias)
#  define __LDBL_REDIR(name, proto) \
  __LDBL_REDIR1 (name, proto, __nldbl_##name)
#  define __LDBL_REDIR1_NTH(name, proto, alias) __REDIRECT_NTH (name, proto, alias)
#  define __LDBL_REDIR_NTH(name, proto) \
  __LDBL_REDIR1_NTH (name, proto, __nldbl_##name)
#  define __LDBL_REDIR1_DECL(name, alias) \
  extern __typeof (name) name __asm (__ASMNAME (#alias));
#  define __LDBL_REDIR_DECL(name) \
  extern __typeof (name) name __asm (__ASMNAME ("__nldbl_" #name));
#  define __REDIRECT_LDBL(name, proto, alias) \
  __LDBL_REDIR1 (name, proto, __nldbl_##alias)
#  define __REDIRECT_NTH_LDBL(name, proto, alias) \
  __LDBL_REDIR1_NTH (name, proto, __nldbl_##alias)
# endif
# 385 "/usr/include/sys/cdefs.h" 3 4
#endif
# 386 "/usr/include/sys/cdefs.h" 3 4
#if !defined __LDBL_COMPAT || !defined __REDIRECT
# define __LDBL_REDIR1(name, proto, alias) name proto
# define __LDBL_REDIR(name, proto) name proto
# define __LDBL_REDIR1_NTH(name, proto, alias) name proto __THROW
# define __LDBL_REDIR_NTH(name, proto) name proto __THROW
# define __LDBL_REDIR_DECL(name)
# ifdef __REDIRECT
#  define __REDIRECT_LDBL(name, proto, alias) __REDIRECT (name, proto, alias)
#  define __REDIRECT_NTH_LDBL(name, proto, alias) \
  __REDIRECT_NTH (name, proto, alias)
# endif
# 397 "/usr/include/sys/cdefs.h" 3 4
#endif
# 398 "/usr/include/sys/cdefs.h" 3 4

#endif	 /* sys/cdefs.h */
# 400 "/usr/include/sys/cdefs.h" 3 4
# 362 "/usr/include/features.h" 2 3 4
# endif
# 363 "/usr/include/features.h" 3 4

/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */
# if defined __USE_FILE_OFFSET64 && !defined __REDIRECT
#  define __USE_LARGEFILE	1
#  define __USE_LARGEFILE64	1
# endif
# 370 "/usr/include/features.h" 3 4

#endif	/* !ASSEMBLER */
# 372 "/usr/include/features.h" 3 4

/* Decide whether we can define 'extern inline' functions in headers.  */
#if __GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \
    && !defined __OPTIMIZE_SIZE__ && !defined __NO_INLINE__ \
    && defined __extern_inline
# define __USE_EXTERN_INLINES	1
#endif
# 379 "/usr/include/features.h" 3 4


/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
#if 0 /* expanded by -frewrite-includes */
#include <gnu/stubs.h>
#endif /* expanded by -frewrite-includes */
# 385 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
/* This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 4 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4

#if __WORDSIZE == 32
#if 0 /* expanded by -frewrite-includes */
# include <gnu/stubs-32.h>
#endif /* expanded by -frewrite-includes */
# 7 "/usr/include/gnu/stubs.h" 3 4
# 8 "/usr/include/gnu/stubs.h" 3 4
#elif __WORDSIZE == 64
# 9 "/usr/include/gnu/stubs.h" 3 4
#if 0 /* expanded by -frewrite-includes */
# include <gnu/stubs-64.h>
#endif /* expanded by -frewrite-includes */
# 9 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */

#ifdef _LIBC
 #error Applications may not define the macro _LIBC
#endif
# 9 "/usr/include/gnu/stubs-64.h" 3 4

#define __stub_bdflush
#define __stub_chflags
#define __stub_fattach
#define __stub_fchflags
#define __stub_fdetach
#define __stub_getmsg
#define __stub_gtty
#define __stub_lchmod
#define __stub_putmsg
#define __stub_revoke
#define __stub_setlogin
#define __stub_sigreturn
#define __stub_sstk
#define __stub_stty
# 10 "/usr/include/gnu/stubs.h" 2 3 4
#else
# 11 "/usr/include/gnu/stubs.h" 3 4
# error "unexpected value for __WORDSIZE macro"
#endif
# 13 "/usr/include/gnu/stubs.h" 3 4
# 386 "/usr/include/features.h" 2 3 4


#endif	/* features.h  */
# 389 "/usr/include/features.h" 3 4
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/os_defines.h" 2 3

// Provide a declaration for the possibly deprecated gets function, as
// glibc 2.15 and later does not declare gets for ISO C11 when
// __GNU_SOURCE is defined.
#if __GLIBC_PREREQ(2,15) && defined(_GNU_SOURCE)
# undef _GLIBCXX_HAVE_GETS
#endif
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/os_defines.h" 3

#endif
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/os_defines.h" 3
# 483 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 2 3

// Pick up any CPU-specific definitions.
#if 0 /* expanded by -frewrite-includes */
#include <bits/cpu_defines.h>
#endif /* expanded by -frewrite-includes */
# 485 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/cpu_defines.h" 1 3
// Specific definitions for generic platforms  -*- C++ -*-

// Copyright (C) 2005-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/cpu_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */

#ifndef _GLIBCXX_CPU_DEFINES
#define _GLIBCXX_CPU_DEFINES 1

#endif
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/cpu_defines.h" 3
# 486 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 2 3

// If platform uses neither visibility nor psuedo-visibility,
// specify empty default for namespace annotation macros.
#ifndef _GLIBCXX_PSEUDO_VISIBILITY
# define _GLIBCXX_PSEUDO_VISIBILITY(V)
#endif
# 492 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// Certain function definitions that are meant to be overridable from
// user code are decorated with this macro.  For some targets, this
// macro causes these definitions to be weak.
#ifndef _GLIBCXX_WEAK_DEFINITION
# define _GLIBCXX_WEAK_DEFINITION
#endif
# 499 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3


// The remainder of the prewritten config is automatic; all the
// user hooks are listed above.

// Create a boolean flag to be used to determine if --fast-math is set.
#ifdef __FAST_MATH__
# define _GLIBCXX_FAST_MATH 1
#else
# 508 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# define _GLIBCXX_FAST_MATH 0
#endif
# 510 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

// This marks string literals in header files to be extracted for eventual
// translation.  It is primarily used for messages in thrown exceptions; see
// src/functexcept.cc.  We use __N because the more traditional _N is used
// for something else under certain OSes (see BADNAMES).
#define __N(msgid)     (msgid)

// For example, <windows.h> is known to #define min and max as macros...
#undef min
#undef max

// End of prewritten config; the settings discovered at configure time follow.
/* config.h.  Generated from config.h.in by configure.  */
/* config.h.in.  Generated from configure.ac by autoheader.  */

/* Define to 1 if you have the `acosf' function. */
#define _GLIBCXX_HAVE_ACOSF 1

/* Define to 1 if you have the `acosl' function. */
#define _GLIBCXX_HAVE_ACOSL 1

/* Define to 1 if you have the `asinf' function. */
#define _GLIBCXX_HAVE_ASINF 1

/* Define to 1 if you have the `asinl' function. */
#define _GLIBCXX_HAVE_ASINL 1

/* Define to 1 if the target assembler supports .symver directive. */
#define _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE 1

/* Define to 1 if you have the `atan2f' function. */
#define _GLIBCXX_HAVE_ATAN2F 1

/* Define to 1 if you have the `atan2l' function. */
#define _GLIBCXX_HAVE_ATAN2L 1

/* Define to 1 if you have the `atanf' function. */
#define _GLIBCXX_HAVE_ATANF 1

/* Define to 1 if you have the `atanl' function. */
#define _GLIBCXX_HAVE_ATANL 1

/* Define to 1 if you have the `at_quick_exit' function. */
#define _GLIBCXX_HAVE_AT_QUICK_EXIT 1

/* Define to 1 if the target assembler supports thread-local storage. */
/* #undef _GLIBCXX_HAVE_CC_TLS */

/* Define to 1 if you have the `ceilf' function. */
#define _GLIBCXX_HAVE_CEILF 1

/* Define to 1 if you have the `ceill' function. */
#define _GLIBCXX_HAVE_CEILL 1

/* Define to 1 if you have the <complex.h> header file. */
#define _GLIBCXX_HAVE_COMPLEX_H 1

/* Define to 1 if you have the `cosf' function. */
#define _GLIBCXX_HAVE_COSF 1

/* Define to 1 if you have the `coshf' function. */
#define _GLIBCXX_HAVE_COSHF 1

/* Define to 1 if you have the `coshl' function. */
#define _GLIBCXX_HAVE_COSHL 1

/* Define to 1 if you have the `cosl' function. */
#define _GLIBCXX_HAVE_COSL 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define _GLIBCXX_HAVE_DLFCN_H 1

/* Define if EBADMSG exists. */
#define _GLIBCXX_HAVE_EBADMSG 1

/* Define if ECANCELED exists. */
#define _GLIBCXX_HAVE_ECANCELED 1

/* Define if ECHILD exists. */
#define _GLIBCXX_HAVE_ECHILD 1

/* Define if EIDRM exists. */
#define _GLIBCXX_HAVE_EIDRM 1

/* Define to 1 if you have the <endian.h> header file. */
#define _GLIBCXX_HAVE_ENDIAN_H 1

/* Define if ENODATA exists. */
#define _GLIBCXX_HAVE_ENODATA 1

/* Define if ENOLINK exists. */
#define _GLIBCXX_HAVE_ENOLINK 1

/* Define if ENOSPC exists. */
#define _GLIBCXX_HAVE_ENOSPC 1

/* Define if ENOSR exists. */
#define _GLIBCXX_HAVE_ENOSR 1

/* Define if ENOSTR exists. */
#define _GLIBCXX_HAVE_ENOSTR 1

/* Define if ENOTRECOVERABLE exists. */
#define _GLIBCXX_HAVE_ENOTRECOVERABLE 1

/* Define if ENOTSUP exists. */
#define _GLIBCXX_HAVE_ENOTSUP 1

/* Define if EOVERFLOW exists. */
#define _GLIBCXX_HAVE_EOVERFLOW 1

/* Define if EOWNERDEAD exists. */
#define _GLIBCXX_HAVE_EOWNERDEAD 1

/* Define if EPERM exists. */
#define _GLIBCXX_HAVE_EPERM 1

/* Define if EPROTO exists. */
#define _GLIBCXX_HAVE_EPROTO 1

/* Define if ETIME exists. */
#define _GLIBCXX_HAVE_ETIME 1

/* Define if ETIMEDOUT exists. */
#define _GLIBCXX_HAVE_ETIMEDOUT 1

/* Define if ETXTBSY exists. */
#define _GLIBCXX_HAVE_ETXTBSY 1

/* Define if EWOULDBLOCK exists. */
#define _GLIBCXX_HAVE_EWOULDBLOCK 1

/* Define to 1 if you have the <execinfo.h> header file. */
#define _GLIBCXX_HAVE_EXECINFO_H 1

/* Define to 1 if you have the `expf' function. */
#define _GLIBCXX_HAVE_EXPF 1

/* Define to 1 if you have the `expl' function. */
#define _GLIBCXX_HAVE_EXPL 1

/* Define to 1 if you have the `fabsf' function. */
#define _GLIBCXX_HAVE_FABSF 1

/* Define to 1 if you have the `fabsl' function. */
#define _GLIBCXX_HAVE_FABSL 1

/* Define to 1 if you have the <fenv.h> header file. */
#define _GLIBCXX_HAVE_FENV_H 1

/* Define to 1 if you have the `finite' function. */
#define _GLIBCXX_HAVE_FINITE 1

/* Define to 1 if you have the `finitef' function. */
#define _GLIBCXX_HAVE_FINITEF 1

/* Define to 1 if you have the `finitel' function. */
#define _GLIBCXX_HAVE_FINITEL 1

/* Define to 1 if you have the <float.h> header file. */
#define _GLIBCXX_HAVE_FLOAT_H 1

/* Define to 1 if you have the `floorf' function. */
#define _GLIBCXX_HAVE_FLOORF 1

/* Define to 1 if you have the `floorl' function. */
#define _GLIBCXX_HAVE_FLOORL 1

/* Define to 1 if you have the `fmodf' function. */
#define _GLIBCXX_HAVE_FMODF 1

/* Define to 1 if you have the `fmodl' function. */
#define _GLIBCXX_HAVE_FMODL 1

/* Define to 1 if you have the `fpclass' function. */
/* #undef _GLIBCXX_HAVE_FPCLASS */

/* Define to 1 if you have the <fp.h> header file. */
/* #undef _GLIBCXX_HAVE_FP_H */

/* Define to 1 if you have the `frexpf' function. */
#define _GLIBCXX_HAVE_FREXPF 1

/* Define to 1 if you have the `frexpl' function. */
#define _GLIBCXX_HAVE_FREXPL 1

/* Define if _Unwind_GetIPInfo is available. */
#define _GLIBCXX_HAVE_GETIPINFO 1

/* Define if gets is available in <stdio.h>. */
#define _GLIBCXX_HAVE_GETS 1

/* Define to 1 if you have the `hypot' function. */
#define _GLIBCXX_HAVE_HYPOT 1

/* Define to 1 if you have the `hypotf' function. */
#define _GLIBCXX_HAVE_HYPOTF 1

/* Define to 1 if you have the `hypotl' function. */
#define _GLIBCXX_HAVE_HYPOTL 1

/* Define if you have the iconv() function. */
#define _GLIBCXX_HAVE_ICONV 1

/* Define to 1 if you have the <ieeefp.h> header file. */
/* #undef _GLIBCXX_HAVE_IEEEFP_H */

/* Define if int64_t is available in <stdint.h>. */
#define _GLIBCXX_HAVE_INT64_T 1

/* Define if int64_t is a long. */
#define _GLIBCXX_HAVE_INT64_T_LONG 1

/* Define if int64_t is a long long. */
/* #undef _GLIBCXX_HAVE_INT64_T_LONG_LONG */

/* Define to 1 if you have the <inttypes.h> header file. */
#define _GLIBCXX_HAVE_INTTYPES_H 1

/* Define to 1 if you have the `isinf' function. */
#define _GLIBCXX_HAVE_ISINF 1

/* Define to 1 if you have the `isinff' function. */
#define _GLIBCXX_HAVE_ISINFF 1

/* Define to 1 if you have the `isinfl' function. */
#define _GLIBCXX_HAVE_ISINFL 1

/* Define to 1 if you have the `isnan' function. */
#define _GLIBCXX_HAVE_ISNAN 1

/* Define to 1 if you have the `isnanf' function. */
#define _GLIBCXX_HAVE_ISNANF 1

/* Define to 1 if you have the `isnanl' function. */
#define _GLIBCXX_HAVE_ISNANL 1

/* Defined if iswblank exists. */
#define _GLIBCXX_HAVE_ISWBLANK 1

/* Define if LC_MESSAGES is available in <locale.h>. */
#define _GLIBCXX_HAVE_LC_MESSAGES 1

/* Define to 1 if you have the `ldexpf' function. */
#define _GLIBCXX_HAVE_LDEXPF 1

/* Define to 1 if you have the `ldexpl' function. */
#define _GLIBCXX_HAVE_LDEXPL 1

/* Define to 1 if you have the <libintl.h> header file. */
#define _GLIBCXX_HAVE_LIBINTL_H 1

/* Only used in build directory testsuite_hooks.h. */
#define _GLIBCXX_HAVE_LIMIT_AS 1

/* Only used in build directory testsuite_hooks.h. */
#define _GLIBCXX_HAVE_LIMIT_DATA 1

/* Only used in build directory testsuite_hooks.h. */
#define _GLIBCXX_HAVE_LIMIT_FSIZE 1

/* Only used in build directory testsuite_hooks.h. */
#define _GLIBCXX_HAVE_LIMIT_RSS 1

/* Only used in build directory testsuite_hooks.h. */
#define _GLIBCXX_HAVE_LIMIT_VMEM 0

/* Define if futex syscall is available. */
#define _GLIBCXX_HAVE_LINUX_FUTEX 1

/* Define to 1 if you have the <locale.h> header file. */
#define _GLIBCXX_HAVE_LOCALE_H 1

/* Define to 1 if you have the `log10f' function. */
#define _GLIBCXX_HAVE_LOG10F 1

/* Define to 1 if you have the `log10l' function. */
#define _GLIBCXX_HAVE_LOG10L 1

/* Define to 1 if you have the `logf' function. */
#define _GLIBCXX_HAVE_LOGF 1

/* Define to 1 if you have the `logl' function. */
#define _GLIBCXX_HAVE_LOGL 1

/* Define to 1 if you have the <machine/endian.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_ENDIAN_H */

/* Define to 1 if you have the <machine/param.h> header file. */
/* #undef _GLIBCXX_HAVE_MACHINE_PARAM_H */

/* Define if mbstate_t exists in wchar.h. */
#define _GLIBCXX_HAVE_MBSTATE_T 1

/* Define to 1 if you have the <memory.h> header file. */
#define _GLIBCXX_HAVE_MEMORY_H 1

/* Define to 1 if you have the `modf' function. */
#define _GLIBCXX_HAVE_MODF 1

/* Define to 1 if you have the `modff' function. */
#define _GLIBCXX_HAVE_MODFF 1

/* Define to 1 if you have the `modfl' function. */
#define _GLIBCXX_HAVE_MODFL 1

/* Define to 1 if you have the <nan.h> header file. */
/* #undef _GLIBCXX_HAVE_NAN_H */

/* Define if poll is available in <poll.h>. */
#define _GLIBCXX_HAVE_POLL 1

/* Define to 1 if you have the `powf' function. */
#define _GLIBCXX_HAVE_POWF 1

/* Define to 1 if you have the `powl' function. */
#define _GLIBCXX_HAVE_POWL 1

/* Define to 1 if you have the `qfpclass' function. */
/* #undef _GLIBCXX_HAVE_QFPCLASS */

/* Define to 1 if you have the `quick_exit' function. */
#define _GLIBCXX_HAVE_QUICK_EXIT 1

/* Define to 1 if you have the `setenv' function. */
#define _GLIBCXX_HAVE_SETENV 1

/* Define to 1 if you have the `sincos' function. */
#define _GLIBCXX_HAVE_SINCOS 1

/* Define to 1 if you have the `sincosf' function. */
#define _GLIBCXX_HAVE_SINCOSF 1

/* Define to 1 if you have the `sincosl' function. */
#define _GLIBCXX_HAVE_SINCOSL 1

/* Define to 1 if you have the `sinf' function. */
#define _GLIBCXX_HAVE_SINF 1

/* Define to 1 if you have the `sinhf' function. */
#define _GLIBCXX_HAVE_SINHF 1

/* Define to 1 if you have the `sinhl' function. */
#define _GLIBCXX_HAVE_SINHL 1

/* Define to 1 if you have the `sinl' function. */
#define _GLIBCXX_HAVE_SINL 1

/* Defined if sleep exists. */
/* #undef _GLIBCXX_HAVE_SLEEP */

/* Define to 1 if you have the `sqrtf' function. */
#define _GLIBCXX_HAVE_SQRTF 1

/* Define to 1 if you have the `sqrtl' function. */
#define _GLIBCXX_HAVE_SQRTL 1

/* Define to 1 if you have the <stdalign.h> header file. */
#define _GLIBCXX_HAVE_STDALIGN_H 1

/* Define to 1 if you have the <stdbool.h> header file. */
#define _GLIBCXX_HAVE_STDBOOL_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define _GLIBCXX_HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define _GLIBCXX_HAVE_STDLIB_H 1

/* Define if strerror_l is available in <string.h>. */
#define _GLIBCXX_HAVE_STRERROR_L 1

/* Define if strerror_r is available in <string.h>. */
#define _GLIBCXX_HAVE_STRERROR_R 1

/* Define to 1 if you have the <strings.h> header file. */
#define _GLIBCXX_HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define _GLIBCXX_HAVE_STRING_H 1

/* Define to 1 if you have the `strtof' function. */
#define _GLIBCXX_HAVE_STRTOF 1

/* Define to 1 if you have the `strtold' function. */
#define _GLIBCXX_HAVE_STRTOLD 1

/* Define if strxfrm_l is available in <string.h>. */
#define _GLIBCXX_HAVE_STRXFRM_L 1

/* Define to 1 if the target runtime linker supports binding the same symbol
   to different versions. */
#define _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT 1

/* Define to 1 if you have the <sys/filio.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_FILIO_H */

/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define _GLIBCXX_HAVE_SYS_IOCTL_H 1

/* Define to 1 if you have the <sys/ipc.h> header file. */
#define _GLIBCXX_HAVE_SYS_IPC_H 1

/* Define to 1 if you have the <sys/isa_defs.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_ISA_DEFS_H */

/* Define to 1 if you have the <sys/machine.h> header file. */
/* #undef _GLIBCXX_HAVE_SYS_MACHINE_H */

/* Define to 1 if you have the <sys/param.h> header file. */
#define _GLIBCXX_HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/resource.h> header file. */
#define _GLIBCXX_HAVE_SYS_RESOURCE_H 1

/* Define to 1 if you have a suitable <sys/sdt.h> header file */
#define _GLIBCXX_HAVE_SYS_SDT_H 1

/* Define to 1 if you have the <sys/sem.h> header file. */
#define _GLIBCXX_HAVE_SYS_SEM_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define _GLIBCXX_HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/sysinfo.h> header file. */
#define _GLIBCXX_HAVE_SYS_SYSINFO_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define _GLIBCXX_HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define _GLIBCXX_HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/uio.h> header file. */
#define _GLIBCXX_HAVE_SYS_UIO_H 1

/* Define if S_IFREG is available in <sys/stat.h>. */
/* #undef _GLIBCXX_HAVE_S_IFREG */

/* Define if S_IFREG is available in <sys/stat.h>. */
#define _GLIBCXX_HAVE_S_ISREG 1

/* Define to 1 if you have the `tanf' function. */
#define _GLIBCXX_HAVE_TANF 1

/* Define to 1 if you have the `tanhf' function. */
#define _GLIBCXX_HAVE_TANHF 1

/* Define to 1 if you have the `tanhl' function. */
#define _GLIBCXX_HAVE_TANHL 1

/* Define to 1 if you have the `tanl' function. */
#define _GLIBCXX_HAVE_TANL 1

/* Define to 1 if you have the <tgmath.h> header file. */
#define _GLIBCXX_HAVE_TGMATH_H 1

/* Define to 1 if the target supports thread-local storage. */
#define _GLIBCXX_HAVE_TLS 1

/* Define to 1 if you have the <unistd.h> header file. */
#define _GLIBCXX_HAVE_UNISTD_H 1

/* Defined if usleep exists. */
/* #undef _GLIBCXX_HAVE_USLEEP */

/* Defined if vfwscanf exists. */
#define _GLIBCXX_HAVE_VFWSCANF 1

/* Defined if vswscanf exists. */
#define _GLIBCXX_HAVE_VSWSCANF 1

/* Defined if vwscanf exists. */
#define _GLIBCXX_HAVE_VWSCANF 1

/* Define to 1 if you have the <wchar.h> header file. */
#define _GLIBCXX_HAVE_WCHAR_H 1

/* Defined if wcstof exists. */
#define _GLIBCXX_HAVE_WCSTOF 1

/* Define to 1 if you have the <wctype.h> header file. */
#define _GLIBCXX_HAVE_WCTYPE_H 1

/* Defined if Sleep exists. */
/* #undef _GLIBCXX_HAVE_WIN32_SLEEP */

/* Define if writev is available in <sys/uio.h>. */
#define _GLIBCXX_HAVE_WRITEV 1

/* Define to 1 if you have the `_acosf' function. */
/* #undef _GLIBCXX_HAVE__ACOSF */

/* Define to 1 if you have the `_acosl' function. */
/* #undef _GLIBCXX_HAVE__ACOSL */

/* Define to 1 if you have the `_asinf' function. */
/* #undef _GLIBCXX_HAVE__ASINF */

/* Define to 1 if you have the `_asinl' function. */
/* #undef _GLIBCXX_HAVE__ASINL */

/* Define to 1 if you have the `_atan2f' function. */
/* #undef _GLIBCXX_HAVE__ATAN2F */

/* Define to 1 if you have the `_atan2l' function. */
/* #undef _GLIBCXX_HAVE__ATAN2L */

/* Define to 1 if you have the `_atanf' function. */
/* #undef _GLIBCXX_HAVE__ATANF */

/* Define to 1 if you have the `_atanl' function. */
/* #undef _GLIBCXX_HAVE__ATANL */

/* Define to 1 if you have the `_ceilf' function. */
/* #undef _GLIBCXX_HAVE__CEILF */

/* Define to 1 if you have the `_ceill' function. */
/* #undef _GLIBCXX_HAVE__CEILL */

/* Define to 1 if you have the `_cosf' function. */
/* #undef _GLIBCXX_HAVE__COSF */

/* Define to 1 if you have the `_coshf' function. */
/* #undef _GLIBCXX_HAVE__COSHF */

/* Define to 1 if you have the `_coshl' function. */
/* #undef _GLIBCXX_HAVE__COSHL */

/* Define to 1 if you have the `_cosl' function. */
/* #undef _GLIBCXX_HAVE__COSL */

/* Define to 1 if you have the `_expf' function. */
/* #undef _GLIBCXX_HAVE__EXPF */

/* Define to 1 if you have the `_expl' function. */
/* #undef _GLIBCXX_HAVE__EXPL */

/* Define to 1 if you have the `_fabsf' function. */
/* #undef _GLIBCXX_HAVE__FABSF */

/* Define to 1 if you have the `_fabsl' function. */
/* #undef _GLIBCXX_HAVE__FABSL */

/* Define to 1 if you have the `_finite' function. */
/* #undef _GLIBCXX_HAVE__FINITE */

/* Define to 1 if you have the `_finitef' function. */
/* #undef _GLIBCXX_HAVE__FINITEF */

/* Define to 1 if you have the `_finitel' function. */
/* #undef _GLIBCXX_HAVE__FINITEL */

/* Define to 1 if you have the `_floorf' function. */
/* #undef _GLIBCXX_HAVE__FLOORF */

/* Define to 1 if you have the `_floorl' function. */
/* #undef _GLIBCXX_HAVE__FLOORL */

/* Define to 1 if you have the `_fmodf' function. */
/* #undef _GLIBCXX_HAVE__FMODF */

/* Define to 1 if you have the `_fmodl' function. */
/* #undef _GLIBCXX_HAVE__FMODL */

/* Define to 1 if you have the `_fpclass' function. */
/* #undef _GLIBCXX_HAVE__FPCLASS */

/* Define to 1 if you have the `_frexpf' function. */
/* #undef _GLIBCXX_HAVE__FREXPF */

/* Define to 1 if you have the `_frexpl' function. */
/* #undef _GLIBCXX_HAVE__FREXPL */

/* Define to 1 if you have the `_hypot' function. */
/* #undef _GLIBCXX_HAVE__HYPOT */

/* Define to 1 if you have the `_hypotf' function. */
/* #undef _GLIBCXX_HAVE__HYPOTF */

/* Define to 1 if you have the `_hypotl' function. */
/* #undef _GLIBCXX_HAVE__HYPOTL */

/* Define to 1 if you have the `_isinf' function. */
/* #undef _GLIBCXX_HAVE__ISINF */

/* Define to 1 if you have the `_isinff' function. */
/* #undef _GLIBCXX_HAVE__ISINFF */

/* Define to 1 if you have the `_isinfl' function. */
/* #undef _GLIBCXX_HAVE__ISINFL */

/* Define to 1 if you have the `_isnan' function. */
/* #undef _GLIBCXX_HAVE__ISNAN */

/* Define to 1 if you have the `_isnanf' function. */
/* #undef _GLIBCXX_HAVE__ISNANF */

/* Define to 1 if you have the `_isnanl' function. */
/* #undef _GLIBCXX_HAVE__ISNANL */

/* Define to 1 if you have the `_ldexpf' function. */
/* #undef _GLIBCXX_HAVE__LDEXPF */

/* Define to 1 if you have the `_ldexpl' function. */
/* #undef _GLIBCXX_HAVE__LDEXPL */

/* Define to 1 if you have the `_log10f' function. */
/* #undef _GLIBCXX_HAVE__LOG10F */

/* Define to 1 if you have the `_log10l' function. */
/* #undef _GLIBCXX_HAVE__LOG10L */

/* Define to 1 if you have the `_logf' function. */
/* #undef _GLIBCXX_HAVE__LOGF */

/* Define to 1 if you have the `_logl' function. */
/* #undef _GLIBCXX_HAVE__LOGL */

/* Define to 1 if you have the `_modf' function. */
/* #undef _GLIBCXX_HAVE__MODF */

/* Define to 1 if you have the `_modff' function. */
/* #undef _GLIBCXX_HAVE__MODFF */

/* Define to 1 if you have the `_modfl' function. */
/* #undef _GLIBCXX_HAVE__MODFL */

/* Define to 1 if you have the `_powf' function. */
/* #undef _GLIBCXX_HAVE__POWF */

/* Define to 1 if you have the `_powl' function. */
/* #undef _GLIBCXX_HAVE__POWL */

/* Define to 1 if you have the `_qfpclass' function. */
/* #undef _GLIBCXX_HAVE__QFPCLASS */

/* Define to 1 if you have the `_sincos' function. */
/* #undef _GLIBCXX_HAVE__SINCOS */

/* Define to 1 if you have the `_sincosf' function. */
/* #undef _GLIBCXX_HAVE__SINCOSF */

/* Define to 1 if you have the `_sincosl' function. */
/* #undef _GLIBCXX_HAVE__SINCOSL */

/* Define to 1 if you have the `_sinf' function. */
/* #undef _GLIBCXX_HAVE__SINF */

/* Define to 1 if you have the `_sinhf' function. */
/* #undef _GLIBCXX_HAVE__SINHF */

/* Define to 1 if you have the `_sinhl' function. */
/* #undef _GLIBCXX_HAVE__SINHL */

/* Define to 1 if you have the `_sinl' function. */
/* #undef _GLIBCXX_HAVE__SINL */

/* Define to 1 if you have the `_sqrtf' function. */
/* #undef _GLIBCXX_HAVE__SQRTF */

/* Define to 1 if you have the `_sqrtl' function. */
/* #undef _GLIBCXX_HAVE__SQRTL */

/* Define to 1 if you have the `_tanf' function. */
/* #undef _GLIBCXX_HAVE__TANF */

/* Define to 1 if you have the `_tanhf' function. */
/* #undef _GLIBCXX_HAVE__TANHF */

/* Define to 1 if you have the `_tanhl' function. */
/* #undef _GLIBCXX_HAVE__TANHL */

/* Define to 1 if you have the `_tanl' function. */
/* #undef _GLIBCXX_HAVE__TANL */

/* Define to 1 if you have the `__cxa_thread_atexit_impl' function. */
/* #undef _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL */

/* Define as const if the declaration of iconv() needs const. */
#define _GLIBCXX_ICONV_CONST 

/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#define LT_OBJDIR ".libs/"

/* Name of package */
/* #undef _GLIBCXX_PACKAGE */

/* Define to the address where bug reports for this package should be sent. */
#define _GLIBCXX_PACKAGE_BUGREPORT ""

/* Define to the full name of this package. */
#define _GLIBCXX_PACKAGE_NAME "package-unused"

/* Define to the full name and version of this package. */
#define _GLIBCXX_PACKAGE_STRING "package-unused version-unused"

/* Define to the one symbol short name of this package. */
#define _GLIBCXX_PACKAGE_TARNAME "libstdc++"

/* Define to the home page for this package. */
#define _GLIBCXX_PACKAGE_URL ""

/* Define to the version of this package. */
#define _GLIBCXX_PACKAGE__GLIBCXX_VERSION "version-unused"

/* The size of `char', as computed by sizeof. */
/* #undef SIZEOF_CHAR */

/* The size of `int', as computed by sizeof. */
/* #undef SIZEOF_INT */

/* The size of `long', as computed by sizeof. */
/* #undef SIZEOF_LONG */

/* The size of `short', as computed by sizeof. */
/* #undef SIZEOF_SHORT */

/* The size of `void *', as computed by sizeof. */
/* #undef SIZEOF_VOID_P */

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Version number of package */
/* #undef _GLIBCXX_VERSION */

/* Define if the compiler supports C++11 atomics. */
#define _GLIBCXX_ATOMIC_BUILTINS 1

/* Define to use concept checking code from the boost libraries. */
/* #undef _GLIBCXX_CONCEPT_CHECKS */

/* Define to 1 if a fully dynamic basic_string is wanted, 0 to disable,
   undefined for platform defaults */
#define _GLIBCXX_FULLY_DYNAMIC_STRING 0

/* Define if gthreads library is available. */
#define _GLIBCXX_HAS_GTHREADS 1

/* Define to 1 if a full hosted library is built, or 0 if freestanding. */
#define _GLIBCXX_HOSTED 1

/* Define if compatibility should be provided for -mlong-double-64. */

/* Define if ptrdiff_t is int. */
/* #undef _GLIBCXX_PTRDIFF_T_IS_INT */

/* Define if using setrlimit to set resource limits during "make check" */
#define _GLIBCXX_RES_LIMITS 1

/* Define if size_t is unsigned int. */
/* #undef _GLIBCXX_SIZE_T_IS_UINT */

/* Define if the compiler is configured for setjmp/longjmp exceptions. */
/* #undef _GLIBCXX_SJLJ_EXCEPTIONS */

/* Define to the value of the EOF integer constant. */
#define _GLIBCXX_STDIO_EOF -1

/* Define to the value of the SEEK_CUR integer constant. */
#define _GLIBCXX_STDIO_SEEK_CUR 1

/* Define to the value of the SEEK_END integer constant. */
#define _GLIBCXX_STDIO_SEEK_END 2

/* Define to use symbol versioning in the shared library. */
#define _GLIBCXX_SYMVER 1

/* Define to use darwin versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_DARWIN */

/* Define to use GNU versioning in the shared library. */
#define _GLIBCXX_SYMVER_GNU 1

/* Define to use GNU namespace versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_GNU_NAMESPACE */

/* Define to use Sun versioning in the shared library. */
/* #undef _GLIBCXX_SYMVER_SUN */

/* Define if C99 functions or macros from <wchar.h>, <math.h>, <complex.h>,
   <stdio.h>, and <stdlib.h> can be used or exposed. */
#define _GLIBCXX_USE_C99 1

/* Define if C99 functions in <complex.h> should be used in <complex>. Using
   compiler builtins for these functions requires corresponding C99 library
   functions to be present. */
#define _GLIBCXX_USE_C99_COMPLEX 1

/* Define if C99 functions in <complex.h> should be used in <tr1/complex>.
   Using compiler builtins for these functions requires corresponding C99
   library functions to be present. */
#define _GLIBCXX_USE_C99_COMPLEX_TR1 1

/* Define if C99 functions in <ctype.h> should be imported in <tr1/cctype> in
   namespace std::tr1. */
#define _GLIBCXX_USE_C99_CTYPE_TR1 1

/* Define if C99 functions in <fenv.h> should be imported in <tr1/cfenv> in
   namespace std::tr1. */
#define _GLIBCXX_USE_C99_FENV_TR1 1

/* Define if C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. */
#define _GLIBCXX_USE_C99_INTTYPES_TR1 1

/* Define if wchar_t C99 functions in <inttypes.h> should be imported in
   <tr1/cinttypes> in namespace std::tr1. */
#define _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1 1

/* Define if C99 functions or macros in <math.h> should be imported in <cmath>
   in namespace std. */
#define _GLIBCXX_USE_C99_MATH 1

/* Define if C99 functions or macros in <math.h> should be imported in
   <tr1/cmath> in namespace std::tr1. */
#define _GLIBCXX_USE_C99_MATH_TR1 1

/* Define if C99 types in <stdint.h> should be imported in <tr1/cstdint> in
   namespace std::tr1. */
#define _GLIBCXX_USE_C99_STDINT_TR1 1

/* Defined if clock_gettime syscall has monotonic and realtime clock support.
   */
#define _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL 1

/* Defined if clock_gettime has monotonic clock support. */
#define _GLIBCXX_USE_CLOCK_MONOTONIC 1

/* Defined if clock_gettime has realtime clock support. */
#define _GLIBCXX_USE_CLOCK_REALTIME 1

/* Define if ISO/IEC TR 24733 decimal floating point types are supported on
   this host. */
#define _GLIBCXX_USE_DECIMAL_FLOAT 1

/* Define if __float128 is supported on this host. */
#define _GLIBCXX_USE_FLOAT128 1

/* Defined if gettimeofday is available. */
#define _GLIBCXX_USE_GETTIMEOFDAY 1

/* Define if get_nprocs is available in <sys/sysinfo.h>. */
#define _GLIBCXX_USE_GET_NPROCS 1

/* Define if __int128 is supported on this host. */
#define _GLIBCXX_USE_INT128 1

/* Define if LFS support is available. */
#define _GLIBCXX_USE_LFS 1

/* Define if code specialized for long long should be used. */
#define _GLIBCXX_USE_LONG_LONG 1

/* Defined if nanosleep is available. */
#define _GLIBCXX_USE_NANOSLEEP 1

/* Define if NLS translations are to be used. */
#define _GLIBCXX_USE_NLS 1

/* Define if pthreads_num_processors_np is available in <pthread.h>. */
/* #undef _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP */

/* Define if POSIX read/write locks are available in <gthr.h>. */
#define _GLIBCXX_USE_PTHREAD_RWLOCK_T 1

/* Define if /dev/random and /dev/urandom are available for the random_device
   of TR1 (Chapter 5.1). */
#define _GLIBCXX_USE_RANDOM_TR1 1

/* Defined if sched_yield is available. */
#define _GLIBCXX_USE_SCHED_YIELD 1

/* Define if _SC_NPROCESSORS_ONLN is available in <unistd.h>. */
#define _GLIBCXX_USE_SC_NPROCESSORS_ONLN 1

/* Define if _SC_NPROC_ONLN is available in <unistd.h>. */
/* #undef _GLIBCXX_USE_SC_NPROC_ONLN */

/* Define if sysctl(), CTL_HW and HW_NCPU are available in <sys/sysctl.h>. */
/* #undef _GLIBCXX_USE_SYSCTL_HW_NCPU */

/* Define if obsolescent tmpnam is available in <stdio.h>. */
#define _GLIBCXX_USE_TMPNAM 1

/* Define if code specialized for wchar_t should be used. */
#define _GLIBCXX_USE_WCHAR_T 1

/* Define to 1 if a verbose library is built, or 0 otherwise. */
#define _GLIBCXX_VERBOSE 1

/* Defined if as can handle rdrand. */
#define _GLIBCXX_X86_RDRAND 1

/* Define to 1 if mutex_timedlock is available. */
#define _GTHREAD_USE_MUTEX_TIMEDLOCK 1

#if defined (_GLIBCXX_HAVE__ACOSF) && ! defined (_GLIBCXX_HAVE_ACOSF)
# define _GLIBCXX_HAVE_ACOSF 1
# define acosf _acosf
#endif
# 1413 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ACOSL) && ! defined (_GLIBCXX_HAVE_ACOSL)
# define _GLIBCXX_HAVE_ACOSL 1
# define acosl _acosl
#endif
# 1418 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ASINF) && ! defined (_GLIBCXX_HAVE_ASINF)
# define _GLIBCXX_HAVE_ASINF 1
# define asinf _asinf
#endif
# 1423 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ASINL) && ! defined (_GLIBCXX_HAVE_ASINL)
# define _GLIBCXX_HAVE_ASINL 1
# define asinl _asinl
#endif
# 1428 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ATAN2F) && ! defined (_GLIBCXX_HAVE_ATAN2F)
# define _GLIBCXX_HAVE_ATAN2F 1
# define atan2f _atan2f
#endif
# 1433 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ATAN2L) && ! defined (_GLIBCXX_HAVE_ATAN2L)
# define _GLIBCXX_HAVE_ATAN2L 1
# define atan2l _atan2l
#endif
# 1438 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ATANF) && ! defined (_GLIBCXX_HAVE_ATANF)
# define _GLIBCXX_HAVE_ATANF 1
# define atanf _atanf
#endif
# 1443 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ATANL) && ! defined (_GLIBCXX_HAVE_ATANL)
# define _GLIBCXX_HAVE_ATANL 1
# define atanl _atanl
#endif
# 1448 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__CEILF) && ! defined (_GLIBCXX_HAVE_CEILF)
# define _GLIBCXX_HAVE_CEILF 1
# define ceilf _ceilf
#endif
# 1453 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__CEILL) && ! defined (_GLIBCXX_HAVE_CEILL)
# define _GLIBCXX_HAVE_CEILL 1
# define ceill _ceill
#endif
# 1458 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__COSF) && ! defined (_GLIBCXX_HAVE_COSF)
# define _GLIBCXX_HAVE_COSF 1
# define cosf _cosf
#endif
# 1463 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__COSHF) && ! defined (_GLIBCXX_HAVE_COSHF)
# define _GLIBCXX_HAVE_COSHF 1
# define coshf _coshf
#endif
# 1468 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__COSHL) && ! defined (_GLIBCXX_HAVE_COSHL)
# define _GLIBCXX_HAVE_COSHL 1
# define coshl _coshl
#endif
# 1473 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__COSL) && ! defined (_GLIBCXX_HAVE_COSL)
# define _GLIBCXX_HAVE_COSL 1
# define cosl _cosl
#endif
# 1478 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__EXPF) && ! defined (_GLIBCXX_HAVE_EXPF)
# define _GLIBCXX_HAVE_EXPF 1
# define expf _expf
#endif
# 1483 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__EXPL) && ! defined (_GLIBCXX_HAVE_EXPL)
# define _GLIBCXX_HAVE_EXPL 1
# define expl _expl
#endif
# 1488 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FABSF) && ! defined (_GLIBCXX_HAVE_FABSF)
# define _GLIBCXX_HAVE_FABSF 1
# define fabsf _fabsf
#endif
# 1493 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FABSL) && ! defined (_GLIBCXX_HAVE_FABSL)
# define _GLIBCXX_HAVE_FABSL 1
# define fabsl _fabsl
#endif
# 1498 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FINITE) && ! defined (_GLIBCXX_HAVE_FINITE)
# define _GLIBCXX_HAVE_FINITE 1
# define finite _finite
#endif
# 1503 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FINITEF) && ! defined (_GLIBCXX_HAVE_FINITEF)
# define _GLIBCXX_HAVE_FINITEF 1
# define finitef _finitef
#endif
# 1508 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FINITEL) && ! defined (_GLIBCXX_HAVE_FINITEL)
# define _GLIBCXX_HAVE_FINITEL 1
# define finitel _finitel
#endif
# 1513 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FLOORF) && ! defined (_GLIBCXX_HAVE_FLOORF)
# define _GLIBCXX_HAVE_FLOORF 1
# define floorf _floorf
#endif
# 1518 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FLOORL) && ! defined (_GLIBCXX_HAVE_FLOORL)
# define _GLIBCXX_HAVE_FLOORL 1
# define floorl _floorl
#endif
# 1523 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FMODF) && ! defined (_GLIBCXX_HAVE_FMODF)
# define _GLIBCXX_HAVE_FMODF 1
# define fmodf _fmodf
#endif
# 1528 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FMODL) && ! defined (_GLIBCXX_HAVE_FMODL)
# define _GLIBCXX_HAVE_FMODL 1
# define fmodl _fmodl
#endif
# 1533 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FPCLASS) && ! defined (_GLIBCXX_HAVE_FPCLASS)
# define _GLIBCXX_HAVE_FPCLASS 1
# define fpclass _fpclass
#endif
# 1538 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FREXPF) && ! defined (_GLIBCXX_HAVE_FREXPF)
# define _GLIBCXX_HAVE_FREXPF 1
# define frexpf _frexpf
#endif
# 1543 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__FREXPL) && ! defined (_GLIBCXX_HAVE_FREXPL)
# define _GLIBCXX_HAVE_FREXPL 1
# define frexpl _frexpl
#endif
# 1548 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__HYPOT) && ! defined (_GLIBCXX_HAVE_HYPOT)
# define _GLIBCXX_HAVE_HYPOT 1
# define hypot _hypot
#endif
# 1553 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__HYPOTF) && ! defined (_GLIBCXX_HAVE_HYPOTF)
# define _GLIBCXX_HAVE_HYPOTF 1
# define hypotf _hypotf
#endif
# 1558 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__HYPOTL) && ! defined (_GLIBCXX_HAVE_HYPOTL)
# define _GLIBCXX_HAVE_HYPOTL 1
# define hypotl _hypotl
#endif
# 1563 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ISINF) && ! defined (_GLIBCXX_HAVE_ISINF)
# define _GLIBCXX_HAVE_ISINF 1
# define isinf _isinf
#endif
# 1568 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ISINFF) && ! defined (_GLIBCXX_HAVE_ISINFF)
# define _GLIBCXX_HAVE_ISINFF 1
# define isinff _isinff
#endif
# 1573 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ISINFL) && ! defined (_GLIBCXX_HAVE_ISINFL)
# define _GLIBCXX_HAVE_ISINFL 1
# define isinfl _isinfl
#endif
# 1578 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ISNAN) && ! defined (_GLIBCXX_HAVE_ISNAN)
# define _GLIBCXX_HAVE_ISNAN 1
# define isnan _isnan
#endif
# 1583 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ISNANF) && ! defined (_GLIBCXX_HAVE_ISNANF)
# define _GLIBCXX_HAVE_ISNANF 1
# define isnanf _isnanf
#endif
# 1588 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__ISNANL) && ! defined (_GLIBCXX_HAVE_ISNANL)
# define _GLIBCXX_HAVE_ISNANL 1
# define isnanl _isnanl
#endif
# 1593 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__LDEXPF) && ! defined (_GLIBCXX_HAVE_LDEXPF)
# define _GLIBCXX_HAVE_LDEXPF 1
# define ldexpf _ldexpf
#endif
# 1598 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__LDEXPL) && ! defined (_GLIBCXX_HAVE_LDEXPL)
# define _GLIBCXX_HAVE_LDEXPL 1
# define ldexpl _ldexpl
#endif
# 1603 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__LOG10F) && ! defined (_GLIBCXX_HAVE_LOG10F)
# define _GLIBCXX_HAVE_LOG10F 1
# define log10f _log10f
#endif
# 1608 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__LOG10L) && ! defined (_GLIBCXX_HAVE_LOG10L)
# define _GLIBCXX_HAVE_LOG10L 1
# define log10l _log10l
#endif
# 1613 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__LOGF) && ! defined (_GLIBCXX_HAVE_LOGF)
# define _GLIBCXX_HAVE_LOGF 1
# define logf _logf
#endif
# 1618 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__LOGL) && ! defined (_GLIBCXX_HAVE_LOGL)
# define _GLIBCXX_HAVE_LOGL 1
# define logl _logl
#endif
# 1623 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__MODF) && ! defined (_GLIBCXX_HAVE_MODF)
# define _GLIBCXX_HAVE_MODF 1
# define modf _modf
#endif
# 1628 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__MODFF) && ! defined (_GLIBCXX_HAVE_MODFF)
# define _GLIBCXX_HAVE_MODFF 1
# define modff _modff
#endif
# 1633 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__MODFL) && ! defined (_GLIBCXX_HAVE_MODFL)
# define _GLIBCXX_HAVE_MODFL 1
# define modfl _modfl
#endif
# 1638 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__POWF) && ! defined (_GLIBCXX_HAVE_POWF)
# define _GLIBCXX_HAVE_POWF 1
# define powf _powf
#endif
# 1643 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__POWL) && ! defined (_GLIBCXX_HAVE_POWL)
# define _GLIBCXX_HAVE_POWL 1
# define powl _powl
#endif
# 1648 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__QFPCLASS) && ! defined (_GLIBCXX_HAVE_QFPCLASS)
# define _GLIBCXX_HAVE_QFPCLASS 1
# define qfpclass _qfpclass
#endif
# 1653 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SINCOS) && ! defined (_GLIBCXX_HAVE_SINCOS)
# define _GLIBCXX_HAVE_SINCOS 1
# define sincos _sincos
#endif
# 1658 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SINCOSF) && ! defined (_GLIBCXX_HAVE_SINCOSF)
# define _GLIBCXX_HAVE_SINCOSF 1
# define sincosf _sincosf
#endif
# 1663 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SINCOSL) && ! defined (_GLIBCXX_HAVE_SINCOSL)
# define _GLIBCXX_HAVE_SINCOSL 1
# define sincosl _sincosl
#endif
# 1668 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SINF) && ! defined (_GLIBCXX_HAVE_SINF)
# define _GLIBCXX_HAVE_SINF 1
# define sinf _sinf
#endif
# 1673 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SINHF) && ! defined (_GLIBCXX_HAVE_SINHF)
# define _GLIBCXX_HAVE_SINHF 1
# define sinhf _sinhf
#endif
# 1678 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SINHL) && ! defined (_GLIBCXX_HAVE_SINHL)
# define _GLIBCXX_HAVE_SINHL 1
# define sinhl _sinhl
#endif
# 1683 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SINL) && ! defined (_GLIBCXX_HAVE_SINL)
# define _GLIBCXX_HAVE_SINL 1
# define sinl _sinl
#endif
# 1688 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SQRTF) && ! defined (_GLIBCXX_HAVE_SQRTF)
# define _GLIBCXX_HAVE_SQRTF 1
# define sqrtf _sqrtf
#endif
# 1693 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__SQRTL) && ! defined (_GLIBCXX_HAVE_SQRTL)
# define _GLIBCXX_HAVE_SQRTL 1
# define sqrtl _sqrtl
#endif
# 1698 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__STRTOF) && ! defined (_GLIBCXX_HAVE_STRTOF)
# define _GLIBCXX_HAVE_STRTOF 1
# define strtof _strtof
#endif
# 1703 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__STRTOLD) && ! defined (_GLIBCXX_HAVE_STRTOLD)
# define _GLIBCXX_HAVE_STRTOLD 1
# define strtold _strtold
#endif
# 1708 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__TANF) && ! defined (_GLIBCXX_HAVE_TANF)
# define _GLIBCXX_HAVE_TANF 1
# define tanf _tanf
#endif
# 1713 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__TANHF) && ! defined (_GLIBCXX_HAVE_TANHF)
# define _GLIBCXX_HAVE_TANHF 1
# define tanhf _tanhf
#endif
# 1718 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__TANHL) && ! defined (_GLIBCXX_HAVE_TANHL)
# define _GLIBCXX_HAVE_TANHL 1
# define tanhl _tanhl
#endif
# 1723 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#if defined (_GLIBCXX_HAVE__TANL) && ! defined (_GLIBCXX_HAVE_TANL)
# define _GLIBCXX_HAVE_TANL 1
# define tanl _tanl
#endif
# 1728 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3

#endif // _GLIBCXX_CXX_CONFIG_H
# 1730 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++config.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/functexcept.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/functexcept.h" 1 3
// Function-Based Exception Support -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/functexcept.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{exception}
 *
 *  This header provides support for -fno-exceptions.
 */

//
// ISO C++ 14882: 19.1  Exception classes
//

#ifndef _FUNCTEXCEPT_H
#define _FUNCTEXCEPT_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/functexcept.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/functexcept.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/exception_defines.h>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/functexcept.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/exception_defines.h" 1 3
// -fno-exceptions Support -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/exception_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{exception}
 */

#ifndef _EXCEPTION_DEFINES_H
#define _EXCEPTION_DEFINES_H 1

#if ! __cpp_exceptions
// Iff -fno-exceptions, transform error handling code to work without it.
# define __try      if (true)
# define __catch(X) if (false)
# define __throw_exception_again
#else
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/exception_defines.h" 3
// Else proceed normally.
# define __try      try
# define __catch(X) catch(X)
# define __throw_exception_again throw
#endif
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/exception_defines.h" 3

#endif
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/exception_defines.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/functexcept.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Helper for exception objects in <except>
  void
  __throw_bad_exception(void) __attribute__((__noreturn__));

  // Helper for exception objects in <new>
  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  // Helper for exception objects in <typeinfo>
  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));

  // Helpers for exception objects in <stdexcept>
  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));

  // Helpers for exception objects in <ios>
  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));

  // Helpers for exception objects in <functional>
  void
  __throw_bad_function_call() __attribute__((__noreturn__));

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 111 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/functexcept.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 1 3
// The  -*- C++ -*- type traits classes for internal use in libstdc++

// Copyright (C) 2000-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ext/type_traits}
 */

// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>

#ifndef _CPP_TYPE_TRAITS_H
#define _CPP_TYPE_TRAITS_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3

//
// This file provides some compile-time information about various types.
// These representations were designed, on purpose, to be constant-expressions
// and not types as found in <bits/type_traits.h>.  In particular, they
// can be used in control structures and the optimizer hopefully will do
// the obvious thing.
//
// Why integral expressions, and not functions nor types?
// Firstly, these compile-time entities are used as template-arguments
// so function return values won't work:  We need compile-time entities.
// We're left with types and constant  integral expressions.
// Secondly, from the point of view of ease of use, type-based compile-time
// information is -not- *that* convenient.  On has to write lots of
// overloaded functions and to hope that the compiler will select the right
// one. As a net effect, the overall structure isn't very clear at first
// glance.
// Thirdly, partial ordering and overload resolution (of function templates)
// is highly costly in terms of compiler-resource.  It is a Good Thing to
// keep these resource consumption as least as possible.
//
// See valarray_array.h for a case use.
//
// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.
//
// Update 2005: types are also provided and <bits/type_traits.h> has been
// removed.
//

// Forward declaration hack, should really include this from somewhere.
namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };

  // N.B. The conversions to bool are needed due to the issue
  // explained in c++/19404.
  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };

  // Compare for equality of types.
  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  // Holds if the template-argument is a void type.
  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Integer types
  //
  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  // Thirteen specializations (yes there are eleven standard integer
  // types; <em>long long</em> and <em>unsigned long long</em> are
  // supported as extensions).  Up to four target-specific __int<N>
  // types are supported as well.
  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

# ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# endif
# 182 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3

#if __cplusplus >= 201103L
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#endif
# 198 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3

  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

#define __INT_N(TYPE) 			\
  template<>				\
    struct __is_integer<TYPE>		\
    {					\
      enum { __value = 1 };		\
      typedef __true_type __type;	\
    };					\
  template<>				\
    struct __is_integer<unsigned TYPE>	\
    {					\
      enum { __value = 1 };		\
      typedef __true_type __type;	\
    };

#ifdef __GLIBCXX_TYPE_INT_N_0
__INT_N(__GLIBCXX_TYPE_INT_N_0)
#endif
# 272 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3
#ifdef __GLIBCXX_TYPE_INT_N_1
__INT_N(__GLIBCXX_TYPE_INT_N_1)
#endif
# 275 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3
#ifdef __GLIBCXX_TYPE_INT_N_2
__INT_N(__GLIBCXX_TYPE_INT_N_2)
#endif
# 278 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3
#ifdef __GLIBCXX_TYPE_INT_N_3
__INT_N(__GLIBCXX_TYPE_INT_N_3)
#endif
# 281 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3

#undef __INT_N

  //
  // Floating point types
  //
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  // three specializations (float, double and 'long double')
  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Pointer types
  //
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Normal iterator type
  //
  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
							      _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // An arithmetic type is an integer type or a floating point type
  //
  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };

  //
  // A scalar type is an arithmetic type or a pointer type
  // 
  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };

  //
  // For use in std::copy and std::find overloads for streambuf iterators.
  //
  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

#ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#endif
# 392 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3

  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  //
  // Move iterator type
  //
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

#if __cplusplus >= 201103L
  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
#endif
# 442 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif //_CPP_TYPE_TRAITS_H
# 447 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cpp_type_traits.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/type_traits.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 1 3
// -*- C++ -*-

// Copyright (C) 2005-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 3, or (at your option) any later
// version.

// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/type_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */

#ifndef _EXT_TYPE_TRAITS
#define _EXT_TYPE_TRAITS 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 3
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 3

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Define a nested type if some predicate holds.
  template<bool, typename>
    struct __enable_if 
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };


  // Conditional expression for types. If true, first, if false, second.
  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };


  // Given an integral builtin type, return the corresponding unsigned type.
  template<typename _Tp>
    struct __add_unsigned
    { 
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
      
    public:
      typedef typename __if_type::__type __type; 
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };

  // Declare but don't define.
  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;


  // Given an integral builtin type, return the corresponding signed type.
  template<typename _Tp>
    struct __remove_unsigned
    { 
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
      
    public:
      typedef typename __if_type::__type __type; 
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };

  // Declare but don't define.
  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;


  // For use in string and vstring.
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }

#if __cplusplus >= 201103L
  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }
#endif
# 163 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 3

  // For complex and cmath
  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  // No nested __type member for non-integer non-floating point types,
  // allows this type to be used for SFINAE to constrain overloads in
  // <cmath> and <complex> to only the intended types.
  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif 
# 219 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/type_traits.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/numeric_traits.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/numeric_traits.h" 1 3
// -*- C++ -*-

// Copyright (C) 2007-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the terms
// of the GNU General Public License as published by the Free Software
// Foundation; either version 3, or (at your option) any later
// version.

// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/numeric_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */

#ifndef _EXT_NUMERIC_TRAITS
#define _EXT_NUMERIC_TRAITS 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/numeric_traits.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/numeric_traits.h" 3
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/numeric_traits.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/type_traits.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/numeric_traits.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/numeric_traits.h" 3

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Compile time constants for builtin types.
  // Sadly std::numeric_limits member functions cannot be used for this.
#define __glibcxx_signed(_Tp) ((_Tp)(-1) < 0)
#define __glibcxx_digits(_Tp) \
  (sizeof(_Tp) * __CHAR_BIT__ - __glibcxx_signed(_Tp))

#define __glibcxx_min(_Tp) \
  (__glibcxx_signed(_Tp) ? (_Tp)1 << __glibcxx_digits(_Tp) : (_Tp)0)

#define __glibcxx_max(_Tp) \
  (__glibcxx_signed(_Tp) ? \
   (((((_Tp)1 << (__glibcxx_digits(_Tp) - 1)) - 1) << 1) + 1) : ~(_Tp)0)

  template<typename _Value>
    struct __numeric_traits_integer
    {
      // Only integers for initialization of member constant.
      static const _Value __min = __glibcxx_min(_Value);
      static const _Value __max = __glibcxx_max(_Value);

      // NB: these two also available in std::numeric_limits as compile
      // time constants, but <limits> is big and we avoid including it.
      static const bool __is_signed = __glibcxx_signed(_Value);
      static const int __digits = __glibcxx_digits(_Value);      
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;

#undef __glibcxx_signed
#undef __glibcxx_digits
#undef __glibcxx_min
#undef __glibcxx_max

#define __glibcxx_floating(_Tp, _Fval, _Dval, _LDval) \
  (std::__are_same<_Tp, float>::__value ? _Fval \
   : std::__are_same<_Tp, double>::__value ? _Dval : _LDval)

#define __glibcxx_max_digits10(_Tp) \
  (2 + __glibcxx_floating(_Tp, __FLT_MANT_DIG__, __DBL_MANT_DIG__, \
			  __LDBL_MANT_DIG__) * 643L / 2136)

#define __glibcxx_digits10(_Tp) \
  __glibcxx_floating(_Tp, __FLT_DIG__, __DBL_DIG__, __LDBL_DIG__)

#define __glibcxx_max_exponent10(_Tp) \
  __glibcxx_floating(_Tp, __FLT_MAX_10_EXP__, __DBL_MAX_10_EXP__, \
		     __LDBL_MAX_10_EXP__)

  template<typename _Value>
    struct __numeric_traits_floating
    {
      // Only floating point types. See N1822. 
      static const int __max_digits10 = __glibcxx_max_digits10(_Value);

      // See above comment...
      static const bool __is_signed = true;
      static const int __digits10 = __glibcxx_digits10(_Value);
      static const int __max_exponent10 = __glibcxx_max_exponent10(_Value);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
				__numeric_traits_integer<_Value>,
				__numeric_traits_floating<_Value> >::__type
    { };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#undef __glibcxx_floating
#undef __glibcxx_max_digits10
#undef __glibcxx_digits10
#undef __glibcxx_max_exponent10

#endif 
# 139 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/numeric_traits.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_pair.h>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 1 3
// Pair implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_pair.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */

#ifndef _STL_PAIR_H
#define _STL_PAIR_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h> // for std::move / std::forward, and std::swap
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 1 3
// Move, forward and identity for C++0x + swap -*- C++ -*-

// Copyright (C) 2007-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/move.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */

#ifndef _MOVE_H
#define _MOVE_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 1 3
// Concept-checking control -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/concept_check.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */

#ifndef _CONCEPT_CHECK_H
#define _CONCEPT_CHECK_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3

// All places in libstdc++-v3 where these are used, or /might/ be used, or
// don't need to be used, or perhaps /should/ be used, are commented with
// "concept requirements" (and maybe some more text).  So grep like crazy
// if you're looking for additional places to use these.

// Concept-checking code is off by default unless users turn it on via
// configure options or editing c++config.h.

#ifndef _GLIBCXX_CONCEPT_CHECKS

#define __glibcxx_function_requires(...)
#define __glibcxx_class_requires(_a,_b)
#define __glibcxx_class_requires2(_a,_b,_c)
#define __glibcxx_class_requires3(_a,_b,_c,_d)
#define __glibcxx_class_requires4(_a,_b,_c,_d,_e)

#else // the checks are on
# 54 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/boost_concept_check.h>
#endif /* expanded by -frewrite-includes */
# 55 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3
# 56 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3

// Note that the obvious and elegant approach of
//
//#define glibcxx_function_requires(C) debug::function_requires< debug::C >()
//
// won't work due to concept templates with more than one parameter, e.g.,
// BinaryPredicateConcept.  The preprocessor tries to split things up on
// the commas in the template argument list.  We can't use an inner pair of
// parenthesis to hide the commas, because "debug::(Temp<Foo,Bar>)" isn't
// a valid instantiation pattern.  Thus, we steal a feature from C99.

#define __glibcxx_function_requires(...)                                 \
            __gnu_cxx::__function_requires< __gnu_cxx::__VA_ARGS__ >();
#define __glibcxx_class_requires(_a,_C)                                  \
            _GLIBCXX_CLASS_REQUIRES(_a, __gnu_cxx, _C);
#define __glibcxx_class_requires2(_a,_b,_C)                              \
            _GLIBCXX_CLASS_REQUIRES2(_a, _b, __gnu_cxx, _C);
#define __glibcxx_class_requires3(_a,_b,_c,_C)                           \
            _GLIBCXX_CLASS_REQUIRES3(_a, _b, _c, __gnu_cxx, _C);
#define __glibcxx_class_requires4(_a,_b,_c,_d,_C)                        \
            _GLIBCXX_CLASS_REQUIRES4(_a, _b, _c, _d, __gnu_cxx, _C);

#endif // enable/disable
# 79 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3

#endif // _GLIBCXX_CONCEPT_CHECK
# 81 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/concept_check.h" 3
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Used, in C++03 mode too, by allocators, etc.
  /**
   *  @brief Same as C++11 std::addressof
   *  @ingroup utilities
   */
  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
    {
      return reinterpret_cast<_Tp*>
	(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <type_traits> // Brings in std::declval too.
#endif /* expanded by -frewrite-includes */
# 57 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
# 58 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @addtogroup utilities
   *  @{
   */

  /**
   *  @brief  Forward an lvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }

  /**
   *  @brief  Forward an rvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
		    " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }

  /**
   *  @brief  Convert a value to an rvalue.
   *  @param  __t  A thing of arbitrary type.
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };

  /**
   *  @brief  Conditionally convert a value to an rvalue.
   *  @param  __x  A thing of arbitrary type.
   *  @return The parameter, possibly cast to an rvalue-reference.
   *
   *  Same as std::move unless the type's move constructor could throw and the
   *  type is copyable, in which case an lvalue-reference is returned instead.
   */
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }

  // declval, from type_traits.

  /**
   *  @brief Returns the actual address of the object or function
   *         referenced by r, even in the presence of an overloaded
   *         operator&.
   *  @param  __r  Reference to an object or function.
   *  @return   The actual address.
  */
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }

  // C++11 version of std::exchange for internal use.
  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }

  /// @} group utilities
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#define _GLIBCXX_MOVE(__val) std::move(__val)
#define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
#else
# 155 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
#define _GLIBCXX_MOVE(__val) (__val)
#define _GLIBCXX_FORWARD(_Tp, __val) (__val)
#endif
# 158 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @addtogroup utilities
   *  @{
   */

  /**
   *  @brief Swaps two values.
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  */
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
#if __cplusplus >= 201103L
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
	            is_nothrow_move_assignable<_Tp>>::value)
#endif
# 181 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
    }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 809. std::swap should be overloaded for array types.
  /// Swap the contents of two arrays.
  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
#if __cplusplus >= 201103L
    noexcept(noexcept(swap(*__a, *__b)))
#endif
# 199 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
	swap(__a[__n], __b[__n]);
    }

  /// @} group utilities
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _MOVE_H */
# 209 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/move.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 2 3

#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <type_traits> // for std::__decay_and_strip too
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3
#endif
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @addtogroup utilities
   *  @{
   */

#if __cplusplus >= 201103L
  /// piecewise_construct_t
  struct piecewise_construct_t { };

  /// piecewise_construct
  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();

  // Forward declarations.
  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;
#endif
# 88 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3

 /**
   *  @brief Struct holding two objects of arbitrary type.
   *
   *  @tparam _T1  Type of first object.
   *  @tparam _T2  Type of second object.
   */
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;    /// @c first_type is the first bound type
      typedef _T2 second_type;   /// @c second_type is the second bound type

      _T1 first;                 /// @c first is a copy of the first object
      _T2 second;                /// @c second is a copy of the second object

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 265.  std::pair::pair() effects overly restrictive
      /** The default constructor creates @c first and @c second using their
       *  respective default constructors.  */
      _GLIBCXX_CONSTEXPR pair()
      : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

      /** There is also a templated copy ctor for the @c pair class itself.  */
#if __cplusplus < 201103L
      template<class _U1, class _U2>
	pair(const pair<_U1, _U2>& __p)
	: first(__p.first), second(__p.second) { }
#else
# 121 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3
      template<class _U1, class _U2, class = typename
	       enable_if<__and_<is_convertible<const _U1&, _T1>,
				is_convertible<const _U2&, _T2>>::value>::type>
	constexpr pair(const pair<_U1, _U2>& __p)
	: first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;

      // DR 811.
      template<class _U1, class = typename
	       enable_if<is_convertible<_U1, _T1>::value>::type>
	constexpr pair(_U1&& __x, const _T2& __y)
	: first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
	       enable_if<is_convertible<_U2, _T2>::value>::type>
	constexpr pair(const _T1& __x, _U2&& __y)
	: first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
	       enable_if<__and_<is_convertible<_U1, _T1>,
				is_convertible<_U2, _T2>>::value>::type>
	constexpr pair(_U1&& __x, _U2&& __y)
	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
	       enable_if<__and_<is_convertible<_U1, _T1>,
				is_convertible<_U2, _T2>>::value>::type>
	constexpr pair(pair<_U1, _U2>&& __p)
	: first(std::forward<_U1>(__p.first)),
	  second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
	first = __p.first;
	second = __p.second;
	return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
	              is_nothrow_move_assignable<_T2>>::value)
      {
	first = std::forward<first_type>(__p.first);
	second = std::forward<second_type>(__p.second);
	return *this;
      }

      template<class _U1, class _U2>
	pair&
	operator=(const pair<_U1, _U2>& __p)
	{
	  first = __p.first;
	  second = __p.second;
	  return *this;
	}

      template<class _U1, class _U2>
	pair&
	operator=(pair<_U1, _U2>&& __p)
	{
	  first = std::forward<_U1>(__p.first);
	  second = std::forward<_U2>(__p.second);
	  return *this;
	}

      void
      swap(pair& __p)
      noexcept(noexcept(swap(first, __p.first))
	       && noexcept(swap(second, __p.second)))
      {
	using std::swap;
	swap(first, __p.first);
	swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
#endif
# 209 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3
    };

  /// Two pairs of the same type are equal iff their members are equal.
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }

  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
	     || (!(__y.first < __x.first) && __x.second < __y.second); }

  /// Uses @c operator== to find the result.
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }

  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }

  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }

  /// Uses @c operator< to find the result.
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }

#if __cplusplus >= 201103L
  /// See std::pair::swap().
  // Note:  no std::swap overloads in C++03 mode, this has performance
  //        implications, see, eg, libstdc++/38466.
  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
#endif
# 258 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3

  /**
   *  @brief A convenience wrapper for creating a pair from two objects.
   *  @param  __x  The first object.
   *  @param  __y  The second object.
   *  @return   A newly-constructed pair<> object of the appropriate type.
   *
   *  The standard requires that the objects be passed by reference-to-const,
   *  but LWG issue #181 says they should be passed by const value.  We follow
   *  the LWG by default.
   */
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 181.  make_pair() unintended behavior
#if __cplusplus >= 201103L
  // NB: DR 706.
  template<class _T1, class _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
#else
# 284 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
#endif
# 289 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3

  /// @}

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif /* _STL_PAIR_H */
# 296 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_pair.h" 3
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_types.h>
#endif /* expanded by -frewrite-includes */
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 1 3
// Types used in iterator implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_iterator_base_types.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file contains all of the general iterator-related utility types,
 *  such as iterator_traits and struct iterator.
 */

#ifndef _STL_ITERATOR_BASE_TYPES_H
#define _STL_ITERATOR_BASE_TYPES_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3

#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
# include <type_traits>  // For __void_t, is_convertible
#endif /* expanded by -frewrite-includes */
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3
#endif
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @defgroup iterators Iterators
   *  Abstractions for uniform iterating through various underlying types.
  */
  //@{ 

  /**
   *  @defgroup iterator_tags Iterator Tags
   *  These are empty types, used to distinguish different iterators.  The
   *  distinction is not made by what they contain, but simply by what they
   *  are.  Different underlying algorithms can then be used based on the
   *  different operations supported by different iterator types.
  */
  //@{ 
  ///  Marking input iterators.
  struct input_iterator_tag { };

  ///  Marking output iterators.
  struct output_iterator_tag { };

  /// Forward iterators support a superset of input iterator operations.
  struct forward_iterator_tag : public input_iterator_tag { };

  /// Bidirectional iterators support a superset of forward iterator
  /// operations.
  struct bidirectional_iterator_tag : public forward_iterator_tag { };

  /// Random-access iterators support a superset of bidirectional
  /// iterator operations.
  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
  //@}

  /**
   *  @brief  Common %iterator class.
   *
   *  This class does nothing but define nested typedefs.  %Iterator classes
   *  can inherit from this class to save some work.  The typedefs are then
   *  used in specializations and overloading.
   *
   *  In particular, there are no default implementations of requirements
   *  such as @c operator++ and the like.  (How could there be?)
  */
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {
      /// One of the @link iterator_tags tag types@endlink.
      typedef _Category  iterator_category;
      /// The type "pointed to" by the iterator.
      typedef _Tp        value_type;
      /// Distance between iterators is represented as this type.
      typedef _Distance  difference_type;
      /// This type represents a pointer-to-value_type.
      typedef _Pointer   pointer;
      /// This type represents a reference-to-value_type.
      typedef _Reference reference;
    };

  /**
   *  @brief  Traits class for iterators.
   *
   *  This class does nothing but define nested typedefs.  The general
   *  version simply @a forwards the nested typedefs from the Iterator
   *  argument.  Specialized versions for pointers and pointers-to-const
   *  provide tighter, more correct semantics.
  */
#if __cplusplus >= 201103L
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
			     __void_t<typename _Iterator::iterator_category,
				      typename _Iterator::value_type,
				      typename _Iterator::difference_type,
				      typename _Iterator::pointer,
				      typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type        value_type;
      typedef typename _Iterator::difference_type   difference_type;
      typedef typename _Iterator::pointer           pointer;
      typedef typename _Iterator::reference         reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
#else
# 165 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type        value_type;
      typedef typename _Iterator::difference_type   difference_type;
      typedef typename _Iterator::pointer           pointer;
      typedef typename _Iterator::reference         reference;
    };
#endif
# 175 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3

  /// Partial specialization for pointer types.
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp                         value_type;
      typedef ptrdiff_t                   difference_type;
      typedef _Tp*                        pointer;
      typedef _Tp&                        reference;
    };

  /// Partial specialization for const pointer types.
  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp                         value_type;
      typedef ptrdiff_t                   difference_type;
      typedef const _Tp*                  pointer;
      typedef const _Tp&                  reference;
    };

  /**
   *  This function is not a part of the C++ standard but is syntactic
   *  sugar for internal library use only.
  */
  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

  //@}

  // If _Iterator has a base returns it otherwise _Iterator is returned
  // untouched
  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };

#if __cplusplus >= 201103L
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
		iterator_traits<_InIter>::iterator_category,
			       input_iterator_tag>::value>::type;
#endif
# 234 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _STL_ITERATOR_BASE_TYPES_H */
# 239 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_types.h" 3

# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_funcs.h>
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 1 3
// Functions used by iterators -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_iterator_base_funcs.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file contains all of the general iterator-related utility
 *  functions, such as distance() and advance().
 */

#ifndef _STL_ITERATOR_BASE_FUNCS_H
#define _STL_ITERATOR_BASE_FUNCS_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 3
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <debug/debug.h>
#endif /* expanded by -frewrite-includes */
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 1 3
// Debugging support implementation -*- C++ -*-

// Copyright (C) 2003-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file debug/debug.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */

#ifndef _GLIBCXX_DEBUG_MACRO_SWITCH_H
#define _GLIBCXX_DEBUG_MACRO_SWITCH_H 1

/** Macros and namespaces used by the implementation outside of debug
 *  wrappers to verify certain properties. The __glibcxx_requires_xxx
 *  macros are merely wrappers around the __glibcxx_check_xxx wrappers
 *  when we are compiling with debug mode, but disappear when we are
 *  in release mode so that there is no checking performed in, e.g.,
 *  the standard library algorithms.
*/

// Debug mode namespaces.

/**
 * @namespace std::__debug
 * @brief GNU debug code, replaces standard behavior with debug behavior.
 */
namespace std
{ 
  namespace __debug { } 
}

/** @namespace __gnu_debug
 *  @brief GNU debug classes for public use.
*/
namespace __gnu_debug
{
  using namespace std::__debug;
}

#ifndef _GLIBCXX_DEBUG

# define _GLIBCXX_DEBUG_ASSERT(_Condition)
# define _GLIBCXX_DEBUG_PEDASSERT(_Condition)
# define _GLIBCXX_DEBUG_ONLY(_Statement) ;
# define __glibcxx_requires_cond(_Cond,_Msg)
# define __glibcxx_requires_valid_range(_First,_Last)
# define __glibcxx_requires_non_empty_range(_First,_Last)
# define __glibcxx_requires_sorted(_First,_Last)
# define __glibcxx_requires_sorted_pred(_First,_Last,_Pred)
# define __glibcxx_requires_sorted_set(_First1,_Last1,_First2)
# define __glibcxx_requires_sorted_set_pred(_First1,_Last1,_First2,_Pred)
# define __glibcxx_requires_partitioned_lower(_First,_Last,_Value)
# define __glibcxx_requires_partitioned_upper(_First,_Last,_Value)
# define __glibcxx_requires_partitioned_lower_pred(_First,_Last,_Value,_Pred)
# define __glibcxx_requires_partitioned_upper_pred(_First,_Last,_Value,_Pred)
# define __glibcxx_requires_heap(_First,_Last)
# define __glibcxx_requires_heap_pred(_First,_Last,_Pred)
# define __glibcxx_requires_nonempty()
# define __glibcxx_requires_string(_String)
# define __glibcxx_requires_string_len(_String,_Len)
# define __glibcxx_requires_subscript(_N)

#else
# 83 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3

#if 0 /* expanded by -frewrite-includes */
# include <debug/macros.h>
#endif /* expanded by -frewrite-includes */
# 84 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3
# 85 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3

#define _GLIBCXX_DEBUG_ASSERT(_Condition) __glibcxx_assert(_Condition)

#ifdef _GLIBCXX_DEBUG_PEDANTIC
# define _GLIBCXX_DEBUG_PEDASSERT(_Condition) _GLIBCXX_DEBUG_ASSERT(_Condition)
#else
# 91 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3
# define _GLIBCXX_DEBUG_PEDASSERT(_Condition)
#endif
# 93 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3

# define _GLIBCXX_DEBUG_ONLY(_Statement) _Statement

# define __glibcxx_requires_cond(_Cond,_Msg) _GLIBCXX_DEBUG_VERIFY(_Cond,_Msg)
# define __glibcxx_requires_valid_range(_First,_Last) \
     __glibcxx_check_valid_range(_First,_Last)
# define __glibcxx_requires_non_empty_range(_First,_Last) \
     __glibcxx_check_non_empty_range(_First,_Last)
# define __glibcxx_requires_sorted(_First,_Last) \
     __glibcxx_check_sorted(_First,_Last)
# define __glibcxx_requires_sorted_pred(_First,_Last,_Pred) \
     __glibcxx_check_sorted_pred(_First,_Last,_Pred)
# define __glibcxx_requires_sorted_set(_First1,_Last1,_First2) \
     __glibcxx_check_sorted_set(_First1,_Last1,_First2)
# define __glibcxx_requires_sorted_set_pred(_First1,_Last1,_First2,_Pred) \
     __glibcxx_check_sorted_set_pred(_First1,_Last1,_First2,_Pred)
# define __glibcxx_requires_partitioned_lower(_First,_Last,_Value)	\
     __glibcxx_check_partitioned_lower(_First,_Last,_Value)
# define __glibcxx_requires_partitioned_upper(_First,_Last,_Value)	\
     __glibcxx_check_partitioned_upper(_First,_Last,_Value)
# define __glibcxx_requires_partitioned_lower_pred(_First,_Last,_Value,_Pred) \
     __glibcxx_check_partitioned_lower_pred(_First,_Last,_Value,_Pred)
# define __glibcxx_requires_partitioned_upper_pred(_First,_Last,_Value,_Pred) \
     __glibcxx_check_partitioned_upper_pred(_First,_Last,_Value,_Pred)
# define __glibcxx_requires_heap(_First,_Last) \
     __glibcxx_check_heap(_First,_Last)
# define __glibcxx_requires_heap_pred(_First,_Last,_Pred) \
     __glibcxx_check_heap_pred(_First,_Last,_Pred)
# define __glibcxx_requires_nonempty() __glibcxx_check_nonempty()
# define __glibcxx_requires_string(_String) __glibcxx_check_string(_String)
# define __glibcxx_requires_string_len(_String,_Len)	\
     __glibcxx_check_string_len(_String,_Len)
# define __glibcxx_requires_subscript(_N) __glibcxx_check_subscript(_N)

#if 0 /* expanded by -frewrite-includes */
# include <debug/functions.h>
#endif /* expanded by -frewrite-includes */
# 127 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3
# 128 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3

#endif
# 130 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3

#endif // _GLIBCXX_DEBUG_MACRO_SWITCH_H
# 132 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/debug/debug.h" 3
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
	{
	  ++__first;
	  ++__n;
	}
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
    }

  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __first  An input iterator.
   *  @param  __last  An input iterator.
   *  @return  The distance between them.
   *
   *  Returns @c n such that __first + n == __last.  This requires
   *  that @p __last must be reachable from @p __first.  Note that @c
   *  n may be negative.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {
      // concept requirements -- taken care of in __distance
      return std::__distance(__first, __last,
			     std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      _GLIBCXX_DEBUG_ASSERT(__n >= 0);
      while (__n--)
	++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
	      bidirectional_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      if (__n > 0)
        while (__n--)
	  ++__i;
      else
        while (__n++)
	  --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __i += __n;
    }

  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __i  An input iterator.
   *  @param  __n  The @a delta by which to change @p __i.
   *  @return  Nothing.
   *
   *  This increments @p i by @p n.  For bidirectional and random access
   *  iterators, @p __n may be negative, in which case @p __i is decremented.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {
      // concept requirements -- taken care of in __advance
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

#if __cplusplus >= 201103L

  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
	 iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
	 iterator_traits<_BidirectionalIterator>::difference_type __n = 1) 
    {
      std::advance(__x, -__n);
      return __x;
    }

#endif // C++11
# 201 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _STL_ITERATOR_BASE_FUNCS_H */
# 206 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator_base_funcs.h" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator.h>
#endif /* expanded by -frewrite-includes */
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 1 3
// Iterators -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_iterator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file implements reverse_iterator, back_insert_iterator,
 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
 *  supporting functions and overloaded operators.
 */

#ifndef _STL_ITERATOR_H
#define _STL_ITERATOR_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/type_traits.h>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/ptr_traits.h>
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ptr_traits.h" 1 3
// Pointer Traits -*- C++ -*-

// Copyright (C) 2011-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ptr_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */

#ifndef _PTR_TRAITS_H
#define _PTR_TRAITS_H 1

#if __cplusplus >= 201103L

#if 0 /* expanded by -frewrite-includes */
#include <type_traits> // For _GLIBCXX_HAS_NESTED_TYPE
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ptr_traits.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ptr_traits.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

_GLIBCXX_HAS_NESTED_TYPE(element_type)
_GLIBCXX_HAS_NESTED_TYPE(difference_type)

  template<typename _Tp, bool = __has_element_type<_Tp>::value>
    struct __ptrtr_elt_type;

  template<typename _Tp>
    struct __ptrtr_elt_type<_Tp, true>
    {
      typedef typename _Tp::element_type __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Tp,
            typename... _Args>
    struct __ptrtr_elt_type<_SomePtr<_Tp, _Args...>, false>
    {
      typedef _Tp __type;
    };

  template<typename _Tp, bool = __has_difference_type<_Tp>::value>
    struct __ptrtr_diff_type
    {
      typedef typename _Tp::difference_type __type;
    };

  template<typename _Tp>
    struct __ptrtr_diff_type<_Tp, false>
    {
      typedef ptrdiff_t __type;
    };

  template<typename _Ptr, typename _Up>
    class __ptrtr_rebind_helper
    {
      template<typename _Ptr2, typename _Up2>
	static constexpr true_type
	_S_chk(typename _Ptr2::template rebind<_Up2>*);

      template<typename, typename>
	static constexpr false_type
	_S_chk(...);

    public:
      using __type = decltype(_S_chk<_Ptr, _Up>(nullptr));
    };

  template<typename _Tp, typename _Up,
           bool = __ptrtr_rebind_helper<_Tp, _Up>::__type::value>
    struct __ptrtr_rebind;

  template<typename _Tp, typename _Up>
    struct __ptrtr_rebind<_Tp, _Up, true>
    {
      typedef typename _Tp::template rebind<_Up> __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Up,
            typename _Tp, typename... _Args>
    struct __ptrtr_rebind<_SomePtr<_Tp, _Args...>, _Up, false>
    {
      typedef _SomePtr<_Up, _Args...> __type;
    };

  template<typename _Tp, typename = typename remove_cv<_Tp>::type>
    struct __ptrtr_not_void
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __ptrtr_not_void<_Tp, void>
    {
      struct __type { };
    };

  template<typename _Ptr>
    class __ptrtr_pointer_to
    {
      typedef typename __ptrtr_elt_type<_Ptr>::__type   __orig_type;
      typedef typename __ptrtr_not_void<__orig_type>::__type __element_type;

    public:
      static _Ptr pointer_to(__element_type& __e)
      { return _Ptr::pointer_to(__e); }
    };

  /**
   * @brief  Uniform interface to all pointer-like types
   * @ingroup pointer_abstractions
  */
  template<typename _Ptr>
    struct pointer_traits : __ptrtr_pointer_to<_Ptr>
    {
      /// The pointer type
      typedef _Ptr                                      pointer;
      /// The type pointed to
      typedef typename __ptrtr_elt_type<_Ptr>::__type   element_type;
      /// Type used to represent the difference between two pointers
      typedef typename __ptrtr_diff_type<_Ptr>::__type  difference_type;

      template<typename _Up>
        using rebind = typename __ptrtr_rebind<_Ptr, _Up>::__type;
    };

  /**
   * @brief  Partial specialization for built-in pointers.
   * @ingroup pointer_abstractions
  */
  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {
      /// The pointer type
      typedef _Tp* pointer;
      /// The type pointed to
      typedef _Tp  element_type;
      /// Type used to represent the difference between two pointers
      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;

      /**
       *  @brief  Obtain a pointer to an object
       *  @param  __r  A reference to an object of type @c element_type
       *  @return @c addressof(__r)
      */
      static pointer
      pointer_to(typename __ptrtr_not_void<element_type>::__type& __r) noexcept
      { return std::addressof(__r); }
    };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 176 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ptr_traits.h" 3

#endif
# 178 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ptr_traits.h" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   * @addtogroup iterators
   * @{
   */

  // 24.4.1 Reverse iterators
  /**
   *  Bidirectional and random access iterators have corresponding reverse
   *  %iterator adaptors that iterate through the data structure in the
   *  opposite direction.  They have the same signatures as the corresponding
   *  iterators.  The fundamental relation between a reverse %iterator and its
   *  corresponding %iterator @c i is established by the identity:
   *  @code
   *      &*(reverse_iterator(i)) == &*(i - 1)
   *  @endcode
   *
   *  <em>This mapping is dictated by the fact that while there is always a
   *  pointer past the end of an array, there might not be a valid pointer
   *  before the beginning of an array.</em> [24.4.1]/1,2
   *
   *  Reverse iterators can be tricky and surprising at first.  Their
   *  semantics make sense, however, and the trickiness is a side effect of
   *  the requirement that the iterators must be safe.
  */
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
		      typename iterator_traits<_Iterator>::value_type,
		      typename iterator_traits<_Iterator>::difference_type,
		      typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator>		__traits_type;

    public:
      typedef _Iterator					iterator_type;
      typedef typename __traits_type::difference_type	difference_type;
      typedef typename __traits_type::pointer		pointer;
      typedef typename __traits_type::reference		reference;

      /**
       *  The default constructor value-initializes member @p current.
       *  If it is a pointer, that means it is zero-initialized.
      */
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 235 No specification of default ctor for reverse_iterator
      reverse_iterator() : current() { }

      /**
       *  This %iterator will move in the opposite direction that @p x does.
      */
      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }

      /**
       *  The copy constructor is normal.
      */
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }

      /**
       *  A %reverse_iterator across other types can be copied if the
       *  underlying %iterator can be converted to the type of @c current.
      */
      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
	: current(__x.base()) { }

      /**
       *  @return  @c current, the %iterator used for underlying work.
      */
      iterator_type
      base() const
      { return current; }

      /**
       *  @return  A reference to the value at @c --current
       *
       *  This requires that @c --current is dereferenceable.
       *
       *  @warning This implementation requires that for an iterator of the
       *           underlying iterator type, @c x, a reference obtained by
       *           @c *x remains valid after @c x has been modified or
       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
      */
      reference
      operator*() const
      {
	_Iterator __tmp = current;
	return *--__tmp;
      }

      /**
       *  @return  A pointer to the value at @c --current
       *
       *  This requires that @c --current is dereferenceable.
      */
      pointer
      operator->() const
      { return &(operator*()); }

      /**
       *  @return  @c *this
       *
       *  Decrements the underlying iterator.
      */
      reverse_iterator&
      operator++()
      {
	--current;
	return *this;
      }

      /**
       *  @return  The original value of @c *this
       *
       *  Decrements the underlying iterator.
      */
      reverse_iterator
      operator++(int)
      {
	reverse_iterator __tmp = *this;
	--current;
	return __tmp;
      }

      /**
       *  @return  @c *this
       *
       *  Increments the underlying iterator.
      */
      reverse_iterator&
      operator--()
      {
	++current;
	return *this;
      }

      /**
       *  @return  A reverse_iterator with the previous value of @c *this
       *
       *  Increments the underlying iterator.
      */
      reverse_iterator
      operator--(int)
      {
	reverse_iterator __tmp = *this;
	++current;
	return __tmp;
      }

      /**
       *  @return  A reverse_iterator that refers to @c current - @a __n
       *
       *  The underlying iterator must be a Random Access Iterator.
      */
      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }

      /**
       *  @return  *this
       *
       *  Moves the underlying iterator backwards @a __n steps.
       *  The underlying iterator must be a Random Access Iterator.
      */
      reverse_iterator&
      operator+=(difference_type __n)
      {
	current -= __n;
	return *this;
      }

      /**
       *  @return  A reverse_iterator that refers to @c current - @a __n
       *
       *  The underlying iterator must be a Random Access Iterator.
      */
      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }

      /**
       *  @return  *this
       *
       *  Moves the underlying iterator forwards @a __n steps.
       *  The underlying iterator must be a Random Access Iterator.
      */
      reverse_iterator&
      operator-=(difference_type __n)
      {
	current += __n;
	return *this;
      }

      /**
       *  @return  The value at @c current - @a __n - 1
       *
       *  The underlying iterator must be a Random Access Iterator.
      */
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };

  //@{
  /**
   *  @param  __x  A %reverse_iterator.
   *  @param  __y  A %reverse_iterator.
   *  @return  A simple bool.
   *
   *  Reverse iterators forward many operations to their underlying base()
   *  iterators.  Others are implemented in terms of one another.
   *
  */
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
	       const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
	      const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
	       const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
	      const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
	       const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
	       const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
	      const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
	      const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
	       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
	      const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
	       const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
	      const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
	       const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
	       const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>
#if __cplusplus >= 201103L
    // DR 685.
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
	      const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
#else
# 384 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
	      const reverse_iterator<_IteratorR>& __y)
#endif
# 388 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
    { return __y.base() - __x.base(); }
  //@}

#if __cplusplus > 201103L
#define __cpp_lib_make_reverse_iterator 201402

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 2285. make_reverse_iterator
  /// Generator function for reverse_iterator.
  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
#endif
# 402 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3

  // 24.4.2.2.1 back_insert_iterator
  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator appends it to the container using
   *  push_back.
   *
   *  Tip:  Using the back_inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container          container_type;

      /// The only way to create this %iterator is with a container.
      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }

      /**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the end, if you like).  Assigning a value to the %iterator will
       *  always append the value to the end of the container.
      */
#if __cplusplus < 201103L
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
	container->push_back(__value);
	return *this;
      }
#else
# 448 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
	container->push_back(__value);
	return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
	container->push_back(std::move(__value));
	return *this;
      }
#endif
# 462 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3

      /// Simply returns *this.
      back_insert_iterator&
      operator*()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      back_insert_iterator&
      operator++()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      back_insert_iterator
      operator++(int)
      { return *this; }
    };

  /**
   *  @param  __x  A container of arbitrary type.
   *  @return  An instance of back_insert_iterator working on @p __x.
   *
   *  This wrapper function helps in creating back_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }

  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator prepends it to the container using
   *  push_front.
   *
   *  Tip:  Using the front_inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container          container_type;

      /// The only way to create this %iterator is with a container.
      explicit front_insert_iterator(_Container& __x) : container(&__x) { }

      /**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the front, if you like).  Assigning a value to the %iterator will
       *  always prepend the value to the front of the container.
      */
#if __cplusplus < 201103L
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
	container->push_front(__value);
	return *this;
      }
#else
# 538 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
	container->push_front(__value);
	return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
	container->push_front(std::move(__value));
	return *this;
      }
#endif
# 552 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3

      /// Simply returns *this.
      front_insert_iterator&
      operator*()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      front_insert_iterator&
      operator++()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      front_insert_iterator
      operator++(int)
      { return *this; }
    };

  /**
   *  @param  __x  A container of arbitrary type.
   *  @return  An instance of front_insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating front_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }

  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator inserts it in the container at the
   *  %iterator's position, rather than overwriting the value at that
   *  position.
   *
   *  (Sequences will actually insert a @e copy of the value before the
   *  %iterator's position.)
   *
   *  Tip:  Using the inserter function to create these iterators can
   *  save typing.
  */
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:
      /// A nested typedef for the type of whatever container you used.
      typedef _Container          container_type;

      /**
       *  The only way to create this %iterator is with a container and an
       *  initial position (a normal %iterator into the container).
      */
      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}

      /**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator maintains its own position in the
       *  container.  Assigning a value to the %iterator will insert the
       *  value into the container at the place before the %iterator.
       *
       *  The position is maintained such that subsequent assignments will
       *  insert values immediately after one another.  For example,
       *  @code
       *     // vector v contains A and Z
       *
       *     insert_iterator i (v, ++v.begin());
       *     i = 1;
       *     i = 2;
       *     i = 3;
       *
       *     // vector v contains A, 1, 2, 3, and Z
       *  @endcode
      */
#if __cplusplus < 201103L
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
	iter = container->insert(iter, __value);
	++iter;
	return *this;
      }
#else
# 650 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
	iter = container->insert(iter, __value);
	++iter;
	return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
	iter = container->insert(iter, std::move(__value));
	++iter;
	return *this;
      }
#endif
# 666 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3

      /// Simply returns *this.
      insert_iterator&
      operator*()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      insert_iterator&
      operator++()
      { return *this; }

      /// Simply returns *this.  (This %iterator does not @a move.)
      insert_iterator&
      operator++(int)
      { return *this; }
    };

  /**
   *  @param __x  A container of arbitrary type.
   *  @return  An instance of insert_iterator working on @p __x.
   *
   *  This wrapper function helps in creating insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  */
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
					 typename _Container::iterator(__i));
    }

  // @} group iterators

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // This iterator adapter is @a normal in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator>		__traits_type;

    public:
      typedef _Iterator					iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type  	value_type;
      typedef typename __traits_type::difference_type 	difference_type;
      typedef typename __traits_type::reference 	reference;
      typedef typename __traits_type::pointer   	pointer;

      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
      : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
			  typename __enable_if<
      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
        : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const _GLIBCXX_NOEXCEPT
      { return *_M_current; }

      pointer
      operator->() const _GLIBCXX_NOEXCEPT
      { return _M_current; }

      __normal_iterator&
      operator++() _GLIBCXX_NOEXCEPT
      {
	++_M_current;
	return *this;
      }

      __normal_iterator
      operator++(int) _GLIBCXX_NOEXCEPT
      { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() _GLIBCXX_NOEXCEPT
      {
	--_M_current;
	return *this;
      }

      __normal_iterator
      operator--(int) _GLIBCXX_NOEXCEPT
      { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const _GLIBCXX_NOEXCEPT
      { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
	       const __normal_iterator<_IteratorR, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
	       const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
	       const __normal_iterator<_IteratorR, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
	       const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
	      const __normal_iterator<_IteratorR, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
	      const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
	      const __normal_iterator<_IteratorR, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
	      const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
	       const __normal_iterator<_IteratorR, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
	       const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
	       const __normal_iterator<_IteratorR, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
	       const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() >= __rhs.base(); }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
#if __cplusplus >= 201103L
    // DR 685.
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
	      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())
#else
# 915 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
	      const __normal_iterator<_IteratorR, _Container>& __rhs)
#endif
# 919 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
	      const __normal_iterator<_Iterator, _Container>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
	      __n, const __normal_iterator<_Iterator, _Container>& __i)
    _GLIBCXX_NOEXCEPT
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if __cplusplus >= 201103L

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   * @addtogroup iterators
   * @{
   */

  // 24.4.3  Move iterators
  /**
   *  Class template move_iterator is an iterator adapter with the same
   *  behavior as the underlying iterator except that its dereference
   *  operator implicitly converts the value returned by the underlying
   *  iterator's dereference operator to an rvalue reference.  Some
   *  generic algorithms can be called with move iterators to replace
   *  copying with moving.
   */
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator>		__traits_type;
      typedef typename __traits_type::reference		__base_ref;

    public:
      typedef _Iterator					iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type  	value_type;
      typedef typename __traits_type::difference_type	difference_type;
      // NB: DR 680.
      typedef _Iterator					pointer;
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 2106. move_iterator wrapping iterators returning prvalues
      typedef typename conditional<is_reference<__base_ref>::value,
			 typename remove_reference<__base_ref>::type&&,
			 __base_ref>::type		reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
	move_iterator(const move_iterator<_Iter>& __i)
	: _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
	++_M_current;
	return *this;
      }

      move_iterator
      operator++(int)
      {
	move_iterator __tmp = *this;
	++_M_current;
	return __tmp;
      }

      move_iterator&
      operator--()
      {
	--_M_current;
	return *this;
      }

      move_iterator
      operator--(int)
      {
	move_iterator __tmp = *this;
	--_M_current;
	return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
	_M_current += __n;
	return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }
    
      move_iterator&
      operator-=(difference_type __n)
      { 
	_M_current -= __n;
	return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };

  // Note: See __normal_iterator operators note from Gaby to understand
  // why there are always 2 versions for most of the move_iterator
  // operators.
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
	       const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
	       const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
	       const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
	       const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
	      const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
	      const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
	       const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
	       const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
	      const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
	      const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
	       const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
	       const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  // DR 685.
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
	      const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
	      const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
	      const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }

  // @} group iterators

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
#define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
  std::__make_move_if_noexcept_iterator(_Iter)
#else
# 1178 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
#define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
#endif // C++11
# 1181 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3

#endif
# 1183 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_iterator.h" 3
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <debug/debug.h>
#endif /* expanded by -frewrite-includes */
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h> // For std::swap and _GLIBCXX_MOVE
#endif /* expanded by -frewrite-includes */
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/predefined_ops.h>
#endif /* expanded by -frewrite-includes */
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/predefined_ops.h" 1 3
// Default predicates for internal use -*- C++ -*-

// Copyright (C) 2013-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file predefined_ops.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly.
 */

#ifndef _GLIBCXX_PREDEFINED_OPS_H
#define _GLIBCXX_PREDEFINED_OPS_H	1

namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };
  _GLIBCXX14_CONSTEXPR
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      _GLIBCXX14_CONSTEXPR
      _Iter_comp_iter(_Compare __comp)
	: _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        _GLIBCXX14_CONSTEXPR
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
	: _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
	bool
	operator()(_Iterator __it, _Value& __val)
	{ return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
	: _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
	bool
	operator()(_Value& __val, _Iterator __it)
	{ return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
	: _M_value(__value)
      { }

      template<typename _Iterator>
	bool
	operator()(_Iterator __it)
	{ return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
	: _M_ref(*__it1)
      { }

      template<typename _Iterator2>
	bool
	operator()(_Iterator2 __it2)
	{ return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
	: _M_pred(__pred)
      { }

      template<typename _Iterator>
	bool
	operator()(_Iterator __it)
	{ return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
	: _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
	bool
	operator()(_Iterator __it)
	{ return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
	: _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
	bool
	operator()(_Iterator2 __it2)
	{ return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
	: _M_pred(__pred)
      { }

      template<typename _Iterator>
	bool
	operator()(_Iterator __it)
	{ return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

} // namespace __ops
} // namespace __gnu_cxx

#endif
# 308 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/predefined_ops.h" 3
# 72 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#if __cplusplus < 201103L
  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
  // nutshell, we are partially implementing the resolution of DR 187,
  // when it's safe, i.e., the value_types are equal.
  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = _GLIBCXX_MOVE(*__a);
          *__a = _GLIBCXX_MOVE(*__b);
          *__b = _GLIBCXX_MOVE(__tmp);
	}
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void 
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
#endif
# 107 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  /**
   *  @brief Swaps the contents of two iterators.
   *  @ingroup mutating_algorithms
   *  @param  __a  An iterator.
   *  @param  __b  Another iterator.
   *  @return   Nothing.
   *
   *  This function swaps the values pointed to by two iterators, not the
   *  iterators themselves.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator1>)
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator2>)

#if __cplusplus < 201103L
      typedef typename iterator_traits<_ForwardIterator1>::value_type
	_ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
	_ValueType2;

      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
				  _ValueType2>)
      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
				  _ValueType1>)

      typedef typename iterator_traits<_ForwardIterator1>::reference
	_ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
	_ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
	&& __are_same<_ValueType1&, _ReferenceType1>::__value
	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
	iter_swap(__a, __b);
#else
# 148 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);
#endif
# 150 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
    }

  /**
   *  @brief Swap the elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @return   An iterator equal to @p first2+(last1-first1).
   *
   *  Swaps each element in the range @p [first1,last1) with the
   *  corresponding element in the range @p [first2,(last1-first1)).
   *  The ranges must not overlap.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		_ForwardIterator2 __first2)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator1>)
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator2>)
      __glibcxx_requires_valid_range(__first1, __last1);

      for (; __first1 != __last1; ++__first1, ++__first2)
	std::iter_swap(__first1, __first2);
      return __first2;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The lesser of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return __b < __a ? __b : __a;
      if (__b < __a)
	return __b;
      return __a;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The greater of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
	return __b;
      return __a;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The lesser of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  */
  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      //return __comp(__b, __a) ? __b : __a;
      if (__comp(__b, __a))
	return __b;
      return __a;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The greater of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  */
  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      //return __comp(__a, __b) ? __b : __a;
      if (__comp(__a, __b))
	return __b;
      return __a;
    }

  // If _Iterator is a __normal_iterator return its base (a plain pointer,
  // normally) otherwise return it untouched.  See copy, fill, ... 
  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }

  // Likewise, for move_iterator.
  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }

  // All of these auxiliary structs serve two purposes.  (1) Replace
  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
  // because the input and output ranges are permitted to overlap.)
  // (2) If we're using random access iterators, then write the loop as
  // a for loop with an explicit count.

  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
	  for (; __first != __last; ++__result, ++__first)
	    *__result = *__first;
	  return __result;
	}
    };

#if __cplusplus >= 201103L
  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
	  for (; __first != __last; ++__result, ++__first)
	    *__result = std::move(*__first);
	  return __result;
	}
    };
#endif
# 329 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        { 
	  typedef typename iterator_traits<_II>::difference_type _Distance;
	  for(_Distance __n = __last - __first; __n > 0; --__n)
	    {
	      *__result = *__first;
	      ++__first;
	      ++__result;
	    }
	  return __result;
	}
    };

#if __cplusplus >= 201103L
  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        { 
	  typedef typename iterator_traits<_II>::difference_type _Distance;
	  for(_Distance __n = __last - __first; __n > 0; --__n)
	    {
	      *__result = std::move(*__first);
	      ++__first;
	      ++__result;
	    }
	  return __result;
	}
    };
#endif
# 367 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
#if __cplusplus >= 201103L
	  // trivial types can have deleted assignment
	  static_assert( is_copy_assignable<_Tp>::value,
	                 "type is not assignable" );
#endif
# 380 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
	  return __result + _Num;
	}
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
	                     && __is_pointer<_II>::__value
	                     && __is_pointer<_OI>::__value
			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
	                      _Category>::__copy_m(__first, __last, __result);
    }

  // Helpers for streambuf iterators (either istream or ostream).
  // NB: avoid including <iosfwd>, relatively large.
  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
				    _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
					     std::__niter_base(__last),
					     std::__niter_base(__result)));
    }

  /**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   result + (first - last)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the copy_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  */
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_II>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
	    typename iterator_traits<_II>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
	      (std::__miter_base(__first), std::__miter_base(__last),
	       __result));
    }

#if __cplusplus >= 201103L
  /**
   *  @brief Moves the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   result + (first - last)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the move_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  */
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_II>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
	    typename iterator_traits<_II>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__copy_move_a2<true>(std::__miter_base(__first),
				       std::__miter_base(__last), __result);
    }

#define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
#else
# 507 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
#define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
#endif
# 509 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
	  while (__first != __last)
	    *--__result = *--__last;
	  return __result;
	}
    };

#if __cplusplus >= 201103L
  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
	  while (__first != __last)
	    *--__result = std::move(*--__last);
	  return __result;
	}
    };
#endif
# 537 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
	  typename iterator_traits<_BI1>::difference_type __n;
	  for (__n = __last - __first; __n > 0; --__n)
	    *--__result = *--__last;
	  return __result;
	}
    };

#if __cplusplus >= 201103L
  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
	  typename iterator_traits<_BI1>::difference_type __n;
	  for (__n = __last - __first; __n > 0; --__n)
	    *--__result = std::move(*--__last);
	  return __result;
	}
    };
#endif
# 567 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
#if __cplusplus >= 201103L
	  // trivial types can have deleted assignment
	  static_assert( is_copy_assignable<_Tp>::value,
	                 "type is not assignable" );
#endif
# 580 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
	  const ptrdiff_t _Num = __last - __first;
	  if (_Num)
	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
	  return __result - _Num;
	}
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
	                     && __is_pointer<_BI1>::__value
	                     && __is_pointer<_BI2>::__value
			     && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
	                               _Category>::__copy_move_b(__first,
								 __last,
								 __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
		  (std::__niter_base(__first), std::__niter_base(__last),
		   std::__niter_base(__result)));
    }

  /**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @param  __result A bidirectional iterator.
   *  @return   result - (first - last)
   *
   *  The function has the same effect as copy, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range (first,last].  Use copy instead.  Note
   *  that the start of the output range may overlap [first,last).
  */
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
      __glibcxx_function_requires(_ConvertibleConcept<
	    typename iterator_traits<_BI1>::value_type,
	    typename iterator_traits<_BI2>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
	      (std::__miter_base(__first), std::__miter_base(__last),
	       __result));
    }

#if __cplusplus >= 201103L
  /**
   *  @brief Moves the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @param  __result A bidirectional iterator.
   *  @return   result - (first - last)
   *
   *  The function has the same effect as move, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range (first,last].  Use move instead.  Note
   *  that the start of the output range may overlap [first,last).
  */
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
      __glibcxx_function_requires(_ConvertibleConcept<
	    typename iterator_traits<_BI1>::value_type,
	    typename iterator_traits<_BI2>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
						std::__miter_base(__last),
						__result);
    }

#define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
#else
# 687 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
#define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
#endif
# 689 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
 	     const _Tp& __value)
    {
      for (; __first != __last; ++__first)
	*__first = __value;
    }
    
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
	*__first = __tmp;
    }

  // Specialization: for char types we can use memset.
  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  /**
   *  @brief Fills the range [first,last) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __value  A reference-to-const of arbitrary type.
   *  @return   Nothing.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @c wmemset.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
		    __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
	   __niter > 0; --__niter, ++__first)
	*__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
	   __niter > 0; --__niter, ++__first)
	*__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }

  /**
   *  @brief Fills the range [first,first+n) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  __first  An output iterator.
   *  @param  __n      The count of copies to perform.
   *  @param  __value  A reference-to-const of arbitrary type.
   *  @return   The iterator at first+n.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @ wmemset.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 865. More algorithms that throw away information
  */
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
	  for (; __first1 != __last1; ++__first1, ++__first2)
	    if (!(*__first1 == *__first2))
	      return false;
	  return true;
	}
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
	  if (const size_t __len = (__last1 - __first1))
	    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
	  return true;
	}
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
			      || __is_pointer<_ValueType1>::__value)
	                     && __is_pointer<_II1>::__value
	                     && __is_pointer<_II2>::__value
			     && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
		   _RAI2 __first2, _RAI2 __last2)
        {
	  const typename iterator_traits<_RAI1>::difference_type
	    __diff1 = __last1 - __first1;
	  const typename iterator_traits<_RAI2>::difference_type
	    __diff2 = __last2 - __first2;
	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
	}

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
				   _II2 __first2, _II2 __last2,
				   _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
	   ++__first1, ++__first2)
	{
	  if (__comp(__first1, __first2))
	    return true;
	  if (__comp(__first2, __first1))
	    return false;
	}
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
	return std::__lexicographical_compare_impl(__first1, __last1,
						   __first2, __last2,
					__gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
	     const _Up* __first2, const _Up* __last2)
	{
	  const size_t __len1 = __last1 - __first1;
	  const size_t __len2 = __last2 - __first2;
	  if (const size_t __len = std::min(__len1, __len2))
	    if (int __result = __builtin_memcmp(__first1, __first2, __len))
	      return __result < 0;
	  return __len1 < __len2;
	}
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
				  _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
	(__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
	 && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
	 && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
	 && __is_pointer<_II1>::__value
	 && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
							    __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
		  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
	{
	  _DistanceType __half = __len >> 1;
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__middle, __val))
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
	    }
	  else
	    __len = __half;
	}
      return __first;
    }

  /**
   *  @brief Finds the first position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return         An iterator pointing to the first element <em>not less
   *                  than</em> @a val, or end() if every element is less than 
   *                  @a val.
   *  @ingroup binary_search_algorithms
  */
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);

      return std::__lower_bound(__first, __last, __val,
				__gnu_cxx::__ops::__iter_less_val());
    }

  /// This is a helper function for the sort routines and for random.tcc.
  //  Precondition: __n > 0.
  inline _GLIBCXX_CONSTEXPR int
  __lg(int __n)
  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }

  inline _GLIBCXX_CONSTEXPR unsigned
  __lg(unsigned __n)
  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }

  inline _GLIBCXX_CONSTEXPR long
  __lg(long __n)
  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }

  inline _GLIBCXX_CONSTEXPR unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }

  inline _GLIBCXX_CONSTEXPR long long
  __lg(long long __n)
  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }

  inline _GLIBCXX_CONSTEXPR unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }

_GLIBCXX_END_NAMESPACE_VERSION

_GLIBCXX_BEGIN_NAMESPACE_ALGO

  /**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_II1>::value_type,
	    typename iterator_traits<_II2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);

      return std::__equal_aux(std::__niter_base(__first1),
			      std::__niter_base(__last1),
			      std::__niter_base(__first2));
    }

  /**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *                  functor@endlink.
   *  @return         A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
	  _IIter2 __first2, _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
      __glibcxx_requires_valid_range(__first1, __last1);

      for (; __first1 != __last1; ++__first1, ++__first2)
	if (!bool(__binary_pred(*__first1, *__first2)))
	  return false;
      return true;
    }

#if __cplusplus > 201103L

#define __cpp_lib_robust_nonmodifying_seq_ops 201304

  /**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_II1>::value_type,
	    typename iterator_traits<_II2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
	{
	  auto __d1 = std::distance(__first1, __last1);
	  auto __d2 = std::distance(__first2, __last2);
	  if (__d1 != __d2)
	    return false;
	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);
	}

      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
	if (!(*__first1 == *__first2))
	  return false;
      return __first1 == __last1 && __first2 == __last2;
    }

  /**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *                  functor@endlink.
   *  @return         A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
	  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
	{
	  auto __d1 = std::distance(__first1, __last1);
	  auto __d2 = std::distance(__first2, __last2);
	  if (__d1 != __d2)
	    return false;
	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,
				       __binary_pred);
	}

      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
	if (!bool(__binary_pred(*__first1, *__first2)))
	  return false;
      return __first1 == __last1 && __first2 == __last2;
    }
#endif
# 1195 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

  /**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  <em>Returns true if the sequence of elements defined by the range
   *  [first1,last1) is lexicographically less than the sequence of elements
   *  defined by the range [first2,last2).  Returns false otherwise.</em>
   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
   *  then this is an inline call to @c memcmp.
  */
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
			    _II2 __first2, _II2 __last2)
    {
#ifdef _GLIBCXX_CONCEPT_CHECKS
      // concept requirements
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
#endif
# 1221 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
						std::__niter_base(__last1),
						std::__niter_base(__first2),
						std::__niter_base(__last2));
    }

  /**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   A boolean true or false.
   *
   *  The same as the four-parameter @c lexicographical_compare, but uses the
   *  comp parameter instead of @c <.
  */
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
			    _II2 __first2, _II2 __last2, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__lexicographical_compare_impl
	(__first1, __last1, __first2, __last2,
	 __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
	       _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
	  ++__first1;
	  ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

  /**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);

      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
			     __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *         functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_requires_valid_range(__first1, __last1);

      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
	__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

#if __cplusplus > 201103L

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
	       _InputIterator2 __first2, _InputIterator2 __last2,
	       _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
	     && __binary_pred(__first1, __first2))
        {
	  ++__first1;
	  ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

  /**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2, _InputIterator2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
			     __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *         functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2, _InputIterator2 __last2,
	     _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
			     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
#endif
# 1422 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

_GLIBCXX_END_NAMESPACE_ALGO
} // namespace std

// NB: This file is included within many other C++ includes, as a way
// of getting the base algorithms. So, make sure that parallel bits
// come in too if requested. 
#ifdef _GLIBCXX_PARALLEL
#if 0 /* expanded by -frewrite-includes */
# include <parallel/algobase.h>
#endif /* expanded by -frewrite-includes */
# 1430 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 1431 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
#endif
# 1432 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3

#endif
# 1434 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algobase.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/allocator.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 1 3
// Allocators -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 * Copyright (c) 1996-1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */

#ifndef _ALLOCATOR_H
#define _ALLOCATOR_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++allocator.h> // Define the base class to std::allocator.
#endif /* expanded by -frewrite-includes */
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++allocator.h" 1 3
// Base to std::allocator -*- C++ -*-

// Copyright (C) 2004-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/c++allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */

#ifndef _GLIBCXX_CXX_ALLOCATOR_H
#define _GLIBCXX_CXX_ALLOCATOR_H 1

#if 0 /* expanded by -frewrite-includes */
#include <ext/new_allocator.h>
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++allocator.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 1 3
// Allocator that wraps operator new -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/new_allocator.h
 *  This file is a GNU extension to the Standard C++ Library.
 */

#ifndef _NEW_ALLOCATOR_H
#define _NEW_ALLOCATOR_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 32 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <new>
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 1 3
// The -*- C++ -*- dynamic memory management header.

// Copyright (C) 1994-2015 Free Software Foundation, Inc.

// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file new
 *  This is a Standard C++ Library header.
 *
 *  The header @c new defines several functions to manage dynamic memory and
 *  handling memory allocation errors; see
 *  http://gcc.gnu.org/onlinedocs/libstdc++/18_support/howto.html#4 for more.
 */

#ifndef _NEW
#define _NEW

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 3
#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 1 3
// Exception Handling support header for -*- C++ -*-

// Copyright (C) 1995-2015 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file exception
 *  This is a Standard C++ Library header.
 */

#ifndef __EXCEPTION__
#define __EXCEPTION__

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3

#pragma GCC visibility push(default)

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/atomic_lockfree_defines.h>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/atomic_lockfree_defines.h" 1 3
// -*- C++ -*- header.

// Copyright (C) 2008-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/atomic_lockfree_defines.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{atomic}
 */

#ifndef _GLIBCXX_ATOMIC_LOCK_FREE_H
#define _GLIBCXX_ATOMIC_LOCK_FREE_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/atomic_lockfree_defines.h" 3

/**
 * @addtogroup atomics
 * @{
 */

/**
 * Lock-free property.
 *
 * 0 indicates that the types are never lock-free.
 * 1 indicates that the types are sometimes lock-free.
 * 2 indicates that the types are always lock-free.
 */

#if __cplusplus >= 201103L
#define ATOMIC_BOOL_LOCK_FREE		__GCC_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE		__GCC_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE	__GCC_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE	__GCC_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE	__GCC_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE		__GCC_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE		__GCC_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE		__GCC_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE		__GCC_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE	__GCC_ATOMIC_POINTER_LOCK_FREE
#endif
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/atomic_lockfree_defines.h" 3

// @} group atomics

#endif
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/atomic_lockfree_defines.h" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 2 3

extern "C++" {

namespace std
{
  /**
   * @defgroup exceptions Exceptions
   * @ingroup diagnostics
   *
   * Classes and functions for reporting errors via exception classes.
   * @{
   */

  /**
   *  @brief Base class for all library exceptions.
   *
   *  This is the base class for all exceptions thrown by the standard
   *  library, and by certain language expressions.  You are free to derive
   *  your own %exception classes, or use a different hierarchy, or to
   *  throw non-class data (e.g., fundamental types).
   */
  class exception
  {
  public:
    exception() _GLIBCXX_USE_NOEXCEPT { }
    virtual ~exception() _GLIBCXX_USE_NOEXCEPT;

    /** Returns a C-style character string describing the general cause
     *  of the current error.  */
    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
  };

  /** If an %exception is thrown which is not listed in a function's
   *  %exception specification, one of these may be thrown.  */
  class bad_exception : public exception
  {
  public:
    bad_exception() _GLIBCXX_USE_NOEXCEPT { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_exception() _GLIBCXX_USE_NOEXCEPT;

    // See comment in eh_exception.cc.
    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
  };

  /// If you write a replacement %terminate handler, it must be of this type.
  typedef void (*terminate_handler) ();

  /// If you write a replacement %unexpected handler, it must be of this type.
  typedef void (*unexpected_handler) ();

  /// Takes a new handler function as an argument, returns the old function.
  terminate_handler set_terminate(terminate_handler) _GLIBCXX_USE_NOEXCEPT;

#if __cplusplus >= 201103L
  /// Return the current terminate handler.
  terminate_handler get_terminate() noexcept;
#endif
# 99 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3

  /** The runtime will call this function if %exception handling must be
   *  abandoned for any reason.  It can also be called by the user.  */
  void terminate() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__noreturn__));

  /// Takes a new handler function as an argument, returns the old function.
  unexpected_handler set_unexpected(unexpected_handler) _GLIBCXX_USE_NOEXCEPT;

#if __cplusplus >= 201103L
  /// Return the current unexpected handler.
  unexpected_handler get_unexpected() noexcept;
#endif
# 111 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3

  /** The runtime will call this function if an %exception is thrown which
   *  violates the function's %exception specification.  */
  void unexpected() __attribute__ ((__noreturn__));

  /** [18.6.4]/1:  'Returns true after completing evaluation of a
   *  throw-expression until either completing initialization of the
   *  exception-declaration in the matching handler or entering @c unexpected()
   *  due to the throw; or after entering @c terminate() for any reason
   *  other than an explicit call to @c terminate().  [Note: This includes
   *  stack unwinding [15.2].  end note]'
   *
   *  2: 'When @c uncaught_exception() is true, throwing an
   *  %exception can result in a call of @c terminate()
   *  (15.5.1).'
   */
  bool uncaught_exception() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));

  // @} group exceptions
} // namespace std

namespace __gnu_cxx
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief A replacement for the standard terminate_handler which
   *  prints more information about the terminating exception (if any)
   *  on stderr.
   *
   *  @ingroup exceptions
   *
   *  Call
   *   @code
   *     std::set_terminate(__gnu_cxx::__verbose_terminate_handler)
   *   @endcode
   *  to use.  For more info, see
   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt02ch06s02.html
   *
   *  In 3.4 and later, this is on by default.
   */
  void __verbose_terminate_handler();

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

} // extern "C++"

#pragma GCC visibility pop

#if (__cplusplus >= 201103L) && (ATOMIC_INT_LOCK_FREE > 1)
#if 0 /* expanded by -frewrite-includes */
#include <bits/exception_ptr.h>
#endif /* expanded by -frewrite-includes */
# 162 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
# 163 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/nested_exception.h>
#endif /* expanded by -frewrite-includes */
# 163 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
# 164 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
#endif
# 165 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3

#endif
# 167 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/exception" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std 
{
  /**
   *  @brief  Exception possibly thrown by @c new.
   *  @ingroup exceptions
   *
   *  @c bad_alloc (or classes derived from it) is used to report allocation
   *  errors from the throwing forms of @c new.  */
  class bad_alloc : public exception 
  {
  public:
    bad_alloc() throw() { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_alloc() throw();

    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };

#if __cplusplus >= 201103L
  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_array_new_length() throw();

    // See comment in eh_exception.cc.
    virtual const char* what() const throw();
  };
#endif
# 81 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 3

  struct nothrow_t { };

  extern const nothrow_t nothrow;

  /** If you write your own error handler to be called by @c new, it must
   *  be of this type.  */
  typedef void (*new_handler)();

  /// Takes a replacement handler as the argument, returns the
  /// previous handler.
  new_handler set_new_handler(new_handler) throw();

#if __cplusplus >= 201103L
  /// Return the current new handler.
  new_handler get_new_handler() noexcept;
#endif
# 98 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 3
} // namespace std

//@{
/** These are replaceable signatures:
 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
 *  - normal array new and delete (same)
 *  - @c nothrow single new and delete (take a @c nothrow argument, return
 *    @c NULL on error)
 *  - @c nothrow array new and delete (same)
 *
 *  Placement new and delete signatures (take a memory address argument,
 *  does nothing) may not be replaced by a user's program.
*/
void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
  __attribute__((__externally_visible__));
void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
  __attribute__((__externally_visible__));
void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
  __attribute__((__externally_visible__));

// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
{ return __p; }
inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
{ return __p; }

// Default placement versions of operator delete.
inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
//@}
} // extern "C++"

#pragma GCC visibility pop

#endif
# 143 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/new" 3
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/functexcept.h>
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
#endif
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  using std::size_t;
  using std::ptrdiff_t;

  /**
   *  @brief  An allocator that uses global new, as per [20.4].
   *  @ingroup allocators
   *
   *  This is precisely the allocator defined in the C++ Standard. 
   *    - all allocation calls operator new
   *    - all deallocation calls operator delete
   *
   *  @tparam  _Tp  Type of allocated object.
   */
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t     size_type;
      typedef ptrdiff_t  difference_type;
      typedef _Tp*       pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp&       reference;
      typedef const _Tp& const_reference;
      typedef _Tp        value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 2103. propagate_on_container_move_assignment
      typedef std::true_type propagate_on_container_move_assignment;
#endif
# 78 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3

      new_allocator() _GLIBCXX_USE_NOEXCEPT { }

      new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }

      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }

      pointer
      address(reference __x) const _GLIBCXX_NOEXCEPT
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const _GLIBCXX_NOEXCEPT
      { return std::__addressof(__x); }

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const _GLIBCXX_USE_NOEXCEPT
      { return size_t(-1) / sizeof(_Tp); }

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void 
        destroy(_Up* __p) { __p->~_Up(); }
#else
# 126 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_] allocator::construct
      void 
      construct(pointer __p, const _Tp& __val) 
      { ::new((void *)__p) _Tp(__val); }

      void 
      destroy(pointer __p) { __p->~_Tp(); }
#endif
# 135 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }
  
  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 151 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/new_allocator.h" 3
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++allocator.h" 2 3

#if __cplusplus >= 201103L
namespace std
{
  /**
   *  @brief  An alias to the base class for std::allocator.
   *  @ingroup allocators
   *
   *  Used to set the std::allocator base class to
   *  __gnu_cxx::new_allocator.
   *
   *  @tparam  _Tp  Type of allocated object.
    */
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
#else
# 51 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++allocator.h" 3
// Define new_allocator as the base class to std::allocator.
# define __allocator_base  __gnu_cxx::new_allocator
#endif
# 54 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++allocator.h" 3

#endif
# 56 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++allocator.h" 3
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/memoryfwd.h>
#endif /* expanded by -frewrite-includes */
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/memoryfwd.h" 1 3
// <memory> Forward declarations -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 * Copyright (c) 1996-1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/memoryfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */

#ifndef _MEMORYFWD_H
#define _MEMORYFWD_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/memoryfwd.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/memoryfwd.h" 3
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/memoryfwd.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   * @defgroup allocators Allocators
   * @ingroup memory
   *
   * Classes encapsulating memory operations.
   *
   * @{
   */

  template<typename>
    class allocator;

  template<>
    class allocator<void>;

  /// Declare uses_allocator so it can be specialized in \<queue\> etc.
  template<typename, typename>
    struct uses_allocator;

  /// @} group memory

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 79 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/memoryfwd.h" 3
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 2 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3
# 50 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3
#endif
# 51 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @addtogroup allocators
   *  @{
   */

  /// allocator<void> specialization.
  template<>
    class allocator<void>
    {
    public:
      typedef size_t      size_type;
      typedef ptrdiff_t   difference_type;
      typedef void*       pointer;
      typedef const void* const_pointer;
      typedef void        value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 2103. std::allocator propagate_on_container_move_assignment
      typedef true_type propagate_on_container_move_assignment;
#endif
# 81 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3
    };

  /**
   * @brief  The @a standard allocator, as per [20.4].
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
   *  for further details.
   *
   *  @tparam  _Tp  Type of allocated object.
   */
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t     size_type;
      typedef ptrdiff_t  difference_type;
      typedef _Tp*       pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp&       reference;
      typedef const _Tp& const_reference;
      typedef _Tp        value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 2103. std::allocator propagate_on_container_move_assignment
      typedef true_type propagate_on_container_move_assignment;
#endif
# 112 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }

      // Inherit everything else.
    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    _GLIBCXX_USE_NOEXCEPT
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    _GLIBCXX_USE_NOEXCEPT
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    _GLIBCXX_USE_NOEXCEPT
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    _GLIBCXX_USE_NOEXCEPT
    { return false; }

  /// @} group allocator

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
#endif
# 158 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3

  // Undefine.
#undef __allocator_base

  // To implement Option 3 of DR 431.
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) _GLIBCXX_NOEXCEPT { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) _GLIBCXX_NOEXCEPT
      {
	// Precondition: swappable allocators.
	if (__one != __two)
	  swap(__one, __two);
      }
    };

  // Optimize for stateless allocators.
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };

#if __cplusplus >= 201103L
  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {
	__try
	  {
	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
		__make_move_if_noexcept_iterator(__c.end()),
		__c.get_allocator()).swap(__c);
	    return true;
	  }
	__catch(...)
	  { return false; }
      }
    };
#endif
# 221 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 226 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/allocator.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/range_access.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/range_access.h" 1 3
// <range_access.h> -*- C++ -*-

// Copyright (C) 2010-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/range_access.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */

#ifndef _GLIBCXX_RANGE_ACCESS_H
#define _GLIBCXX_RANGE_ACCESS_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/range_access.h" 3

#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/range_access.h" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/range_access.h" 3
namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief  Return an iterator pointing to the first element of
   *          the container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }

  /**
   *  @brief  Return an iterator pointing to the first element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }

  /**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }

  /**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }

  /**
   *  @brief  Return an iterator pointing to the first element of the array.
   *  @param  __arr  Array.
   */
  template<class _Tp, size_t _Nm>
    inline _GLIBCXX14_CONSTEXPR _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }

  /**
   *  @brief  Return an iterator pointing to one past the last element
   *          of the array.
   *  @param  __arr  Array.
   */
  template<class _Tp, size_t _Nm>
    inline _GLIBCXX14_CONSTEXPR _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }

#if __cplusplus >= 201402L
  /**
   *  @brief  Return an iterator pointing to the first element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }

  /**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }

  /**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }

  /**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }

  /**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }

  /**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }

  /**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the array.
   *  @param  __arr  Array.
   */
  template<class _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }

  /**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the array.
   *  @param  __arr  Array.
   */
  template<class _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }

  /**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the initializer_list.
   *  @param  __il  initializer_list.
   */
  template<class _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }

  /**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the initializer_list.
   *  @param  __il  initializer_list.
   */
  template<class _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }

  /**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }

  /**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the const container.
   *  @param  __cont  Container.
   */
  template<class _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }

#endif // C++14
# 224 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/range_access.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif // C++11
# 229 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/range_access.h" 3

#endif // _GLIBCXX_RANGE_ACCESS_H
# 231 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/range_access.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_list.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 1 3
// List implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_list.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{list}
 */

#ifndef _STL_LIST_H
#define _STL_LIST_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
#endif
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
  namespace __detail
  {
  _GLIBCXX_BEGIN_NAMESPACE_VERSION

    // Supporting structures are split into common and templated
    // types; the latter publicly inherits from the former in an
    // effort to reduce code duplication.  This results in some
    // "needless" static_cast'ing later on, but it's all safe
    // downcasting.

    /// Common part of a node in the %list. 
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) _GLIBCXX_USE_NOEXCEPT;

      void
      _M_transfer(_List_node_base* const __first,
		  _List_node_base* const __last) _GLIBCXX_USE_NOEXCEPT;

      void
      _M_reverse() _GLIBCXX_USE_NOEXCEPT;

      void
      _M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT;

      void
      _M_unhook() _GLIBCXX_USE_NOEXCEPT;
    };

  _GLIBCXX_END_NAMESPACE_VERSION
  } // namespace detail

_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /// An actual node in the %list.
  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {
      ///< User's data.
      _Tp _M_data;

#if __cplusplus >= 201103L
      template<typename... _Args>
        _List_node(_Args&&... __args)
	: __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...) 
        { }
#endif
# 117 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
    };

  /**
   *  @brief A list::iterator.
   *
   *  All the functions are op overloads.
  */
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp>                _Self;
      typedef _List_node<_Tp>                    _Node;

      typedef ptrdiff_t                          difference_type;
      typedef std::bidirectional_iterator_tag    iterator_category;
      typedef _Tp                                value_type;
      typedef _Tp*                               pointer;
      typedef _Tp&                               reference;

      _List_iterator() _GLIBCXX_NOEXCEPT
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT
      : _M_node(__x) { }

      _Self
      _M_const_cast() const _GLIBCXX_NOEXCEPT
      { return *this; }

      // Must downcast from _List_node_base to _List_node to get to _M_data.
      reference
      operator*() const _GLIBCXX_NOEXCEPT
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const _GLIBCXX_NOEXCEPT
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++() _GLIBCXX_NOEXCEPT
      {
	_M_node = _M_node->_M_next;
	return *this;
      }

      _Self
      operator++(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _M_node->_M_next;
	return __tmp;
      }

      _Self&
      operator--() _GLIBCXX_NOEXCEPT
      {
	_M_node = _M_node->_M_prev;
	return *this;
      }

      _Self
      operator--(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _M_node->_M_prev;
	return __tmp;
      }

      bool
      operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node != __x._M_node; }

      // The only member points to the %list element.
      __detail::_List_node_base* _M_node;
    };

  /**
   *  @brief A list::const_iterator.
   *
   *  All the functions are op overloads.
  */
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp>          _Self;
      typedef const _List_node<_Tp>              _Node;
      typedef _List_iterator<_Tp>                iterator;

      typedef ptrdiff_t                          difference_type;
      typedef std::bidirectional_iterator_tag    iterator_category;
      typedef _Tp                                value_type;
      typedef const _Tp*                         pointer;
      typedef const _Tp&                         reference;

      _List_const_iterator() _GLIBCXX_NOEXCEPT
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      _GLIBCXX_NOEXCEPT
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
      : _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const _GLIBCXX_NOEXCEPT
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }

      // Must downcast from List_node_base to _List_node to get to
      // _M_data.
      reference
      operator*() const _GLIBCXX_NOEXCEPT
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const _GLIBCXX_NOEXCEPT
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++() _GLIBCXX_NOEXCEPT
      {
	_M_node = _M_node->_M_next;
	return *this;
      }

      _Self
      operator++(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _M_node->_M_next;
	return __tmp;
      }

      _Self&
      operator--() _GLIBCXX_NOEXCEPT
      {
	_M_node = _M_node->_M_prev;
	return *this;
      }

      _Self
      operator--(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _M_node->_M_prev;
	return __tmp;
      }

      bool
      operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node != __x._M_node; }

      // The only member points to the %list element.
      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
	       const _List_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
    { return __x._M_node != __y._M_node; }

_GLIBCXX_BEGIN_NAMESPACE_CXX11
  /// See bits/stl_deque.h's _Deque_base for an explanation.
  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
      // NOTA BENE
      // The stored instance is not actually of "allocator_type"'s
      // type.  Instead we rebind the type to
      // Allocator<List_node<Tp>>, which according to [20.1.5]/4
      // should probably be the same.  List_node<Tp> is not the same
      // size as Tp (it's two pointers larger), and specializations on
      // Tp may go unused because List_node<Tp> is being bound
      // instead.
      //
      // We put this to the test in the constructors and in
      // get_allocator, where we use conversions between
      // allocator_type and _Node_alloc_type. The conversion is
      // required by table 32 in [20.1.5].
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      static size_t
      _S_distance(const __detail::_List_node_base* __first,
		  const __detail::_List_node_base* __last)
      {
	size_t __n = 0;
	while (__first != __last)
	  {
	    __first = __first->_M_next;
	    ++__n;
	  }
	return __n;
      }

      struct _List_impl
      : public _Node_alloc_type
      {
#if _GLIBCXX_USE_CXX11_ABI
	_List_node<size_t> _M_node;
#else
# 338 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
	__detail::_List_node_base _M_node;
#endif
# 340 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

	_List_impl()
	: _Node_alloc_type(), _M_node()
	{ }

	_List_impl(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT
	: _Node_alloc_type(__a), _M_node()
	{ }

#if __cplusplus >= 201103L
	_List_impl(_Node_alloc_type&& __a) _GLIBCXX_NOEXCEPT
	: _Node_alloc_type(std::move(__a)), _M_node()
	{ }
#endif
# 354 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      };

      _List_impl _M_impl;

#if _GLIBCXX_USE_CXX11_ABI
      size_t _M_get_size() const { return _M_impl._M_node._M_data; }

      void _M_set_size(size_t __n) { _M_impl._M_node._M_data = __n; }

      void _M_inc_size(size_t __n) { _M_impl._M_node._M_data += __n; }

      void _M_dec_size(size_t __n) { _M_impl._M_node._M_data -= __n; }

      size_t
      _M_distance(const __detail::_List_node_base* __first,
		  const __detail::_List_node_base* __last) const
      { return _S_distance(__first, __last); }

      // return the stored size
      size_t _M_node_count() const { return _M_impl._M_node._M_data; }
#else
# 375 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      // dummy implementations used when the size is not stored
      size_t _M_get_size() const { return 0; }
      void _M_set_size(size_t) { }
      void _M_inc_size(size_t) { }
      void _M_dec_size(size_t) { }
      size_t _M_distance(const void*, const void*) const { return 0; }

      // count the number of nodes
      size_t _M_node_count() const
      {
	return _S_distance(_M_impl._M_node._M_next,
			   std::__addressof(_M_impl._M_node));
      }
#endif
# 389 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p) _GLIBCXX_NOEXCEPT
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
      { return *static_cast<_Node_alloc_type*>(&_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
      { return *static_cast<const _Node_alloc_type*>(&_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT
      : _M_impl(__a)
      { _M_init(); }

#if __cplusplus >= 201103L
      _List_base(_List_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Node_allocator()))
      {
	auto* const __xnode = std::__addressof(__x._M_impl._M_node);
	if (__xnode->_M_next == __xnode)
	  _M_init();
	else
	  {
	    auto* const __node = std::__addressof(_M_impl._M_node);
	    __node->_M_next = __xnode->_M_next;
	    __node->_M_prev = __xnode->_M_prev;
	    __node->_M_next->_M_prev = __node->_M_prev->_M_next = __node;
	    _M_set_size(__x._M_get_size());
	    __x._M_init();
	  }
      }
#endif
# 443 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      // This is what actually destroys the list.
      ~_List_base() _GLIBCXX_NOEXCEPT
      { _M_clear(); }

      void
      _M_clear() _GLIBCXX_NOEXCEPT;

      void
      _M_init() _GLIBCXX_NOEXCEPT
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
	_M_set_size(0);
      }
    };

  /**
   *  @brief A standard container with linear time access to elements,
   *  and fixed time insertion/deletion at any point in the sequence.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a> with the
   *  %exception of @c at and @c operator[].
   *
   *  This is a @e doubly @e linked %list.  Traversal up and down the
   *  %list requires linear time, but adding and removing elements (or
   *  @e nodes) is done in constant time, regardless of where the
   *  change takes place.  Unlike std::vector and std::deque,
   *  random-access iterators are not provided, so subscripting ( @c
   *  [] ) access is not allowed.  For algorithms which only need
   *  sequential access, this lack makes no difference.
   *
   *  Also unlike the other standard containers, std::list provides
   *  specialized algorithms %unique to linked lists, such as
   *  splicing, sorting, and in-place reversal.
   *
   *  A couple points on memory allocation for list<Tp>:
   *
   *  First, we never actually allocate a Tp, we allocate
   *  List_node<Tp>'s and trust [20.1.5]/4 to DTRT.  This is to ensure
   *  that after elements from %list<X,Alloc1> are spliced into
   *  %list<X,Alloc2>, destroying the memory of the second %list is a
   *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.
   *
   *  Second, a %list conceptually represented as
   *  @code
   *    A <---> B <---> C <---> D
   *  @endcode
   *  is actually circular; a link exists between A and D.  The %list
   *  class holds (as its only data member) a private list::iterator
   *  pointing to @e D, not to @e A!  To get to the head of the %list,
   *  we start at the tail and move forward by one.  When this member
   *  iterator's next/previous pointers refer to itself, the %list is
   *  %empty. 
  */
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {
      // concept requirements
      typedef typename _Alloc::value_type                _Alloc_value_type;
      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)

      typedef _List_base<_Tp, _Alloc>                    _Base;
      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
      typedef typename _Base::_Node_alloc_type		 _Node_alloc_type;

    public:
      typedef _Tp                                        value_type;
      typedef typename _Tp_alloc_type::pointer           pointer;
      typedef typename _Tp_alloc_type::const_pointer     const_pointer;
      typedef typename _Tp_alloc_type::reference         reference;
      typedef typename _Tp_alloc_type::const_reference   const_reference;
      typedef _List_iterator<_Tp>                        iterator;
      typedef _List_const_iterator<_Tp>                  const_iterator;
      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;
      typedef std::reverse_iterator<iterator>            reverse_iterator;
      typedef size_t                                     size_type;
      typedef ptrdiff_t                                  difference_type;
      typedef _Alloc                                     allocator_type;

    protected:
      // Note that pointers-to-_Node's can be ctor-converted to
      // iterator types.
      typedef _List_node<_Tp>				 _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;

      /**
       *  @param  __args  An instance of user data.
       *
       *  Allocates space for a new node and constructs a copy of
       *  @a __args in it.
       */
#if __cplusplus < 201103L
      _Node*
      _M_create_node(const value_type& __x)
      {
	_Node* __p = this->_M_get_node();
	__try
	  {
	    _M_get_Tp_allocator().construct
	      (std::__addressof(__p->_M_data), __x);
	  }
	__catch(...)
	  {
	    _M_put_node(__p);
	    __throw_exception_again;
	  }
	return __p;
      }
#else
# 567 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      template<typename... _Args>
        _Node*
        _M_create_node(_Args&&... __args)
	{
	  _Node* __p = this->_M_get_node();
	  __try
	    {
	      _M_get_Node_allocator().construct(__p,
						std::forward<_Args>(__args)...);
	    }
	  __catch(...)
	    {
	      _M_put_node(__p);
	      __throw_exception_again;
	    }
	  return __p;
	}
#endif
# 585 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

    public:
      // [23.2.2.1] construct/copy/destroy
      // (assign() and get_allocator() are also listed in this section)

      /**
       *  @brief  Creates a %list with no elements.
       */
      list()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<_Node_alloc_type>::value)
#endif
# 597 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      : _Base() { }

      /**
       *  @brief  Creates a %list with no elements.
       *  @param  __a  An allocator object.
       */
      explicit
      list(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      : _Base(_Node_alloc_type(__a)) { }

#if __cplusplus >= 201103L
      /**
       *  @brief  Creates a %list with default constructed elements.
       *  @param  __n  The number of elements to initially create.
       *
       *  This constructor fills the %list with @a __n default
       *  constructed elements.
       */
      explicit
      list(size_type __n)
      : _Base()
      { _M_default_initialize(__n); }

      /**
       *  @brief  Creates a %list with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator object.
       *
       *  This constructor fills the %list with @a __n copies of @a __value.
       */
      list(size_type __n, const value_type& __value,
	   const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
#else
# 633 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      /**
       *  @brief  Creates a %list with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator object.
       *
       *  This constructor fills the %list with @a __n copies of @a __value.
       */
      explicit
      list(size_type __n, const value_type& __value = value_type(),
	   const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
#endif
# 647 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  %List copy constructor.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  The newly-created %list uses a copy of the allocation object used
       *  by @a __x.
       */
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }

#if __cplusplus >= 201103L
      /**
       *  @brief  %List move constructor.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  The newly-created %list contains the exact contents of @a __x.
       *  The contents of @a __x are a valid, but unspecified %list.
       */
      list(list&& __x) noexcept
      : _Base(std::move(__x)) { }

      /**
       *  @brief  Builds a %list from an initializer_list
       *  @param  __l  An initializer_list of value_type.
       *  @param  __a  An allocator object.
       *
       *  Create a %list consisting of copies of the elements in the
       *  initializer_list @a __l.  This is linear in __l.size().
       */
      list(initializer_list<value_type> __l,
           const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }
#endif
# 683 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Builds a %list from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __a  An allocator object.
       *
       *  Create a %list consisting of copies of the elements from
       *  [@a __first,@a __last).  This is linear in N (where N is
       *  distance(@a __first,@a __last)).
       */
#if __cplusplus >= 201103L
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        list(_InputIterator __first, _InputIterator __last,
	     const allocator_type& __a = allocator_type())
	: _Base(_Node_alloc_type(__a))
        { _M_initialize_dispatch(__first, __last, __false_type()); }
#else
# 702 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
	     const allocator_type& __a = allocator_type())
	: _Base(_Node_alloc_type(__a))
        { 
	  // Check whether it's an integral type.  If so, it's not an iterator.
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_initialize_dispatch(__first, __last, _Integral());
	}
#endif
# 712 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  No explicit dtor needed as the _Base dtor takes care of
       *  things.  The _Base dtor only erases the elements, and note
       *  that if the elements themselves are pointers, the pointed-to
       *  memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       */

      /**
       *  @brief  %List assignment operator.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but unlike the copy
       *  constructor, the allocator object is not copied.
       */
      list&
      operator=(const list& __x);

#if __cplusplus >= 201103L
      /**
       *  @brief  %List move assignment operator.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  The contents of @a __x are moved into this %list (without copying).
       *  @a __x is a valid, but unspecified %list
       */
      list&
      operator=(list&& __x)
      {
	// NB: DR 1204.
	// NB: DR 675.
	this->clear();
	this->swap(__x);
	return *this;
      }

      /**
       *  @brief  %List initializer list assignment operator.
       *  @param  __l  An initializer_list of value_type.
       *
       *  Replace the contents of the %list with copies of the elements
       *  in the initializer_list @a __l.  This is linear in l.size().
       */
      list&
      operator=(initializer_list<value_type> __l)
      {
	this->assign(__l.begin(), __l.end());
	return *this;
      }
#endif
# 763 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Assigns a given value to a %list.
       *  @param  __n  Number of elements to be assigned.
       *  @param  __val  Value to be assigned.
       *
       *  This function fills a %list with @a __n copies of the given
       *  value.  Note that the assignment completely changes the %list
       *  and that the resulting %list's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }

      /**
       *  @brief  Assigns a range to a %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function fills a %list with copies of the elements in the
       *  range [@a __first,@a __last).
       *
       *  Note that the assignment completely changes the %list and
       *  that the resulting %list's size is the same as the number of
       *  elements assigned.  Old data may be lost.
       */
#if __cplusplus >= 201103L
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
#else
# 797 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
	  // Check whether it's an integral type.  If so, it's not an iterator.
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_assign_dispatch(__first, __last, _Integral());
	}
#endif
# 806 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Assigns an initializer_list to a %list.
       *  @param  __l  An initializer_list of value_type.
       *
       *  Replace the contents of the %list with copies of the elements
       *  in the initializer_list @a __l.  This is linear in __l.size().
       */
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }
#endif
# 819 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /// Get a copy of the memory allocation object.
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return _Base::get_allocator(); }

      // iterators
      /**
       *  Returns a read/write iterator that points to the first element in the
       *  %list.  Iteration is done in ordinary element order.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return iterator(this->_M_impl._M_node._M_next); }

      /**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %list.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return const_iterator(this->_M_impl._M_node._M_next); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  element in the %list.  Iteration is done in ordinary element
       *  order.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(&this->_M_impl._M_node); }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %list.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return const_iterator(&this->_M_impl._M_node); }

      /**
       *  Returns a read/write reverse iterator that points to the last
       *  element in the %list.  Iteration is done in reverse element
       *  order.
       */
      reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to
       *  the last element in the %list.  Iteration is done in reverse
       *  element order.
       */
      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(end()); }

      /**
       *  Returns a read/write reverse iterator that points to one
       *  before the first element in the %list.  Iteration is done in
       *  reverse element order.
       */
      reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(begin()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first element in the %list.  Iteration is done in reverse
       *  element order.
       */
      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(begin()); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %list.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %list.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
      cend() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to
       *  the last element in the %list.  Iteration is done in reverse
       *  element order.
       */
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first element in the %list.  Iteration is done in reverse
       *  element order.
       */
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }
#endif
# 934 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      // [23.2.2.2] capacity
      /**
       *  Returns true if the %list is empty.  (Thus begin() would equal
       *  end().)
       */
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }

      /**  Returns the number of elements in the %list.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return this->_M_node_count(); }

      /**  Returns the size() of the largest possible %list.  */
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _M_get_Node_allocator().max_size(); }

#if __cplusplus >= 201103L
      /**
       *  @brief Resizes the %list to the specified number of elements.
       *  @param __new_size Number of elements the %list should contain.
       *
       *  This function will %resize the %list to the specified number
       *  of elements.  If the number is smaller than the %list's
       *  current size the %list is truncated, otherwise default
       *  constructed elements are appended.
       */
      void
      resize(size_type __new_size);

      /**
       *  @brief Resizes the %list to the specified number of elements.
       *  @param __new_size Number of elements the %list should contain.
       *  @param __x Data with which new elements should be populated.
       *
       *  This function will %resize the %list to the specified number
       *  of elements.  If the number is smaller than the %list's
       *  current size the %list is truncated, otherwise the %list is
       *  extended and new elements are populated with given data.
       */
      void
      resize(size_type __new_size, const value_type& __x);
#else
# 980 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      /**
       *  @brief Resizes the %list to the specified number of elements.
       *  @param __new_size Number of elements the %list should contain.
       *  @param __x Data with which new elements should be populated.
       *
       *  This function will %resize the %list to the specified number
       *  of elements.  If the number is smaller than the %list's
       *  current size the %list is truncated, otherwise the %list is
       *  extended and new elements are populated with given data.
       */
      void
      resize(size_type __new_size, value_type __x = value_type());
#endif
# 993 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      // element access
      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %list.
       */
      reference
      front() _GLIBCXX_NOEXCEPT
      { return *begin(); }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %list.
       */
      const_reference
      front() const _GLIBCXX_NOEXCEPT
      { return *begin(); }

      /**
       *  Returns a read/write reference to the data at the last element
       *  of the %list.
       */
      reference
      back() _GLIBCXX_NOEXCEPT
      { 
	iterator __tmp = end();
	--__tmp;
	return *__tmp;
      }

      /**
       *  Returns a read-only (constant) reference to the data at the last
       *  element of the %list.
       */
      const_reference
      back() const _GLIBCXX_NOEXCEPT
      { 
	const_iterator __tmp = end();
	--__tmp;
	return *__tmp;
      }

      // [23.2.2.3] modifiers
      /**
       *  @brief  Add data to the front of the %list.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the front of the %list and assigns the given data
       *  to it.  Due to the nature of a %list this operation can be
       *  done in constant time, and does not invalidate iterators and
       *  references.
       */
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }

#if __cplusplus >= 201103L
      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args)
        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
#endif
# 1060 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Removes first element.
       *
       *  This is a typical stack operation.  It shrinks the %list by
       *  one.  Due to the nature of a %list this operation can be done
       *  in constant time, and only invalidates iterators/references to
       *  the element being removed.
       *
       *  Note that no data is returned, and if the first element's data
       *  is needed, it should be retrieved before pop_front() is
       *  called.
       */
      void
      pop_front() _GLIBCXX_NOEXCEPT
      { this->_M_erase(begin()); }

      /**
       *  @brief  Add data to the end of the %list.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %list and assigns the given data to
       *  it.  Due to the nature of a %list this operation can be done
       *  in constant time, and does not invalidate iterators and
       *  references.
       */
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }

#if __cplusplus >= 201103L
      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args)
        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
#endif
# 1101 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation.  It shrinks the %list by
       *  one.  Due to the nature of a %list this operation can be done
       *  in constant time, and only invalidates iterators/references to
       *  the element being removed.
       *
       *  Note that no data is returned, and if the last element's data
       *  is needed, it should be retrieved before pop_back() is called.
       */
      void
      pop_back() _GLIBCXX_NOEXCEPT
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Constructs object in %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __args  Arguments.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert an object of type T constructed
       *  with T(std::forward<Args>(args)...) before the specified
       *  location.  Due to the nature of a %list this operation can
       *  be done in constant time, and does not invalidate iterators
       *  and references.
       */
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);

      /**
       *  @brief  Inserts given value into %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
       */
      iterator
      insert(const_iterator __position, const value_type& __x);
#else
# 1148 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      /**
       *  @brief  Inserts given value into %list before specified iterator.
       *  @param  __position  An iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
       */
      iterator
      insert(iterator __position, const value_type& __x);
#endif
# 1162 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts given rvalue into %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given rvalue before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
        */
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }

      /**
       *  @brief  Inserts the contents of an initializer_list into %list
       *          before specified const_iterator.
       *  @param  __p  A const_iterator into the %list.
       *  @param  __l  An initializer_list of value_type.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert copies of the data in the
       *  initializer_list @a l into the %list before the location
       *  specified by @a p.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       */
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
#endif
# 1198 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts a number of copies of given data into the %list.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert a specified number of copies of the
       *  given data before the location specified by @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       */
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x);
#else
# 1217 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      /**
       *  @brief  Inserts a number of copies of given data into the %list.
       *  @param  __position  An iterator into the %list.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *
       *  This function will insert a specified number of copies of the
       *  given data before the location specified by @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       */
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
	list __tmp(__n, __x, get_allocator());
	splice(__position, __tmp);
      }
#endif
# 1236 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts a range into the %list.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert copies of the data in the range [@a
       *  first,@a last) into the %list before the location specified by
       *  @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       */
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
	iterator
	insert(const_iterator __position, _InputIterator __first,
	       _InputIterator __last);
#else
# 1259 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      /**
       *  @brief  Inserts a range into the %list.
       *  @param  __position  An iterator into the %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function will insert copies of the data in the range [@a
       *  first,@a last) into the %list before the location specified by
       *  @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       */
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
	       _InputIterator __last)
        {
	  list __tmp(__first, __last, get_allocator());
	  splice(__position, __tmp);
	}
#endif
# 1281 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Remove element at given position.
       *  @param  __position  Iterator pointing to element to be erased.
       *  @return  An iterator pointing to the next element (or end()).
       *
       *  This function will erase the element at the given position and thus
       *  shorten the %list by one.
       *
       *  Due to the nature of a %list this operation can be done in
       *  constant time, and only invalidates iterators/references to
       *  the element being removed.  The user is also cautioned that
       *  this function only erases the element, and that if the element
       *  is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       */
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __position) noexcept;
#else
# 1301 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      erase(iterator __position);
#endif
# 1303 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Remove a range of elements.
       *  @param  __first  Iterator pointing to the first element to be erased.
       *  @param  __last  Iterator pointing to one past the last element to be
       *                erased.
       *  @return  An iterator pointing to the element pointed to by @a last
       *           prior to erasing (or end()).
       *
       *  This function will erase the elements in the range @a
       *  [first,last) and shorten the %list accordingly.
       *
       *  This operation is linear time in the size of the range and only
       *  invalidates iterators/references to the element being removed.
       *  The user is also cautioned that this function only erases the
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer
       *  is the user's responsibility.
       */
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __first, const_iterator __last) noexcept
#else
# 1326 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      erase(iterator __first, iterator __last)
#endif
# 1328 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      {
	while (__first != __last)
	  __first = erase(__first);
	return __last._M_const_cast();
      }

      /**
       *  @brief  Swaps data with another %list.
       *  @param  __x  A %list of the same element and allocator types.
       *
       *  This exchanges the elements between two lists in constant
       *  time.  Note that the global std::swap() function is
       *  specialized such that std::swap(l1,l2) will feed to this
       *  function.
       */
      void
      swap(list& __x)
      {
	__detail::_List_node_base::swap(this->_M_impl._M_node, 
					__x._M_impl._M_node);

	size_t __xsize = __x._M_get_size();
	__x._M_set_size(this->_M_get_size());
	this->_M_set_size(__xsize);

	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 431. Swapping containers with unequal allocators.
	std::__alloc_swap<typename _Base::_Node_alloc_type>::
	  _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }

      /**
       *  Erases all the elements.  Note that this function only erases
       *  the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      {
        _Base::_M_clear();
        _Base::_M_init();
      }

      // [23.2.2.4] list operations
      /**
       *  @brief  Insert contents of another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *
       *  The elements of @a __x are inserted in constant time in front of
       *  the element referenced by @a __position.  @a __x becomes an empty
       *  list.
       *
       *  Requires this != @a __x.
       */
      void
#if __cplusplus >= 201103L
      splice(const_iterator __position, list&& __x) noexcept
#else
# 1388 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      splice(iterator __position, list& __x)
#endif
# 1390 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      {
	if (!__x.empty())
	  {
	    _M_check_equal_allocators(__x);

	    this->_M_transfer(__position._M_const_cast(),
			      __x.begin(), __x.end());

	    this->_M_inc_size(__x._M_get_size());
	    __x._M_set_size(0);
	  }
      }

#if __cplusplus >= 201103L
      void
      splice(const_iterator __position, list& __x) noexcept
      { splice(__position, std::move(__x)); }
#endif
# 1408 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert element from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __i  Const_iterator referencing the element to move.
       *
       *  Removes the element in list @a __x referenced by @a __i and
       *  inserts it into the current list before @a __position.
       */
      void
      splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
#else
# 1423 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      /**
       *  @brief  Insert element from another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *  @param  __i  Iterator referencing the element to move.
       *
       *  Removes the element in list @a __x referenced by @a __i and
       *  inserts it into the current list before @a __position.
       */
      void
      splice(iterator __position, list& __x, iterator __i)
#endif
# 1435 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      {
	iterator __j = __i._M_const_cast();
	++__j;
	if (__position == __i || __position == __j)
	  return;

	if (this != &__x)
	  _M_check_equal_allocators(__x);

	this->_M_transfer(__position._M_const_cast(),
			  __i._M_const_cast(), __j);

	this->_M_inc_size(1);
	__x._M_dec_size(1);
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert element from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __i  Const_iterator referencing the element to move.
       *
       *  Removes the element in list @a __x referenced by @a __i and
       *  inserts it into the current list before @a __position.
       */
      void
      splice(const_iterator __position, list& __x, const_iterator __i) noexcept
      { splice(__position, std::move(__x), __i); }
#endif
# 1466 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert range from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __first  Const_iterator referencing the start of range in x.
       *  @param  __last  Const_iterator referencing the end of range in x.
       *
       *  Removes elements in the range [__first,__last) and inserts them
       *  before @a __position in constant time.
       *
       *  Undefined if @a __position is in [__first,__last).
       */
      void
      splice(const_iterator __position, list&& __x, const_iterator __first,
	     const_iterator __last) noexcept
#else
# 1485 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      /**
       *  @brief  Insert range from another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *  @param  __first  Iterator referencing the start of range in x.
       *  @param  __last  Iterator referencing the end of range in x.
       *
       *  Removes elements in the range [__first,__last) and inserts them
       *  before @a __position in constant time.
       *
       *  Undefined if @a __position is in [__first,__last).
       */
      void
      splice(iterator __position, list& __x, iterator __first,
	     iterator __last)
#endif
# 1501 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      {
	if (__first != __last)
	  {
	    if (this != &__x)
	      _M_check_equal_allocators(__x);

	    size_t __n = this->_M_distance(__first._M_node, __last._M_node);
	    this->_M_inc_size(__n);
	    __x._M_dec_size(__n);

	    this->_M_transfer(__position._M_const_cast(),
			      __first._M_const_cast(),
			      __last._M_const_cast());
	  }
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert range from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __first  Const_iterator referencing the start of range in x.
       *  @param  __last  Const_iterator referencing the end of range in x.
       *
       *  Removes elements in the range [__first,__last) and inserts them
       *  before @a __position in constant time.
       *
       *  Undefined if @a __position is in [__first,__last).
       */
      void
      splice(const_iterator __position, list& __x, const_iterator __first,
	     const_iterator __last) noexcept
      { splice(__position, std::move(__x), __first, __last); }
#endif
# 1536 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Remove all elements equal to value.
       *  @param  __value  The value to remove.
       *
       *  Removes every element in the list equal to @a value.
       *  Remaining elements stay in list order.  Note that this
       *  function only erases the elements, and that if the elements
       *  themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      void
      remove(const _Tp& __value);

      /**
       *  @brief  Remove all elements satisfying a predicate.
       *  @tparam  _Predicate  Unary predicate function or object.
       *
       *  Removes every element in the list for which the predicate
       *  returns true.  Remaining elements stay in list order.  Note
       *  that this function only erases the elements, and that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      template<typename _Predicate>
        void
        remove_if(_Predicate);

      /**
       *  @brief  Remove consecutive duplicate elements.
       *
       *  For each consecutive set of elements with the same value,
       *  remove all but the first one.  Remaining elements stay in
       *  list order.  Note that this function only erases the
       *  elements, and that if the elements themselves are pointers,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */
      void
      unique();

      /**
       *  @brief  Remove consecutive elements satisfying a predicate.
       *  @tparam _BinaryPredicate  Binary predicate function or object.
       *
       *  For each consecutive set of elements [first,last) that
       *  satisfy predicate(first,i) where i is an iterator in
       *  [first,last), remove all but the first one.  Remaining
       *  elements stay in list order.  Note that this function only
       *  erases the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       */
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);

      /**
       *  @brief  Merge sorted lists.
       *  @param  __x  Sorted list to merge.
       *
       *  Assumes that both @a __x and this list are sorted according to
       *  operator<().  Merges elements of @a __x into this list in
       *  sorted order, leaving @a __x empty when complete.  Elements in
       *  this list precede elements in @a __x that are equal.
       */
#if __cplusplus >= 201103L
      void
      merge(list&& __x);

      void
      merge(list& __x)
      { merge(std::move(__x)); }
#else
# 1612 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      void
      merge(list& __x);
#endif
# 1615 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Merge sorted lists according to comparison function.
       *  @tparam _StrictWeakOrdering Comparison function defining
       *  sort order.
       *  @param  __x  Sorted list to merge.
       *  @param  __comp  Comparison functor.
       *
       *  Assumes that both @a __x and this list are sorted according to
       *  StrictWeakOrdering.  Merges elements of @a __x into this list
       *  in sorted order, leaving @a __x empty when complete.  Elements
       *  in this list precede elements in @a __x that are equivalent
       *  according to StrictWeakOrdering().
       */
#if __cplusplus >= 201103L
      template<typename _StrictWeakOrdering>
        void
        merge(list&& __x, _StrictWeakOrdering __comp);

      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp)
        { merge(std::move(__x), __comp); }
#else
# 1639 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp);
#endif
# 1643 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      /**
       *  @brief  Reverse the elements in list.
       *
       *  Reverse the order of elements in the list in linear time.
       */
      void
      reverse() _GLIBCXX_NOEXCEPT
      { this->_M_impl._M_node._M_reverse(); }

      /**
       *  @brief  Sort the elements.
       *
       *  Sorts the elements of this list in NlogN time.  Equivalent
       *  elements remain in list order.
       */
      void
      sort();

      /**
       *  @brief  Sort the elements according to comparison function.
       *
       *  Sorts the elements of this list in NlogN time.  Equivalent
       *  elements remain in list order.
       */
      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:
      // Internal constructor functions follow.

      // Called by the range constructor to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }

      // Called by the range constructor to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
			       __false_type)
        {
	  for (; __first != __last; ++__first)
#if __cplusplus >= 201103L
	    emplace_back(*__first);
#else
# 1694 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
	    push_back(*__first);
#endif
# 1696 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
	}

      // Called by list(n,v,a), and the range constructor when it turns out
      // to be the same thing.
      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
	for (; __n; --__n)
	  push_back(__x);
      }

#if __cplusplus >= 201103L
      // Called by list(n).
      void
      _M_default_initialize(size_type __n)
      {
	for (; __n; --__n)
	  emplace_back();
      }

      // Called by resize(sz).
      void
      _M_default_append(size_type __n);
#endif
# 1720 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      // Internal assign functions follow.

      // Called by the range assign to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }

      // Called by the range assign to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
			   __false_type);

      // Called by assign(n,t), and the range assign when it turns out
      // to be the same thing.
      void
      _M_fill_assign(size_type __n, const value_type& __val);


      // Moves the elements from [first,last) before position.
      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }

      // Inserts new element at position given and with value given.
#if __cplusplus < 201103L
      void
      _M_insert(iterator __position, const value_type& __x)
      {
        _Node* __tmp = _M_create_node(__x);
        __tmp->_M_hook(__position._M_node);
	this->_M_inc_size(1);
      }
#else
# 1759 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
	 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
	 __tmp->_M_hook(__position._M_node);
	 this->_M_inc_size(1);
       }
#endif
# 1768 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3

      // Erases element at position given.
      void
      _M_erase(iterator __position) _GLIBCXX_NOEXCEPT
      {
	this->_M_dec_size(1);
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
#if __cplusplus >= 201103L
        _M_get_Node_allocator().destroy(__n);
#else
# 1779 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
	_M_get_Tp_allocator().destroy(std::__addressof(__n->_M_data));
#endif
# 1781 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
        _M_put_node(__n);
      }

      // To implement the splice (and merge) bits of N1599.
      void
      _M_check_equal_allocators(list& __x) _GLIBCXX_NOEXCEPT
      {
	if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
	    _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
	  __builtin_abort();
      }
    };
_GLIBCXX_END_NAMESPACE_CXX11

  /**
   *  @brief  List equality comparison.
   *  @param  __x  A %list.
   *  @param  __y  A %list of the same type as @a __x.
   *  @return  True iff the size and elements of the lists are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of
   *  the lists.  Lists are considered equivalent if their sizes are
   *  equal, and if corresponding elements compare equal.
  */
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
	{
	  ++__i1;
	  ++__i2;
	}
      return __i1 == __end1 && __i2 == __end2;
    }

  /**
   *  @brief  List ordering relation.
   *  @param  __x  A %list.
   *  @param  __y  A %list of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  lists.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
					  __y.begin(), __y.end()); }

  /// Based on operator==
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }

  /// See std::list::swap().
  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif /* _STL_LIST_H */
# 1874 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_list.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/list.tcc>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 1 3
// List implementation (out of line) -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/list.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{list}
 */

#ifndef _LIST_TCC
#define _LIST_TCC 1

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear() _GLIBCXX_NOEXCEPT
    {
      typedef _List_node<_Tp>  _Node;
      __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
      while (__cur != &_M_impl._M_node)
	{
	  _Node* __tmp = static_cast<_Node*>(__cur);
	  __cur = __tmp->_M_next;
#if __cplusplus >= 201103L
	  _M_get_Node_allocator().destroy(__tmp);
#else
# 77 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
	  _M_get_Tp_allocator().destroy(std::__addressof(__tmp->_M_data));
#endif
# 79 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
	  _M_put_node(__tmp);
	}
    }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
	_Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
	__tmp->_M_hook(__position._M_const_cast()._M_node);
	this->_M_inc_size(1);
	return iterator(__tmp);
      }
#endif
# 96 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
#if __cplusplus >= 201103L
    insert(const_iterator __position, const value_type& __x)
#else
# 103 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
    insert(iterator __position, const value_type& __x)
#endif
# 105 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_const_cast()._M_node);
      this->_M_inc_size(1);
      return iterator(__tmp);
    }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(const_iterator __position, size_type __n, const value_type& __x)
    {
      if (__n)
	{
	  list __tmp(__n, __x, get_allocator());
	  iterator __it = __tmp.begin();
	  splice(__position, __tmp);
	  return __it;
	}
      return __position._M_const_cast();
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator, typename>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      insert(const_iterator __position, _InputIterator __first,
	     _InputIterator __last)
      {
	list __tmp(__first, __last, get_allocator());
	if (!__tmp.empty())
	  {
	    iterator __it = __tmp.begin();
	    splice(__position, __tmp);
	    return __it;
	  }
	return __position._M_const_cast();
      }
#endif
# 145 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3

  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
#if __cplusplus >= 201103L
    erase(const_iterator __position) noexcept
#else
# 152 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
    erase(iterator __position)
#endif
# 154 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position._M_const_cast());
      return __ret;
    }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      size_type __i = 0;
      __try
	{
	  for (; __i < __n; ++__i)
	    emplace_back();
	}
      __catch(...)
	{
	  for (; __i; --__i)
	    pop_back();
	  __throw_exception_again;
	}
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else                          // __i == end()
	_M_default_append(__new_size - __len);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else                          // __i == end()
        insert(end(), __new_size - __len, __x);
    }
#else
# 210 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else                          // __i == end()
        insert(end(), __new_size - __len, __x);
    }
#endif
# 225 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3

  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
	{
	  iterator __first1 = begin();
	  iterator __last1 = end();
	  const_iterator __first2 = __x.begin();
	  const_iterator __last2 = __x.end();
	  for (; __first1 != __last1 && __first2 != __last2;
	       ++__first1, ++__first2)
	    *__first1 = *__first2;
	  if (__first2 == __last2)
	    erase(__first1, __last1);
	  else
	    insert(__last1, __first2, __last2);
	}
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
			 __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
	     ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
	{
	  iterator __next = __first;
	  ++__next;
	  if (*__first == __value)
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 526. Is it undefined if a function in the standard changes
	      // in parameters?
	      if (std::__addressof(*__first) != std::__addressof(__value))
		_M_erase(__first);
	      else
		__extra = __first;
	    }
	  __first = __next;
	}
      if (__extra != __last)
	_M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
	return;
      iterator __next = __first;
      while (++__next != __last)
	{
	  if (*__first == *__next)
	    _M_erase(__next);
	  else
	    __first = __next;
	  __next = __first;
	}
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
#if __cplusplus >= 201103L
    merge(list&& __x)
#else
# 334 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
    merge(list& __x)
#endif
# 336 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 300. list::merge() specification incomplete
      if (this != &__x)
	{
	  _M_check_equal_allocators(__x); 

	  iterator __first1 = begin();
	  iterator __last1 = end();
	  iterator __first2 = __x.begin();
	  iterator __last2 = __x.end();
	  while (__first1 != __last1 && __first2 != __last2)
	    if (*__first2 < *__first1)
	      {
		iterator __next = __first2;
		_M_transfer(__first1, __first2, ++__next);
		__first2 = __next;
	      }
	    else
	      ++__first1;
	  if (__first2 != __last2)
	    _M_transfer(__last1, __first2, __last2);

	  this->_M_inc_size(__x._M_get_size());
	  __x._M_set_size(0);
	}
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
#if __cplusplus >= 201103L
      merge(list&& __x, _StrictWeakOrdering __comp)
#else
# 371 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
      merge(list& __x, _StrictWeakOrdering __comp)
#endif
# 373 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 300. list::merge() specification incomplete
	if (this != &__x)
	  {
	    _M_check_equal_allocators(__x);

	    iterator __first1 = begin();
	    iterator __last1 = end();
	    iterator __first2 = __x.begin();
	    iterator __last2 = __x.end();
	    while (__first1 != __last1 && __first2 != __last2)
	      if (__comp(*__first2, *__first1))
		{
		  iterator __next = __first2;
		  _M_transfer(__first1, __first2, ++__next);
		  __first2 = __next;
		}
	      else
		++__first1;
	    if (__first2 != __last2)
	      _M_transfer(__last1, __first2, __last2);

	    this->_M_inc_size(__x._M_get_size());
	    __x._M_set_size(0);
	  }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {
      // Do nothing if the list has length 0 or 1.
      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
	  && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
	  {
	    __carry.splice(__carry.begin(), *this, begin());

	    for(__counter = &__tmp[0];
		__counter != __fill && !__counter->empty();
		++__counter)
	      {
		__counter->merge(__carry);
		__carry.swap(*__counter);
	      }
	    __carry.swap(*__counter);
	    if (__counter == __fill)
	      ++__fill;
	  }
	while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
	  {
	    iterator __next = __first;
	    ++__next;
	    if (__pred(*__first))
	      _M_erase(__first);
	    __first = __next;
	  }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
	  return;
        iterator __next = __first;
        while (++__next != __last)
	  {
	    if (__binary_pred(*__first, *__next))
	      _M_erase(__next);
	    else
	      __first = __next;
	    __next = __first;
	  }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {
	// Do nothing if the list has length 0 or 1.
	if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
	    && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
	  {
	    list __carry;
	    list __tmp[64];
	    list * __fill = &__tmp[0];
	    list * __counter;

	    do
	      {
		__carry.splice(__carry.begin(), *this, begin());

		for(__counter = &__tmp[0];
		    __counter != __fill && !__counter->empty();
		    ++__counter)
		  {
		    __counter->merge(__carry, __comp);
		    __carry.swap(*__counter);
		  }
		__carry.swap(*__counter);
		if (__counter == __fill)
		  ++__fill;
	      }
	    while ( !empty() );

	    for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
	      __counter->merge(*(__counter - 1), __comp);
	    swap(*(__fill - 1));
	  }
      }

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif /* _LIST_TCC */
# 519 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/list.tcc" 3

# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 2 3

#ifdef _GLIBCXX_DEBUG
#if 0 /* expanded by -frewrite-includes */
# include <debug/list>
#endif /* expanded by -frewrite-includes */
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
#endif
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3

#ifdef _GLIBCXX_PROFILE
#if 0 /* expanded by -frewrite-includes */
# include <profile/list>
#endif /* expanded by -frewrite-includes */
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
# 72 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3
#endif
# 73 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3

#endif /* _GLIBCXX_LIST */
# 75 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/list" 3

# 9 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include <iostream>
#endif /* expanded by -frewrite-includes */
# 9 "CpfRetentionStrategy.cc"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 1 3
// Standard iostream objects -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/iostream
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.3  Standard iostream objects
//

#ifndef _GLIBCXX_IOSTREAM
#define _GLIBCXX_IOSTREAM 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 3
#if 0 /* expanded by -frewrite-includes */
#include <ostream>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 1 3
// Output streams -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/ostream
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.6.2  Output streams
//

#ifndef _GLIBCXX_OSTREAM
#define _GLIBCXX_OSTREAM 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3

#if 0 /* expanded by -frewrite-includes */
#include <ios>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 1 3
// Iostreams base classes -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/ios
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.4  Iostreams base classes
//

#ifndef _GLIBCXX_IOS
#define _GLIBCXX_IOS 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3

#if 0 /* expanded by -frewrite-includes */
#include <iosfwd>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 1 3
// <iosfwd> Forward declarations -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/iosfwd
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.2  Forward declarations
//

#ifndef _GLIBCXX_IOSFWD
#define _GLIBCXX_IOSFWD 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stringfwd.h> 	// For string forward declarations.
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 1 3
// <string> Forward declarations -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/stringfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21 Strings library
//

#ifndef _STRINGFWD_H
#define _STRINGFWD_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/memoryfwd.h>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @defgroup strings Strings
   *
   *  @{
  */

  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;

#ifdef _GLIBCXX_USE_WCHAR_T
  template<> struct char_traits<wchar_t>;
#endif
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3

#if ((__cplusplus >= 201103L) \
     && defined(_GLIBCXX_USE_C99_STDINT_TR1))
  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;
#endif
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3

_GLIBCXX_BEGIN_NAMESPACE_CXX11

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  /// A string of @c char
  typedef basic_string<char>    string;   

#ifdef _GLIBCXX_USE_WCHAR_T
  /// A string of @c wchar_t
  typedef basic_string<wchar_t> wstring;   
#endif
# 80 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3

#if ((__cplusplus >= 201103L) \
     && defined(_GLIBCXX_USE_C99_STDINT_TR1))
  /// A string of @c char16_t
  typedef basic_string<char16_t> u16string; 

  /// A string of @c char32_t
  typedef basic_string<char32_t> u32string; 
#endif
# 89 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3

_GLIBCXX_END_NAMESPACE_CXX11

  /** @}  */

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif	// _STRINGFWD_H
# 98 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stringfwd.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/postypes.h>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 1 3
// Position types -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/postypes.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iosfwd}
 */

//
// ISO C++ 14882: 27.4.1 - Types
// ISO C++ 14882: 27.4.3 - Template class fpos
//

#ifndef _GLIBCXX_POSTYPES_H
#define _GLIBCXX_POSTYPES_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <cwchar> // For mbstate_t
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cwchar
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wchar.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 21.4
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if _GLIBCXX_HAVE_WCHAR_H
#if 0 /* expanded by -frewrite-includes */
#include <wchar.h>
#endif /* expanded by -frewrite-includes */
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */

#ifndef _WCHAR_H

#if !defined __need_mbstate_t && !defined __need_wint_t
# define _WCHAR_H 1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/wchar.h" 3 4
# 29 "/usr/include/wchar.h" 3 4
#endif
# 30 "/usr/include/wchar.h" 3 4

#ifdef _WCHAR_H
/* Get FILE definition.  */
# define __need___FILE
# if defined __USE_UNIX98 || defined __USE_XOPEN2K
#  define __need_FILE
# endif
# 37 "/usr/include/wchar.h" 3 4
#if 0 /* expanded by -frewrite-includes */
# include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */

#ifndef _STDIO_H

#if !defined __need_FILE && !defined __need___FILE
# define _STDIO_H	1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/stdio.h" 3 4
# 29 "/usr/include/stdio.h" 3 4

__BEGIN_DECLS

# define __need_size_t
# define __need_NULL
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/stdio.h" 3 4
# 35 "/usr/include/stdio.h" 3 4

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/stdio.h" 3 4
# 37 "/usr/include/stdio.h" 3 4
# define __need_FILE
# define __need___FILE
#endif /* Don't need FILE.  */
# 40 "/usr/include/stdio.h" 3 4


#if !defined __FILE_defined && defined __need_FILE

/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;

__BEGIN_NAMESPACE_STD
/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;
__END_NAMESPACE_STD
#if defined __USE_LARGEFILE64 || defined __USE_SVID || defined __USE_POSIX \
    || defined __USE_BSD || defined __USE_ISOC99 || defined __USE_XOPEN \
    || defined __USE_POSIX2
__USING_NAMESPACE_STD(FILE)
#endif
# 56 "/usr/include/stdio.h" 3 4

# define __FILE_defined	1
#endif /* FILE not defined.  */
# 59 "/usr/include/stdio.h" 3 4
#undef	__need_FILE


#if !defined ____FILE_defined && defined __need___FILE

/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;

# define ____FILE_defined	1
#endif /* __FILE not defined.  */
# 69 "/usr/include/stdio.h" 3 4
#undef	__need___FILE


#ifdef	_STDIO_H
#define _STDIO_USES_IOSTREAM

#if 0 /* expanded by -frewrite-includes */
#include <libio.h>
#endif /* expanded by -frewrite-includes */
# 75 "/usr/include/stdio.h" 3 4
# 76 "/usr/include/stdio.h" 3 4

#if defined __USE_XOPEN || defined __USE_XOPEN2K8
# ifdef __GNUC__
#  ifndef _VA_LIST_DEFINED
typedef _G_va_list va_list;
#   define _VA_LIST_DEFINED
#  endif
# 83 "/usr/include/stdio.h" 3 4
# else
# 84 "/usr/include/stdio.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#  include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 84 "/usr/include/stdio.h" 3 4
# 85 "/usr/include/stdio.h" 3 4
# endif
# 86 "/usr/include/stdio.h" 3 4
#endif
# 87 "/usr/include/stdio.h" 3 4

#ifdef __USE_XOPEN2K8
# ifndef __off_t_defined
# ifndef __USE_FILE_OFFSET64
typedef __off_t off_t;
# else
# 93 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;
# endif
# 95 "/usr/include/stdio.h" 3 4
# define __off_t_defined
# endif
# 97 "/usr/include/stdio.h" 3 4
# if defined __USE_LARGEFILE64 && !defined __off64_t_defined
typedef __off64_t off64_t;
# define __off64_t_defined
# endif
# 101 "/usr/include/stdio.h" 3 4

# ifndef __ssize_t_defined
typedef __ssize_t ssize_t;
# define __ssize_t_defined
# endif
# 106 "/usr/include/stdio.h" 3 4
#endif
# 107 "/usr/include/stdio.h" 3 4

/* The type of the second argument to `fgetpos' and `fsetpos'.  */
__BEGIN_NAMESPACE_STD
#ifndef __USE_FILE_OFFSET64
typedef _G_fpos_t fpos_t;
#else
# 113 "/usr/include/stdio.h" 3 4
typedef _G_fpos64_t fpos_t;
#endif
# 115 "/usr/include/stdio.h" 3 4
__END_NAMESPACE_STD
#ifdef __USE_LARGEFILE64
typedef _G_fpos64_t fpos64_t;
#endif
# 119 "/usr/include/stdio.h" 3 4

/* The possibilities for the third argument to `setvbuf'.  */
#define _IOFBF 0 		/* Fully buffered.  */
#define _IOLBF 1		/* Line buffered.  */
#define _IONBF 2		/* No buffering.  */


/* Default buffer size.  */
#ifndef BUFSIZ
# define BUFSIZ _IO_BUFSIZ
#endif
# 130 "/usr/include/stdio.h" 3 4


/* End of file character.
   Some things throughout the library rely on this being -1.  */
#ifndef EOF
# define EOF (-1)
#endif
# 137 "/usr/include/stdio.h" 3 4


/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
#define SEEK_SET	0	/* Seek from beginning of file.  */
#define SEEK_CUR	1	/* Seek from current position.  */
#define SEEK_END	2	/* Seek from end of file.  */


#if defined __USE_SVID || defined __USE_XOPEN
/* Default path prefix for `tempnam' and `tmpnam'.  */
# define P_tmpdir	"/tmp"
#endif
# 150 "/usr/include/stdio.h" 3 4


/* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
   		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/stdio_lim.h>
#endif /* expanded by -frewrite-includes */
# 161 "/usr/include/stdio.h" 3 4
# 162 "/usr/include/stdio.h" 3 4


/* Standard streams.  */
extern struct _IO_FILE *stdin;		/* Standard input stream.  */
extern struct _IO_FILE *stdout;		/* Standard output stream.  */
extern struct _IO_FILE *stderr;		/* Standard error output stream.  */
#ifdef __STDC__
/* C89/C99 say they're macros.  Make them happy.  */
#define stdin stdin
#define stdout stdout
#define stderr stderr
#endif
# 174 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
/* Remove file FILENAME.  */
extern int remove (__const char *__filename) __THROW;
/* Rename file OLD to NEW.  */
extern int rename (__const char *__old, __const char *__new) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_ATFILE
/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
extern int renameat (int __oldfd, __const char *__old, int __newfd,
		     __const char *__new) __THROW;
#endif
# 187 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
/* Create a temporary file and open it read/write.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
#ifndef __USE_FILE_OFFSET64
extern FILE *tmpfile (void) __wur;
#else
# 196 "/usr/include/stdio.h" 3 4
# ifdef __REDIRECT
extern FILE *__REDIRECT (tmpfile, (void), tmpfile64) __wur;
# else
# 199 "/usr/include/stdio.h" 3 4
#  define tmpfile tmpfile64
# endif
# 201 "/usr/include/stdio.h" 3 4
#endif
# 202 "/usr/include/stdio.h" 3 4

#ifdef __USE_LARGEFILE64
extern FILE *tmpfile64 (void) __wur;
#endif
# 206 "/usr/include/stdio.h" 3 4

/* Generate a temporary filename.  */
extern char *tmpnam (char *__s) __THROW __wur;
__END_NAMESPACE_STD

#ifdef __USE_MISC
/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s) __THROW __wur;
#endif
# 216 "/usr/include/stdio.h" 3 4


#if defined __USE_SVID || defined __USE_XOPEN
/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __THROW __attribute_malloc__ __wur;
#endif
# 229 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fclose (FILE *__stream);
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fflush (FILE *__stream);
__END_NAMESPACE_STD

#ifdef __USE_MISC
/* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fflush_unlocked (FILE *__stream);
#endif
# 253 "/usr/include/stdio.h" 3 4

#ifdef __USE_GNU
/* Close all streams.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fcloseall (void);
#endif
# 263 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
#ifndef __USE_FILE_OFFSET64
/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *fopen (__const char *__restrict __filename,
		    __const char *__restrict __modes) __wur;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *freopen (__const char *__restrict __filename,
		      __const char *__restrict __modes,
		      FILE *__restrict __stream) __wur;
#else
# 281 "/usr/include/stdio.h" 3 4
# ifdef __REDIRECT
extern FILE *__REDIRECT (fopen, (__const char *__restrict __filename,
				 __const char *__restrict __modes), fopen64)
  __wur;
extern FILE *__REDIRECT (freopen, (__const char *__restrict __filename,
				   __const char *__restrict __modes,
				   FILE *__restrict __stream), freopen64)
  __wur;
# else
# 290 "/usr/include/stdio.h" 3 4
#  define fopen fopen64
#  define freopen freopen64
# endif
# 293 "/usr/include/stdio.h" 3 4
#endif
# 294 "/usr/include/stdio.h" 3 4
__END_NAMESPACE_STD
#ifdef __USE_LARGEFILE64
extern FILE *fopen64 (__const char *__restrict __filename,
		      __const char *__restrict __modes) __wur;
extern FILE *freopen64 (__const char *__restrict __filename,
			__const char *__restrict __modes,
			FILE *__restrict __stream) __wur;
#endif
# 302 "/usr/include/stdio.h" 3 4

#ifdef	__USE_POSIX
/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, __const char *__modes) __THROW __wur;
#endif
# 307 "/usr/include/stdio.h" 3 4

#ifdef	__USE_GNU
/* Create a new stream that refers to the given magic cookie,
   and uses the given functions for input and output.  */
extern FILE *fopencookie (void *__restrict __magic_cookie,
			  __const char *__restrict __modes,
			  _IO_cookie_io_functions_t __io_funcs) __THROW __wur;
#endif
# 315 "/usr/include/stdio.h" 3 4

#ifdef __USE_XOPEN2K8
/* Create a new stream that refers to a memory buffer.  */
extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __THROW __wur;

/* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  */
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __THROW __wur;
#endif
# 326 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __THROW;
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
		    int __modes, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef	__USE_BSD
/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
		       size_t __size) __THROW;

/* Make STREAM line-buffered.  */
extern void setlinebuf (FILE *__stream) __THROW;
#endif
# 348 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fprintf (FILE *__restrict __stream,
		    __const char *__restrict __format, ...);
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (__const char *__restrict __format, ...);
/* Write formatted output to S.  */
extern int sprintf (char *__restrict __s,
		    __const char *__restrict __format, ...) __THROW;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
		     _G_va_list __arg);
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vprintf (__const char *__restrict __format, _G_va_list __arg);
/* Write formatted output to S from argument list ARG.  */
extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
		     _G_va_list __arg) __THROW;
__END_NAMESPACE_STD

#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
__BEGIN_NAMESPACE_C99
/* Maximum chars of output to write in MAXLEN.  */
extern int snprintf (char *__restrict __s, size_t __maxlen,
		     __const char *__restrict __format, ...)
     __THROW __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
		      __const char *__restrict __format, _G_va_list __arg)
     __THROW __attribute__ ((__format__ (__printf__, 3, 0)));
__END_NAMESPACE_C99
#endif
# 394 "/usr/include/stdio.h" 3 4

#ifdef __USE_GNU
/* Write formatted output to a string dynamically allocated with `malloc'.
   Store the address of the string in *PTR.  */
extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
		      _G_va_list __arg)
     __THROW __attribute__ ((__format__ (__printf__, 2, 0))) __wur;
extern int __asprintf (char **__restrict __ptr,
		       __const char *__restrict __fmt, ...)
     __THROW __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
extern int asprintf (char **__restrict __ptr,
		     __const char *__restrict __fmt, ...)
     __THROW __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
#endif
# 408 "/usr/include/stdio.h" 3 4

#ifdef __USE_XOPEN2K8
/* Write formatted output to a file descriptor.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int vdprintf (int __fd, __const char *__restrict __fmt,
		     _G_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
#endif
# 422 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fscanf (FILE *__restrict __stream,
		   __const char *__restrict __format, ...) __wur;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int scanf (__const char *__restrict __format, ...) __wur;
/* Read formatted input from S.  */
extern int sscanf (__const char *__restrict __s,
		   __const char *__restrict __format, ...) __THROW;

#if defined __USE_ISOC99 && !defined __USE_GNU \
    && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
    && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
# ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fscanf, (FILE *__restrict __stream,
				__const char *__restrict __format, ...),
		       __isoc99_fscanf) __wur;
extern int __REDIRECT (scanf, (__const char *__restrict __format, ...),
		       __isoc99_scanf) __wur;
extern int __REDIRECT (sscanf, (__const char *__restrict __s,
				__const char *__restrict __format, ...),
		       __isoc99_sscanf) __THROW;
# else
# 456 "/usr/include/stdio.h" 3 4
extern int __isoc99_fscanf (FILE *__restrict __stream,
			    __const char *__restrict __format, ...) __wur;
extern int __isoc99_scanf (__const char *__restrict __format, ...) __wur;
extern int __isoc99_sscanf (__const char *__restrict __s,
			    __const char *__restrict __format, ...) __THROW;
#  define fscanf __isoc99_fscanf
#  define scanf __isoc99_scanf
#  define sscanf __isoc99_sscanf
# endif
# 465 "/usr/include/stdio.h" 3 4
#endif
# 466 "/usr/include/stdio.h" 3 4

__END_NAMESPACE_STD

#ifdef	__USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
		    _G_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;

/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vscanf (__const char *__restrict __format, _G_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;

/* Read formatted input from S into argument list ARG.  */
extern int vsscanf (__const char *__restrict __s,
		    __const char *__restrict __format, _G_va_list __arg)
     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));

# if !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (vfscanf,
		       (FILE *__restrict __s,
			__const char *__restrict __format, _G_va_list __arg),
		       __isoc99_vfscanf)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;
extern int __REDIRECT (vscanf, (__const char *__restrict __format,
				_G_va_list __arg), __isoc99_vscanf)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;
extern int __REDIRECT (vsscanf,
		       (__const char *__restrict __s,
			__const char *__restrict __format, _G_va_list __arg),
		       __isoc99_vsscanf)
     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));
#  else
# 512 "/usr/include/stdio.h" 3 4
extern int __isoc99_vfscanf (FILE *__restrict __s,
			     __const char *__restrict __format,
			     _G_va_list __arg) __wur;
extern int __isoc99_vscanf (__const char *__restrict __format,
			    _G_va_list __arg) __wur;
extern int __isoc99_vsscanf (__const char *__restrict __s,
			     __const char *__restrict __format,
			     _G_va_list __arg) __THROW;
#   define vfscanf __isoc99_vfscanf
#   define vscanf __isoc99_vscanf
#   define vsscanf __isoc99_vsscanf
#  endif
# 524 "/usr/include/stdio.h" 3 4
# endif
# 525 "/usr/include/stdio.h" 3 4

__END_NAMESPACE_C99
#endif /* Use ISO C9x.  */
# 528 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);
__END_NAMESPACE_STD

/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */
#define getc(_fp) _IO_getc (_fp)

#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
#endif /* Use POSIX or MISC.  */
# 557 "/usr/include/stdio.h" 3 4

#ifdef __USE_MISC
/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetc_unlocked (FILE *__stream);
#endif /* Use MISC.  */
# 567 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int putchar (int __c);
__END_NAMESPACE_STD

/* The C standard explicitly says this can be a macro,
   so we always do the optimization for it.  */
#define putc(_ch, _fp) _IO_putc (_ch, _fp)

#ifdef __USE_MISC
/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputc_unlocked (int __c, FILE *__stream);
#endif /* Use MISC.  */
# 600 "/usr/include/stdio.h" 3 4

#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
#endif /* Use POSIX or MISC.  */
# 609 "/usr/include/stdio.h" 3 4


#if defined __USE_SVID || defined __USE_MISC \
    || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
/* Get a word (int) from STREAM.  */
extern int getw (FILE *__stream);

/* Write a word (int) to STREAM.  */
extern int putw (int __w, FILE *__stream);
#endif
# 619 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __wur;

/* Get a newline-terminated string from stdin, removing the newline.
   DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *gets (char *__s) __wur;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function does the same as `fgets' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern char *fgets_unlocked (char *__restrict __s, int __n,
			     FILE *__restrict __stream) __wur;
#endif
# 647 "/usr/include/stdio.h" 3 4


#ifdef	__USE_XOPEN2K8
/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern _IO_ssize_t __getdelim (char **__restrict __lineptr,
			       size_t *__restrict __n, int __delimiter,
			       FILE *__restrict __stream) __wur;
extern _IO_ssize_t getdelim (char **__restrict __lineptr,
			     size_t *__restrict __n, int __delimiter,
			     FILE *__restrict __stream) __wur;

/* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern _IO_ssize_t getline (char **__restrict __lineptr,
			    size_t *__restrict __n,
			    FILE *__restrict __stream) __wur;
#endif
# 677 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Write a string to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int puts (__const char *__s);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int ungetc (int __c, FILE *__stream);


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern size_t fread (void *__restrict __ptr, size_t __size,
		     size_t __n, FILE *__restrict __stream) __wur;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
		      size_t __n, FILE *__restrict __s) __wur;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function does the same as `fputs' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputs_unlocked (__const char *__restrict __s,
			   FILE *__restrict __stream);
#endif
# 724 "/usr/include/stdio.h" 3 4

#ifdef __USE_MISC
/* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
			      size_t __n, FILE *__restrict __stream) __wur;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
			       size_t __n, FILE *__restrict __stream) __wur;
#endif
# 737 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseek (FILE *__stream, long int __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern long int ftell (FILE *__stream) __wur;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void rewind (FILE *__stream);
__END_NAMESPACE_STD

/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */

#if defined __USE_LARGEFILE || defined __USE_XOPEN2K
# ifndef __USE_FILE_OFFSET64
/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern __off_t ftello (FILE *__stream) __wur;
# else
# 775 "/usr/include/stdio.h" 3 4
#  ifdef __REDIRECT
extern int __REDIRECT (fseeko,
		       (FILE *__stream, __off64_t __off, int __whence),
		       fseeko64);
extern __off64_t __REDIRECT (ftello, (FILE *__stream), ftello64);
#  else
# 781 "/usr/include/stdio.h" 3 4
#   define fseeko fseeko64
#   define ftello ftello64
#  endif
# 784 "/usr/include/stdio.h" 3 4
# endif
# 785 "/usr/include/stdio.h" 3 4
#endif
# 786 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
#ifndef __USE_FILE_OFFSET64
/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
#else
# 800 "/usr/include/stdio.h" 3 4
# ifdef __REDIRECT
extern int __REDIRECT (fgetpos, (FILE *__restrict __stream,
				 fpos_t *__restrict __pos), fgetpos64);
extern int __REDIRECT (fsetpos,
		       (FILE *__stream, __const fpos_t *__pos), fsetpos64);
# else
# 806 "/usr/include/stdio.h" 3 4
#  define fgetpos fgetpos64
#  define fsetpos fsetpos64
# endif
# 809 "/usr/include/stdio.h" 3 4
#endif
# 810 "/usr/include/stdio.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_LARGEFILE64
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __wur;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);
#endif
# 818 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE *__stream) __THROW;
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE *__stream) __THROW __wur;
/* Return the error indicator for STREAM.  */
extern int ferror (FILE *__stream) __THROW __wur;
__END_NAMESPACE_STD

#ifdef __USE_MISC
/* Faster versions when locking is not required.  */
extern void clearerr_unlocked (FILE *__stream) __THROW;
extern int feof_unlocked (FILE *__stream) __THROW __wur;
extern int ferror_unlocked (FILE *__stream) __THROW __wur;
#endif
# 834 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void perror (__const char *__s);
__END_NAMESPACE_STD

/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/sys_errlist.h>
#endif /* expanded by -frewrite-includes */
# 848 "/usr/include/stdio.h" 3 4
# 849 "/usr/include/stdio.h" 3 4


#ifdef	__USE_POSIX
/* Return the system file descriptor for STREAM.  */
extern int fileno (FILE *__stream) __THROW __wur;
#endif /* Use POSIX.  */
# 855 "/usr/include/stdio.h" 3 4

#ifdef __USE_MISC
/* Faster version when locking is not required.  */
extern int fileno_unlocked (FILE *__stream) __THROW __wur;
#endif
# 860 "/usr/include/stdio.h" 3 4


#if (defined __USE_POSIX2 || defined __USE_SVID  || defined __USE_BSD || \
     defined __USE_MISC)
/* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *popen (__const char *__command, __const char *__modes) __wur;

/* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int pclose (FILE *__stream);
#endif
# 876 "/usr/include/stdio.h" 3 4


#ifdef	__USE_POSIX
/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) __THROW;
#endif /* Use POSIX.  */
# 882 "/usr/include/stdio.h" 3 4


#ifdef __USE_XOPEN
/* Return the name of the current user.  */
extern char *cuserid (char *__s);
#endif /* Use X/Open, but not issue 6.  */
# 888 "/usr/include/stdio.h" 3 4


#ifdef	__USE_GNU
struct obstack;			/* See <obstack.h>.  */

/* Write formatted output to an obstack.  */
extern int obstack_printf (struct obstack *__restrict __obstack,
			   __const char *__restrict __format, ...)
     __THROW __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
			    __const char *__restrict __format,
			    _G_va_list __args)
     __THROW __attribute__ ((__format__ (__printf__, 2, 0)));
#endif /* Use GNU.  */
# 902 "/usr/include/stdio.h" 3 4


#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.  */

/* Acquire ownership of STREAM.  */
extern void flockfile (FILE *__stream) __THROW;

/* Try to acquire ownership of STREAM but do not block if it is not
   possible.  */
extern int ftrylockfile (FILE *__stream) __THROW __wur;

/* Relinquish the ownership granted for STREAM.  */
extern void funlockfile (FILE *__stream) __THROW;
#endif /* POSIX || misc */
# 917 "/usr/include/stdio.h" 3 4

#if defined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU
/* The X/Open standard requires some functions and variables to be
   declared here which do not belong into this header.  But we have to
   follow.  In GNU mode we don't do this nonsense.  */
# define __need_getopt
#if 0 /* expanded by -frewrite-includes */
# include <getopt.h>
#endif /* expanded by -frewrite-includes */
# 923 "/usr/include/stdio.h" 3 4
# 924 "/usr/include/stdio.h" 3 4
#endif	/* X/Open, but not issue 6 and not for GNU.  */
# 925 "/usr/include/stdio.h" 3 4

/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
#ifdef __USE_EXTERN_INLINES
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio.h>
#endif /* expanded by -frewrite-includes */
# 929 "/usr/include/stdio.h" 3 4
# 930 "/usr/include/stdio.h" 3 4
#endif
# 931 "/usr/include/stdio.h" 3 4
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio2.h>
#endif /* expanded by -frewrite-includes */
# 932 "/usr/include/stdio.h" 3 4
# 933 "/usr/include/stdio.h" 3 4
#endif
# 934 "/usr/include/stdio.h" 3 4
#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 935 "/usr/include/stdio.h" 3 4
# 936 "/usr/include/stdio.h" 3 4
#endif
# 937 "/usr/include/stdio.h" 3 4

__END_DECLS

#endif /* <stdio.h> included.  */
# 941 "/usr/include/stdio.h" 3 4

#endif /* !_STDIO_H */
# 943 "/usr/include/stdio.h" 3 4
# 38 "/usr/include/wchar.h" 2 3 4
/* Get va_list definition.  */
# define __need___va_list
#if 0 /* expanded by -frewrite-includes */
# include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/wchar.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stdarg.h" 1 3 4
/*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDARG_H
#define __STDARG_H

#ifndef _VA_LIST
typedef __builtin_va_list va_list;
#define _VA_LIST
#endif
# 33 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stdarg.h" 3 4
#define va_start(ap, param) __builtin_va_start(ap, param)
#define va_end(ap)          __builtin_va_end(ap)
#define va_arg(ap, type)    __builtin_va_arg(ap, type)

/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 */
#define __va_copy(d,s) __builtin_va_copy(d,s)

#if __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
#define va_copy(dest, src)  __builtin_va_copy(dest, src)
#endif
# 45 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stdarg.h" 3 4

/* Hack required to make standard headers work, at least on Ubuntu */
#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST 1
#endif
# 50 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;

#endif /* __STDARG_H */
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stdarg.h" 3 4
# 41 "/usr/include/wchar.h" 2 3 4

#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
/* wchar_t type related definitions.
   Copyright (C) 2000 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _BITS_WCHAR_H
#define _BITS_WCHAR_H	1

#define __WCHAR_MIN	(-2147483647 - 1)
#define __WCHAR_MAX	(2147483647)

#endif	/* bits/wchar.h */
# 27 "/usr/include/bits/wchar.h" 3 4
# 43 "/usr/include/wchar.h" 2 3 4

/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
# define __need_size_t
# define __need_wchar_t
# define __need_NULL
#endif
# 49 "/usr/include/wchar.h" 3 4
#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__
# undef __need_wint_t
# define __need_wint_t
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 52 "/usr/include/wchar.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 53 "/usr/include/wchar.h" 2 3 4

/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
   there.  So define it ourselves if it remains undefined.  */
# ifndef _WINT_T
/* Integral type unchanged by default argument promotions that can
   hold any value corresponding to members of the extended character
   set, as well as at least one value that does not correspond to any
   member of the extended character set.  */
#  define _WINT_T
typedef unsigned int wint_t;
# else
# 64 "/usr/include/wchar.h" 3 4
/* Work around problems with the <stddef.h> file which doesn't put
   wint_t in the std namespace.  */
#  if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES \
      && defined __WINT_TYPE__
__BEGIN_NAMESPACE_STD
typedef __WINT_TYPE__ wint_t;
__END_NAMESPACE_STD
#  endif
# 72 "/usr/include/wchar.h" 3 4
# endif
# 73 "/usr/include/wchar.h" 3 4

/* Tell the caller that we provide correct C++ prototypes.  */
# if defined __cplusplus && __GNUC_PREREQ (4, 4)
#  define __CORRECT_ISO_CPP_WCHAR_H_PROTO
# endif
# 78 "/usr/include/wchar.h" 3 4
#endif
# 79 "/usr/include/wchar.h" 3 4

#if (defined _WCHAR_H || defined __need_mbstate_t) && !defined __mbstate_t_defined
# define __mbstate_t_defined	1
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
# ifdef __WINT_TYPE__
    __WINT_TYPE__ __wch;
# else
# 91 "/usr/include/wchar.h" 3 4
    wint_t __wch;
# endif
# 93 "/usr/include/wchar.h" 3 4
    char __wchb[4];
  } __value;		/* Value so far.  */
} __mbstate_t;
#endif
# 97 "/usr/include/wchar.h" 3 4
#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
#ifdef _WCHAR_H

__BEGIN_NAMESPACE_C99
/* Public type.  */
typedef __mbstate_t mbstate_t;
__END_NAMESPACE_C99
#ifdef __USE_GNU
__USING_NAMESPACE_C99(mbstate_t)
#endif
# 111 "/usr/include/wchar.h" 3 4

#ifndef WCHAR_MIN
/* These constants might also be defined in <inttypes.h>.  */
# define WCHAR_MIN __WCHAR_MIN
# define WCHAR_MAX __WCHAR_MAX
#endif
# 117 "/usr/include/wchar.h" 3 4

#ifndef WEOF
# define WEOF (0xffffffffu)
#endif
# 121 "/usr/include/wchar.h" 3 4

/* For XPG4 compliance we have to define the stuff from <wctype.h> here
   as well.  */
#if defined __USE_XOPEN && !defined __USE_UNIX98
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 125 "/usr/include/wchar.h" 3 4
# 126 "/usr/include/wchar.h" 3 4
#endif
# 127 "/usr/include/wchar.h" 3 4


__BEGIN_DECLS

__BEGIN_NAMESPACE_STD
/* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  */
struct tm;
__END_NAMESPACE_STD
/* XXX We have to clean this up at some point.  Since tm is in the std
   namespace but wcsftime is in __c99 the type wouldn't be found
   without inserting it in the global namespace.  */
__USING_NAMESPACE_STD(tm)


__BEGIN_NAMESPACE_STD
/* Copy SRC to DEST.  */
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Copy no more than N wide-characters of SRC to DEST.  */
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Append SRC onto DEST.  */
extern wchar_t *wcscat (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Append no more than N wide-characters of SRC onto DEST.  */
extern wchar_t *wcsncat (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Compare S1 and S2.  */
extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     __THROW __attribute_pure__;
/* Compare N wide-characters of S1 and S2.  */
extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Compare S1 and S2, ignoring case.  */
extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
			size_t __n) __THROW;

/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 177 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _XLOCALE_H
#define _XLOCALE_H	1

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  The file and
   this data structure is not standardized.  Don't rely on it.  It can
   go away without warning.  */
typedef struct __locale_struct
{
  /* Note: LC_ALL is not a valid index into this array.  */
  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */

  /* To increase the speed of this solution we add some special members.  */
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  /* Note: LC_ALL is not a valid index into this array.  */
  const char *__names[13];
} *__locale_t;

/* POSIX 2008 makes locale_t official.  */
typedef __locale_t locale_t;

#endif /* xlocale.h */
# 46 "/usr/include/xlocale.h" 3 4
# 178 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			 __locale_t __loc) __THROW;

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			  size_t __n, __locale_t __loc) __THROW;
#endif
# 185 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  */
extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;
/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm (wchar_t *__restrict __s1,
		       __const wchar_t *__restrict __s2, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */

/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  */
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
		      __locale_t __loc) __THROW;

/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
			 size_t __n, __locale_t __loc) __THROW;

/* Duplicate S, returning an identical malloc'd string.  */
extern wchar_t *wcsdup (__const wchar_t *__s) __THROW __attribute_malloc__;
#endif
# 215 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Find the first occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
#else
# 224 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 227 "/usr/include/wchar.h" 3 4
/* Find the last occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
#else
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 237 "/usr/include/wchar.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  */
extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 245 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  */
extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     __THROW __attribute_pure__;
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  */
extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
/* Find the first occurrence in WCS of any character in ACCEPT.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
				       __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
#else
# 263 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
#endif
# 266 "/usr/include/wchar.h" 3 4
/* Find the first occurrence of NEEDLE in HAYSTACK.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
#else
# 274 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
#endif
# 277 "/usr/include/wchar.h" 3 4

/* Divide WCS into tokens separated by characters in DELIM.  */
extern wchar_t *wcstok (wchar_t *__restrict __s,
			__const wchar_t *__restrict __delim,
			wchar_t **__restrict __ptr) __THROW;

/* Return the number of wide characters in S.  */
extern size_t wcslen (__const wchar_t *__s) __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN
/* Another name for `wcsstr' from XPG4.  */
# ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
# else
# 296 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
# endif
# 299 "/usr/include/wchar.h" 3 4
#endif
# 300 "/usr/include/wchar.h" 3 4

#ifdef __USE_XOPEN2K8
/* Return the number of wide characters in S, but at most MAXLEN.  */
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     __THROW __attribute_pure__;
#endif
# 306 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Search N wide characters of S for C.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
				       size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
#else
# 317 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __attribute_pure__;
#endif
# 320 "/usr/include/wchar.h" 3 4

/* Compare N wide characters of S1 and S2.  */
extern int wmemcmp (__const wchar_t *__restrict __s1,
		    __const wchar_t *__restrict __s2, size_t __n)
     __THROW __attribute_pure__;

/* Copy N wide characters of SRC to DEST.  */
extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
			 __const wchar_t *__restrict __s2, size_t __n) __THROW;

/* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW;

/* Set N wide characters of S to C.  */
extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  */
extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
			  __const wchar_t *__restrict __s2, size_t __n)
     __THROW;
#endif
# 346 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Determine whether C constitutes a valid (one-byte) multibyte
   character.  */
extern wint_t btowc (int __c) __THROW;

/* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) __THROW;

/* Determine whether PS points to an object representing the initial
   state.  */
extern int mbsinit (__const mbstate_t *__ps) __THROW __attribute_pure__;

/* Write wide character representation of multibyte character pointed
   to by S to PWC.  */
extern size_t mbrtowc (wchar_t *__restrict __pwc,
		       __const char *__restrict __s, size_t __n,
		       mbstate_t *__p) __THROW;

/* Write multibyte representation of wide character WC to S.  */
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
		       mbstate_t *__restrict __ps) __THROW;

/* Return number of bytes in multibyte character pointed to by S.  */
extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
			mbstate_t *__restrict __ps) __THROW;
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
		      mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_EXTERN_INLINES
/* Define inline function as optimization.  */

/* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  */
extern wint_t __btowc_alias (int __c) __asm ("btowc");
__extern_inline wint_t
__NTH (btowc (int __c))
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
	  ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
__extern_inline int
__NTH (wctob (wint_t __wc))
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
	  ? (int) __wc : __wctob_alias (__wc)); }

__extern_inline size_t
__NTH (mbrlen (__const char *__restrict __s, size_t __n,
	       mbstate_t *__restrict __ps))
{ return (__ps != NULL
	  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL)); }
#endif
# 402 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Write wide character representation of multibyte character string
   SRC to DST.  */
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
			 __const char **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of wide character string
   SRC to DST.  */
extern size_t wcsrtombs (char *__restrict __dst,
			 __const wchar_t **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD


#ifdef	__USE_XOPEN2K8
/* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  */
extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
			  __const char **__restrict __src, size_t __nmc,
			  size_t __len, mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  */
extern size_t wcsnrtombs (char *__restrict __dst,
			  __const wchar_t **__restrict __src,
			  size_t __nwc, size_t __len,
			  mbstate_t *__restrict __ps) __THROW;
#endif	/* use POSIX 2008 */
# 432 "/usr/include/wchar.h" 3 4


/* The following functions are extensions found in X/Open CAE.  */
#ifdef __USE_XOPEN
/* Determine number of column positions required for C.  */
extern int wcwidth (wchar_t __c) __THROW;

/* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  */
extern int wcswidth (__const wchar_t *__s, size_t __n) __THROW;
#endif	/* Use X/Open.  */
# 443 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of the wide string NPTR to `double'
   representation.  */
extern double wcstod (__const wchar_t *__restrict __nptr,
		      wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float wcstof (__const wchar_t *__restrict __nptr,
		     wchar_t **__restrict __endptr) __THROW;
extern long double wcstold (__const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_C99
#endif /* C99 */
# 461 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of wide string NPTR to `long int'
   representation.  */
extern long int wcstol (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, int __base) __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  */
extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
				  wchar_t **__restrict __endptr, int __base)
     __THROW;
__END_NAMESPACE_STD

#if defined __USE_ISOC99 || (defined __GNUC__ && defined __USE_GNU)
__BEGIN_NAMESPACE_C99
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
					wchar_t **__restrict __endptr,
					int __base) __THROW;
__END_NAMESPACE_C99
#endif /* ISO C99 or GCC and GNU.  */
# 493 "/usr/include/wchar.h" 3 4

#if defined __GNUC__ && defined __USE_GNU
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
			     wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
				       wchar_t **__restrict __endptr,
				       int __base) __THROW;
#endif /* GCC and use GNU.  */
# 509 "/usr/include/wchar.h" 3 4

#ifdef __USE_GNU
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 524 "/usr/include/wchar.h" 3 4
# 525 "/usr/include/wchar.h" 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
			  wchar_t **__restrict __endptr, int __base,
			  __locale_t __loc) __THROW;

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
				    wchar_t **__restrict __endptr,
				    int __base, __locale_t __loc) __THROW;

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
				wchar_t **__restrict __endptr,
				int __base, __locale_t __loc) __THROW;

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
					  wchar_t **__restrict __endptr,
					  int __base, __locale_t __loc)
     __THROW;

extern double wcstod_l (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern float wcstof_l (__const wchar_t *__restrict __nptr,
		       wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr,
			      __locale_t __loc) __THROW;


/* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  */
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;
#endif	/* use GNU */
# 571 "/usr/include/wchar.h" 3 4


/* Wide character I/O functions.  */

#ifdef	__USE_XOPEN2K8
/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  */
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __THROW;
#endif
# 580 "/usr/include/wchar.h" 3 4

#if defined __USE_ISOC95 || defined __USE_UNIX98
__BEGIN_NAMESPACE_STD

/* Select orientation for stream.  */
extern int fwide (__FILE *__fp, int __mode) __THROW;


/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwprintf (__FILE *__restrict __stream,
		     __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wprintf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
/* Write formatted output of at most N characters to S.  */
extern int swprintf (wchar_t *__restrict __s, size_t __n,
		     __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwprintf (__FILE *__restrict __s,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwprintf (__const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
/* Write formatted output of at most N character to S from argument
   list ARG.  */
extern int vswprintf (wchar_t *__restrict __s, size_t __n,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;


/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwscanf (__FILE *__restrict __stream,
		    __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wscanf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
/* Read formatted input from S.  */
extern int swscanf (__const wchar_t *__restrict __s,
		    __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;

# if defined __USE_ISOC99 && !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_fwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
extern int __REDIRECT (wscanf, (__const wchar_t *__restrict __format, ...),
		       __isoc99_wscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
extern int __REDIRECT (swscanf, (__const wchar_t *__restrict __s,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_swscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
#  else
# 666 "/usr/include/wchar.h" 3 4
extern int __isoc99_fwscanf (__FILE *__restrict __stream,
			     __const wchar_t *__restrict __format, ...);
extern int __isoc99_wscanf (__const wchar_t *__restrict __format, ...);
extern int __isoc99_swscanf (__const wchar_t *__restrict __s,
			     __const wchar_t *__restrict __format, ...)
     __THROW;
#   define fwscanf __isoc99_fwscanf
#   define wscanf __isoc99_wscanf
#   define swscanf __isoc99_swscanf
#  endif
# 676 "/usr/include/wchar.h" 3 4
# endif
# 677 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_STD
#endif /* Use ISO C95, C99 and Unix98. */
# 680 "/usr/include/wchar.h" 3 4

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwscanf (__FILE *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwscanf (__const wchar_t *__restrict __format,
		    __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
/* Read formatted input from S into argument list ARG.  */
extern int vswscanf (__const wchar_t *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;

# if !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
extern int __REDIRECT (vfwscanf, (__FILE *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vfwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
extern int __REDIRECT (vwscanf, (__const wchar_t *__restrict __format,
				 __gnuc_va_list __arg), __isoc99_vwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
extern int __REDIRECT (vswscanf, (__const wchar_t *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vswscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
#  else
# 720 "/usr/include/wchar.h" 3 4
extern int __isoc99_vfwscanf (__FILE *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg);
extern int __isoc99_vwscanf (__const wchar_t *__restrict __format,
			     __gnuc_va_list __arg);
extern int __isoc99_vswscanf (__const wchar_t *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg) __THROW;
#   define vfwscanf __isoc99_vfwscanf
#   define vwscanf __isoc99_vwscanf
#   define vswscanf __isoc99_vswscanf
#  endif
# 732 "/usr/include/wchar.h" 3 4
# endif
# 733 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_C99
#endif /* Use ISO C99. */
# 736 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t getwchar (void);


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t putwchar (wchar_t __wc);


/* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
			__FILE *__restrict __stream);

/* Write a string to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int fputws (__const wchar_t *__restrict __ws,
		   __FILE *__restrict __stream);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
__END_NAMESPACE_STD


#ifdef __USE_GNU
/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);

/* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fgetwc_unlocked (__FILE *__stream);

/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);

/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);


/* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
				 __FILE *__restrict __stream);

/* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputws_unlocked (__const wchar_t *__restrict __ws,
			    __FILE *__restrict __stream);
#endif
# 847 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_C99
/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
			__const wchar_t *__restrict __format,
			__const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_C99

# ifdef __USE_GNU
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 859 "/usr/include/wchar.h" 3 4
# 860 "/usr/include/wchar.h" 3 4

/* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  */
extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
			  __const wchar_t *__restrict __format,
			  __const struct tm *__restrict __tp,
			  __locale_t __loc) __THROW;
# endif
# 868 "/usr/include/wchar.h" 3 4

/* The X/Open standard demands that most of the functions defined in
   the <wctype.h> header must also appear here.  This is probably
   because some X/Open members wrote their implementation before the
   ISO C standard was published and introduced the better solution.
   We have to provide these definitions for compliance reasons but we
   do this nonsense only if really necessary.  */
#if defined __USE_UNIX98 && !defined __USE_GNU
# define __need_iswxxx
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 877 "/usr/include/wchar.h" 3 4
# 878 "/usr/include/wchar.h" 3 4
#endif
# 879 "/usr/include/wchar.h" 3 4

/* Define some macros helping to catch buffer overflows.  */
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar2.h>
#endif /* expanded by -frewrite-includes */
# 882 "/usr/include/wchar.h" 3 4
# 883 "/usr/include/wchar.h" 3 4
#endif
# 884 "/usr/include/wchar.h" 3 4

#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 886 "/usr/include/wchar.h" 3 4
# 887 "/usr/include/wchar.h" 3 4
#endif
# 888 "/usr/include/wchar.h" 3 4

__END_DECLS

#endif	/* _WCHAR_H defined */
# 892 "/usr/include/wchar.h" 3 4

#endif /* wchar.h  */
# 894 "/usr/include/wchar.h" 3 4

/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 2 3
#endif
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#ifndef _GLIBCXX_CWCHAR
#define _GLIBCXX_CWCHAR 1

// Need to do a bit of trickery here with mbstate_t as char_traits
// assumes it is in wchar.h, regardless of wchar_t specializations.
#ifndef _GLIBCXX_HAVE_MBSTATE_T
extern "C"
{
  typedef struct
  {
    int __fill[6];
  } mbstate_t;
}
#endif
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

namespace std
{
  using ::mbstate_t;
} // namespace std

// Get rid of those macros defined in <wchar.h> in lieu of real functions.
#undef btowc
#undef fgetwc
#undef fgetws
#undef fputwc
#undef fputws
#undef fwide
#undef fwprintf
#undef fwscanf
#undef getwc
#undef getwchar
#undef mbrlen
#undef mbrtowc
#undef mbsinit
#undef mbsrtowcs
#undef putwc
#undef putwchar
#undef swprintf
#undef swscanf
#undef ungetwc
#undef vfwprintf
#if _GLIBCXX_HAVE_VFWSCANF
# undef vfwscanf
#endif
# 91 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef vswprintf
#if _GLIBCXX_HAVE_VSWSCANF
# undef vswscanf
#endif
# 95 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef vwprintf
#if _GLIBCXX_HAVE_VWSCANF
# undef vwscanf
#endif
# 99 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef wcrtomb
#undef wcscat
#undef wcschr
#undef wcscmp
#undef wcscoll
#undef wcscpy
#undef wcscspn
#undef wcsftime
#undef wcslen
#undef wcsncat
#undef wcsncmp
#undef wcsncpy
#undef wcspbrk
#undef wcsrchr
#undef wcsrtombs
#undef wcsspn
#undef wcsstr
#undef wcstod
#if _GLIBCXX_HAVE_WCSTOF
# undef wcstof
#endif
# 120 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef wcstok
#undef wcstol
#undef wcstoul
#undef wcsxfrm
#undef wctob
#undef wmemchr
#undef wmemcmp
#undef wmemcpy
#undef wmemmove
#undef wmemset
#undef wprintf
#undef wscanf

#if _GLIBCXX_USE_WCHAR_T

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
  using ::swprintf;
#endif
# 160 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
#if _GLIBCXX_HAVE_VFWSCANF
  using ::vfwscanf;
#endif
# 166 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
  using ::vswprintf;
#endif
# 169 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VSWSCANF
  using ::vswscanf;
#endif
# 172 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::vwprintf;
#if _GLIBCXX_HAVE_VWSCANF
  using ::vwscanf;
#endif
# 176 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
#if _GLIBCXX_HAVE_WCSTOF
  using ::wcstof;
#endif
# 193 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;

#ifndef __CORRECT_ISO_CPP_WCHAR_H_PROTO
  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
#endif
# 231 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if _GLIBCXX_USE_C99

#undef wcstold
#undef wcstoll
#undef wcstoull

namespace __gnu_cxx
{
#if _GLIBCXX_USE_C99_CHECK || _GLIBCXX_USE_C99_DYNAMIC
  extern "C" long double
    (wcstold)(const wchar_t * __restrict, wchar_t ** __restrict) throw ();
#endif
# 247 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if !_GLIBCXX_USE_C99_DYNAMIC
  using ::wcstold;
#endif
# 250 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_USE_C99_LONG_LONG_CHECK || _GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  extern "C" long long int
    (wcstoll)(const wchar_t * __restrict, wchar_t ** __restrict, int) throw ();
  extern "C" unsigned long long int
    (wcstoull)(const wchar_t * __restrict, wchar_t ** __restrict, int) throw ();
#endif
# 256 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  using ::wcstoll;
  using ::wcstoull;
#endif
# 260 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
} // namespace __gnu_cxx

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
} // namespace

#endif
# 270 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#endif //_GLIBCXX_USE_WCHAR_T
# 272 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if __cplusplus >= 201103L

#ifdef _GLIBCXX_USE_WCHAR_T

namespace std
{
#if _GLIBCXX_HAVE_WCSTOF
  using std::wcstof;
#endif
# 282 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VFWSCANF
  using std::vfwscanf;
#endif
# 285 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VSWSCANF
  using std::vswscanf;
#endif
# 288 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VWSCANF
  using std::vwscanf;
#endif
# 291 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if _GLIBCXX_USE_C99
  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;
#endif
# 297 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
} // namespace

#endif // _GLIBCXX_USE_WCHAR_T
# 300 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#endif // C++11
# 302 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#endif
# 304 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 2 3

// XXX If <stdint.h> is really needed, make sure to define the macros
// before including it, in order not to break <tr1/cstdint> (and <cstdint>
// in C++0x).  Reconsider all this as soon as possible...
#if (defined(_GLIBCXX_HAVE_INT64_T) && !defined(_GLIBCXX_HAVE_INT64_T_LONG) \
     && !defined(_GLIBCXX_HAVE_INT64_T_LONG_LONG))

#ifndef __STDC_LIMIT_MACROS
# define _UNDEF__STDC_LIMIT_MACROS
# define __STDC_LIMIT_MACROS
#endif
# 52 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
#ifndef __STDC_CONSTANT_MACROS
# define _UNDEF__STDC_CONSTANT_MACROS
# define __STDC_CONSTANT_MACROS
#endif
# 56 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <stdint.h> // For int64_t
#endif /* expanded by -frewrite-includes */
# 56 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
# 57 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
#ifdef _UNDEF__STDC_LIMIT_MACROS
# undef __STDC_LIMIT_MACROS
# undef _UNDEF__STDC_LIMIT_MACROS
#endif
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
#ifdef _UNDEF__STDC_CONSTANT_MACROS
# undef __STDC_CONSTANT_MACROS
# undef _UNDEF__STDC_CONSTANT_MACROS
#endif
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3

#endif
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // The types streamoff, streampos and wstreampos and the class
  // template fpos<> are described in clauses 21.1.2, 21.1.3, 27.1.2,
  // 27.2, 27.4.1, 27.4.3 and D.6. Despite all this verbiage, the
  // behaviour of these types is mostly implementation defined or
  // unspecified. The behaviour in this implementation is as noted
  // below.

  /**
   *  @brief  Type used by fpos, char_traits<char>, and char_traits<wchar_t>.
   *
   *  In clauses 21.1.3.1 and 27.4.1 streamoff is described as an
   *  implementation defined type.
   *  Note: In versions of GCC up to and including GCC 3.3, streamoff
   *  was typedef long.
  */  
#ifdef _GLIBCXX_HAVE_INT64_T_LONG
  typedef long          streamoff;
#elif defined(_GLIBCXX_HAVE_INT64_T_LONG_LONG)
# 90 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
  typedef long long     streamoff;
#elif defined(_GLIBCXX_HAVE_INT64_T) 
# 92 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
  typedef int64_t       streamoff;
#else
# 94 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
  typedef long long     streamoff;
#endif
# 96 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3

  /// Integral type for I/O operation counts and buffer sizes.
  typedef ptrdiff_t	streamsize; // Signed integral type

  /**
   *  @brief  Class representing stream positions.
   *
   *  The standard places no requirements upon the template parameter StateT.
   *  In this implementation StateT must be DefaultConstructible,
   *  CopyConstructible and Assignable.  The standard only requires that fpos
   *  should contain a member of type StateT. In this implementation it also
   *  contains an offset stored as a signed integer.
   *
   *  @param  StateT  Type passed to and returned from state().
   */
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff	                _M_off;
      _StateT			_M_state;

    public:
      // The standard doesn't require that fpos objects can be default
      // constructed. This implementation provides a default
      // constructor that initializes the offset to 0 and default
      // constructs the state.
      fpos()
      : _M_off(0), _M_state() { }

      // The standard requires that fpos objects can be constructed
      // from streamoff objects using the constructor syntax, and
      // fails to give any meaningful semantics. In this
      // implementation implicit conversion is also allowed, and this
      // constructor stores the streamoff as the offset and default
      // constructs the state.
      /// Construct position from offset.
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }

      /// Convert to streamoff.
      operator streamoff() const { return _M_off; }

      /// Remember the value of @a st.
      void
      state(_StateT __st)
      { _M_state = __st; }

      /// Return the last set value of @a st.
      _StateT
      state() const
      { return _M_state; }

      // The standard requires that this operator must be defined, but
      // gives no semantics. In this implementation it just adds its
      // argument to the stored offset and returns *this.
      /// Add offset to this position.
      fpos&
      operator+=(streamoff __off)
      {
	_M_off += __off;
	return *this;
      }

      // The standard requires that this operator must be defined, but
      // gives no semantics. In this implementation it just subtracts
      // its argument from the stored offset and returns *this.
      /// Subtract offset from this position.
      fpos&
      operator-=(streamoff __off)
      {
	_M_off -= __off;
	return *this;
      }

      // The standard requires that this operator must be defined, but
      // defines its semantics only in terms of operator-. In this
      // implementation it constructs a copy of *this, adds the
      // argument to that copy using operator+= and then returns the
      // copy.
      /// Add position and offset.
      fpos
      operator+(streamoff __off) const
      {
	fpos __pos(*this);
	__pos += __off;
	return __pos;
      }

      // The standard requires that this operator must be defined, but
      // defines its semantics only in terms of operator+. In this
      // implementation it constructs a copy of *this, subtracts the
      // argument from that copy using operator-= and then returns the
      // copy.
      /// Subtract offset from position.
      fpos
      operator-(streamoff __off) const
      {
	fpos __pos(*this);
	__pos -= __off;
	return __pos;
      }

      // The standard requires that this operator must be defined, but
      // defines its semantics only in terms of operator+. In this
      // implementation it returns the difference between the offset
      // stored in *this and in the argument.
      /// Subtract position to return offset.
      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };

  // The standard only requires that operator== must be an
  // equivalence relation. In this implementation two fpos<StateT>
  // objects belong to the same equivalence class if the contained
  // offsets compare equal.
  /// Test if equivalent to another position.
  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }

  // Clauses 21.1.3.1 and 21.1.3.2 describe streampos and wstreampos
  // as implementation defined types, but clause 27.2 requires that
  // they must both be typedefs for fpos<mbstate_t>
  /// File position for char streams.
  typedef fpos<mbstate_t> streampos;
  /// File position for wchar_t streams.
  typedef fpos<mbstate_t> wstreampos;

#if __cplusplus >= 201103L
  /// File position for char16_t streams.
  typedef fpos<mbstate_t> u16streampos;
  /// File position for char32_t streams.
  typedef fpos<mbstate_t> u32streampos;
#endif
# 238 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 243 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/postypes.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @defgroup io I/O
   *
   *  Nearly all of the I/O classes are parameterized on the type of
   *  characters they read and write.  (The major exception is ios_base at
   *  the top of the hierarchy.)  This is a change from pre-Standard
   *  streams, which were not templates.
   *
   *  For ease of use and compatibility, all of the basic_* I/O-related
   *  classes are given typedef names for both of the builtin character
   *  widths (wide and narrow).  The typedefs are the same as the
   *  pre-Standard names, for example:
   *
   *  @code
   *     typedef basic_ifstream<char>  ifstream;
   *  @endcode
   *
   *  Because properly forward-declaring these classes can be difficult, you
   *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;
   *  header, which contains only declarations of all the I/O classes as
   *  well as the typedefs.  Trying to forward-declare the typedefs
   *  themselves (e.g., <code>class ostream;</code>) is not valid ISO C++.
   *
   *  For more specific declarations, see
   *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/io.html#std.io.objects
   *
   *  @{
  */
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


_GLIBCXX_BEGIN_NAMESPACE_CXX11

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	    typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	   typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	   typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
	   typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

_GLIBCXX_END_NAMESPACE_CXX11

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;


  /// Base class for @c char streams.
  typedef basic_ios<char> 		ios; 

  /// Base class for @c char buffers.
  typedef basic_streambuf<char> 	streambuf;

  /// Base class for @c char input streams.
  typedef basic_istream<char> 		istream;

  /// Base class for @c char output streams.
  typedef basic_ostream<char> 		ostream;

  /// Base class for @c char mixed input and output streams.
  typedef basic_iostream<char> 		iostream;

  /// Class for @c char memory buffers.
  typedef basic_stringbuf<char> 	stringbuf;

  /// Class for @c char input memory streams.
  typedef basic_istringstream<char> 	istringstream;

  /// Class for @c char output memory streams.
  typedef basic_ostringstream<char> 	ostringstream;

  /// Class for @c char mixed input and output memory streams.
  typedef basic_stringstream<char> 	stringstream;

  /// Class for @c char file buffers.
  typedef basic_filebuf<char> 		filebuf;

  /// Class for @c char input file streams.
  typedef basic_ifstream<char> 		ifstream;

  /// Class for @c char output file streams.
  typedef basic_ofstream<char> 		ofstream;

  /// Class for @c char mixed input and output file streams.
  typedef basic_fstream<char> 		fstream;

#ifdef _GLIBCXX_USE_WCHAR_T
  /// Base class for @c wchar_t streams.
  typedef basic_ios<wchar_t> 		wios;

  /// Base class for @c wchar_t buffers.
  typedef basic_streambuf<wchar_t> 	wstreambuf;

  /// Base class for @c wchar_t input streams.
  typedef basic_istream<wchar_t> 	wistream;

  /// Base class for @c wchar_t output streams.
  typedef basic_ostream<wchar_t> 	wostream;

  /// Base class for @c wchar_t mixed input and output streams.
  typedef basic_iostream<wchar_t> 	wiostream;

  /// Class for @c wchar_t memory buffers.
  typedef basic_stringbuf<wchar_t> 	wstringbuf;

  /// Class for @c wchar_t input memory streams.
  typedef basic_istringstream<wchar_t> 	wistringstream;

  /// Class for @c wchar_t output memory streams.
  typedef basic_ostringstream<wchar_t> 	wostringstream;

  /// Class for @c wchar_t mixed input and output memory streams.
  typedef basic_stringstream<wchar_t> 	wstringstream;

  /// Class for @c wchar_t file buffers.
  typedef basic_filebuf<wchar_t> 	wfilebuf;

  /// Class for @c wchar_t input file streams.
  typedef basic_ifstream<wchar_t> 	wifstream;

  /// Class for @c wchar_t output file streams.
  typedef basic_ofstream<wchar_t> 	wofstream;

  /// Class for @c wchar_t mixed input and output file streams.
  typedef basic_fstream<wchar_t> 	wfstream;
#endif
# 210 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 3
  /** @}  */

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _GLIBCXX_IOSFWD */
# 216 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iosfwd" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <exception> 		// For ios_base::failure
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/char_traits.h> 	// For char_traits, streamoff, streamsize, fpos
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 1 3
// Character Traits for use by standard string and iostream -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/char_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21  Strings library
//

#ifndef _CHAR_TRAITS_H
#define _CHAR_TRAITS_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h>  // std::copy, std::fill_n
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/postypes.h>      // For streampos
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <cwchar>               // For WEOF, wmemmove, wmemset, etc.
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cwchar
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wchar.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 21.4
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if _GLIBCXX_HAVE_WCHAR_H
#if 0 /* expanded by -frewrite-includes */
#include <wchar.h>
#endif /* expanded by -frewrite-includes */
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */

#ifndef _WCHAR_H

#if !defined __need_mbstate_t && !defined __need_wint_t
# define _WCHAR_H 1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/wchar.h" 3 4
# 29 "/usr/include/wchar.h" 3 4
#endif
# 30 "/usr/include/wchar.h" 3 4

#ifdef _WCHAR_H
/* Get FILE definition.  */
# define __need___FILE
# if defined __USE_UNIX98 || defined __USE_XOPEN2K
#  define __need_FILE
# endif
# 37 "/usr/include/wchar.h" 3 4
#if 0 /* expanded by -frewrite-includes */
# include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/wchar.h" 3 4
# 38 "/usr/include/wchar.h" 3 4
/* Get va_list definition.  */
# define __need___va_list
#if 0 /* expanded by -frewrite-includes */
# include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/wchar.h" 3 4
# 41 "/usr/include/wchar.h" 3 4

#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/wchar.h" 3 4
# 43 "/usr/include/wchar.h" 3 4

/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
# define __need_size_t
# define __need_wchar_t
# define __need_NULL
#endif
# 49 "/usr/include/wchar.h" 3 4
#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__
# undef __need_wint_t
# define __need_wint_t
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 52 "/usr/include/wchar.h" 3 4
# 53 "/usr/include/wchar.h" 3 4

/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
   there.  So define it ourselves if it remains undefined.  */
# ifndef _WINT_T
/* Integral type unchanged by default argument promotions that can
   hold any value corresponding to members of the extended character
   set, as well as at least one value that does not correspond to any
   member of the extended character set.  */
#  define _WINT_T
typedef unsigned int wint_t;
# else
# 64 "/usr/include/wchar.h" 3 4
/* Work around problems with the <stddef.h> file which doesn't put
   wint_t in the std namespace.  */
#  if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES \
      && defined __WINT_TYPE__
__BEGIN_NAMESPACE_STD
typedef __WINT_TYPE__ wint_t;
__END_NAMESPACE_STD
#  endif
# 72 "/usr/include/wchar.h" 3 4
# endif
# 73 "/usr/include/wchar.h" 3 4

/* Tell the caller that we provide correct C++ prototypes.  */
# if defined __cplusplus && __GNUC_PREREQ (4, 4)
#  define __CORRECT_ISO_CPP_WCHAR_H_PROTO
# endif
# 78 "/usr/include/wchar.h" 3 4
#endif
# 79 "/usr/include/wchar.h" 3 4

#if (defined _WCHAR_H || defined __need_mbstate_t) && !defined __mbstate_t_defined
# define __mbstate_t_defined	1
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
# ifdef __WINT_TYPE__
    __WINT_TYPE__ __wch;
# else
# 91 "/usr/include/wchar.h" 3 4
    wint_t __wch;
# endif
# 93 "/usr/include/wchar.h" 3 4
    char __wchb[4];
  } __value;		/* Value so far.  */
} __mbstate_t;
#endif
# 97 "/usr/include/wchar.h" 3 4
#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
#ifdef _WCHAR_H

__BEGIN_NAMESPACE_C99
/* Public type.  */
typedef __mbstate_t mbstate_t;
__END_NAMESPACE_C99
#ifdef __USE_GNU
__USING_NAMESPACE_C99(mbstate_t)
#endif
# 111 "/usr/include/wchar.h" 3 4

#ifndef WCHAR_MIN
/* These constants might also be defined in <inttypes.h>.  */
# define WCHAR_MIN __WCHAR_MIN
# define WCHAR_MAX __WCHAR_MAX
#endif
# 117 "/usr/include/wchar.h" 3 4

#ifndef WEOF
# define WEOF (0xffffffffu)
#endif
# 121 "/usr/include/wchar.h" 3 4

/* For XPG4 compliance we have to define the stuff from <wctype.h> here
   as well.  */
#if defined __USE_XOPEN && !defined __USE_UNIX98
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 125 "/usr/include/wchar.h" 3 4
# 126 "/usr/include/wchar.h" 3 4
#endif
# 127 "/usr/include/wchar.h" 3 4


__BEGIN_DECLS

__BEGIN_NAMESPACE_STD
/* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  */
struct tm;
__END_NAMESPACE_STD
/* XXX We have to clean this up at some point.  Since tm is in the std
   namespace but wcsftime is in __c99 the type wouldn't be found
   without inserting it in the global namespace.  */
__USING_NAMESPACE_STD(tm)


__BEGIN_NAMESPACE_STD
/* Copy SRC to DEST.  */
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Copy no more than N wide-characters of SRC to DEST.  */
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Append SRC onto DEST.  */
extern wchar_t *wcscat (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Append no more than N wide-characters of SRC onto DEST.  */
extern wchar_t *wcsncat (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Compare S1 and S2.  */
extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     __THROW __attribute_pure__;
/* Compare N wide-characters of S1 and S2.  */
extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Compare S1 and S2, ignoring case.  */
extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
			size_t __n) __THROW;

/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 177 "/usr/include/wchar.h" 3 4
# 178 "/usr/include/wchar.h" 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			 __locale_t __loc) __THROW;

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			  size_t __n, __locale_t __loc) __THROW;
#endif
# 185 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  */
extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;
/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm (wchar_t *__restrict __s1,
		       __const wchar_t *__restrict __s2, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */

/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  */
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
		      __locale_t __loc) __THROW;

/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
			 size_t __n, __locale_t __loc) __THROW;

/* Duplicate S, returning an identical malloc'd string.  */
extern wchar_t *wcsdup (__const wchar_t *__s) __THROW __attribute_malloc__;
#endif
# 215 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Find the first occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
#else
# 224 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 227 "/usr/include/wchar.h" 3 4
/* Find the last occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
#else
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 237 "/usr/include/wchar.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  */
extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 245 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  */
extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     __THROW __attribute_pure__;
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  */
extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
/* Find the first occurrence in WCS of any character in ACCEPT.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
				       __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
#else
# 263 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
#endif
# 266 "/usr/include/wchar.h" 3 4
/* Find the first occurrence of NEEDLE in HAYSTACK.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
#else
# 274 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
#endif
# 277 "/usr/include/wchar.h" 3 4

/* Divide WCS into tokens separated by characters in DELIM.  */
extern wchar_t *wcstok (wchar_t *__restrict __s,
			__const wchar_t *__restrict __delim,
			wchar_t **__restrict __ptr) __THROW;

/* Return the number of wide characters in S.  */
extern size_t wcslen (__const wchar_t *__s) __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN
/* Another name for `wcsstr' from XPG4.  */
# ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
# else
# 296 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
# endif
# 299 "/usr/include/wchar.h" 3 4
#endif
# 300 "/usr/include/wchar.h" 3 4

#ifdef __USE_XOPEN2K8
/* Return the number of wide characters in S, but at most MAXLEN.  */
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     __THROW __attribute_pure__;
#endif
# 306 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Search N wide characters of S for C.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
				       size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
#else
# 317 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __attribute_pure__;
#endif
# 320 "/usr/include/wchar.h" 3 4

/* Compare N wide characters of S1 and S2.  */
extern int wmemcmp (__const wchar_t *__restrict __s1,
		    __const wchar_t *__restrict __s2, size_t __n)
     __THROW __attribute_pure__;

/* Copy N wide characters of SRC to DEST.  */
extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
			 __const wchar_t *__restrict __s2, size_t __n) __THROW;

/* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW;

/* Set N wide characters of S to C.  */
extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  */
extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
			  __const wchar_t *__restrict __s2, size_t __n)
     __THROW;
#endif
# 346 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Determine whether C constitutes a valid (one-byte) multibyte
   character.  */
extern wint_t btowc (int __c) __THROW;

/* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) __THROW;

/* Determine whether PS points to an object representing the initial
   state.  */
extern int mbsinit (__const mbstate_t *__ps) __THROW __attribute_pure__;

/* Write wide character representation of multibyte character pointed
   to by S to PWC.  */
extern size_t mbrtowc (wchar_t *__restrict __pwc,
		       __const char *__restrict __s, size_t __n,
		       mbstate_t *__p) __THROW;

/* Write multibyte representation of wide character WC to S.  */
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
		       mbstate_t *__restrict __ps) __THROW;

/* Return number of bytes in multibyte character pointed to by S.  */
extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
			mbstate_t *__restrict __ps) __THROW;
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
		      mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_EXTERN_INLINES
/* Define inline function as optimization.  */

/* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  */
extern wint_t __btowc_alias (int __c) __asm ("btowc");
__extern_inline wint_t
__NTH (btowc (int __c))
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
	  ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
__extern_inline int
__NTH (wctob (wint_t __wc))
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
	  ? (int) __wc : __wctob_alias (__wc)); }

__extern_inline size_t
__NTH (mbrlen (__const char *__restrict __s, size_t __n,
	       mbstate_t *__restrict __ps))
{ return (__ps != NULL
	  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL)); }
#endif
# 402 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Write wide character representation of multibyte character string
   SRC to DST.  */
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
			 __const char **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of wide character string
   SRC to DST.  */
extern size_t wcsrtombs (char *__restrict __dst,
			 __const wchar_t **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD


#ifdef	__USE_XOPEN2K8
/* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  */
extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
			  __const char **__restrict __src, size_t __nmc,
			  size_t __len, mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  */
extern size_t wcsnrtombs (char *__restrict __dst,
			  __const wchar_t **__restrict __src,
			  size_t __nwc, size_t __len,
			  mbstate_t *__restrict __ps) __THROW;
#endif	/* use POSIX 2008 */
# 432 "/usr/include/wchar.h" 3 4


/* The following functions are extensions found in X/Open CAE.  */
#ifdef __USE_XOPEN
/* Determine number of column positions required for C.  */
extern int wcwidth (wchar_t __c) __THROW;

/* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  */
extern int wcswidth (__const wchar_t *__s, size_t __n) __THROW;
#endif	/* Use X/Open.  */
# 443 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of the wide string NPTR to `double'
   representation.  */
extern double wcstod (__const wchar_t *__restrict __nptr,
		      wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float wcstof (__const wchar_t *__restrict __nptr,
		     wchar_t **__restrict __endptr) __THROW;
extern long double wcstold (__const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_C99
#endif /* C99 */
# 461 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of wide string NPTR to `long int'
   representation.  */
extern long int wcstol (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, int __base) __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  */
extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
				  wchar_t **__restrict __endptr, int __base)
     __THROW;
__END_NAMESPACE_STD

#if defined __USE_ISOC99 || (defined __GNUC__ && defined __USE_GNU)
__BEGIN_NAMESPACE_C99
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
					wchar_t **__restrict __endptr,
					int __base) __THROW;
__END_NAMESPACE_C99
#endif /* ISO C99 or GCC and GNU.  */
# 493 "/usr/include/wchar.h" 3 4

#if defined __GNUC__ && defined __USE_GNU
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
			     wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
				       wchar_t **__restrict __endptr,
				       int __base) __THROW;
#endif /* GCC and use GNU.  */
# 509 "/usr/include/wchar.h" 3 4

#ifdef __USE_GNU
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 524 "/usr/include/wchar.h" 3 4
# 525 "/usr/include/wchar.h" 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
			  wchar_t **__restrict __endptr, int __base,
			  __locale_t __loc) __THROW;

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
				    wchar_t **__restrict __endptr,
				    int __base, __locale_t __loc) __THROW;

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
				wchar_t **__restrict __endptr,
				int __base, __locale_t __loc) __THROW;

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
					  wchar_t **__restrict __endptr,
					  int __base, __locale_t __loc)
     __THROW;

extern double wcstod_l (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern float wcstof_l (__const wchar_t *__restrict __nptr,
		       wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr,
			      __locale_t __loc) __THROW;


/* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  */
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;
#endif	/* use GNU */
# 571 "/usr/include/wchar.h" 3 4


/* Wide character I/O functions.  */

#ifdef	__USE_XOPEN2K8
/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  */
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __THROW;
#endif
# 580 "/usr/include/wchar.h" 3 4

#if defined __USE_ISOC95 || defined __USE_UNIX98
__BEGIN_NAMESPACE_STD

/* Select orientation for stream.  */
extern int fwide (__FILE *__fp, int __mode) __THROW;


/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwprintf (__FILE *__restrict __stream,
		     __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wprintf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
/* Write formatted output of at most N characters to S.  */
extern int swprintf (wchar_t *__restrict __s, size_t __n,
		     __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwprintf (__FILE *__restrict __s,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwprintf (__const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
/* Write formatted output of at most N character to S from argument
   list ARG.  */
extern int vswprintf (wchar_t *__restrict __s, size_t __n,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;


/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwscanf (__FILE *__restrict __stream,
		    __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wscanf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
/* Read formatted input from S.  */
extern int swscanf (__const wchar_t *__restrict __s,
		    __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;

# if defined __USE_ISOC99 && !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_fwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
extern int __REDIRECT (wscanf, (__const wchar_t *__restrict __format, ...),
		       __isoc99_wscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
extern int __REDIRECT (swscanf, (__const wchar_t *__restrict __s,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_swscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
#  else
# 666 "/usr/include/wchar.h" 3 4
extern int __isoc99_fwscanf (__FILE *__restrict __stream,
			     __const wchar_t *__restrict __format, ...);
extern int __isoc99_wscanf (__const wchar_t *__restrict __format, ...);
extern int __isoc99_swscanf (__const wchar_t *__restrict __s,
			     __const wchar_t *__restrict __format, ...)
     __THROW;
#   define fwscanf __isoc99_fwscanf
#   define wscanf __isoc99_wscanf
#   define swscanf __isoc99_swscanf
#  endif
# 676 "/usr/include/wchar.h" 3 4
# endif
# 677 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_STD
#endif /* Use ISO C95, C99 and Unix98. */
# 680 "/usr/include/wchar.h" 3 4

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwscanf (__FILE *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwscanf (__const wchar_t *__restrict __format,
		    __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
/* Read formatted input from S into argument list ARG.  */
extern int vswscanf (__const wchar_t *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;

# if !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
extern int __REDIRECT (vfwscanf, (__FILE *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vfwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
extern int __REDIRECT (vwscanf, (__const wchar_t *__restrict __format,
				 __gnuc_va_list __arg), __isoc99_vwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
extern int __REDIRECT (vswscanf, (__const wchar_t *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vswscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
#  else
# 720 "/usr/include/wchar.h" 3 4
extern int __isoc99_vfwscanf (__FILE *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg);
extern int __isoc99_vwscanf (__const wchar_t *__restrict __format,
			     __gnuc_va_list __arg);
extern int __isoc99_vswscanf (__const wchar_t *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg) __THROW;
#   define vfwscanf __isoc99_vfwscanf
#   define vwscanf __isoc99_vwscanf
#   define vswscanf __isoc99_vswscanf
#  endif
# 732 "/usr/include/wchar.h" 3 4
# endif
# 733 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_C99
#endif /* Use ISO C99. */
# 736 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t getwchar (void);


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t putwchar (wchar_t __wc);


/* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
			__FILE *__restrict __stream);

/* Write a string to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int fputws (__const wchar_t *__restrict __ws,
		   __FILE *__restrict __stream);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
__END_NAMESPACE_STD


#ifdef __USE_GNU
/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);

/* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fgetwc_unlocked (__FILE *__stream);

/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);

/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);


/* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
				 __FILE *__restrict __stream);

/* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputws_unlocked (__const wchar_t *__restrict __ws,
			    __FILE *__restrict __stream);
#endif
# 847 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_C99
/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
			__const wchar_t *__restrict __format,
			__const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_C99

# ifdef __USE_GNU
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 859 "/usr/include/wchar.h" 3 4
# 860 "/usr/include/wchar.h" 3 4

/* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  */
extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
			  __const wchar_t *__restrict __format,
			  __const struct tm *__restrict __tp,
			  __locale_t __loc) __THROW;
# endif
# 868 "/usr/include/wchar.h" 3 4

/* The X/Open standard demands that most of the functions defined in
   the <wctype.h> header must also appear here.  This is probably
   because some X/Open members wrote their implementation before the
   ISO C standard was published and introduced the better solution.
   We have to provide these definitions for compliance reasons but we
   do this nonsense only if really necessary.  */
#if defined __USE_UNIX98 && !defined __USE_GNU
# define __need_iswxxx
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 877 "/usr/include/wchar.h" 3 4
# 878 "/usr/include/wchar.h" 3 4
#endif
# 879 "/usr/include/wchar.h" 3 4

/* Define some macros helping to catch buffer overflows.  */
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar2.h>
#endif /* expanded by -frewrite-includes */
# 882 "/usr/include/wchar.h" 3 4
# 883 "/usr/include/wchar.h" 3 4
#endif
# 884 "/usr/include/wchar.h" 3 4

#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 886 "/usr/include/wchar.h" 3 4
# 887 "/usr/include/wchar.h" 3 4
#endif
# 888 "/usr/include/wchar.h" 3 4

__END_DECLS

#endif	/* _WCHAR_H defined */
# 892 "/usr/include/wchar.h" 3 4

#endif /* wchar.h  */
# 894 "/usr/include/wchar.h" 3 4

/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 2 3
#endif
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#ifndef _GLIBCXX_CWCHAR
#define _GLIBCXX_CWCHAR 1

// Need to do a bit of trickery here with mbstate_t as char_traits
// assumes it is in wchar.h, regardless of wchar_t specializations.
#ifndef _GLIBCXX_HAVE_MBSTATE_T
extern "C"
{
  typedef struct
  {
    int __fill[6];
  } mbstate_t;
}
#endif
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

namespace std
{
  using ::mbstate_t;
} // namespace std

// Get rid of those macros defined in <wchar.h> in lieu of real functions.
#undef btowc
#undef fgetwc
#undef fgetws
#undef fputwc
#undef fputws
#undef fwide
#undef fwprintf
#undef fwscanf
#undef getwc
#undef getwchar
#undef mbrlen
#undef mbrtowc
#undef mbsinit
#undef mbsrtowcs
#undef putwc
#undef putwchar
#undef swprintf
#undef swscanf
#undef ungetwc
#undef vfwprintf
#if _GLIBCXX_HAVE_VFWSCANF
# undef vfwscanf
#endif
# 91 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef vswprintf
#if _GLIBCXX_HAVE_VSWSCANF
# undef vswscanf
#endif
# 95 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef vwprintf
#if _GLIBCXX_HAVE_VWSCANF
# undef vwscanf
#endif
# 99 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef wcrtomb
#undef wcscat
#undef wcschr
#undef wcscmp
#undef wcscoll
#undef wcscpy
#undef wcscspn
#undef wcsftime
#undef wcslen
#undef wcsncat
#undef wcsncmp
#undef wcsncpy
#undef wcspbrk
#undef wcsrchr
#undef wcsrtombs
#undef wcsspn
#undef wcsstr
#undef wcstod
#if _GLIBCXX_HAVE_WCSTOF
# undef wcstof
#endif
# 120 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#undef wcstok
#undef wcstol
#undef wcstoul
#undef wcsxfrm
#undef wctob
#undef wmemchr
#undef wmemcmp
#undef wmemcpy
#undef wmemmove
#undef wmemset
#undef wprintf
#undef wscanf

#if _GLIBCXX_USE_WCHAR_T

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
  using ::swprintf;
#endif
# 160 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
#if _GLIBCXX_HAVE_VFWSCANF
  using ::vfwscanf;
#endif
# 166 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
  using ::vswprintf;
#endif
# 169 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VSWSCANF
  using ::vswscanf;
#endif
# 172 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::vwprintf;
#if _GLIBCXX_HAVE_VWSCANF
  using ::vwscanf;
#endif
# 176 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
#if _GLIBCXX_HAVE_WCSTOF
  using ::wcstof;
#endif
# 193 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;

#ifndef __CORRECT_ISO_CPP_WCHAR_H_PROTO
  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
#endif
# 231 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if _GLIBCXX_USE_C99

#undef wcstold
#undef wcstoll
#undef wcstoull

namespace __gnu_cxx
{
#if _GLIBCXX_USE_C99_CHECK || _GLIBCXX_USE_C99_DYNAMIC
  extern "C" long double
    (wcstold)(const wchar_t * __restrict, wchar_t ** __restrict) throw ();
#endif
# 247 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if !_GLIBCXX_USE_C99_DYNAMIC
  using ::wcstold;
#endif
# 250 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_USE_C99_LONG_LONG_CHECK || _GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  extern "C" long long int
    (wcstoll)(const wchar_t * __restrict, wchar_t ** __restrict, int) throw ();
  extern "C" unsigned long long int
    (wcstoull)(const wchar_t * __restrict, wchar_t ** __restrict, int) throw ();
#endif
# 256 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  using ::wcstoll;
  using ::wcstoull;
#endif
# 260 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
} // namespace __gnu_cxx

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
} // namespace

#endif
# 270 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#endif //_GLIBCXX_USE_WCHAR_T
# 272 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if __cplusplus >= 201103L

#ifdef _GLIBCXX_USE_WCHAR_T

namespace std
{
#if _GLIBCXX_HAVE_WCSTOF
  using std::wcstof;
#endif
# 282 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VFWSCANF
  using std::vfwscanf;
#endif
# 285 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VSWSCANF
  using std::vswscanf;
#endif
# 288 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
#if _GLIBCXX_HAVE_VWSCANF
  using std::vwscanf;
#endif
# 291 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#if _GLIBCXX_USE_C99
  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;
#endif
# 297 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
} // namespace

#endif // _GLIBCXX_USE_WCHAR_T
# 300 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#endif // C++11
# 302 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3

#endif
# 304 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwchar" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 2 3

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief  Mapping from character type to associated types.
   *
   *  @note This is an implementation class for the generic version
   *  of char_traits.  It defines int_type, off_type, pos_type, and
   *  state_type.  By default these are unsigned long, streamoff,
   *  streampos, and mbstate_t.  Users who need a different set of
   *  types, but who don't need to change the definitions of any function
   *  defined in char_traits, can specialize __gnu_cxx::_Char_types
   *  while leaving __gnu_cxx::char_traits alone. */
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long   int_type;
      typedef std::streampos  pos_type;
      typedef std::streamoff  off_type;
      typedef std::mbstate_t  state_type;
    };


  /**
   *  @brief  Base class used to implement std::char_traits.
   *
   *  @note For any given actual character type, this definition is
   *  probably wrong.  (Most of the member functions are likely to be
   *  right, but the int_type and state_type typedefs, and the eof()
   *  member function, are likely to be wrong.)  The reason this class
   *  exists is so users can specialize it.  Classes in namespace std
   *  may not be specialized for fundamental types, but classes in
   *  namespace __gnu_cxx may be.
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.  
   */
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT                                    char_type;
      typedef typename _Char_types<_CharT>::int_type    int_type;
      typedef typename _Char_types<_CharT>::pos_type    pos_type;
      typedef typename _Char_types<_CharT>::off_type    off_type;
      typedef typename _Char_types<_CharT>::state_type  state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static _GLIBCXX_CONSTEXPR bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static _GLIBCXX_CONSTEXPR char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static _GLIBCXX_CONSTEXPR int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static _GLIBCXX_CONSTEXPR bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR int_type
      eof()
      { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }

      static _GLIBCXX_CONSTEXPR int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
	if (lt(__s1[__i], __s2[__i]))
	  return -1;
	else if (lt(__s2[__i], __s1[__i]))
	  return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
						    __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      // NB: Inline std::copy so no recursive dependencies.
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      // NB: Inline std::fill_n so no recursive dependencies.
      std::fill_n(__s, __n, __a);
      return __s;
    }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // 21.1
  /**
   *  @brief  Basis for explicit traits specializations.
   *
   *  @note  For any given actual character type, this definition is
   *  probably wrong.  Since this is just a thin wrapper around
   *  __gnu_cxx::char_traits, it is possible to achieve a more
   *  appropriate definition by specializing __gnu_cxx::char_traits.
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.
  */
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };


  /// 21.1.3.1  char_traits specializations
  template<>
    struct char_traits<char>
    {
      typedef char              char_type;
      typedef int               int_type;
      typedef streampos         pos_type;
      typedef streamoff         off_type;
      typedef mbstate_t         state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { __c1 = __c2; }

      static _GLIBCXX_CONSTEXPR bool
      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR bool
      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      {
	// LWG 467.
	return (static_cast<unsigned char>(__c1)
		< static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static _GLIBCXX_CONSTEXPR char_type
      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
      { return static_cast<char_type>(__c); }

      // To keep both the byte 0xff and the eof symbol 0xffffffff
      // from ending up as 0xffffffff.
      static _GLIBCXX_CONSTEXPR int_type
      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static _GLIBCXX_CONSTEXPR bool
      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR int_type
      eof() _GLIBCXX_NOEXCEPT
      { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }

      static _GLIBCXX_CONSTEXPR int_type
      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
      { return (__c == eof()) ? 0 : __c; }
  };


#ifdef _GLIBCXX_USE_WCHAR_T
  /// 21.1.3.2  char_traits specializations
  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t           char_type;
      typedef wint_t            int_type;
      typedef streamoff         off_type;
      typedef wstreampos        pos_type;
      typedef mbstate_t         state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { __c1 = __c2; }

      static _GLIBCXX_CONSTEXPR bool
      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR bool
      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static _GLIBCXX_CONSTEXPR char_type
      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
      { return char_type(__c); }

      static _GLIBCXX_CONSTEXPR int_type
      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
      { return int_type(__c); }

      static _GLIBCXX_CONSTEXPR bool
      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR int_type
      eof() _GLIBCXX_NOEXCEPT
      { return static_cast<int_type>(WEOF); }

      static _GLIBCXX_CONSTEXPR int_type
      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
#endif //_GLIBCXX_USE_WCHAR_T
# 373 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if ((__cplusplus >= 201103L) \
     && defined(_GLIBCXX_USE_C99_STDINT_TR1))

#if 0 /* expanded by -frewrite-includes */
#include <cstdint>
#endif /* expanded by -frewrite-includes */
# 380 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3
# 381 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t          char_type;
      typedef uint_least16_t    int_type;
      typedef streamoff         off_type;
      typedef u16streampos      pos_type;
      typedef mbstate_t         state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
	for (size_t __i = 0; __i < __n; ++__i)
	  if (lt(__s1[__i], __s2[__i]))
	    return -1;
	  else if (lt(__s2[__i], __s1[__i]))
	    return 1;
	return 0;
      }

      static size_t
      length(const char_type* __s)
      {
	size_t __i = 0;
	while (!eq(__s[__i], char_type()))
	  ++__i;
	return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
	for (size_t __i = 0; __i < __n; ++__i)
	  if (eq(__s[__i], __a))
	    return __s + __i;
	return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
	return (static_cast<char_type*>
		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
	return (static_cast<char_type*>
		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
	for (size_t __i = 0; __i < __n; ++__i)
	  assign(__s[__i], __a);
	return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t          char_type;
      typedef uint_least32_t    int_type;
      typedef streamoff         off_type;
      typedef u32streampos      pos_type;
      typedef mbstate_t         state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
	for (size_t __i = 0; __i < __n; ++__i)
	  if (lt(__s1[__i], __s2[__i]))
	    return -1;
	  else if (lt(__s2[__i], __s1[__i]))
	    return 1;
	return 0;
      }

      static size_t
      length(const char_type* __s)
      {
	size_t __i = 0;
	while (!eq(__s[__i], char_type()))
	  ++__i;
	return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
	for (size_t __i = 0; __i < __n; ++__i)
	  if (eq(__s[__i], __a))
	    return __s + __i;
	return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
	return (static_cast<char_type*>
		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { 
	return (static_cast<char_type*>
		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
	for (size_t __i = 0; __i < __n; ++__i)
	  assign(__s[__i], __a);
	return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif 
# 576 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3

#endif // _CHAR_TRAITS_H
# 578 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/char_traits.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/localefwd.h>	// For class locale
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 1 3
// <locale> Forward declarations -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/localefwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

#ifndef _LOCALE_FWD_H
#define _LOCALE_FWD_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/c++locale.h>  // Defines __c_locale, config-specific include
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 1 3
// Wrapper for underlying C-language localization -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/c++locale.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.8  Standard locale categories.
//

// Written by Benjamin Kosnik <bkoz@redhat.com>

#ifndef _GLIBCXX_CXX_LOCALE_H
#define _GLIBCXX_CXX_LOCALE_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <clocale>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/clocale" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file clocale
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c locale.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 18.2.2  Implementation properties: C library
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/clocale" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/clocale" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/clocale" 3
#if 0 /* expanded by -frewrite-includes */
#include <locale.h>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/clocale" 3
# 1 "/usr/include/locale.h" 1 3 4
/* Copyright (C) 1991,1992,1995-2002,2007,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.11 Localization	<locale.h>
 */

#ifndef	_LOCALE_H
#define	_LOCALE_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 26 "/usr/include/locale.h" 3 4
# 27 "/usr/include/locale.h" 3 4

#define __need_NULL
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 29 "/usr/include/locale.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 30 "/usr/include/locale.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <bits/locale.h>
#endif /* expanded by -frewrite-includes */
# 30 "/usr/include/locale.h" 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
/* Definition of locale category symbol values.
   Copyright (C) 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#if !defined _LOCALE_H && !defined _LANGINFO_H
# error "Never use <bits/locale.h> directly; include <locale.h> instead."
#endif
# 23 "/usr/include/bits/locale.h" 3 4

#ifndef _BITS_LOCALE_H
#define _BITS_LOCALE_H	1

enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};

#endif	/* bits/locale.h */
# 45 "/usr/include/bits/locale.h" 3 4
# 31 "/usr/include/locale.h" 2 3 4

__BEGIN_DECLS

/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
#define LC_CTYPE          __LC_CTYPE
#define LC_NUMERIC        __LC_NUMERIC
#define LC_TIME           __LC_TIME
#define LC_COLLATE        __LC_COLLATE
#define LC_MONETARY       __LC_MONETARY
#define LC_MESSAGES       __LC_MESSAGES
#define	LC_ALL		  __LC_ALL
#define LC_PAPER	  __LC_PAPER
#define LC_NAME		  __LC_NAME
#define LC_ADDRESS	  __LC_ADDRESS
#define LC_TELEPHONE	  __LC_TELEPHONE
#define LC_MEASUREMENT	  __LC_MEASUREMENT
#define LC_IDENTIFICATION __LC_IDENTIFICATION


__BEGIN_NAMESPACE_STD

/* Structure giving information about numeric and monetary notation.  */
struct lconv
{
  /* Numeric (non-monetary) information.  */

  char *decimal_point;		/* Decimal point character.  */
  char *thousands_sep;		/* Thousands separator.  */
  /* Each element is the number of digits in each group;
     elements with higher indices are farther left.
     An element with value CHAR_MAX means that no further grouping is done.
     An element with value 0 means that the previous element is used
     for all groups farther left.  */
  char *grouping;

  /* Monetary information.  */

  /* First three chars are a currency symbol from ISO 4217.
     Fourth char is the separator.  Fifth char is '\0'.  */
  char *int_curr_symbol;
  char *currency_symbol;	/* Local currency symbol.  */
  char *mon_decimal_point;	/* Decimal point character.  */
  char *mon_thousands_sep;	/* Thousands separator.  */
  char *mon_grouping;		/* Like `grouping' element (above).  */
  char *positive_sign;		/* Sign for positive values.  */
  char *negative_sign;		/* Sign for negative values.  */
  char int_frac_digits;		/* Int'l fractional digits.  */
  char frac_digits;		/* Local fractional digits.  */
  /* 1 if currency_symbol precedes a positive value, 0 if succeeds.  */
  char p_cs_precedes;
  /* 1 iff a space separates currency_symbol from a positive value.  */
  char p_sep_by_space;
  /* 1 if currency_symbol precedes a negative value, 0 if succeeds.  */
  char n_cs_precedes;
  /* 1 iff a space separates currency_symbol from a negative value.  */
  char n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and currency_symbol.
     1 The sign string precedes the quantity and currency_symbol.
     2 The sign string follows the quantity and currency_symbol.
     3 The sign string immediately precedes the currency_symbol.
     4 The sign string immediately follows the currency_symbol.  */
  char p_sign_posn;
  char n_sign_posn;
#ifdef __USE_ISOC99
  /* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  */
  char int_p_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a positive value.  */
  char int_p_sep_by_space;
  /* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  */
  char int_n_cs_precedes;
  /* 1 iff a space separates int_curr_symbol from a negative value.  */
  char int_n_sep_by_space;
  /* Positive and negative sign positions:
     0 Parentheses surround the quantity and int_curr_symbol.
     1 The sign string precedes the quantity and int_curr_symbol.
     2 The sign string follows the quantity and int_curr_symbol.
     3 The sign string immediately precedes the int_curr_symbol.
     4 The sign string immediately follows the int_curr_symbol.  */
  char int_p_sign_posn;
  char int_n_sign_posn;
#else
# 114 "/usr/include/locale.h" 3 4
  char __int_p_cs_precedes;
  char __int_p_sep_by_space;
  char __int_n_cs_precedes;
  char __int_n_sep_by_space;
  char __int_p_sign_posn;
  char __int_n_sign_posn;
#endif
# 121 "/usr/include/locale.h" 3 4
};


/* Set and/or return the current locale.  */
extern char *setlocale (int __category, __const char *__locale) __THROW;

/* Return the numeric/monetary information for the current locale.  */
extern struct lconv *localeconv (void) __THROW;

__END_NAMESPACE_STD


#ifdef	__USE_XOPEN2K8
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Get locale datatype definition.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 146 "/usr/include/locale.h" 3 4
# 147 "/usr/include/locale.h" 3 4

/* Return a reference to a data structure representing a set of locale
   datasets.  Unlike for the CATEGORY parameter for `setlocale' the
   CATEGORY_MASK parameter here uses a single bit for each category,
   made by OR'ing together LC_*_MASK bits above.  */
extern __locale_t newlocale (int __category_mask, __const char *__locale,
			     __locale_t __base) __THROW;

/* These are the bits that can be set in the CATEGORY_MASK argument to
   `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
   of (1 << LC_FOO), but this is not a part of the interface that
   callers can assume will be true.  */
# define LC_CTYPE_MASK		(1 << __LC_CTYPE)
# define LC_NUMERIC_MASK	(1 << __LC_NUMERIC)
# define LC_TIME_MASK		(1 << __LC_TIME)
# define LC_COLLATE_MASK	(1 << __LC_COLLATE)
# define LC_MONETARY_MASK	(1 << __LC_MONETARY)
# define LC_MESSAGES_MASK	(1 << __LC_MESSAGES)
# define LC_PAPER_MASK		(1 << __LC_PAPER)
# define LC_NAME_MASK		(1 << __LC_NAME)
# define LC_ADDRESS_MASK	(1 << __LC_ADDRESS)
# define LC_TELEPHONE_MASK	(1 << __LC_TELEPHONE)
# define LC_MEASUREMENT_MASK	(1 << __LC_MEASUREMENT)
# define LC_IDENTIFICATION_MASK	(1 << __LC_IDENTIFICATION)
# define LC_ALL_MASK		(LC_CTYPE_MASK \
				 | LC_NUMERIC_MASK \
				 | LC_TIME_MASK \
				 | LC_COLLATE_MASK \
				 | LC_MONETARY_MASK \
				 | LC_MESSAGES_MASK \
				 | LC_PAPER_MASK \
				 | LC_NAME_MASK \
				 | LC_ADDRESS_MASK \
				 | LC_TELEPHONE_MASK \
				 | LC_MEASUREMENT_MASK \
				 | LC_IDENTIFICATION_MASK \
				 )

/* Return a duplicate of the set of locale in DATASET.  All usage
   counters are increased if necessary.  */
extern __locale_t duplocale (__locale_t __dataset) __THROW;

/* Free the data associated with a locale dataset previously returned
   by a call to `setlocale_r'.  */
extern void freelocale (__locale_t __dataset) __THROW;

/* Switch the current thread's locale to DATASET.
   If DATASET is null, instead just return the current setting.
   The special value LC_GLOBAL_LOCALE is the initial setting
   for all threads and can also be installed any time, meaning
   the thread uses the global settings controlled by `setlocale'.  */
extern __locale_t uselocale (__locale_t __dataset) __THROW;

/* This value can be passed to `uselocale' and may be returned by it.
   Passing this value to any other function has undefined behavior.  */
# define LC_GLOBAL_LOCALE	((__locale_t) -1L)

#endif
# 205 "/usr/include/locale.h" 3 4

__END_DECLS

#endif /* locale.h  */
# 209 "/usr/include/locale.h" 3 4
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/clocale" 2 3

#ifndef _GLIBCXX_CLOCALE
#define _GLIBCXX_CLOCALE 1

// Get rid of those macros defined in <locale.h> in lieu of real functions.
#undef setlocale
#undef localeconv

namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
} // namespace std

#endif
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/clocale" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 2 3

#define _GLIBCXX_C_LOCALE_GNU 1

#define _GLIBCXX_NUM_CATEGORIES 6

#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)
namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  extern "C" __typeof(uselocale) __uselocale;

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace
#endif
# 57 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  typedef __locale_t		__c_locale;

  // Convert numeric value of type double and long double to string and
  // return length of string.  If vsnprintf is available use it, otherwise
  // fall back to the unsafe vsprintf which, in general, can be dangerous
  // and should be avoided.
  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
		   char* __out,
		   const int __size __attribute__ ((__unused__)),
		   const char* __fmt, ...)
  {
#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)
    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
#else
# 77 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3
    char* __old = std::setlocale(LC_NUMERIC, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
	const size_t __len = __builtin_strlen(__old) + 1;
	__sav = new char[__len];
	__builtin_memcpy(__sav, __old, __len);
	std::setlocale(LC_NUMERIC, "C");
      }
#endif
# 87 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);

#ifdef _GLIBCXX_USE_C99
    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
#else
# 94 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3
    const int __ret = __builtin_vsprintf(__out, __fmt, __args);
#endif
# 96 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3

    __builtin_va_end(__args);

#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)
    __gnu_cxx::__uselocale(__old);
#else
# 102 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3
    if (__sav)
      {
	std::setlocale(LC_NUMERIC, __sav);
	delete [] __sav;
      }
#endif
# 108 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3
    return __ret;
  }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 115 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/c++locale.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <iosfwd>            // For ostreambuf_iterator, istreambuf_iterator
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <cctype>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c ctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: <ccytpe>
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
#if 0 /* expanded by -frewrite-includes */
#include <ctype.h>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
# 1 "/usr/include/ctype.h" 1 3 4
/* Copyright (C) 1991,92,93,95,96,97,98,99,2001,2002,2004,2007,2008,2009
   	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard 7.4: Character handling	<ctype.h>
 */

#ifndef	_CTYPE_H
#define	_CTYPE_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/ctype.h" 3 4
# 28 "/usr/include/ctype.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */

#ifndef	_BITS_TYPES_H
#define	_BITS_TYPES_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/bits/types.h" 3 4
# 28 "/usr/include/bits/types.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 29 "/usr/include/bits/types.h" 2 3 4

/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
#if __WORDSIZE == 64
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
#elif defined __GLIBC_HAVE_LONG_LONG
# 47 "/usr/include/bits/types.h" 3 4
__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;
#endif
# 50 "/usr/include/bits/types.h" 3 4

/* quad_t is also 64 bits.  */
#if __WORDSIZE == 64
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
#elif defined __GLIBC_HAVE_LONG_LONG
# 56 "/usr/include/bits/types.h" 3 4
__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
#else
# 59 "/usr/include/bits/types.h" 3 4
typedef struct
{
  long __val[2];
} __quad_t;
typedef struct
{
  __u_long __val[2];
} __u_quad_t;
#endif
# 68 "/usr/include/bits/types.h" 3 4


/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

	16		-- "natural" 16-bit type (always short)
	32		-- "natural" 32-bit type (always int)
	64		-- "natural" 64-bit type (long or long long)
	LONG32		-- 32-bit type, traditionally long
	QUAD		-- 64-bit type, always long long
	WORD		-- natural type of __WORDSIZE bits (int or long)
	LONGWORD	-- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  */

#define	__S16_TYPE		short int
#define __U16_TYPE		unsigned short int
#define	__S32_TYPE		int
#define __U32_TYPE		unsigned int
#define __SLONGWORD_TYPE	long int
#define __ULONGWORD_TYPE	unsigned long int
#if __WORDSIZE == 32
# define __SQUAD_TYPE		__quad_t
# define __UQUAD_TYPE		__u_quad_t
# define __SWORD_TYPE		int
# define __UWORD_TYPE		unsigned int
# define __SLONG32_TYPE		long int
# define __ULONG32_TYPE		unsigned long int
# define __S64_TYPE		__quad_t
# define __U64_TYPE		__u_quad_t
/* We want __extension__ before typedef's that use nonstandard base types
   such as `long long' in C89 mode.  */
# define __STD_TYPE		__extension__ typedef
#elif __WORDSIZE == 64
# 118 "/usr/include/bits/types.h" 3 4
# define __SQUAD_TYPE		long int
# define __UQUAD_TYPE		unsigned long int
# define __SWORD_TYPE		long int
# define __UWORD_TYPE		unsigned long int
# define __SLONG32_TYPE		int
# define __ULONG32_TYPE		unsigned int
# define __S64_TYPE		long int
# define __U64_TYPE		unsigned long int
/* No need to mark the typedef with __extension__.   */
# define __STD_TYPE		typedef
#else
# 129 "/usr/include/bits/types.h" 3 4
# error
#endif
# 131 "/usr/include/bits/types.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <bits/typesizes.h>	/* Defines __*_T_TYPE macros.  */
#endif /* expanded by -frewrite-includes */
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
/* bits/typesizes.h -- underlying types for *_t.  Generic version.
   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _BITS_TYPES_H
# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
#endif
# 23 "/usr/include/bits/typesizes.h" 3 4

#ifndef	_BITS_TYPESIZES_H
#define	_BITS_TYPESIZES_H	1

/* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  */

#define __DEV_T_TYPE		__UQUAD_TYPE
#define __UID_T_TYPE		__U32_TYPE
#define __GID_T_TYPE		__U32_TYPE
#define __INO_T_TYPE		__ULONGWORD_TYPE
#define __INO64_T_TYPE		__UQUAD_TYPE
#define __MODE_T_TYPE		__U32_TYPE
#define __NLINK_T_TYPE		__UWORD_TYPE
#define __OFF_T_TYPE		__SLONGWORD_TYPE
#define __OFF64_T_TYPE		__SQUAD_TYPE
#define __PID_T_TYPE		__S32_TYPE
#define __RLIM_T_TYPE		__ULONGWORD_TYPE
#define __RLIM64_T_TYPE		__UQUAD_TYPE
#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
#define	__ID_T_TYPE		__U32_TYPE
#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
#define __TIME_T_TYPE		__SLONGWORD_TYPE
#define __USECONDS_T_TYPE	__U32_TYPE
#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
#define __DADDR_T_TYPE		__S32_TYPE
#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
#define __KEY_T_TYPE		__S32_TYPE
#define __CLOCKID_T_TYPE	__S32_TYPE
#define __TIMER_T_TYPE		void *
#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
#define __FSID_T_TYPE		struct { int __val[2]; }
#define __SSIZE_T_TYPE		__SWORD_TYPE

/* Number of descriptors that can fit in an `fd_set'.  */
#define	__FD_SETSIZE		1024


#endif /* bits/typesizes.h */
# 67 "/usr/include/bits/typesizes.h" 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


__STD_TYPE __DEV_T_TYPE __dev_t;	/* Type of device numbers.  */
__STD_TYPE __UID_T_TYPE __uid_t;	/* Type of user identifications.  */
__STD_TYPE __GID_T_TYPE __gid_t;	/* Type of group identifications.  */
__STD_TYPE __INO_T_TYPE __ino_t;	/* Type of file serial numbers.  */
__STD_TYPE __INO64_T_TYPE __ino64_t;	/* Type of file serial numbers (LFS).*/
__STD_TYPE __MODE_T_TYPE __mode_t;	/* Type of file attribute bitmasks.  */
__STD_TYPE __NLINK_T_TYPE __nlink_t;	/* Type of file link counts.  */
__STD_TYPE __OFF_T_TYPE __off_t;	/* Type of file sizes and offsets.  */
__STD_TYPE __OFF64_T_TYPE __off64_t;	/* Type of file sizes and offsets (LFS).  */
__STD_TYPE __PID_T_TYPE __pid_t;	/* Type of process identifications.  */
__STD_TYPE __FSID_T_TYPE __fsid_t;	/* Type of file system IDs.  */
__STD_TYPE __CLOCK_T_TYPE __clock_t;	/* Type of CPU usage counts.  */
__STD_TYPE __RLIM_T_TYPE __rlim_t;	/* Type for resource measurement.  */
__STD_TYPE __RLIM64_T_TYPE __rlim64_t;	/* Type for resource measurement (LFS).  */
__STD_TYPE __ID_T_TYPE __id_t;		/* General type for IDs.  */
__STD_TYPE __TIME_T_TYPE __time_t;	/* Seconds since the Epoch.  */
__STD_TYPE __USECONDS_T_TYPE __useconds_t; /* Count of microseconds.  */
__STD_TYPE __SUSECONDS_T_TYPE __suseconds_t; /* Signed count of microseconds.  */

__STD_TYPE __DADDR_T_TYPE __daddr_t;	/* The type of a disk address.  */
__STD_TYPE __SWBLK_T_TYPE __swblk_t;	/* Type of a swap block maybe?  */
__STD_TYPE __KEY_T_TYPE __key_t;	/* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
__STD_TYPE __CLOCKID_T_TYPE __clockid_t;

/* Timer ID returned by `timer_create'.  */
__STD_TYPE __TIMER_T_TYPE __timer_t;

/* Type to represent block size.  */
__STD_TYPE __BLKSIZE_T_TYPE __blksize_t;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
__STD_TYPE __BLKCNT_T_TYPE __blkcnt_t;
__STD_TYPE __BLKCNT64_T_TYPE __blkcnt64_t;

/* Type to count file system blocks.  */
__STD_TYPE __FSBLKCNT_T_TYPE __fsblkcnt_t;
__STD_TYPE __FSBLKCNT64_T_TYPE __fsblkcnt64_t;

/* Type to count file system nodes.  */
__STD_TYPE __FSFILCNT_T_TYPE __fsfilcnt_t;
__STD_TYPE __FSFILCNT64_T_TYPE __fsfilcnt64_t;

__STD_TYPE __SSIZE_T_TYPE __ssize_t; /* Type of a byte count, or error.  */

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t;	/* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
__STD_TYPE __SWORD_TYPE __intptr_t;

/* Duplicate info from sys/socket.h.  */
__STD_TYPE __U32_TYPE __socklen_t;


#undef __STD_TYPE

#endif /* bits/types.h */
# 198 "/usr/include/bits/types.h" 3 4
# 29 "/usr/include/ctype.h" 2 3 4

__BEGIN_DECLS

#ifndef _ISbit
/* These are all the characteristics of characters.
   If there get to be more than 16 distinct characteristics,
   many things must be changed that use `unsigned short int's.

   The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */

#if 0 /* expanded by -frewrite-includes */
# include <endian.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
/* Copyright (C) 1992, 1996, 1997, 2000, 2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef	_ENDIAN_H
#define	_ENDIAN_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 22 "/usr/include/endian.h" 3 4
# 23 "/usr/include/endian.h" 3 4

/* Definitions for byte order, according to significance of bytes,
   from low addresses to high addresses.  The value is what you get by
   putting '4' in the most significant byte, '3' in the second most
   significant byte, '2' in the second least significant byte, and '1'
   in the least significant byte, and then writing down one digit for
   each byte, starting with the byte at the lowest address at the left,
   and proceeding to the byte with the highest address at the right.  */

#define	__LITTLE_ENDIAN	1234
#define	__BIG_ENDIAN	4321
#define	__PDP_ENDIAN	3412

/* This file defines `__BYTE_ORDER' for the particular machine.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/endian.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
/* x86_64 is little-endian.  */

#ifndef _ENDIAN_H
# error "Never use <bits/endian.h> directly; include <endian.h> instead."
#endif
# 6 "/usr/include/bits/endian.h" 3 4

#define __BYTE_ORDER __LITTLE_ENDIAN
# 38 "/usr/include/endian.h" 2 3 4

/* Some machines may need to use a different endianness for floating point
   values.  */
#ifndef __FLOAT_WORD_ORDER
# define __FLOAT_WORD_ORDER __BYTE_ORDER
#endif
# 44 "/usr/include/endian.h" 3 4

#ifdef	__USE_BSD
# define LITTLE_ENDIAN	__LITTLE_ENDIAN
# define BIG_ENDIAN	__BIG_ENDIAN
# define PDP_ENDIAN	__PDP_ENDIAN
# define BYTE_ORDER	__BYTE_ORDER
#endif
# 51 "/usr/include/endian.h" 3 4

#if __BYTE_ORDER == __LITTLE_ENDIAN
# define __LONG_LONG_PAIR(HI, LO) LO, HI
#elif __BYTE_ORDER == __BIG_ENDIAN
# 55 "/usr/include/endian.h" 3 4
# define __LONG_LONG_PAIR(HI, LO) HI, LO
#endif
# 57 "/usr/include/endian.h" 3 4


#ifdef __USE_BSD
/* Conversion interfaces.  */
#if 0 /* expanded by -frewrite-includes */
# include <bits/byteswap.h>
#endif /* expanded by -frewrite-includes */
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997, 1998, 2000, 2002, 2003, 2007, 2008, 2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#if !defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H
# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
#endif
# 24 "/usr/include/bits/byteswap.h" 3 4

#ifndef _BITS_BYTESWAP_H
#define _BITS_BYTESWAP_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4

/* Swap bytes in 16 bit value.  */
#define __bswap_constant_16(x) \
     ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))

#if defined __GNUC__ && __GNUC__ >= 2
# define __bswap_16(x) \
     (__extension__							      \
      ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
	 if (__builtin_constant_p (__x))				      \
	   __v = __bswap_constant_16 (__x);				      \
	 else								      \
	   __asm__ ("rorw $8, %w0"					      \
		    : "=r" (__v)					      \
		    : "0" (__x)						      \
		    : "cc");						      \
	 __v; }))
#else
# 47 "/usr/include/bits/byteswap.h" 3 4
/* This is better than nothing.  */
# define __bswap_16(x) \
     (__extension__							      \
      ({ register unsigned short int __x = (unsigned short int) (x);          \
	 __bswap_constant_16 (__x); }))
#endif
# 53 "/usr/include/bits/byteswap.h" 3 4


/* Swap bytes in 32 bit value.  */
#define __bswap_constant_32(x) \
     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))

#if defined __GNUC__ && __GNUC__ >= 2
# if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
			  || defined __pentiumpro__ || defined __pentium4__   \
			  || defined __k8__ || defined __athlon__	      \
			  || defined __k6__ || defined __nocona__	      \
			  || defined __core2__ || defined __geode__	      \
			  || defined __amdfam10__)
/* To swap the bytes in a word the i486 processors and up provide the
   `bswap' opcode.  On i386 we have to use three instructions.  */
#  define __bswap_32(x) \
     (__extension__							      \
      ({ register unsigned int __v, __x = (x);				      \
	 if (__builtin_constant_p (__x))				      \
	   __v = __bswap_constant_32 (__x);				      \
	 else								      \
	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
	 __v; }))
# else
# 78 "/usr/include/bits/byteswap.h" 3 4
#  define __bswap_32(x)							      \
     (__extension__							      \
      ({ register unsigned int __v, __x = (x);				      \
	 if (__builtin_constant_p (__x))				      \
	   __v = __bswap_constant_32 (__x);				      \
	 else								      \
	   __asm__ ("rorw $8, %w0;"					      \
		    "rorl $16, %0;"					      \
		    "rorw $8, %w0"					      \
		    : "=r" (__v)					      \
		    : "0" (__x)						      \
		    : "cc");						      \
	 __v; }))
# endif
# 92 "/usr/include/bits/byteswap.h" 3 4
#else
# 93 "/usr/include/bits/byteswap.h" 3 4
# define __bswap_32(x) \
     (__extension__							      \
      ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
#endif
# 97 "/usr/include/bits/byteswap.h" 3 4


#if defined __GNUC__ && __GNUC__ >= 2
/* Swap bytes in 64 bit value.  */
# define __bswap_constant_64(x) \
     ((((x) & 0xff00000000000000ull) >> 56)				      \
      | (((x) & 0x00ff000000000000ull) >> 40)				      \
      | (((x) & 0x0000ff0000000000ull) >> 24)				      \
      | (((x) & 0x000000ff00000000ull) >> 8)				      \
      | (((x) & 0x00000000ff000000ull) << 8)				      \
      | (((x) & 0x0000000000ff0000ull) << 24)				      \
      | (((x) & 0x000000000000ff00ull) << 40)				      \
      | (((x) & 0x00000000000000ffull) << 56))

# if __WORDSIZE == 64
#  define __bswap_64(x) \
     (__extension__							      \
      ({ register unsigned long __v, __x = (x);				      \
	 if (__builtin_constant_p (__x))				      \
	   __v = __bswap_constant_64 (__x);				      \
	 else								      \
	   __asm__ ("bswap %q0" : "=r" (__v) : "0" (__x));		      \
	 __v; }))
# else
# 121 "/usr/include/bits/byteswap.h" 3 4
#  define __bswap_64(x) \
     (__extension__                                                           \
      ({ union { __extension__ unsigned long long int __ll;                   \
		 unsigned int __l[2]; } __w, __r;                             \
	 if (__builtin_constant_p (x))                                        \
	   __r.__ll = __bswap_constant_64 (x);                                \
	 else                                                                 \
	   {                                                                  \
	     __w.__ll = (x);                                                  \
	     __r.__l[0] = __bswap_32 (__w.__l[1]);                            \
	     __r.__l[1] = __bswap_32 (__w.__l[0]);                            \
	   }                                                                  \
	 __r.__ll; }))
# endif
# 135 "/usr/include/bits/byteswap.h" 3 4
#endif
# 136 "/usr/include/bits/byteswap.h" 3 4

#endif /* _BITS_BYTESWAP_H */
# 138 "/usr/include/bits/byteswap.h" 3 4
# 62 "/usr/include/endian.h" 2 3 4

# if __BYTE_ORDER == __LITTLE_ENDIAN
#  define htobe16(x) __bswap_16 (x)
#  define htole16(x) (x)
#  define be16toh(x) __bswap_16 (x)
#  define le16toh(x) (x)

#  define htobe32(x) __bswap_32 (x)
#  define htole32(x) (x)
#  define be32toh(x) __bswap_32 (x)
#  define le32toh(x) (x)

#  define htobe64(x) __bswap_64 (x)
#  define htole64(x) (x)
#  define be64toh(x) __bswap_64 (x)
#  define le64toh(x) (x)
# else
# 79 "/usr/include/endian.h" 3 4
#  define htobe16(x) (x)
#  define htole16(x) __bswap_16 (x)
#  define be16toh(x) (x)
#  define le16toh(x) __bswap_16 (x)

#  define htobe32(x) (x)
#  define htole32(x) __bswap_32 (x)
#  define be32toh(x) (x)
#  define le32toh(x) __bswap_32 (x)

#  define htobe64(x) (x)
#  define htole64(x) __bswap_64 (x)
#  define be64toh(x) (x)
#  define le64toh(x) __bswap_64 (x)
# endif
# 94 "/usr/include/endian.h" 3 4
#endif
# 95 "/usr/include/endian.h" 3 4

#endif	/* endian.h */
# 97 "/usr/include/endian.h" 3 4
# 42 "/usr/include/ctype.h" 2 3 4
# if __BYTE_ORDER == __BIG_ENDIAN
#  define _ISbit(bit)	(1 << (bit))
# else /* __BYTE_ORDER == __LITTLE_ENDIAN */
# 45 "/usr/include/ctype.h" 3 4
#  define _ISbit(bit)	((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))
# endif
# 47 "/usr/include/ctype.h" 3 4

enum
{
  _ISupper = _ISbit (0),	/* UPPERCASE.  */
  _ISlower = _ISbit (1),	/* lowercase.  */
  _ISalpha = _ISbit (2),	/* Alphabetic.  */
  _ISdigit = _ISbit (3),	/* Numeric.  */
  _ISxdigit = _ISbit (4),	/* Hexadecimal numeric.  */
  _ISspace = _ISbit (5),	/* Whitespace.  */
  _ISprint = _ISbit (6),	/* Printing.  */
  _ISgraph = _ISbit (7),	/* Graphical.  */
  _ISblank = _ISbit (8),	/* Blank (usually SPC and TAB).  */
  _IScntrl = _ISbit (9),	/* Control character.  */
  _ISpunct = _ISbit (10),	/* Punctuation.  */
  _ISalnum = _ISbit (11)	/* Alphanumeric.  */
};
#endif /* ! _ISbit  */
# 64 "/usr/include/ctype.h" 3 4

/* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.

   In the thread-specific locale model (see `uselocale' in <locale.h>)
   we cannot use global variables for these as was done in the past.
   Instead, the following accessor functions return the address of
   each variable, which is local to the current thread if multithreaded.

   These point into arrays of 384, so they can be indexed by any `unsigned
   char' value [0,255]; by EOF (-1); or by any `signed char' value
   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
   char' values and for EOF; we also support negative `signed char' values
   for broken old programs.  The case conversion arrays are of `int's
   rather than `unsigned char's because tolower (EOF) must be EOF, which
   doesn't fit into an `unsigned char'.  But today more important is that
   the arrays are also used for multi-byte character sets.  */
extern __const unsigned short int **__ctype_b_loc (void)
     __THROW __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __THROW __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __THROW __attribute__ ((__const));

#define __isctype(c, type) \
  ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)

#define	__isascii(c)	(((c) & ~0x7f) == 0)	/* If C is a 7 bit value.  */
#define	__toascii(c)	((c) & 0x7f)		/* Mask off high bits.  */

#define	__exctype(name)	extern int name (int) __THROW

__BEGIN_NAMESPACE_STD

/* The following names are all functions:
     int isCHARACTERISTIC(int c);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
__exctype (isalnum);
__exctype (isalpha);
__exctype (iscntrl);
__exctype (isdigit);
__exctype (islower);
__exctype (isgraph);
__exctype (isprint);
__exctype (ispunct);
__exctype (isspace);
__exctype (isupper);
__exctype (isxdigit);


/* Return the lowercase version of C.  */
extern int tolower (int __c) __THROW;

/* Return the uppercase version of C.  */
extern int toupper (int __c) __THROW;

__END_NAMESPACE_STD


/* ISO C99 introduced one new function.  */
#ifdef	__USE_ISOC99
__BEGIN_NAMESPACE_C99

__exctype (isblank);

__END_NAMESPACE_C99
#endif
# 132 "/usr/include/ctype.h" 3 4

#ifdef __USE_GNU
/* Test C for a set of character classes according to MASK.  */
extern int isctype (int __c, int __mask) __THROW;
#endif
# 137 "/usr/include/ctype.h" 3 4

#if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN

/* Return nonzero iff C is in the ASCII set
   (i.e., is no more than 7 bits wide).  */
extern int isascii (int __c) __THROW;

/* Return the part of C that is in the ASCII set
   (i.e., the low-order 7 bits of C).  */
extern int toascii (int __c) __THROW;

/* These are the same as `toupper' and `tolower' except that they do not
   check the argument for being in the range of a `char'.  */
__exctype (_toupper);
__exctype (_tolower);
#endif /* Use SVID or use misc.  */
# 153 "/usr/include/ctype.h" 3 4

/* This code is needed for the optimized mapping functions.  */
#define __tobody(c, f, a, args) \
  (__extension__							      \
   ({ int __res;							      \
      if (sizeof (c) > 1)						      \
	{								      \
	  if (__builtin_constant_p (c))					      \
	    {								      \
	      int __c = (c);						      \
	      __res = __c < -128 || __c > 255 ? __c : (a)[__c];		      \
	    }								      \
	  else								      \
	    __res = f args;						      \
	}								      \
      else								      \
	__res = (a)[(int) (c)];						      \
      __res; }))

#if !defined __NO_CTYPE && !defined __cplusplus
# define isalnum(c)	__isctype((c), _ISalnum)
# define isalpha(c)	__isctype((c), _ISalpha)
# define iscntrl(c)	__isctype((c), _IScntrl)
# define isdigit(c)	__isctype((c), _ISdigit)
# define islower(c)	__isctype((c), _ISlower)
# define isgraph(c)	__isctype((c), _ISgraph)
# define isprint(c)	__isctype((c), _ISprint)
# define ispunct(c)	__isctype((c), _ISpunct)
# define isspace(c)	__isctype((c), _ISspace)
# define isupper(c)	__isctype((c), _ISupper)
# define isxdigit(c)	__isctype((c), _ISxdigit)

# ifdef __USE_ISOC99
#  define isblank(c)	__isctype((c), _ISblank)
# endif
# 188 "/usr/include/ctype.h" 3 4

# ifdef __USE_EXTERN_INLINES
__extern_inline int
__NTH (tolower (int __c))
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

__extern_inline int
__NTH (toupper (int __c))
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# endif
# 202 "/usr/include/ctype.h" 3 4

# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus
#  define tolower(c)	__tobody (c, tolower, *__ctype_tolower_loc (), (c))
#  define toupper(c)	__tobody (c, toupper, *__ctype_toupper_loc (), (c))
# endif /* Optimizing gcc */
# 207 "/usr/include/ctype.h" 3 4

# if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN
#  define isascii(c)	__isascii (c)
#  define toascii(c)	__toascii (c)

#  define _tolower(c)	((int) (*__ctype_tolower_loc ())[(int) (c)])
#  define _toupper(c)	((int) (*__ctype_toupper_loc ())[(int) (c)])
# endif
# 215 "/usr/include/ctype.h" 3 4

#endif /* Not __NO_CTYPE.  */
# 217 "/usr/include/ctype.h" 3 4


#ifdef __USE_XOPEN2K8
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 233 "/usr/include/ctype.h" 3 4
# 234 "/usr/include/ctype.h" 3 4

/* These definitions are similar to the ones above but all functions
   take as an argument a handle for the locale which shall be used.  */
#  define __isctype_l(c, type, locale) \
  ((locale)->__ctype_b[(int) (c)] & (unsigned short int) type)

# define __exctype_l(name) 						      \
  extern int name (int, __locale_t) __THROW

/* The following names are all functions:
     int isCHARACTERISTIC(int c, locale_t *locale);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
__exctype_l (isalnum_l);
__exctype_l (isalpha_l);
__exctype_l (iscntrl_l);
__exctype_l (isdigit_l);
__exctype_l (islower_l);
__exctype_l (isgraph_l);
__exctype_l (isprint_l);
__exctype_l (ispunct_l);
__exctype_l (isspace_l);
__exctype_l (isupper_l);
__exctype_l (isxdigit_l);

__exctype_l (isblank_l);


/* Return the lowercase version of C in locale L.  */
extern int __tolower_l (int __c, __locale_t __l) __THROW;
extern int tolower_l (int __c, __locale_t __l) __THROW;

/* Return the uppercase version of C.  */
extern int __toupper_l (int __c, __locale_t __l) __THROW;
extern int toupper_l (int __c, __locale_t __l) __THROW;

# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus
#  define __tolower_l(c, locale) \
  __tobody (c, __tolower_l, (locale)->__ctype_tolower, (c, locale))
#  define __toupper_l(c, locale) \
  __tobody (c, __toupper_l, (locale)->__ctype_toupper, (c, locale))
#  define tolower_l(c, locale)	__tolower_l ((c), (locale))
#  define toupper_l(c, locale)	__toupper_l ((c), (locale))
# endif	/* Optimizing gcc */
# 278 "/usr/include/ctype.h" 3 4


# ifndef __NO_CTYPE
#  define __isalnum_l(c,l)	__isctype_l((c), _ISalnum, (l))
#  define __isalpha_l(c,l)	__isctype_l((c), _ISalpha, (l))
#  define __iscntrl_l(c,l)	__isctype_l((c), _IScntrl, (l))
#  define __isdigit_l(c,l)	__isctype_l((c), _ISdigit, (l))
#  define __islower_l(c,l)	__isctype_l((c), _ISlower, (l))
#  define __isgraph_l(c,l)	__isctype_l((c), _ISgraph, (l))
#  define __isprint_l(c,l)	__isctype_l((c), _ISprint, (l))
#  define __ispunct_l(c,l)	__isctype_l((c), _ISpunct, (l))
#  define __isspace_l(c,l)	__isctype_l((c), _ISspace, (l))
#  define __isupper_l(c,l)	__isctype_l((c), _ISupper, (l))
#  define __isxdigit_l(c,l)	__isctype_l((c), _ISxdigit, (l))

#  define __isblank_l(c,l)	__isctype_l((c), _ISblank, (l))

#  if defined __USE_SVID || defined __USE_MISC
#   define __isascii_l(c,l)	((l), __isascii (c))
#   define __toascii_l(c,l)	((l), __toascii (c))
#  endif
# 299 "/usr/include/ctype.h" 3 4

#  define isalnum_l(c,l)	__isalnum_l ((c), (l))
#  define isalpha_l(c,l)	__isalpha_l ((c), (l))
#  define iscntrl_l(c,l)	__iscntrl_l ((c), (l))
#  define isdigit_l(c,l)	__isdigit_l ((c), (l))
#  define islower_l(c,l)	__islower_l ((c), (l))
#  define isgraph_l(c,l)	__isgraph_l ((c), (l))
#  define isprint_l(c,l)	__isprint_l ((c), (l))
#  define ispunct_l(c,l)	__ispunct_l ((c), (l))
#  define isspace_l(c,l)	__isspace_l ((c), (l))
#  define isupper_l(c,l)	__isupper_l ((c), (l))
#  define isxdigit_l(c,l)	__isxdigit_l ((c), (l))

#  define isblank_l(c,l)	__isblank_l ((c), (l))

#  if defined __USE_SVID || defined __USE_MISC
#   define isascii_l(c,l)	__isascii_l ((c), (l))
#   define toascii_l(c,l)	__toascii_l ((c), (l))
#  endif
# 318 "/usr/include/ctype.h" 3 4

# endif /* Not __NO_CTYPE.  */
# 320 "/usr/include/ctype.h" 3 4

#endif /* Use POSIX 2008.  */
# 322 "/usr/include/ctype.h" 3 4

__END_DECLS

#endif /* ctype.h  */
# 326 "/usr/include/ctype.h" 3 4
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 2 3

#ifndef _GLIBCXX_CCTYPE
#define _GLIBCXX_CCTYPE 1

// Get rid of those macros defined in <ctype.h> in lieu of real functions.
#undef isalnum
#undef isalpha
#undef iscntrl
#undef isdigit
#undef isgraph
#undef islower
#undef isprint
#undef ispunct
#undef isspace
#undef isupper
#undef isxdigit
#undef tolower
#undef toupper

namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
} // namespace std

#if __cplusplus >= 201103L

#ifdef _GLIBCXX_USE_C99_CTYPE_TR1

#undef isblank

namespace std
{
  using ::isblank;
} // namespace std

#endif // _GLIBCXX_USE_C99_CTYPE_TR1
# 91 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3

#endif // C++11
# 93 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3

#endif
# 95 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /** 
   *  @defgroup locales Locales
   *
   *  Classes and functions for internationalization and localization.
   */

  // 22.1.1 Locale
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);

  // 22.1.3 Convenience interfaces
  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

#if __cplusplus >= 201103L
  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);
#endif
# 115 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);

  // 22.2.1 and 22.2.1.3 ctype
  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;
#ifdef _GLIBCXX_USE_WCHAR_T
  template<> class ctype<wchar_t>;
#endif
# 132 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
  template<typename _CharT>
    class ctype_byname;
  // NB: Specialized for char and wchar_t in locale_facets.h.

  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;
#ifdef _GLIBCXX_USE_WCHAR_T
  template<> class codecvt<wchar_t, char, mbstate_t>;
#endif
# 143 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;

  // 22.2.2 and 22.2.3 numeric
_GLIBCXX_BEGIN_NAMESPACE_LDBL
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
_GLIBCXX_END_NAMESPACE_LDBL
_GLIBCXX_BEGIN_NAMESPACE_CXX11
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
_GLIBCXX_END_NAMESPACE_CXX11

_GLIBCXX_BEGIN_NAMESPACE_CXX11
  // 22.2.4 collation
  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
_GLIBCXX_END_NAMESPACE_CXX11

  // 22.2.5 date and time
  class time_base;
_GLIBCXX_BEGIN_NAMESPACE_CXX11
  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >
    class time_get_byname;
_GLIBCXX_END_NAMESPACE_CXX11
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;

  // 22.2.6 money
  class money_base;
_GLIBCXX_BEGIN_NAMESPACE_LDBL_OR_CXX11
  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
_GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11
_GLIBCXX_BEGIN_NAMESPACE_CXX11
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
_GLIBCXX_END_NAMESPACE_CXX11

  // 22.2.7 message retrieval
  class messages_base;
_GLIBCXX_BEGIN_NAMESPACE_CXX11
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
_GLIBCXX_END_NAMESPACE_CXX11

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 207 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/localefwd.h" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/ios_base.h>	// For ios_base declarations.
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 1 3
// Iostreams base classes -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ios_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */

//
// ISO C++ 14882: 27.4  Iostreams base classes
//

#ifndef _IOS_BASE_H
#define _IOS_BASE_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <ext/atomicity.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 1 3
// Support for atomic operations -*- C++ -*-

// Copyright (C) 2004-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/atomicity.h
 *  This file is a GNU extension to the Standard C++ Library.
 */

#ifndef _GLIBCXX_ATOMICITY_H
#define _GLIBCXX_ATOMICITY_H	1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/gthr.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 1 3
/* Threads compatibility routines for libgcc2.  */
/* Compile this one with gcc.  */
/* Copyright (C) 1997-2015 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

#ifndef _GLIBCXX_GCC_GTHR_H
#define _GLIBCXX_GCC_GTHR_H

#ifndef _GLIBCXX_HIDE_EXPORTS
#pragma GCC visibility push(default)
#endif
# 32 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 3

/* If this file is compiled with threads support, it must
       #define __GTHREADS 1
   to indicate that threads support is present.  Also it has define
   function
     int __gthread_active_p ()
   that returns 1 if thread system is active, 0 if not.

   The threads interface must define the following types:
     __gthread_key_t
     __gthread_once_t
     __gthread_mutex_t
     __gthread_recursive_mutex_t

   The threads interface must define the following macros:

     __GTHREAD_ONCE_INIT
     		to initialize __gthread_once_t
     __GTHREAD_MUTEX_INIT
     		to initialize __gthread_mutex_t to get a fast
		non-recursive mutex.
     __GTHREAD_MUTEX_INIT_FUNCTION
		to initialize __gthread_mutex_t to get a fast
		non-recursive mutex.
		Define this to a function which looks like this:
		  void __GTHREAD_MUTEX_INIT_FUNCTION (__gthread_mutex_t *)
     		Some systems can't initialize a mutex without a
		function call.  Don't define __GTHREAD_MUTEX_INIT in this case.
     __GTHREAD_RECURSIVE_MUTEX_INIT
     __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION
     		as above, but for a recursive mutex.

   The threads interface must define the following static functions:

     int __gthread_once (__gthread_once_t *once, void (*func) ())

     int __gthread_key_create (__gthread_key_t *keyp, void (*dtor) (void *))
     int __gthread_key_delete (__gthread_key_t key)

     void *__gthread_getspecific (__gthread_key_t key)
     int __gthread_setspecific (__gthread_key_t key, const void *ptr)

     int __gthread_mutex_destroy (__gthread_mutex_t *mutex);
     int __gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *mutex);

     int __gthread_mutex_lock (__gthread_mutex_t *mutex);
     int __gthread_mutex_trylock (__gthread_mutex_t *mutex);
     int __gthread_mutex_unlock (__gthread_mutex_t *mutex);

     int __gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex);
     int __gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex);
     int __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex);

   The following are supported in POSIX threads only. They are required to
   fix a deadlock in static initialization inside libsupc++. The header file
   gthr-posix.h defines a symbol __GTHREAD_HAS_COND to signify that these extra
   features are supported.

   Types:
     __gthread_cond_t

   Macros:
     __GTHREAD_COND_INIT
     __GTHREAD_COND_INIT_FUNCTION

   Interface:
     int __gthread_cond_broadcast (__gthread_cond_t *cond);
     int __gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex);
     int __gthread_cond_wait_recursive (__gthread_cond_t *cond,
					__gthread_recursive_mutex_t *mutex);

   All functions returning int should return zero on success or the error
   number.  If the operation is not supported, -1 is returned.

   If the following are also defined, you should
     #define __GTHREADS_CXX0X 1
   to enable the c++0x thread library.

   Types:
     __gthread_t
     __gthread_time_t

   Interface:
     int __gthread_create (__gthread_t *thread, void *(*func) (void*),
                           void *args);
     int __gthread_join (__gthread_t thread, void **value_ptr);
     int __gthread_detach (__gthread_t thread);
     int __gthread_equal (__gthread_t t1, __gthread_t t2);
     __gthread_t __gthread_self (void);
     int __gthread_yield (void);

     int __gthread_mutex_timedlock (__gthread_mutex_t *m,
                                    const __gthread_time_t *abs_timeout);
     int __gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *m,
                                          const __gthread_time_t *abs_time);

     int __gthread_cond_signal (__gthread_cond_t *cond);
     int __gthread_cond_timedwait (__gthread_cond_t *cond,
                                   __gthread_mutex_t *mutex,
                                   const __gthread_time_t *abs_timeout);

*/

#if __GXX_WEAK__
/* The pe-coff weak support isn't fully compatible to ELF's weak.
   For static libraries it might would work, but as we need to deal
   with shared versions too, we disable it for mingw-targets.  */
#ifdef __MINGW32__
#undef _GLIBCXX_GTHREAD_USE_WEAK
#define _GLIBCXX_GTHREAD_USE_WEAK 0
#endif
# 143 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 3

#ifndef _GLIBCXX_GTHREAD_USE_WEAK
#define _GLIBCXX_GTHREAD_USE_WEAK 1
#endif
# 147 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 3
#endif
# 148 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/gthr-default.h>
#endif /* expanded by -frewrite-includes */
# 148 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 1 3
/* Threads compatibility routines for libgcc2 and libobjc.  */
/* Compile this one with gcc.  */
/* Copyright (C) 1997-2015 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

#ifndef _GLIBCXX_GCC_GTHR_POSIX_H
#define _GLIBCXX_GCC_GTHR_POSIX_H

/* POSIX threads specific definitions.
   Easy, since the interface is just one-to-one mapping.  */

#define __GTHREADS 1
#define __GTHREADS_CXX0X 1

#if 0 /* expanded by -frewrite-includes */
#include <pthread.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _PTHREAD_H
#define _PTHREAD_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 23 "/usr/include/pthread.h" 3 4
# 24 "/usr/include/pthread.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <endian.h>
#endif /* expanded by -frewrite-includes */
# 24 "/usr/include/pthread.h" 3 4
# 25 "/usr/include/pthread.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <sched.h>
#endif /* expanded by -frewrite-includes */
# 25 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996,1997,1999,2001-2004,2007,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef	_SCHED_H
#define	_SCHED_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 24 "/usr/include/sched.h" 3 4
# 25 "/usr/include/sched.h" 3 4

/* Get type definitions.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/sched.h" 3 4
# 28 "/usr/include/sched.h" 3 4

#define __need_size_t
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 30 "/usr/include/sched.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 31 "/usr/include/sched.h" 2 3 4

#define __need_time_t
#define __need_timespec
#if 0 /* expanded by -frewrite-includes */
#include <time.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/sched.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2003,2006,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */

#ifndef	_TIME_H

#if (! defined __need_time_t && !defined __need_clock_t && \
     ! defined __need_timespec)
# define _TIME_H	1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/time.h" 3 4
# 29 "/usr/include/time.h" 3 4

__BEGIN_DECLS

#endif
# 33 "/usr/include/time.h" 3 4

#ifdef	_TIME_H
/* Get size_t and NULL from <stddef.h>.  */
# define __need_size_t
# define __need_NULL
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/time.h" 3 4
# 39 "/usr/include/time.h" 3 4

/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */
#if 0 /* expanded by -frewrite-includes */
# include <bits/time.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/time.h" 3 4
# 43 "/usr/include/time.h" 3 4

/* This is the obsolete POSIX.1-1988 name for the same constant.  */
# if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
#  ifndef CLK_TCK
#   define CLK_TCK	CLOCKS_PER_SEC
#  endif
# 49 "/usr/include/time.h" 3 4
# endif
# 50 "/usr/include/time.h" 3 4

#endif /* <time.h> included.  */
# 52 "/usr/include/time.h" 3 4

#if !defined __clock_t_defined && (defined _TIME_H || defined __need_clock_t)
# define __clock_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 56 "/usr/include/time.h" 3 4
# 57 "/usr/include/time.h" 3 4

__BEGIN_NAMESPACE_STD
/* Returned by `clock'.  */
typedef __clock_t clock_t;
__END_NAMESPACE_STD
#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
__USING_NAMESPACE_STD(clock_t)
#endif
# 65 "/usr/include/time.h" 3 4

#endif /* clock_t not defined and <time.h> or need clock_t.  */
# 67 "/usr/include/time.h" 3 4
#undef	__need_clock_t

#if !defined __time_t_defined && (defined _TIME_H || defined __need_time_t)
# define __time_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 72 "/usr/include/time.h" 3 4
# 73 "/usr/include/time.h" 3 4

__BEGIN_NAMESPACE_STD
/* Returned by `time'.  */
typedef __time_t time_t;
__END_NAMESPACE_STD
#if defined __USE_POSIX || defined __USE_MISC || defined __USE_SVID
__USING_NAMESPACE_STD(time_t)
#endif
# 81 "/usr/include/time.h" 3 4

#endif /* time_t not defined and <time.h> or need time_t.  */
# 83 "/usr/include/time.h" 3 4
#undef	__need_time_t

#if !defined __clockid_t_defined && \
   ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_clockid_t)
# define __clockid_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 89 "/usr/include/time.h" 3 4
# 90 "/usr/include/time.h" 3 4

/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;

#endif /* clockid_t not defined and <time.h> or need clockid_t.  */
# 95 "/usr/include/time.h" 3 4
#undef	__clockid_time_t

#if !defined __timer_t_defined && \
    ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_timer_t)
# define __timer_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 101 "/usr/include/time.h" 3 4
# 102 "/usr/include/time.h" 3 4

/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;

#endif /* timer_t not defined and <time.h> or need timer_t.  */
# 107 "/usr/include/time.h" 3 4
#undef	__need_timer_t


#if !defined __timespec_defined &&				\
    ((defined _TIME_H &&					\
      (defined __USE_POSIX199309 || defined __USE_MISC)) ||	\
      defined __need_timespec)
# define __timespec_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>	/* This defines __time_t for us.  */
#endif /* expanded by -frewrite-includes */
# 116 "/usr/include/time.h" 3 4
# 117 "/usr/include/time.h" 3 4

/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */
struct timespec
  {
    __time_t tv_sec;		/* Seconds.  */
    long int tv_nsec;		/* Nanoseconds.  */
  };

#endif /* timespec not defined and <time.h> or need timespec.  */
# 127 "/usr/include/time.h" 3 4
#undef	__need_timespec


#ifdef	_TIME_H
__BEGIN_NAMESPACE_STD
/* Used by other time functions.  */
struct tm
{
  int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
  int tm_min;			/* Minutes.	[0-59] */
  int tm_hour;			/* Hours.	[0-23] */
  int tm_mday;			/* Day.		[1-31] */
  int tm_mon;			/* Month.	[0-11] */
  int tm_year;			/* Year	- 1900.  */
  int tm_wday;			/* Day of week.	[0-6] */
  int tm_yday;			/* Days in year.[0-365]	*/
  int tm_isdst;			/* DST.		[-1/0/1]*/

#ifdef	__USE_BSD
  long int tm_gmtoff;		/* Seconds east of UTC.  */
  __const char *tm_zone;	/* Timezone abbreviation.  */
#else
# 149 "/usr/include/time.h" 3 4
  long int __tm_gmtoff;		/* Seconds east of UTC.  */
  __const char *__tm_zone;	/* Timezone abbreviation.  */
#endif
# 152 "/usr/include/time.h" 3 4
};
__END_NAMESPACE_STD
#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
__USING_NAMESPACE_STD(tm)
#endif
# 157 "/usr/include/time.h" 3 4


#ifdef __USE_POSIX199309
/* POSIX.1b structure for timer start values and intervals.  */
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };

/* We can use a simple forward declaration.  */
struct sigevent;

#endif	/* POSIX.1b */
# 171 "/usr/include/time.h" 3 4

#ifdef __USE_XOPEN2K
# ifndef __pid_t_defined
typedef __pid_t pid_t;
#  define __pid_t_defined
# endif
# 177 "/usr/include/time.h" 3 4
#endif
# 178 "/usr/include/time.h" 3 4


__BEGIN_NAMESPACE_STD
/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) __THROW;

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) __THROW;

/* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)
     __THROW __attribute__ ((__const__));

/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) __THROW;


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
			__const char *__restrict __format,
			__const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_STD

# ifdef __USE_XOPEN
/* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  */
extern char *strptime (__const char *__restrict __s,
		       __const char *__restrict __fmt, struct tm *__tp)
     __THROW;
# endif
# 211 "/usr/include/time.h" 3 4

# ifdef __USE_XOPEN2K8
/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 215 "/usr/include/time.h" 3 4
# 216 "/usr/include/time.h" 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
			  __const char *__restrict __format,
			  __const struct tm *__restrict __tp,
			  __locale_t __loc) __THROW;
# endif
# 222 "/usr/include/time.h" 3 4

# ifdef __USE_GNU
extern char *strptime_l (__const char *__restrict __s,
			 __const char *__restrict __fmt, struct tm *__tp,
			 __locale_t __loc) __THROW;
# endif
# 228 "/usr/include/time.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (__const time_t *__timer) __THROW;

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (__const time_t *__timer) __THROW;
__END_NAMESPACE_STD

# if defined __USE_POSIX || defined __USE_MISC
/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
extern struct tm *gmtime_r (__const time_t *__restrict __timer,
			    struct tm *__restrict __tp) __THROW;

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (__const time_t *__restrict __timer,
			       struct tm *__restrict __tp) __THROW;
# endif	/* POSIX or misc */
# 251 "/usr/include/time.h" 3 4

__BEGIN_NAMESPACE_STD
/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (__const struct tm *__tp) __THROW;

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (__const time_t *__timer) __THROW;
__END_NAMESPACE_STD

# if defined __USE_POSIX || defined __USE_MISC
/* Reentrant versions of the above functions.  */

/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime_r (__const struct tm *__restrict __tp,
			char *__restrict __buf) __THROW;

/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
extern char *ctime_r (__const time_t *__restrict __timer,
		      char *__restrict __buf) __THROW;
# endif	/* POSIX or misc */
# 273 "/usr/include/time.h" 3 4


/* Defined in localtime.c.  */
extern char *__tzname[2];	/* Current timezone names.  */
extern int __daylight;		/* If daylight-saving time is ever in use.  */
extern long int __timezone;	/* Seconds west of UTC.  */


# ifdef	__USE_POSIX
/* Same as above.  */
extern char *tzname[2];

/* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  */
extern void tzset (void) __THROW;
# endif
# 289 "/usr/include/time.h" 3 4

# if defined __USE_SVID || defined __USE_XOPEN
extern int daylight;
extern long int timezone;
# endif
# 294 "/usr/include/time.h" 3 4

# ifdef __USE_SVID
/* Set the system time to *WHEN.
   This call is restricted to the superuser.  */
extern int stime (__const time_t *__when) __THROW;
# endif
# 300 "/usr/include/time.h" 3 4


/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
# define __isleap(year)	\
  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))


# ifdef __USE_MISC
/* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  */

/* Like `mktime', but for TP represents Universal Time, not local time.  */
extern time_t timegm (struct tm *__tp) __THROW;

/* Another name for `mktime'.  */
extern time_t timelocal (struct tm *__tp) __THROW;

/* Return the number of days in YEAR.  */
extern int dysize (int __year) __THROW  __attribute__ ((__const__));
# endif
# 321 "/usr/include/time.h" 3 4


# ifdef __USE_POSIX199309
/* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int nanosleep (__const struct timespec *__requested_time,
		      struct timespec *__remaining);


/* Get resolution of clock CLOCK_ID.  */
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __THROW;

/* Get current value of clock CLOCK_ID and store it in TP.  */
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __THROW;

/* Set clock CLOCK_ID to value TP.  */
extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __THROW;

#  ifdef __USE_XOPEN2K
/* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
			    __const struct timespec *__req,
			    struct timespec *__rem);

/* Return clock ID for CPU-time clock.  */
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __THROW;
#  endif
# 354 "/usr/include/time.h" 3 4


/* Create new per-process timer using CLOCK_ID.  */
extern int timer_create (clockid_t __clock_id,
			 struct sigevent *__restrict __evp,
			 timer_t *__restrict __timerid) __THROW;

/* Delete timer TIMERID.  */
extern int timer_delete (timer_t __timerid) __THROW;

/* Set timer TIMERID to VALUE, returning old value in OVLAUE.  */
extern int timer_settime (timer_t __timerid, int __flags,
			  __const struct itimerspec *__restrict __value,
			  struct itimerspec *__restrict __ovalue) __THROW;

/* Get current value of timer TIMERID and store it in VLAUE.  */
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __THROW;

/* Get expiration overrun for timer TIMERID.  */
extern int timer_getoverrun (timer_t __timerid) __THROW;
# endif
# 376 "/usr/include/time.h" 3 4


# ifdef __USE_XOPEN_EXTENDED
/* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
        specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) */
extern int getdate_err;

/* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern struct tm *getdate (__const char *__string);
# endif
# 401 "/usr/include/time.h" 3 4

# ifdef __USE_GNU
/* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getdate_r (__const char *__restrict __string,
		      struct tm *__restrict __resbufp);
# endif
# 416 "/usr/include/time.h" 3 4

__END_DECLS

#endif /* <time.h> included.  */
# 420 "/usr/include/time.h" 3 4

#endif /* <time.h> not already included.  */
# 422 "/usr/include/time.h" 3 4
# 35 "/usr/include/sched.h" 2 3 4

#ifndef __pid_t_defined
typedef __pid_t pid_t;
# define __pid_t_defined
#endif
# 40 "/usr/include/sched.h" 3 4


/* Get system specific constant and data structure definitions.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/sched.h>
#endif /* expanded by -frewrite-includes */
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
/* Definitions of constants and data structure for POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-1999,2001-2003,2005,2006,2007,2008,2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef __need_schedparam

#ifndef _SCHED_H
# error "Never include <bits/sched.h> directly; use <sched.h> instead."
#endif
# 27 "/usr/include/bits/sched.h" 3 4


/* Scheduling algorithms.  */
#define SCHED_OTHER		0
#define SCHED_FIFO		1
#define SCHED_RR		2
#ifdef __USE_GNU
# define SCHED_BATCH		3
# define SCHED_IDLE		5

# define SCHED_RESET_ON_FORK	0x40000000
#endif
# 39 "/usr/include/bits/sched.h" 3 4

#ifdef __USE_MISC
/* Cloning flags.  */
# define CSIGNAL       0x000000ff /* Signal mask to be sent at exit.  */
# define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
# define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
# define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
# define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
# define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
# define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
				     wake it up on mm_release.  */
# define CLONE_PARENT  0x00008000 /* Set if we want to have the same
				     parent as the cloner.  */
# define CLONE_THREAD  0x00010000 /* Set to add to same thread group.  */
# define CLONE_NEWNS   0x00020000 /* Set to create new namespace.  */
# define CLONE_SYSVSEM 0x00040000 /* Set to shared SVID SEM_UNDO semantics.  */
# define CLONE_SETTLS  0x00080000 /* Set TLS info.  */
# define CLONE_PARENT_SETTID 0x00100000 /* Store TID in userlevel buffer
					   before MM copy.  */
# define CLONE_CHILD_CLEARTID 0x00200000 /* Register exit futex and memory
					    location to clear.  */
# define CLONE_DETACHED 0x00400000 /* Create clone detached.  */
# define CLONE_UNTRACED 0x00800000 /* Set if the tracing process can't
				      force CLONE_PTRACE on this clone.  */
# define CLONE_CHILD_SETTID 0x01000000 /* Store TID in userlevel buffer in
					  the child.  */
# define CLONE_NEWUTS	0x04000000	/* New utsname group.  */
# define CLONE_NEWIPC	0x08000000	/* New ipcs.  */
# define CLONE_NEWUSER	0x10000000	/* New user namespace.  */
# define CLONE_NEWPID	0x20000000	/* New pid namespace.  */
# define CLONE_NEWNET	0x40000000	/* New network namespace.  */
# define CLONE_IO	0x80000000	/* Clone I/O context.  */
#endif
# 72 "/usr/include/bits/sched.h" 3 4

/* The official definition.  */
struct sched_param
  {
    int __sched_priority;
  };

__BEGIN_DECLS

#ifdef __USE_MISC
/* Clone current process.  */
extern int clone (int (*__fn) (void *__arg), void *__child_stack,
		  int __flags, void *__arg, ...) __THROW;

/* Unshare the specified resources.  */
extern int unshare (int __flags) __THROW;

/* Get index of currently used CPU.  */
extern int sched_getcpu (void) __THROW;
#endif
# 92 "/usr/include/bits/sched.h" 3 4

__END_DECLS

#endif	/* need schedparam */
# 96 "/usr/include/bits/sched.h" 3 4

#if !defined __defined_schedparam \
    && (defined __need_schedparam || defined _SCHED_H)
# define __defined_schedparam	1
/* Data structure to describe a process' schedulability.  */
struct __sched_param
  {
    int __sched_priority;
  };
# undef __need_schedparam
#endif
# 107 "/usr/include/bits/sched.h" 3 4


#if defined _SCHED_H && !defined __cpu_set_t_defined
# define __cpu_set_t_defined
/* Size definition for CPU sets.  */
# define __CPU_SETSIZE	1024
# define __NCPUBITS	(8 * sizeof (__cpu_mask))

/* Type for array elements in 'cpu_set_t'.  */
typedef unsigned long int __cpu_mask;

/* Basic access functions.  */
# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))

/* Data structure to describe CPU mask.  */
typedef struct
{
  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
} cpu_set_t;

/* Access functions for CPU masks.  */
# if __GNUC_PREREQ (2, 91)
#  define __CPU_ZERO_S(setsize, cpusetp) \
  do __builtin_memset (cpusetp, '\0', setsize); while (0)
# else
# 133 "/usr/include/bits/sched.h" 3 4
#  define __CPU_ZERO_S(setsize, cpusetp) \
  do {									      \
    size_t __i;								      \
    size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
    __cpu_mask *__bits = (cpusetp)->__bits;				      \
    for (__i = 0; __i < __imax; ++__i)					      \
      __bits[__i] = 0;							      \
  } while (0)
# endif
# 142 "/usr/include/bits/sched.h" 3 4
# define __CPU_SET_S(cpu, setsize, cpusetp) \
  (__extension__							      \
   ({ size_t __cpu = (cpu);						      \
      __cpu < 8 * (setsize)						      \
      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
	 |= __CPUMASK (__cpu))						      \
      : 0; }))
# define __CPU_CLR_S(cpu, setsize, cpusetp) \
  (__extension__							      \
   ({ size_t __cpu = (cpu);						      \
      __cpu < 8 * (setsize)						      \
      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
	 &= ~__CPUMASK (__cpu))						      \
      : 0; }))
# define __CPU_ISSET_S(cpu, setsize, cpusetp) \
  (__extension__							      \
   ({ size_t __cpu = (cpu);						      \
      __cpu < 8 * (setsize)						      \
      ? ((((__const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]      \
	  & __CPUMASK (__cpu))) != 0					      \
      : 0; }))

# define __CPU_COUNT_S(setsize, cpusetp) \
  __sched_cpucount (setsize, cpusetp)

# if __GNUC_PREREQ (2, 91)
#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
  (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
# else
# 171 "/usr/include/bits/sched.h" 3 4
#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
  (__extension__							      \
   ({ __const __cpu_mask *__arr1 = (cpusetp1)->__bits;			      \
      __const __cpu_mask *__arr2 = (cpusetp2)->__bits;			      \
      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
      size_t __i;							      \
      for (__i = 0; __i < __imax; ++__i)				      \
	if (__bits[__i] != __bits[__i])					      \
	  break;							      \
      __i == __imax; }))
# endif
# 182 "/usr/include/bits/sched.h" 3 4

# define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) \
  (__extension__							      \
   ({ cpu_set_t *__dest = (destset);					      \
      __const __cpu_mask *__arr1 = (srcset1)->__bits;			      \
      __const __cpu_mask *__arr2 = (srcset2)->__bits;			      \
      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
      size_t __i;							      \
      for (__i = 0; __i < __imax; ++__i)				      \
	((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i];    \
      __dest; }))

# define __CPU_ALLOC_SIZE(count) \
  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))
# define __CPU_ALLOC(count) __sched_cpualloc (count)
# define __CPU_FREE(cpuset) __sched_cpufree (cpuset)

__BEGIN_DECLS

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  __THROW;
extern cpu_set_t *__sched_cpualloc (size_t __count) __THROW __wur;
extern void __sched_cpufree (cpu_set_t *__set) __THROW;

__END_DECLS

#endif
# 209 "/usr/include/bits/sched.h" 3 4
# 44 "/usr/include/sched.h" 2 3 4
/* Define the real names for the elements of `struct sched_param'.  */
#define sched_priority	__sched_priority


__BEGIN_DECLS

/* Set scheduling parameters for a process.  */
extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     __THROW;

/* Retrieve scheduling parameters for a particular process.  */
extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __THROW;

/* Set scheduling algorithm and/or parameters for a process.  */
extern int sched_setscheduler (__pid_t __pid, int __policy,
			       __const struct sched_param *__param) __THROW;

/* Retrieve scheduling algorithm for a particular purpose.  */
extern int sched_getscheduler (__pid_t __pid) __THROW;

/* Yield the processor.  */
extern int sched_yield (void) __THROW;

/* Get maximum priority value for a scheduler.  */
extern int sched_get_priority_max (int __algorithm) __THROW;

/* Get minimum priority value for a scheduler.  */
extern int sched_get_priority_min (int __algorithm) __THROW;

/* Get the SCHED_RR interval for the named process.  */
extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __THROW;


#ifdef __USE_GNU
/* Access macros for `cpu_set'.  */
# define CPU_SETSIZE __CPU_SETSIZE
# define CPU_SET(cpu, cpusetp)	 __CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)
# define CPU_CLR(cpu, cpusetp)	 __CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)
# define CPU_ISSET(cpu, cpusetp) __CPU_ISSET_S (cpu, sizeof (cpu_set_t), \
						cpusetp)
# define CPU_ZERO(cpusetp)	 __CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)
# define CPU_COUNT(cpusetp)	 __CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)

# define CPU_SET_S(cpu, setsize, cpusetp)   __CPU_SET_S (cpu, setsize, cpusetp)
# define CPU_CLR_S(cpu, setsize, cpusetp)   __CPU_CLR_S (cpu, setsize, cpusetp)
# define CPU_ISSET_S(cpu, setsize, cpusetp) __CPU_ISSET_S (cpu, setsize, \
							   cpusetp)
# define CPU_ZERO_S(setsize, cpusetp)	    __CPU_ZERO_S (setsize, cpusetp)
# define CPU_COUNT_S(setsize, cpusetp)	    __CPU_COUNT_S (setsize, cpusetp)

# define CPU_EQUAL(cpusetp1, cpusetp2) \
  __CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)
# define CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
  __CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)

# define CPU_AND(destset, srcset1, srcset2) \
  __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)
# define CPU_OR(destset, srcset1, srcset2) \
  __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)
# define CPU_XOR(destset, srcset1, srcset2) \
  __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)
# define CPU_AND_S(setsize, destset, srcset1, srcset2) \
  __CPU_OP_S (setsize, destset, srcset1, srcset2, &)
# define CPU_OR_S(setsize, destset, srcset1, srcset2) \
  __CPU_OP_S (setsize, destset, srcset1, srcset2, |)
# define CPU_XOR_S(setsize, destset, srcset1, srcset2) \
  __CPU_OP_S (setsize, destset, srcset1, srcset2, ^)

# define CPU_ALLOC_SIZE(count) __CPU_ALLOC_SIZE (count)
# define CPU_ALLOC(count) __CPU_ALLOC (count)
# define CPU_FREE(cpuset) __CPU_FREE (cpuset)


/* Set the CPU affinity for a task */
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
			      __const cpu_set_t *__cpuset) __THROW;

/* Get the CPU affinity for a task */
extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
			      cpu_set_t *__cpuset) __THROW;
#endif
# 125 "/usr/include/sched.h" 3 4

__END_DECLS

#endif /* sched.h */
# 129 "/usr/include/sched.h" 3 4
# 26 "/usr/include/pthread.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <time.h>
#endif /* expanded by -frewrite-includes */
# 26 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
/* Copyright (C) 1991-2003,2006,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */

#ifndef	_TIME_H

#if (! defined __need_time_t && !defined __need_clock_t && \
     ! defined __need_timespec)
# define _TIME_H	1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/time.h" 3 4
# 29 "/usr/include/time.h" 3 4

__BEGIN_DECLS

#endif
# 33 "/usr/include/time.h" 3 4

#ifdef	_TIME_H
/* Get size_t and NULL from <stddef.h>.  */
# define __need_size_t
# define __need_NULL
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 38 "/usr/include/time.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 39 "/usr/include/time.h" 2 3 4

/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */
#if 0 /* expanded by -frewrite-includes */
# include <bits/time.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Generic version.
   Copyright (C) 1996,1997,1999-2002,2003,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <time.h> instead.
 */

#ifndef __need_timeval
# ifndef _BITS_TIME_H
#  define _BITS_TIME_H	1

/* ISO/IEC 9899:1990 7.12.1: <time.h>
   The macro `CLOCKS_PER_SEC' is the number per second of the value
   returned by the `clock' function. */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
#  define CLOCKS_PER_SEC  1000000l

#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
   presents the real value for clock ticks per second for the system.  */
#if 0 /* expanded by -frewrite-includes */
#   include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/bits/time.h" 3 4
# 40 "/usr/include/bits/time.h" 3 4
extern long int __sysconf (int);
#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
#  endif
# 43 "/usr/include/bits/time.h" 3 4

#  ifdef __USE_POSIX199309
/* Identifier for system-wide realtime clock.  */
#   define CLOCK_REALTIME		0
/* Monotonic system-wide clock.  */
#   define CLOCK_MONOTONIC		1
/* High-resolution timer from the CPU.  */
#   define CLOCK_PROCESS_CPUTIME_ID	2
/* Thread-specific CPU-time clock.  */
#   define CLOCK_THREAD_CPUTIME_ID	3
/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
#   define CLOCK_MONOTONIC_RAW		4
/* Identifier for system-wide realtime clock, updated only on ticks.  */
#   define CLOCK_REALTIME_COARSE	5
/* Monotonic system-wide clock, updated only on ticks.  */
#   define CLOCK_MONOTONIC_COARSE	6

/* Flag to indicate time is absolute.  */
#   define TIMER_ABSTIME		1
#  endif
# 63 "/usr/include/bits/time.h" 3 4

# endif	/* bits/time.h */
# 65 "/usr/include/bits/time.h" 3 4
#endif
# 66 "/usr/include/bits/time.h" 3 4

#ifdef __need_timeval
# undef __need_timeval
# ifndef _STRUCT_TIMEVAL
#  define _STRUCT_TIMEVAL	1
#if 0 /* expanded by -frewrite-includes */
#  include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 71 "/usr/include/bits/time.h" 3 4
# 72 "/usr/include/bits/time.h" 3 4

/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec;		/* Seconds.  */
    __suseconds_t tv_usec;	/* Microseconds.  */
  };
# endif	/* struct timeval */
# 81 "/usr/include/bits/time.h" 3 4
#endif	/* need timeval */
# 82 "/usr/include/bits/time.h" 3 4
# 43 "/usr/include/time.h" 2 3 4

/* This is the obsolete POSIX.1-1988 name for the same constant.  */
# if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
#  ifndef CLK_TCK
#   define CLK_TCK	CLOCKS_PER_SEC
#  endif
# 49 "/usr/include/time.h" 3 4
# endif
# 50 "/usr/include/time.h" 3 4

#endif /* <time.h> included.  */
# 52 "/usr/include/time.h" 3 4

#if !defined __clock_t_defined && (defined _TIME_H || defined __need_clock_t)
# define __clock_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 56 "/usr/include/time.h" 3 4
# 57 "/usr/include/time.h" 3 4

__BEGIN_NAMESPACE_STD
/* Returned by `clock'.  */
typedef __clock_t clock_t;
__END_NAMESPACE_STD
#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
__USING_NAMESPACE_STD(clock_t)
#endif
# 65 "/usr/include/time.h" 3 4

#endif /* clock_t not defined and <time.h> or need clock_t.  */
# 67 "/usr/include/time.h" 3 4
#undef	__need_clock_t

#if !defined __time_t_defined && (defined _TIME_H || defined __need_time_t)
# define __time_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 72 "/usr/include/time.h" 3 4
# 73 "/usr/include/time.h" 3 4

__BEGIN_NAMESPACE_STD
/* Returned by `time'.  */
typedef __time_t time_t;
__END_NAMESPACE_STD
#if defined __USE_POSIX || defined __USE_MISC || defined __USE_SVID
__USING_NAMESPACE_STD(time_t)
#endif
# 81 "/usr/include/time.h" 3 4

#endif /* time_t not defined and <time.h> or need time_t.  */
# 83 "/usr/include/time.h" 3 4
#undef	__need_time_t

#if !defined __clockid_t_defined && \
   ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_clockid_t)
# define __clockid_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 89 "/usr/include/time.h" 3 4
# 90 "/usr/include/time.h" 3 4

/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;

#endif /* clockid_t not defined and <time.h> or need clockid_t.  */
# 95 "/usr/include/time.h" 3 4
#undef	__clockid_time_t

#if !defined __timer_t_defined && \
    ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_timer_t)
# define __timer_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 101 "/usr/include/time.h" 3 4
# 102 "/usr/include/time.h" 3 4

/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;

#endif /* timer_t not defined and <time.h> or need timer_t.  */
# 107 "/usr/include/time.h" 3 4
#undef	__need_timer_t


#if !defined __timespec_defined &&				\
    ((defined _TIME_H &&					\
      (defined __USE_POSIX199309 || defined __USE_MISC)) ||	\
      defined __need_timespec)
# define __timespec_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>	/* This defines __time_t for us.  */
#endif /* expanded by -frewrite-includes */
# 116 "/usr/include/time.h" 3 4
# 117 "/usr/include/time.h" 3 4

/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */
struct timespec
  {
    __time_t tv_sec;		/* Seconds.  */
    long int tv_nsec;		/* Nanoseconds.  */
  };

#endif /* timespec not defined and <time.h> or need timespec.  */
# 127 "/usr/include/time.h" 3 4
#undef	__need_timespec


#ifdef	_TIME_H
__BEGIN_NAMESPACE_STD
/* Used by other time functions.  */
struct tm
{
  int tm_sec;			/* Seconds.	[0-60] (1 leap second) */
  int tm_min;			/* Minutes.	[0-59] */
  int tm_hour;			/* Hours.	[0-23] */
  int tm_mday;			/* Day.		[1-31] */
  int tm_mon;			/* Month.	[0-11] */
  int tm_year;			/* Year	- 1900.  */
  int tm_wday;			/* Day of week.	[0-6] */
  int tm_yday;			/* Days in year.[0-365]	*/
  int tm_isdst;			/* DST.		[-1/0/1]*/

#ifdef	__USE_BSD
  long int tm_gmtoff;		/* Seconds east of UTC.  */
  __const char *tm_zone;	/* Timezone abbreviation.  */
#else
# 149 "/usr/include/time.h" 3 4
  long int __tm_gmtoff;		/* Seconds east of UTC.  */
  __const char *__tm_zone;	/* Timezone abbreviation.  */
#endif
# 152 "/usr/include/time.h" 3 4
};
__END_NAMESPACE_STD
#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
__USING_NAMESPACE_STD(tm)
#endif
# 157 "/usr/include/time.h" 3 4


#ifdef __USE_POSIX199309
/* POSIX.1b structure for timer start values and intervals.  */
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };

/* We can use a simple forward declaration.  */
struct sigevent;

#endif	/* POSIX.1b */
# 171 "/usr/include/time.h" 3 4

#ifdef __USE_XOPEN2K
# ifndef __pid_t_defined
typedef __pid_t pid_t;
#  define __pid_t_defined
# endif
# 177 "/usr/include/time.h" 3 4
#endif
# 178 "/usr/include/time.h" 3 4


__BEGIN_NAMESPACE_STD
/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) __THROW;

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) __THROW;

/* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)
     __THROW __attribute__ ((__const__));

/* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) __THROW;


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
			__const char *__restrict __format,
			__const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_STD

# ifdef __USE_XOPEN
/* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  */
extern char *strptime (__const char *__restrict __s,
		       __const char *__restrict __fmt, struct tm *__tp)
     __THROW;
# endif
# 211 "/usr/include/time.h" 3 4

# ifdef __USE_XOPEN2K8
/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 215 "/usr/include/time.h" 3 4
# 216 "/usr/include/time.h" 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
			  __const char *__restrict __format,
			  __const struct tm *__restrict __tp,
			  __locale_t __loc) __THROW;
# endif
# 222 "/usr/include/time.h" 3 4

# ifdef __USE_GNU
extern char *strptime_l (__const char *__restrict __s,
			 __const char *__restrict __fmt, struct tm *__tp,
			 __locale_t __loc) __THROW;
# endif
# 228 "/usr/include/time.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (__const time_t *__timer) __THROW;

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (__const time_t *__timer) __THROW;
__END_NAMESPACE_STD

# if defined __USE_POSIX || defined __USE_MISC
/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
extern struct tm *gmtime_r (__const time_t *__restrict __timer,
			    struct tm *__restrict __tp) __THROW;

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (__const time_t *__restrict __timer,
			       struct tm *__restrict __tp) __THROW;
# endif	/* POSIX or misc */
# 251 "/usr/include/time.h" 3 4

__BEGIN_NAMESPACE_STD
/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (__const struct tm *__tp) __THROW;

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (__const time_t *__timer) __THROW;
__END_NAMESPACE_STD

# if defined __USE_POSIX || defined __USE_MISC
/* Reentrant versions of the above functions.  */

/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime_r (__const struct tm *__restrict __tp,
			char *__restrict __buf) __THROW;

/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
extern char *ctime_r (__const time_t *__restrict __timer,
		      char *__restrict __buf) __THROW;
# endif	/* POSIX or misc */
# 273 "/usr/include/time.h" 3 4


/* Defined in localtime.c.  */
extern char *__tzname[2];	/* Current timezone names.  */
extern int __daylight;		/* If daylight-saving time is ever in use.  */
extern long int __timezone;	/* Seconds west of UTC.  */


# ifdef	__USE_POSIX
/* Same as above.  */
extern char *tzname[2];

/* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  */
extern void tzset (void) __THROW;
# endif
# 289 "/usr/include/time.h" 3 4

# if defined __USE_SVID || defined __USE_XOPEN
extern int daylight;
extern long int timezone;
# endif
# 294 "/usr/include/time.h" 3 4

# ifdef __USE_SVID
/* Set the system time to *WHEN.
   This call is restricted to the superuser.  */
extern int stime (__const time_t *__when) __THROW;
# endif
# 300 "/usr/include/time.h" 3 4


/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
# define __isleap(year)	\
  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))


# ifdef __USE_MISC
/* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  */

/* Like `mktime', but for TP represents Universal Time, not local time.  */
extern time_t timegm (struct tm *__tp) __THROW;

/* Another name for `mktime'.  */
extern time_t timelocal (struct tm *__tp) __THROW;

/* Return the number of days in YEAR.  */
extern int dysize (int __year) __THROW  __attribute__ ((__const__));
# endif
# 321 "/usr/include/time.h" 3 4


# ifdef __USE_POSIX199309
/* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int nanosleep (__const struct timespec *__requested_time,
		      struct timespec *__remaining);


/* Get resolution of clock CLOCK_ID.  */
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __THROW;

/* Get current value of clock CLOCK_ID and store it in TP.  */
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __THROW;

/* Set clock CLOCK_ID to value TP.  */
extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     __THROW;

#  ifdef __USE_XOPEN2K
/* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
			    __const struct timespec *__req,
			    struct timespec *__rem);

/* Return clock ID for CPU-time clock.  */
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __THROW;
#  endif
# 354 "/usr/include/time.h" 3 4


/* Create new per-process timer using CLOCK_ID.  */
extern int timer_create (clockid_t __clock_id,
			 struct sigevent *__restrict __evp,
			 timer_t *__restrict __timerid) __THROW;

/* Delete timer TIMERID.  */
extern int timer_delete (timer_t __timerid) __THROW;

/* Set timer TIMERID to VALUE, returning old value in OVLAUE.  */
extern int timer_settime (timer_t __timerid, int __flags,
			  __const struct itimerspec *__restrict __value,
			  struct itimerspec *__restrict __ovalue) __THROW;

/* Get current value of timer TIMERID and store it in VLAUE.  */
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __THROW;

/* Get expiration overrun for timer TIMERID.  */
extern int timer_getoverrun (timer_t __timerid) __THROW;
# endif
# 376 "/usr/include/time.h" 3 4


# ifdef __USE_XOPEN_EXTENDED
/* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
        specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) */
extern int getdate_err;

/* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern struct tm *getdate (__const char *__string);
# endif
# 401 "/usr/include/time.h" 3 4

# ifdef __USE_GNU
/* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int getdate_r (__const char *__restrict __string,
		      struct tm *__restrict __resbufp);
# endif
# 416 "/usr/include/time.h" 3 4

__END_DECLS

#endif /* <time.h> included.  */
# 420 "/usr/include/time.h" 3 4

#endif /* <time.h> not already included.  */
# 422 "/usr/include/time.h" 3 4
# 27 "/usr/include/pthread.h" 2 3 4

#if 0 /* expanded by -frewrite-includes */
#include <bits/pthreadtypes.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _BITS_PTHREADTYPES_H
#define _BITS_PTHREADTYPES_H	1

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4

#if __WORDSIZE == 64
# define __SIZEOF_PTHREAD_ATTR_T 56
# define __SIZEOF_PTHREAD_MUTEX_T 40
# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
# define __SIZEOF_PTHREAD_COND_T 48
# define __SIZEOF_PTHREAD_CONDATTR_T 4
# define __SIZEOF_PTHREAD_RWLOCK_T 56
# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
# define __SIZEOF_PTHREAD_BARRIER_T 32
# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
#else
# 36 "/usr/include/bits/pthreadtypes.h" 3 4
# define __SIZEOF_PTHREAD_ATTR_T 36
# define __SIZEOF_PTHREAD_MUTEX_T 24
# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
# define __SIZEOF_PTHREAD_COND_T 48
# define __SIZEOF_PTHREAD_CONDATTR_T 4
# define __SIZEOF_PTHREAD_RWLOCK_T 32
# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
# define __SIZEOF_PTHREAD_BARRIER_T 20
# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
#endif
# 46 "/usr/include/bits/pthreadtypes.h" 3 4


/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef unsigned long int pthread_t;


typedef union
{
  char __size[__SIZEOF_PTHREAD_ATTR_T];
  long int __align;
} pthread_attr_t;


#if __WORDSIZE == 64
typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
#else
# 67 "/usr/include/bits/pthreadtypes.h" 3 4
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
#endif
# 72 "/usr/include/bits/pthreadtypes.h" 3 4


/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;
#if __WORDSIZE == 64
    unsigned int __nusers;
#endif
# 86 "/usr/include/bits/pthreadtypes.h" 3 4
    /* KIND must stay at this position in the structure to maintain
       binary compatibility.  */
    int __kind;
#if __WORDSIZE == 64
    int __spins;
    __pthread_list_t __list;
# define __PTHREAD_MUTEX_HAVE_PREV	1
#else
# 94 "/usr/include/bits/pthreadtypes.h" 3 4
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
#endif
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[__SIZEOF_PTHREAD_MUTEX_T];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
  int __align;
} pthread_mutexattr_t;


/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[__SIZEOF_PTHREAD_COND_T];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
  int __align;
} pthread_condattr_t;


/* Keys for thread-specific data */
typedef unsigned int pthread_key_t;


/* Once-only execution */
typedef int pthread_once_t;


#if defined __USE_UNIX98 || defined __USE_XOPEN2K
/* Data structure for read-write lock variable handling.  The
   structure of the attribute type is not exposed on purpose.  */
typedef union
{
# if __WORDSIZE == 64
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned int __flags;
  } __data;
# else
# 170 "/usr/include/bits/pthreadtypes.h" 3 4
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
# endif
# 187 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
  long int __align;
} pthread_rwlockattr_t;
#endif
# 197 "/usr/include/bits/pthreadtypes.h" 3 4


#ifdef __USE_XOPEN2K
/* POSIX spinlock data type.  */
typedef volatile int pthread_spinlock_t;


/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  */
typedef union
{
  char __size[__SIZEOF_PTHREAD_BARRIER_T];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
  int __align;
} pthread_barrierattr_t;
#endif
# 218 "/usr/include/bits/pthreadtypes.h" 3 4


#if __WORDSIZE == 32
/* Extra attributes for the cleanup functions.  */
# define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
#endif
# 224 "/usr/include/bits/pthreadtypes.h" 3 4

#endif	/* bits/pthreadtypes.h */
# 226 "/usr/include/bits/pthreadtypes.h" 3 4
# 29 "/usr/include/pthread.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <bits/setjmp.h>
#endif /* expanded by -frewrite-includes */
# 29 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
/* Copyright (C) 2001,2002,2003,2005,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* Define the machine-dependent type `jmp_buf'.  x86-64 version.  */
#ifndef _BITS_SETJMP_H
#define _BITS_SETJMP_H  1

#if !defined _SETJMP_H && !defined _PTHREAD_H
# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
#endif
# 26 "/usr/include/bits/setjmp.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4

#ifndef _ASM

# if __WORDSIZE == 64
typedef long int __jmp_buf[8];
# else
# 34 "/usr/include/bits/setjmp.h" 3 4
typedef int __jmp_buf[6];
# endif
# 36 "/usr/include/bits/setjmp.h" 3 4

#endif
# 38 "/usr/include/bits/setjmp.h" 3 4

#endif  /* bits/setjmp.h */
# 40 "/usr/include/bits/setjmp.h" 3 4
# 30 "/usr/include/pthread.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 30 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 31 "/usr/include/pthread.h" 2 3 4


/* Detach state.  */
enum
{
  PTHREAD_CREATE_JOINABLE,
#define PTHREAD_CREATE_JOINABLE	PTHREAD_CREATE_JOINABLE
  PTHREAD_CREATE_DETACHED
#define PTHREAD_CREATE_DETACHED	PTHREAD_CREATE_DETACHED
};


/* Mutex types.  */
enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP
#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
#endif
# 57 "/usr/include/pthread.h" 3 4
#ifdef __USE_GNU
  /* For compatibility.  */
  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
#endif
# 61 "/usr/include/pthread.h" 3 4
};


#ifdef __USE_XOPEN2K
/* Robust mutex or not flags.  */
enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};
#endif
# 74 "/usr/include/pthread.h" 3 4


#ifdef __USE_UNIX98
/* Mutex protocols.  */
enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
#endif
# 85 "/usr/include/pthread.h" 3 4


/* Mutex initializers.  */
#if __WORDSIZE == 64
# define PTHREAD_MUTEX_INITIALIZER \
  { { 0, 0, 0, 0, 0, 0, { 0, 0 } } }
# ifdef __USE_GNU
#  define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, { 0, 0 } } }
#  define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, 0, { 0, 0 } } }
#  define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, 0, { 0, 0 } } }
# endif
# 99 "/usr/include/pthread.h" 3 4
#else
# 100 "/usr/include/pthread.h" 3 4
# define PTHREAD_MUTEX_INITIALIZER \
  { { 0, 0, 0, 0, 0, { 0 } } }
# ifdef __USE_GNU
#  define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, { 0 } } }
#  define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, 0, { 0 } } }
#  define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, 0, { 0 } } }
# endif
# 110 "/usr/include/pthread.h" 3 4
#endif
# 111 "/usr/include/pthread.h" 3 4


/* Read-write lock types.  */
#if defined __USE_UNIX98 || defined __USE_XOPEN2K
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};

/* Read-write lock initializers.  */
# define PTHREAD_RWLOCK_INITIALIZER \
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
# ifdef __USE_GNU
#  if __WORDSIZE == 64
#   define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,					      \
	PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP } }
#  else
# 132 "/usr/include/pthread.h" 3 4
#   if __BYTE_ORDER == __LITTLE_ENDIAN
#    define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \
  { { 0, 0, 0, 0, 0, 0, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, \
      0, 0, 0, 0 } }
#   else
# 137 "/usr/include/pthread.h" 3 4
#    define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,\
      0 } }
#   endif
# 141 "/usr/include/pthread.h" 3 4
#  endif
# 142 "/usr/include/pthread.h" 3 4
# endif
# 143 "/usr/include/pthread.h" 3 4
#endif  /* Unix98 or XOpen2K */
# 144 "/usr/include/pthread.h" 3 4


/* Scheduler inheritance.  */
enum
{
  PTHREAD_INHERIT_SCHED,
#define PTHREAD_INHERIT_SCHED   PTHREAD_INHERIT_SCHED
  PTHREAD_EXPLICIT_SCHED
#define PTHREAD_EXPLICIT_SCHED  PTHREAD_EXPLICIT_SCHED
};


/* Scope handling.  */
enum
{
  PTHREAD_SCOPE_SYSTEM,
#define PTHREAD_SCOPE_SYSTEM    PTHREAD_SCOPE_SYSTEM
  PTHREAD_SCOPE_PROCESS
#define PTHREAD_SCOPE_PROCESS   PTHREAD_SCOPE_PROCESS
};


/* Process shared or private flag.  */
enum
{
  PTHREAD_PROCESS_PRIVATE,
#define PTHREAD_PROCESS_PRIVATE PTHREAD_PROCESS_PRIVATE
  PTHREAD_PROCESS_SHARED
#define PTHREAD_PROCESS_SHARED  PTHREAD_PROCESS_SHARED
};



/* Conditional variable handling.  */
#define PTHREAD_COND_INITIALIZER { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }


/* Cleanup buffers */
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);             /* Function to call.  */
  void *__arg;                            /* Its argument.  */
  int __canceltype;                       /* Saved cancellation type. */
  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */
};

/* Cancellation */
enum
{
  PTHREAD_CANCEL_ENABLE,
#define PTHREAD_CANCEL_ENABLE   PTHREAD_CANCEL_ENABLE
  PTHREAD_CANCEL_DISABLE
#define PTHREAD_CANCEL_DISABLE  PTHREAD_CANCEL_DISABLE
};
enum
{
  PTHREAD_CANCEL_DEFERRED,
#define PTHREAD_CANCEL_DEFERRED	PTHREAD_CANCEL_DEFERRED
  PTHREAD_CANCEL_ASYNCHRONOUS
#define PTHREAD_CANCEL_ASYNCHRONOUS	PTHREAD_CANCEL_ASYNCHRONOUS
};
#define PTHREAD_CANCELED ((void *) -1)


/* Single execution handling.  */
#define PTHREAD_ONCE_INIT 0


#ifdef __USE_XOPEN2K
/* Value returned by 'pthread_barrier_wait' for one of the threads after
   the required number of threads have called this function.
   -1 is distinct from 0 and all errno constants */
# define PTHREAD_BARRIER_SERIAL_THREAD -1
#endif
# 218 "/usr/include/pthread.h" 3 4


__BEGIN_DECLS

/* Create a new thread, starting with execution of START-ROUTINE
   getting passed ARG.  Creation attributed come from ATTR.  The new
   handle is stored in *NEWTHREAD.  */
extern int pthread_create (pthread_t *__restrict __newthread,
			   __const pthread_attr_t *__restrict __attr,
			   void *(*__start_routine) (void *),
			   void *__restrict __arg) __THROW __nonnull ((1, 3));

/* Terminate calling thread.

   The registered cleanup handlers are called via exception handling
   so we cannot mark this function with __THROW.*/
extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));

/* Make calling thread wait for termination of the thread TH.  The
   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
   is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_join (pthread_t __th, void **__thread_return);

#ifdef __USE_GNU
/* Check whether thread TH has terminated.  If yes return the status of
   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */
extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __THROW;

/* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT.  The exit status of the thread is stored in
   *THREAD_RETURN, if THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
				 __const struct timespec *__abstime);
#endif
# 258 "/usr/include/pthread.h" 3 4

/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
   The resources of TH will therefore be freed immediately when it
   terminates, instead of waiting for another thread to perform PTHREAD_JOIN
   on it.  */
extern int pthread_detach (pthread_t __th) __THROW;


/* Obtain the identifier of the current thread.  */
extern pthread_t pthread_self (void) __THROW __attribute__ ((__const__));

/* Compare two thread identifiers.  */
extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) __THROW;


/* Thread attribute handling.  */

/* Initialize thread attribute *ATTR with default attributes
   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
    no user-provided stack).  */
extern int pthread_attr_init (pthread_attr_t *__attr) __THROW __nonnull ((1));

/* Destroy thread attribute *ATTR.  */
extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __THROW __nonnull ((1));

/* Get detach state attribute.  */
extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
					int *__detachstate)
     __THROW __nonnull ((1, 2));

/* Set detach state attribute.  */
extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
					int __detachstate)
     __THROW __nonnull ((1));


/* Get the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
				      size_t *__guardsize)
     __THROW __nonnull ((1, 2));

/* Set the size of the guard area created for stack overflow protection.  */
extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
				      size_t __guardsize)
     __THROW __nonnull ((1));


/* Return in *PARAM the scheduling parameters of *ATTR.  */
extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
				       __attr,
				       struct sched_param *__restrict __param)
     __THROW __nonnull ((1, 2));

/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */
extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
				       __const struct sched_param *__restrict
				       __param) __THROW __nonnull ((1, 2));

/* Return in *POLICY the scheduling policy of *ATTR.  */
extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
					__attr, int *__restrict __policy)
     __THROW __nonnull ((1, 2));

/* Set scheduling policy in *ATTR according to POLICY.  */
extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __THROW __nonnull ((1));

/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */
extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
					 __attr, int *__restrict __inherit)
     __THROW __nonnull ((1, 2));

/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */
extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
					 int __inherit)
     __THROW __nonnull ((1));


/* Return in *SCOPE the scheduling contention scope of *ATTR.  */
extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
				  int *__restrict __scope)
     __THROW __nonnull ((1, 2));

/* Set scheduling contention scope in *ATTR according to SCOPE.  */
extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __THROW __nonnull ((1));

/* Return the previously set address for the stack.  */
extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
				      __attr, void **__restrict __stackaddr)
     __THROW __nonnull ((1, 2)) __attribute_deprecated__;

/* Set the starting address of the stack of the thread to be created.
   Depending on whether the stack grows up or down the value must either
   be higher or lower than all the address in the memory block.  The
   minimal size of the block must be PTHREAD_STACK_MIN.  */
extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
				      void *__stackaddr)
     __THROW __nonnull ((1)) __attribute_deprecated__;

/* Return the currently used minimal stack size.  */
extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
				      __attr, size_t *__restrict __stacksize)
     __THROW __nonnull ((1, 2));

/* Add information about the minimum stack size needed for the thread
   to be started.  This size must never be less than PTHREAD_STACK_MIN
   and must also not exceed the system limits.  */
extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
				      size_t __stacksize)
     __THROW __nonnull ((1));

#ifdef __USE_XOPEN2K
/* Return the previously set address for the stack.  */
extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
				  void **__restrict __stackaddr,
				  size_t *__restrict __stacksize)
     __THROW __nonnull ((1, 2, 3));

/* The following two interfaces are intended to replace the last two.  They
   require setting the address as well as the size since only setting the
   address will make the implementation on some architectures impossible.  */
extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
				  size_t __stacksize) __THROW __nonnull ((1));
#endif
# 384 "/usr/include/pthread.h" 3 4

#ifdef __USE_GNU
/* Thread created with attribute ATTR will be limited to run only on
   the processors represented in CPUSET.  */
extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
					size_t __cpusetsize,
					__const cpu_set_t *__cpuset)
     __THROW __nonnull ((1, 3));

/* Get bit set in CPUSET representing the processors threads created with
   ATTR can run on.  */
extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
					size_t __cpusetsize,
					cpu_set_t *__cpuset)
     __THROW __nonnull ((1, 3));


/* Initialize thread attribute *ATTR with attributes corresponding to the
   already running thread TH.  It shall be called on uninitialized ATTR
   and destroyed with pthread_attr_destroy when no longer needed.  */
extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __THROW __nonnull ((2));
#endif
# 407 "/usr/include/pthread.h" 3 4


/* Functions for scheduling control.  */

/* Set the scheduling parameters for TARGET_THREAD according to POLICY
   and *PARAM.  */
extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
				  __const struct sched_param *__param)
     __THROW __nonnull ((3));

/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */
extern int pthread_getschedparam (pthread_t __target_thread,
				  int *__restrict __policy,
				  struct sched_param *__restrict __param)
     __THROW __nonnull ((2, 3));

/* Set the scheduling priority for TARGET_THREAD.  */
extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __THROW;


#ifdef __USE_GNU
/* Get thread name visible in the kernel and its interfaces.  */
extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
			       size_t __buflen)
     __THROW __nonnull ((2));

/* Set thread name visible in the kernel and its interfaces.  */
extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
     __THROW __nonnull ((2));
#endif
# 438 "/usr/include/pthread.h" 3 4


#ifdef __USE_UNIX98
/* Determine level of concurrency.  */
extern int pthread_getconcurrency (void) __THROW;

/* Set new concurrency level to LEVEL.  */
extern int pthread_setconcurrency (int __level) __THROW;
#endif
# 447 "/usr/include/pthread.h" 3 4

#ifdef __USE_GNU
/* Yield the processor to another thread or process.
   This function is similar to the POSIX `sched_yield' function but
   might be differently implemented in the case of a m-on-n thread
   implementation.  */
extern int pthread_yield (void) __THROW;


/* Limit specified thread TH to run only on the processors represented
   in CPUSET.  */
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
				   __const cpu_set_t *__cpuset)
     __THROW __nonnull ((3));

/* Get bit set in CPUSET representing the processors TH can run on.  */
extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
				   cpu_set_t *__cpuset)
     __THROW __nonnull ((3));
#endif
# 467 "/usr/include/pthread.h" 3 4


/* Functions for handling initialization.  */

/* Guarantee that the initialization function INIT_ROUTINE will be called
   only once, even if pthread_once is executed several times with the
   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
   extern variable initialized to PTHREAD_ONCE_INIT.

   The initialization functions might throw exception which is why
   this function is not marked with __THROW.  */
extern int pthread_once (pthread_once_t *__once_control,
			 void (*__init_routine) (void)) __nonnull ((1, 2));


/* Functions for handling cancellation.

   Note that these functions are explicitly not marked to not throw an
   exception in C++ code.  If cancellation is implemented by unwinding
   this is necessary to have the compiler generate the unwind information.  */

/* Set cancelability state of current thread to STATE, returning old
   state in *OLDSTATE if OLDSTATE is not NULL.  */
extern int pthread_setcancelstate (int __state, int *__oldstate);

/* Set cancellation state of current thread to TYPE, returning the old
   type in *OLDTYPE if OLDTYPE is not NULL.  */
extern int pthread_setcanceltype (int __type, int *__oldtype);

/* Cancel THREAD immediately or at the next possibility.  */
extern int pthread_cancel (pthread_t __th);

/* Test for pending cancellation for the current thread and terminate
   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
   cancelled.  */
extern void pthread_testcancel (void);


/* Cancellation handling with integration into exception handling.  */

typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));

/* No special attributes by default.  */
#ifndef __cleanup_fct_attribute
# define __cleanup_fct_attribute
#endif
# 521 "/usr/include/pthread.h" 3 4


/* Structure to hold the cleanup handler information.  */
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};

#if defined __GNUC__ && defined __EXCEPTIONS
# ifdef __cplusplus
/* Class to handle cancellation handler invocation.  */
class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
					   &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};

/* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  */
#  define pthread_cleanup_push(routine, arg) \
  do {									      \
    __pthread_cleanup_class __clframe (routine, arg)

/* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. */
#  define pthread_cleanup_pop(execute) \
    __clframe.__setdoit (execute);					      \
  } while (0)

#  ifdef __USE_GNU
/* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  */
#   define pthread_cleanup_push_defer_np(routine, arg) \
  do {									      \
    __pthread_cleanup_class __clframe (routine, arg);			      \
    __clframe.__defer ()

/* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  */
#   define pthread_cleanup_pop_restore_np(execute) \
    __clframe.__restore ();						      \
    __clframe.__setdoit (execute);					      \
  } while (0)
#  endif
# 586 "/usr/include/pthread.h" 3 4
# else
# 587 "/usr/include/pthread.h" 3 4
/* Function called to call the cleanup handler.  As an extern inline
   function the compiler is free to decide inlining the change when
   needed or fall back on the copy which must exist somewhere
   else.  */
__extern_inline void
__pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame)
{
  if (__frame->__do_it)
    __frame->__cancel_routine (__frame->__cancel_arg);
}

/* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  */
#  define pthread_cleanup_push(routine, arg) \
  do {									      \
    struct __pthread_cleanup_frame __clframe				      \
      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))		      \
      = { .__cancel_routine = (routine), .__cancel_arg = (arg),	 	      \
	  .__do_it = 1 };

/* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. */
#  define pthread_cleanup_pop(execute) \
    __clframe.__do_it = (execute);					      \
  } while (0)

#  ifdef __USE_GNU
/* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  */
#   define pthread_cleanup_push_defer_np(routine, arg) \
  do {									      \
    struct __pthread_cleanup_frame __clframe				      \
      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))		      \
      = { .__cancel_routine = (routine), .__cancel_arg = (arg),		      \
	  .__do_it = 1 };						      \
    (void) pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,		      \
				  &__clframe.__cancel_type)

/* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  */
#   define pthread_cleanup_pop_restore_np(execute) \
    (void) pthread_setcanceltype (__clframe.__cancel_type, NULL);	      \
    __clframe.__do_it = (execute);					      \
  } while (0)
#  endif
# 639 "/usr/include/pthread.h" 3 4
# endif
# 640 "/usr/include/pthread.h" 3 4
#else
# 641 "/usr/include/pthread.h" 3 4
/* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  */
# define pthread_cleanup_push(routine, arg) \
  do {									      \
    __pthread_unwind_buf_t __cancel_buf;				      \
    void (*__cancel_routine) (void *) = (routine);			      \
    void *__cancel_arg = (arg);						      \
    int not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *)	      \
				      __cancel_buf.__cancel_jmp_buf, 0);      \
    if (__builtin_expect (not_first_call, 0))				      \
      {									      \
	__cancel_routine (__cancel_arg);				      \
	__pthread_unwind_next (&__cancel_buf);				      \
	/* NOTREACHED */						      \
      }									      \
									      \
    __pthread_register_cancel (&__cancel_buf);				      \
    do {
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     __cleanup_fct_attribute;

/* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. */
# define pthread_cleanup_pop(execute) \
      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\
    } while (0);							      \
    __pthread_unregister_cancel (&__cancel_buf);			      \
    if (execute)							      \
      __cancel_routine (__cancel_arg);					      \
  } while (0)
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  __cleanup_fct_attribute;

# ifdef __USE_GNU
/* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  */
#  define pthread_cleanup_push_defer_np(routine, arg) \
  do {									      \
    __pthread_unwind_buf_t __cancel_buf;				      \
    void (*__cancel_routine) (void *) = (routine);			      \
    void *__cancel_arg = (arg);						      \
    int not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *)	      \
				      __cancel_buf.__cancel_jmp_buf, 0);      \
    if (__builtin_expect (not_first_call, 0))				      \
      {									      \
	__cancel_routine (__cancel_arg);				      \
	__pthread_unwind_next (&__cancel_buf);				      \
	/* NOTREACHED */						      \
      }									      \
									      \
    __pthread_register_cancel_defer (&__cancel_buf);			      \
    do {
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     __cleanup_fct_attribute;

/* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  */
#  define pthread_cleanup_pop_restore_np(execute) \
      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\
    } while (0);							      \
    __pthread_unregister_cancel_restore (&__cancel_buf);		      \
    if (execute)							      \
      __cancel_routine (__cancel_arg);					      \
  } while (0)
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  __cleanup_fct_attribute;
# endif
# 715 "/usr/include/pthread.h" 3 4

/* Internal interface to initiate cleanup.  */
extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __cleanup_fct_attribute __attribute__ ((__noreturn__))
# ifndef SHARED
     __attribute__ ((__weak__))
# endif
# 722 "/usr/include/pthread.h" 3 4
     ;
#endif
# 724 "/usr/include/pthread.h" 3 4

/* Function used in the macros.  */
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __THROW;


/* Mutex handling.  */

/* Initialize a mutex.  */
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
			       __const pthread_mutexattr_t *__mutexattr)
     __THROW __nonnull ((1));

/* Destroy a mutex.  */
extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __THROW __nonnull ((1));

/* Try locking a mutex.  */
extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __THROW __nonnull ((1));

/* Lock a mutex.  */
extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __THROW __nonnull ((1));

#ifdef __USE_XOPEN2K
/* Wait until lock becomes available, or specified time passes. */
extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
				    __const struct timespec *__restrict
				    __abstime) __THROW __nonnull ((1, 2));
#endif
# 755 "/usr/include/pthread.h" 3 4

/* Unlock a mutex.  */
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __THROW __nonnull ((1));


/* Get the priority ceiling of MUTEX.  */
extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
					 __restrict __mutex,
					 int *__restrict __prioceiling)
     __THROW __nonnull ((1, 2));

/* Set the priority ceiling of MUTEX to PRIOCEILING, return old
   priority ceiling value in *OLD_CEILING.  */
extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
					 int __prioceiling,
					 int *__restrict __old_ceiling)
     __THROW __nonnull ((1, 3));


#ifdef __USE_XOPEN2K8
/* Declare the state protected by MUTEX as consistent.  */
extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __THROW __nonnull ((1));
# ifdef __USE_GNU
extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     __THROW __nonnull ((1));
# endif
# 783 "/usr/include/pthread.h" 3 4
#endif
# 784 "/usr/include/pthread.h" 3 4


/* Functions for handling mutex attributes.  */

/* Initialize mutex attribute object ATTR with default attributes
   (kind is PTHREAD_MUTEX_TIMED_NP).  */
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __THROW __nonnull ((1));

/* Destroy mutex attribute object ATTR.  */
extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __THROW __nonnull ((1));

/* Get the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
					 __restrict __attr,
					 int *__restrict __pshared)
     __THROW __nonnull ((1, 2));

/* Set the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
					 int __pshared)
     __THROW __nonnull ((1));

#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
/* Return in *KIND the mutex kind attribute in *ATTR.  */
extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
				      __attr, int *__restrict __kind)
     __THROW __nonnull ((1, 2));

/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
   PTHREAD_MUTEX_DEFAULT).  */
extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __THROW __nonnull ((1));
#endif
# 820 "/usr/include/pthread.h" 3 4

/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */
extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
					  __restrict __attr,
					  int *__restrict __protocol)
     __THROW __nonnull ((1, 2));

/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either
   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */
extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
					  int __protocol)
     __THROW __nonnull ((1));

/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */
extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
					     __restrict __attr,
					     int *__restrict __prioceiling)
     __THROW __nonnull ((1, 2));

/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */
extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
					     int __prioceiling)
     __THROW __nonnull ((1));

#ifdef __USE_XOPEN2K
/* Get the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
					int *__robustness)
     __THROW __nonnull ((1, 2));
# ifdef __USE_GNU
extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
					   int *__robustness)
     __THROW __nonnull ((1, 2));
# endif
# 854 "/usr/include/pthread.h" 3 4

/* Set the robustness flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
					int __robustness)
     __THROW __nonnull ((1));
# ifdef __USE_GNU
extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
					   int __robustness)
     __THROW __nonnull ((1));
# endif
# 864 "/usr/include/pthread.h" 3 4
#endif
# 865 "/usr/include/pthread.h" 3 4


#if defined __USE_UNIX98 || defined __USE_XOPEN2K
/* Functions for handling read-write locks.  */

/* Initialize read-write lock RWLOCK using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
				__const pthread_rwlockattr_t *__restrict
				__attr) __THROW __nonnull ((1));

/* Destroy read-write lock RWLOCK.  */
extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __THROW __nonnull ((1));

/* Acquire read lock for RWLOCK.  */
extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __THROW __nonnull ((1));

/* Try to acquire read lock for RWLOCK.  */
extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __THROW __nonnull ((1));

# ifdef __USE_XOPEN2K
/* Try to acquire read lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
				       __const struct timespec *__restrict
				       __abstime) __THROW __nonnull ((1, 2));
# endif
# 894 "/usr/include/pthread.h" 3 4

/* Acquire write lock for RWLOCK.  */
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __THROW __nonnull ((1));

/* Try to acquire write lock for RWLOCK.  */
extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __THROW __nonnull ((1));

# ifdef __USE_XOPEN2K
/* Try to acquire write lock for RWLOCK or return after specfied time.  */
extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
				       __const struct timespec *__restrict
				       __abstime) __THROW __nonnull ((1, 2));
# endif
# 909 "/usr/include/pthread.h" 3 4

/* Unlock RWLOCK.  */
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __THROW __nonnull ((1));


/* Functions for handling read-write lock attributes.  */

/* Initialize attribute object ATTR with default values.  */
extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __THROW __nonnull ((1));

/* Destroy attribute object ATTR.  */
extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __THROW __nonnull ((1));

/* Return current setting of process-shared attribute of ATTR in PSHARED.  */
extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
					  __restrict __attr,
					  int *__restrict __pshared)
     __THROW __nonnull ((1, 2));

/* Set process-shared attribute of ATTR to PSHARED.  */
extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
					  int __pshared)
     __THROW __nonnull ((1));

/* Return current setting of reader/writer preference.  */
extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
					  __restrict __attr,
					  int *__restrict __pref)
     __THROW __nonnull ((1, 2));

/* Set reader/write preference.  */
extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
					  int __pref) __THROW __nonnull ((1));
#endif
# 946 "/usr/include/pthread.h" 3 4


/* Functions for handling conditional variables.  */

/* Initialize condition variable COND using attributes ATTR, or use
   the default values if later is NULL.  */
extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
			      __const pthread_condattr_t *__restrict
			      __cond_attr) __THROW __nonnull ((1));

/* Destroy condition variable COND.  */
extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __THROW __nonnull ((1));

/* Wake up one thread waiting for condition variable COND.  */
extern int pthread_cond_signal (pthread_cond_t *__cond)
     __THROW __nonnull ((1));

/* Wake up all threads waiting for condition variables COND.  */
extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __THROW __nonnull ((1));

/* Wait for condition variable COND to be signaled or broadcast.
   MUTEX is assumed to be locked before.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
			      pthread_mutex_t *__restrict __mutex)
     __nonnull ((1, 2));

/* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
   absolute time specification; zero is the beginning of the epoch
   (00:00:00 GMT, January 1, 1970).

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
				   pthread_mutex_t *__restrict __mutex,
				   __const struct timespec *__restrict
				   __abstime) __nonnull ((1, 2, 3));

/* Functions for handling condition variable attributes.  */

/* Initialize condition variable attribute ATTR.  */
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __THROW __nonnull ((1));

/* Destroy condition variable attribute ATTR.  */
extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __THROW __nonnull ((1));

/* Get the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_getpshared (__const pthread_condattr_t *
					__restrict __attr,
					int *__restrict __pshared)
     __THROW __nonnull ((1, 2));

/* Set the process-shared flag of the condition variable attribute ATTR.  */
extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
					int __pshared) __THROW __nonnull ((1));

#ifdef __USE_XOPEN2K
/* Get the clock selected for the conditon variable attribute ATTR.  */
extern int pthread_condattr_getclock (__const pthread_condattr_t *
				      __restrict __attr,
				      __clockid_t *__restrict __clock_id)
     __THROW __nonnull ((1, 2));

/* Set the clock selected for the conditon variable attribute ATTR.  */
extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
				      __clockid_t __clock_id)
     __THROW __nonnull ((1));
#endif
# 1021 "/usr/include/pthread.h" 3 4


#ifdef __USE_XOPEN2K
/* Functions to handle spinlocks.  */

/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
   be shared between different processes.  */
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __THROW __nonnull ((1));

/* Destroy the spinlock LOCK.  */
extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __THROW __nonnull ((1));

/* Wait until spinlock LOCK is retrieved.  */
extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __THROW __nonnull ((1));

/* Try to lock spinlock LOCK.  */
extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __THROW __nonnull ((1));

/* Release spinlock LOCK.  */
extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __THROW __nonnull ((1));


/* Functions to handle barriers.  */

/* Initialize BARRIER with the attributes in ATTR.  The barrier is
   opened when COUNT waiters arrived.  */
extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
				 __const pthread_barrierattr_t *__restrict
				 __attr, unsigned int __count)
     __THROW __nonnull ((1));

/* Destroy a previously dynamically initialized barrier BARRIER.  */
extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __THROW __nonnull ((1));

/* Wait on barrier BARRIER.  */
extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __THROW __nonnull ((1));


/* Initialize barrier attribute ATTR.  */
extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __THROW __nonnull ((1));

/* Destroy previously dynamically initialized barrier attribute ATTR.  */
extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __THROW __nonnull ((1));

/* Get the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
					   __restrict __attr,
					   int *__restrict __pshared)
     __THROW __nonnull ((1, 2));

/* Set the process-shared flag of the barrier attribute ATTR.  */
extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
					   int __pshared)
     __THROW __nonnull ((1));
#endif
# 1085 "/usr/include/pthread.h" 3 4


/* Functions for handling thread-specific data.  */

/* Create a key value identifying a location in the thread-specific
   data area.  Each thread maintains a distinct thread-specific data
   area.  DESTR_FUNCTION, if non-NULL, is called with the value
   associated to that key when the key is destroyed.
   DESTR_FUNCTION is not called if the value associated is NULL when
   the key is destroyed.  */
extern int pthread_key_create (pthread_key_t *__key,
			       void (*__destr_function) (void *))
     __THROW __nonnull ((1));

/* Destroy KEY.  */
extern int pthread_key_delete (pthread_key_t __key) __THROW;

/* Return current value of the thread-specific data slot identified by KEY.  */
extern void *pthread_getspecific (pthread_key_t __key) __THROW;

/* Store POINTER in the thread-specific data slot identified by KEY. */
extern int pthread_setspecific (pthread_key_t __key,
				__const void *__pointer) __THROW ;


#ifdef __USE_XOPEN2K
/* Get ID of CPU-time clock for thread THREAD_ID.  */
extern int pthread_getcpuclockid (pthread_t __thread_id,
				  __clockid_t *__clock_id)
     __THROW __nonnull ((2));
#endif
# 1116 "/usr/include/pthread.h" 3 4


/* Install handlers to be called when a new process is created with FORK.
   The PREPARE handler is called in the parent process just before performing
   FORK. The PARENT handler is called in the parent process just after FORK.
   The CHILD handler is called in the child process.  Each of the three
   handlers can be NULL, meaning that no handler needs to be called at that
   point.
   PTHREAD_ATFORK can be called several times, in which case the PREPARE
   handlers are called in LIFO order (last added with PTHREAD_ATFORK,
   first called before FORK), and the PARENT and CHILD handlers are called
   in FIFO (first added, first called).  */

extern int pthread_atfork (void (*__prepare) (void),
			   void (*__parent) (void),
			   void (*__child) (void)) __THROW;


#ifdef __USE_EXTERN_INLINES
/* Optimizations.  */
__extern_inline int
__NTH (pthread_equal (pthread_t __thread1, pthread_t __thread2))
{
  return __thread1 == __thread2;
}
#endif
# 1142 "/usr/include/pthread.h" 3 4

__END_DECLS

#endif	/* pthread.h */
# 1146 "/usr/include/pthread.h" 3 4
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 2 3

#if ((defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)) \
     || !defined(_GTHREAD_USE_MUTEX_TIMEDLOCK))
#if 0 /* expanded by -frewrite-includes */
# include <unistd.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# if defined(_POSIX_TIMEOUTS) && _POSIX_TIMEOUTS >= 0
#  define _GTHREAD_USE_MUTEX_TIMEDLOCK 1
# else
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#  define _GTHREAD_USE_MUTEX_TIMEDLOCK 0
# endif
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#endif
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;

/* POSIX like conditional variables are supported.  Please look at comments
   in gthr.h for details. */
#define __GTHREAD_HAS_COND	1

#define __GTHREAD_MUTEX_INIT PTHREAD_MUTEX_INITIALIZER
#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function
#define __GTHREAD_ONCE_INIT PTHREAD_ONCE_INIT
#if defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)
#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER
#elif defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP)
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#define __GTHREAD_RECURSIVE_MUTEX_INIT PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
#else
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
#endif
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER
#define __GTHREAD_TIME_INIT {0,0}

#ifdef _GTHREAD_USE_MUTEX_INIT_FUNC
# undef __GTHREAD_MUTEX_INIT
#endif
# 75 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#ifdef _GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC
# undef __GTHREAD_RECURSIVE_MUTEX_INIT
# undef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION
# define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
#endif
# 80 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#ifdef _GTHREAD_USE_COND_INIT_FUNC
# undef __GTHREAD_COND_INIT
# define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init_function
#endif
# 84 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

#if __GXX_WEAK__ && _GLIBCXX_GTHREAD_USE_WEAK
# ifndef __gthrw_pragma
#  define __gthrw_pragma(pragma)
# endif
# 89 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# define __gthrw2(name,name2,type) \
  static __typeof(type) name __attribute__ ((__weakref__(#name2))); \
  __gthrw_pragma(weak type)
# define __gthrw_(name) __gthrw_ ## name
#else
# 94 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# define __gthrw2(name,name2,type)
# define __gthrw_(name) name
#endif
# 97 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

/* Typically, __gthrw_foo is a weak reference to symbol foo.  */
#define __gthrw(name) __gthrw2(__gthrw_ ## name,name,name)

__gthrw(pthread_once)
__gthrw(pthread_getspecific)
__gthrw(pthread_setspecific)

__gthrw(pthread_create)
__gthrw(pthread_join)
__gthrw(pthread_equal)
__gthrw(pthread_self)
__gthrw(pthread_detach)
#ifndef __BIONIC__
__gthrw(pthread_cancel)
#endif
# 113 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
__gthrw(sched_yield)

__gthrw(pthread_mutex_lock)
__gthrw(pthread_mutex_trylock)
#if _GTHREAD_USE_MUTEX_TIMEDLOCK
__gthrw(pthread_mutex_timedlock)
#endif
# 120 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
__gthrw(pthread_mutex_unlock)
__gthrw(pthread_mutex_init)
__gthrw(pthread_mutex_destroy)

__gthrw(pthread_cond_init)
__gthrw(pthread_cond_broadcast)
__gthrw(pthread_cond_signal)
__gthrw(pthread_cond_wait)
__gthrw(pthread_cond_timedwait)
__gthrw(pthread_cond_destroy)

__gthrw(pthread_key_create)
__gthrw(pthread_key_delete)
__gthrw(pthread_mutexattr_init)
__gthrw(pthread_mutexattr_settype)
__gthrw(pthread_mutexattr_destroy)


#if defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)
/* Objective-C.  */
__gthrw(pthread_exit)
#ifdef _POSIX_PRIORITY_SCHEDULING
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
__gthrw(sched_get_priority_max)
__gthrw(sched_get_priority_min)
#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
# 146 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#endif /* _POSIX_PRIORITY_SCHEDULING */
# 147 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
__gthrw(pthread_attr_destroy)
__gthrw(pthread_attr_init)
__gthrw(pthread_attr_setdetachstate)
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
__gthrw(pthread_getschedparam)
__gthrw(pthread_setschedparam)
#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
# 154 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#endif /* _LIBOBJC || _LIBOBJC_WEAK */
# 155 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

#if __GXX_WEAK__ && _GLIBCXX_GTHREAD_USE_WEAK

/* On Solaris 2.6 up to 9, the libc exposes a POSIX threads interface even if
   -pthreads is not specified.  The functions are dummies and most return an
   error value.  However pthread_once returns 0 without invoking the routine
   it is passed so we cannot pretend that the interface is active if -pthreads
   is not specified.  On Solaris 2.5.1, the interface is not exposed at all so
   we need to play the usual game with weak symbols.  On Solaris 10 and up, a
   working interface is always exposed.  On FreeBSD 6 and later, libc also
   exposes a dummy POSIX threads interface, similar to what Solaris 2.6 up
   to 9 does.  FreeBSD >= 700014 even provides a pthread_cancel stub in libc,
   which means the alternate __gthread_active_p below cannot be used there.  */

#if defined(__FreeBSD__) || (defined(__sun) && defined(__svr4__))

static volatile int __gthread_active = -1;

static void
__gthread_trigger (void)
{
  __gthread_active = 1;
}

static inline int
__gthread_active_p (void)
{
  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;
  static pthread_once_t __gthread_active_once = PTHREAD_ONCE_INIT;

  /* Avoid reading __gthread_active twice on the main code path.  */
  int __gthread_active_latest_value = __gthread_active;

  /* This test is not protected to avoid taking a lock on the main code
     path so every update of __gthread_active in a threaded program must
     be atomic with regard to the result of the test.  */
  if (__builtin_expect (__gthread_active_latest_value < 0, 0))
    {
      if (__gthrw_(pthread_once))
	{
	  /* If this really is a threaded program, then we must ensure that
	     __gthread_active has been set to 1 before exiting this block.  */
	  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);
	  __gthrw_(pthread_once) (&__gthread_active_once, __gthread_trigger);
	  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);
	}

      /* Make sure we'll never enter this block again.  */
      if (__gthread_active < 0)
	__gthread_active = 0;

      __gthread_active_latest_value = __gthread_active;
    }

  return __gthread_active_latest_value != 0;
}

#else /* neither FreeBSD nor Solaris */
# 213 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

/* For a program to be multi-threaded the only thing that it certainly must
   be using is pthread_create.  However, there may be other libraries that
   intercept pthread_create with their own definitions to wrap pthreads
   functionality for some purpose.  In those cases, pthread_create being
   defined might not necessarily mean that libpthread is actually linked
   in.

   For the GNU C library, we can use a known internal name.  This is always
   available in the ABI, but no other library would define it.  That is
   ideal, since any public pthread function might be intercepted just as
   pthread_create might be.  __pthread_key_create is an "internal"
   implementation symbol, but it is part of the public exported ABI.  Also,
   it's among the symbols that the static libpthread.a always links in
   whenever pthread_create is used, so there is no danger of a false
   negative result in any statically-linked, multi-threaded program.

   For others, we choose pthread_cancel as a function that seems unlikely
   to be redefined by an interceptor library.  The bionic (Android) C
   library does not provide pthread_cancel, so we do use pthread_create
   there (and interceptor libraries lose).  */

#ifdef __GLIBC__
__gthrw2(__gthrw_(__pthread_key_create),
	 __pthread_key_create,
	 pthread_key_create)
# define GTHR_ACTIVE_PROXY	__gthrw_(__pthread_key_create)
#elif defined (__BIONIC__)
# 241 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# define GTHR_ACTIVE_PROXY	__gthrw_(pthread_create)
#else
# 243 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# define GTHR_ACTIVE_PROXY	__gthrw_(pthread_cancel)
#endif
# 245 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &GTHR_ACTIVE_PROXY;
  return __gthread_active_ptr != 0;
}

#endif /* FreeBSD or Solaris */
# 255 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

#else /* not __GXX_WEAK__ */
# 257 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

/* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread
   calls in shared flavors of the HP-UX C library.  Most of the stubs
   have no functionality.  The details are described in the "libc cumulative
   patch" for each subversion of HP-UX 11.  There are two special interfaces
   provided for checking whether an application is linked to a shared pthread
   library or not.  However, these interfaces aren't available in early
   libpthread libraries.  We also need a test that works for archive
   libraries.  We can't use pthread_once as some libc versions call the
   init function.  We also can't use pthread_create or pthread_attr_init
   as these create a thread and thereby prevent changing the default stack
   size.  The function pthread_default_stacksize_np is available in both
   the archive and shared versions of libpthread.   It can be used to
   determine the default pthread stack size.  There is a stub in some
   shared libc versions which returns a zero size if pthreads are not
   active.  We provide an equivalent stub to handle cases where libc
   doesn't provide one.  */

#if defined(__hppa__) && defined(__hpux__)

static volatile int __gthread_active = -1;

static inline int
__gthread_active_p (void)
{
  /* Avoid reading __gthread_active twice on the main code path.  */
  int __gthread_active_latest_value = __gthread_active;
  size_t __s;

  if (__builtin_expect (__gthread_active_latest_value < 0, 0))
    {
      pthread_default_stacksize_np (0, &__s);
      __gthread_active = __s ? 1 : 0;
      __gthread_active_latest_value = __gthread_active;
    }

  return __gthread_active_latest_value != 0;
}

#else /* not hppa-hpux */
# 297 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

static inline int
__gthread_active_p (void)
{
  return 1;
}

#endif /* hppa-hpux */
# 305 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

#endif /* __GXX_WEAK__ */
# 307 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

#ifdef _LIBOBJC

/* This is the config.h file in libobjc/ */
#if 0 /* expanded by -frewrite-includes */
#include <config.h>
#endif /* expanded by -frewrite-includes */
# 311 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# 312 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

#ifdef HAVE_SCHED_H
#if 0 /* expanded by -frewrite-includes */
# include <sched.h>
#endif /* expanded by -frewrite-includes */
# 314 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# 315 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#endif
# 316 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

/* Key structure for maintaining thread specific storage */
static pthread_key_t _objc_thread_storage;
static pthread_attr_t _objc_thread_attribs;

/* Thread local storage for a single thread */
static void *thread_local_storage = NULL;

/* Backend initialization functions */

/* Initialize the threads subsystem.  */
static inline int
__gthread_objc_init_thread_system (void)
{
  if (__gthread_active_p ())
    {
      /* Initialize the thread storage key.  */
      if (__gthrw_(pthread_key_create) (&_objc_thread_storage, NULL) == 0)
	{
	  /* The normal default detach state for threads is
	   * PTHREAD_CREATE_JOINABLE which causes threads to not die
	   * when you think they should.  */
	  if (__gthrw_(pthread_attr_init) (&_objc_thread_attribs) == 0
	      && __gthrw_(pthread_attr_setdetachstate) (&_objc_thread_attribs,
					      PTHREAD_CREATE_DETACHED) == 0)
	    return 0;
	}
    }

  return -1;
}

/* Close the threads subsystem.  */
static inline int
__gthread_objc_close_thread_system (void)
{
  if (__gthread_active_p ()
      && __gthrw_(pthread_key_delete) (_objc_thread_storage) == 0
      && __gthrw_(pthread_attr_destroy) (&_objc_thread_attribs) == 0)
    return 0;

  return -1;
}

/* Backend thread functions */

/* Create a new thread of execution.  */
static inline objc_thread_t
__gthread_objc_thread_detach (void (*func)(void *), void *arg)
{
  objc_thread_t thread_id;
  pthread_t new_thread_handle;

  if (!__gthread_active_p ())
    return NULL;

  if (!(__gthrw_(pthread_create) (&new_thread_handle, &_objc_thread_attribs,
				  (void *) func, arg)))
    thread_id = (objc_thread_t) new_thread_handle;
  else
    thread_id = NULL;

  return thread_id;
}

/* Set the current thread's priority.  */
static inline int
__gthread_objc_thread_set_priority (int priority)
{
  if (!__gthread_active_p ())
    return -1;
  else
    {
#ifdef _POSIX_PRIORITY_SCHEDULING
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
      pthread_t thread_id = __gthrw_(pthread_self) ();
      int policy;
      struct sched_param params;
      int priority_min, priority_max;

      if (__gthrw_(pthread_getschedparam) (thread_id, &policy, &params) == 0)
	{
	  if ((priority_max = __gthrw_(sched_get_priority_max) (policy)) == -1)
	    return -1;

	  if ((priority_min = __gthrw_(sched_get_priority_min) (policy)) == -1)
	    return -1;

	  if (priority > priority_max)
	    priority = priority_max;
	  else if (priority < priority_min)
	    priority = priority_min;
	  params.sched_priority = priority;

	  /*
	   * The solaris 7 and several other man pages incorrectly state that
	   * this should be a pointer to policy but pthread.h is universally
	   * at odds with this.
	   */
	  if (__gthrw_(pthread_setschedparam) (thread_id, policy, &params) == 0)
	    return 0;
	}
#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
# 419 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#endif /* _POSIX_PRIORITY_SCHEDULING */
# 420 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
      return -1;
    }
}

/* Return the current thread's priority.  */
static inline int
__gthread_objc_thread_get_priority (void)
{
#ifdef _POSIX_PRIORITY_SCHEDULING
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
  if (__gthread_active_p ())
    {
      int policy;
      struct sched_param params;

      if (__gthrw_(pthread_getschedparam) (__gthrw_(pthread_self) (), &policy, &params) == 0)
	return params.sched_priority;
      else
	return -1;
    }
  else
#endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */
# 442 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
#endif /* _POSIX_PRIORITY_SCHEDULING */
# 443 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
    return OBJC_THREAD_INTERACTIVE_PRIORITY;
}

/* Yield our process time to another thread.  */
static inline void
__gthread_objc_thread_yield (void)
{
  if (__gthread_active_p ())
    __gthrw_(sched_yield) ();
}

/* Terminate the current thread.  */
static inline int
__gthread_objc_thread_exit (void)
{
  if (__gthread_active_p ())
    /* exit the thread */
    __gthrw_(pthread_exit) (&__objc_thread_exit_status);

  /* Failed if we reached here */
  return -1;
}

/* Returns an integer value which uniquely describes a thread.  */
static inline objc_thread_t
__gthread_objc_thread_id (void)
{
  if (__gthread_active_p ())
    return (objc_thread_t) __gthrw_(pthread_self) ();
  else
    return (objc_thread_t) 1;
}

/* Sets the thread's local storage pointer.  */
static inline int
__gthread_objc_thread_set_data (void *value)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_setspecific) (_objc_thread_storage, value);
  else
    {
      thread_local_storage = value;
      return 0;
    }
}

/* Returns the thread's local storage pointer.  */
static inline void *
__gthread_objc_thread_get_data (void)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_getspecific) (_objc_thread_storage);
  else
    return thread_local_storage;
}

/* Backend mutex functions */

/* Allocate a mutex.  */
static inline int
__gthread_objc_mutex_allocate (objc_mutex_t mutex)
{
  if (__gthread_active_p ())
    {
      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));

      if (__gthrw_(pthread_mutex_init) ((pthread_mutex_t *) mutex->backend, NULL))
	{
	  objc_free (mutex->backend);
	  mutex->backend = NULL;
	  return -1;
	}
    }

  return 0;
}

/* Deallocate a mutex.  */
static inline int
__gthread_objc_mutex_deallocate (objc_mutex_t mutex)
{
  if (__gthread_active_p ())
    {
      int count;

      /*
       * Posix Threads specifically require that the thread be unlocked
       * for __gthrw_(pthread_mutex_destroy) to work.
       */

      do
	{
	  count = __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend);
	  if (count < 0)
	    return -1;
	}
      while (count);

      if (__gthrw_(pthread_mutex_destroy) ((pthread_mutex_t *) mutex->backend))
	return -1;

      objc_free (mutex->backend);
      mutex->backend = NULL;
    }
  return 0;
}

/* Grab a lock on a mutex.  */
static inline int
__gthread_objc_mutex_lock (objc_mutex_t mutex)
{
  if (__gthread_active_p ()
      && __gthrw_(pthread_mutex_lock) ((pthread_mutex_t *) mutex->backend) != 0)
    {
      return -1;
    }

  return 0;
}

/* Try to grab a lock on a mutex.  */
static inline int
__gthread_objc_mutex_trylock (objc_mutex_t mutex)
{
  if (__gthread_active_p ()
      && __gthrw_(pthread_mutex_trylock) ((pthread_mutex_t *) mutex->backend) != 0)
    {
      return -1;
    }

  return 0;
}

/* Unlock the mutex */
static inline int
__gthread_objc_mutex_unlock (objc_mutex_t mutex)
{
  if (__gthread_active_p ()
      && __gthrw_(pthread_mutex_unlock) ((pthread_mutex_t *) mutex->backend) != 0)
    {
      return -1;
    }

  return 0;
}

/* Backend condition mutex functions */

/* Allocate a condition.  */
static inline int
__gthread_objc_condition_allocate (objc_condition_t condition)
{
  if (__gthread_active_p ())
    {
      condition->backend = objc_malloc (sizeof (pthread_cond_t));

      if (__gthrw_(pthread_cond_init) ((pthread_cond_t *) condition->backend, NULL))
	{
	  objc_free (condition->backend);
	  condition->backend = NULL;
	  return -1;
	}
    }

  return 0;
}

/* Deallocate a condition.  */
static inline int
__gthread_objc_condition_deallocate (objc_condition_t condition)
{
  if (__gthread_active_p ())
    {
      if (__gthrw_(pthread_cond_destroy) ((pthread_cond_t *) condition->backend))
	return -1;

      objc_free (condition->backend);
      condition->backend = NULL;
    }
  return 0;
}

/* Wait on the condition */
static inline int
__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_cond_wait) ((pthread_cond_t *) condition->backend,
			      (pthread_mutex_t *) mutex->backend);
  else
    return 0;
}

/* Wake up all threads waiting on this condition.  */
static inline int
__gthread_objc_condition_broadcast (objc_condition_t condition)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_cond_broadcast) ((pthread_cond_t *) condition->backend);
  else
    return 0;
}

/* Wake up one thread waiting on this condition.  */
static inline int
__gthread_objc_condition_signal (objc_condition_t condition)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_cond_signal) ((pthread_cond_t *) condition->backend);
  else
    return 0;
}

#else /* _LIBOBJC */
# 657 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
		  void *__args)
{
  return __gthrw_(pthread_create) (__threadid, NULL, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_(pthread_join) (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_(pthread_detach) (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_(pthread_equal) (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_(pthread_self) ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_(sched_yield) ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_once) (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_(pthread_key_create) (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_(pthread_key_delete) (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_(pthread_getspecific) (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_(pthread_setspecific) (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_(pthread_mutex_init) (__mutex, NULL);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_mutex_destroy) (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_mutex_lock) (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_mutex_trylock) (__mutex);
  else
    return 0;
}

#if _GTHREAD_USE_MUTEX_TIMEDLOCK
static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
			   const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_mutex_timedlock) (__mutex, __abs_timeout);
  else
    return 0;
}
#endif
# 773 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_(pthread_mutex_unlock) (__mutex);
  else
    return 0;
}

#if !defined( PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP) \
  || defined(_GTHREAD_USE_RECURSIVE_MUTEX_INIT_FUNC)
static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t __attr;
      int __r;

      __r = __gthrw_(pthread_mutexattr_init) (&__attr);
      if (!__r)
	__r = __gthrw_(pthread_mutexattr_settype) (&__attr,
						   PTHREAD_MUTEX_RECURSIVE);
      if (!__r)
	__r = __gthrw_(pthread_mutex_init) (__mutex, &__attr);
      if (!__r)
	__r = __gthrw_(pthread_mutexattr_destroy) (&__attr);
      return __r;
    }
  return 0;
}
#endif
# 806 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}

#if _GTHREAD_USE_MUTEX_TIMEDLOCK
static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
				     const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}
#endif
# 827 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}

#ifdef _GTHREAD_USE_COND_INIT_FUNC
static inline void
__gthread_cond_init_function (__gthread_cond_t *__cond)
{
  if (__gthread_active_p ())
    __gthrw_(pthread_cond_init) (__cond, NULL);
}
#endif
# 848 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_(pthread_cond_broadcast) (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_(pthread_cond_signal) (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_(pthread_cond_wait) (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
			  const __gthread_time_t *__abs_timeout)
{
  return __gthrw_(pthread_cond_timedwait) (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
			       __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_(pthread_cond_destroy) (__cond);
}

#endif /* _LIBOBJC */
# 888 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3

#endif /* ! _GLIBCXX_GCC_GTHR_POSIX_H */
# 890 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr-default.h" 3
# 149 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 2 3

#ifndef _GLIBCXX_HIDE_EXPORTS
#pragma GCC visibility pop
#endif
# 153 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 3

#endif /* ! _GLIBCXX_GCC_GTHR_H */
# 155 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/gthr.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/atomic_word.h>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/atomic_word.h" 1 3
// Low-level type for atomic operations -*- C++ -*-

// Copyright (C) 2004-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file atomic_word.h
 *  This file is a GNU extension to the Standard C++ Library.
 */

#ifndef _GLIBCXX_ATOMIC_WORD_H
#define _GLIBCXX_ATOMIC_WORD_H	1

typedef int _Atomic_word;

// Define these two macros using the appropriate memory barrier for the target.
// The commented out versions below are the defaults.
// See ia64/atomic_word.h for an alternative approach.

// This one prevents loads from being hoisted across the barrier;
// in other words, this is a Load-Load acquire barrier.
// This is necessary iff TARGET_RELAXED_ORDERING is defined in tm.h.  
// #define _GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory")

// This one prevents stores from being sunk across the barrier; in other
// words, a Store-Store release barrier.
// #define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory")

#endif 
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/atomic_word.h" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 2 3

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Functions for portable atomic access.
  // To abstract locking primitives across all thread policies, use:
  // __exchange_and_add_dispatch
  // __atomic_add_dispatch
#ifdef _GLIBCXX_ATOMIC_BUILTINS
  static inline _Atomic_word 
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, __ATOMIC_ACQ_REL); }
#else
# 55 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
  _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add(volatile _Atomic_word*, int) throw ();

  void
  __attribute__ ((__unused__))
  __atomic_add(volatile _Atomic_word*, int) throw ();
#endif
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3

  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
#else
# 86 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
    return __exchange_and_add_single(__mem, __val);
#endif
# 88 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {
#ifdef __GTHREADS
    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);
#else
# 100 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
    __atomic_add_single(__mem, __val);
#endif
# 102 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
  }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

// Even if the CPU doesn't need a memory barrier, we need to ensure
// that the compiler doesn't reorder memory accesses across the
// barriers.
#ifndef _GLIBCXX_READ_MEM_BARRIER
#define _GLIBCXX_READ_MEM_BARRIER __asm __volatile ("":::"memory")
#endif
# 113 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
#ifndef _GLIBCXX_WRITE_MEM_BARRIER
#define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile ("":::"memory")
#endif
# 116 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3

#endif 
# 118 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/atomicity.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/localefwd.h>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/locale_classes.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_classes.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

#ifndef _LOCALE_CLASSES_H
#define _LOCALE_CLASSES_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/localefwd.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 1 3
// Components for manipulating sequences of characters -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/string
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 21  Strings library
//

#ifndef _GLIBCXX_STRING
#define _GLIBCXX_STRING	1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stringfwd.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/char_traits.h>  // NB: In turn includes stl_algobase.h
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/allocator.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/localefwd.h>    // For operators >>, <<, and getline.
#endif /* expanded by -frewrite-includes */
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/ostream_insert.h>
#endif /* expanded by -frewrite-includes */
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 1 3
// Helpers for ostream inserters -*- C++ -*-

// Copyright (C) 2007-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ostream_insert.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ostream}
 */

#ifndef _OSTREAM_INSERT_H
#define _OSTREAM_INSERT_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <iosfwd>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/cxxabi_forced.h>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cxxabi_forced.h" 1 3
// cxxabi.h subset for cancellation -*- C++ -*-
  
// Copyright (C) 2007-2015 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
// 
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/cxxabi_forced.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cxxabi.h}
 */

#ifndef _CXXABI_FORCED_H
#define _CXXABI_FORCED_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)

#ifdef __cplusplus
namespace __cxxabiv1
{  
  /** 
   *  @brief Thrown as part of forced unwinding.
   *  @ingroup exceptions
   *
   *  A magic placeholder class that can be caught by reference to
   *  recognize forced unwinding.
   */
  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();

    // Prevent catch by value.
    virtual void __pure_dummy() = 0; 
  };
}
#endif // __cplusplus
# 57 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility pop

#endif // __CXXABI_FORCED_H 
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/cxxabi_forced.h" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
		    const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits>       __ostream_type;      
      typedef typename __ostream_type::ios_base    __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
	__out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits>       __ostream_type;      
      typedef typename __ostream_type::ios_base    __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
	{
	  const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
	  if (_Traits::eq_int_type(__put, _Traits::eof()))
	    {
	      __out.setstate(__ios_base::badbit);
	      break;
	    }
	}
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
		     const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits>       __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
	{
	  __try
	    {
	      const streamsize __w = __out.width();
	      if (__w > __n)
		{
		  const bool __left = ((__out.flags()
					& __ios_base::adjustfield)
				       == __ios_base::left);
		  if (!__left)
		    __ostream_fill(__out, __w - __n);
		  if (__out.good())
		    __ostream_write(__out, __s, __n);
		  if (__left && __out.good())
		    __ostream_fill(__out, __w - __n);
		}
	      else
		__ostream_write(__out, __s, __n);
	      __out.width(0);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      __out._M_setstate(__ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { __out._M_setstate(__ios_base::badbit); }
	}
      return __out;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
					     streamsize);
#endif
# 124 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 3
#endif
# 125 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif /* _OSTREAM_INSERT_H */
# 130 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream_insert.h" 3
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_types.h>
#endif /* expanded by -frewrite-includes */
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_funcs.h>
#endif /* expanded by -frewrite-includes */
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator.h>
#endif /* expanded by -frewrite-includes */
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_function.h> // For less
#endif /* expanded by -frewrite-includes */
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 1 3
// Functor implementations -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_function.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */

#ifndef _STL_FUNCTION_H
#define _STL_FUNCTION_H 1

#if __cplusplus > 201103L
#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
#endif
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // 20.3.1 base classes
  /** @defgroup functors Function Objects
   * @ingroup utilities
   *
   *  Function objects, or @e functors, are objects with an @c operator()
   *  defined and accessible.  They can be passed as arguments to algorithm
   *  templates and used in place of a function pointer.  Not only is the
   *  resulting expressiveness of the library increased, but the generated
   *  code can be more efficient than what you might write by hand.  When we
   *  refer to @a functors, then, generally we include function pointers in
   *  the description as well.
   *
   *  Often, functors are only created as temporaries passed to algorithm
   *  calls, rather than being created as named variables.
   *
   *  Two examples taken from the standard itself follow.  To perform a
   *  by-element addition of two vectors @c a and @c b containing @c double,
   *  and put the result in @c a, use
   *  \code
   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
   *  \endcode
   *  To negate every element in @c a, use
   *  \code
   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
   *  \endcode
   *  The addition and negation functions will be inlined directly.
   *
   *  The standard functors are derived from structs named @c unary_function
   *  and @c binary_function.  These two classes contain nothing but typedefs,
   *  to aid in generic (template) programming.  If you write your own
   *  functors, you might consider doing the same.
   *
   *  @{
   */
  /**
   *  This is one of the @link functors functor base classes@endlink.
   */
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      /// @c argument_type is the type of the argument
      typedef _Arg 	argument_type;   

      /// @c result_type is the return type
      typedef _Result 	result_type;  
    };

  /**
   *  This is one of the @link functors functor base classes@endlink.
   */
  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      /// @c first_argument_type is the type of the first argument
      typedef _Arg1 	first_argument_type; 

      /// @c second_argument_type is the type of the second argument
      typedef _Arg2 	second_argument_type;

      /// @c result_type is the return type
      typedef _Result 	result_type;
    };
  /** @}  */

  // 20.3.2 arithmetic
  /** @defgroup arithmetic_functors Arithmetic Classes
   * @ingroup functors
   *
   *  Because basic math often needs to be done during an algorithm,
   *  the library provides functors for those operations.  See the
   *  documentation for @link functors the base classes@endlink
   *  for examples of their use.
   *
   *  @{
   */

#if __cplusplus > 201103L
  struct __is_transparent;  // undefined

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;
#endif
# 164 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };

#if __cplusplus > 201103L

#define __cpp_lib_transparent_operators 201210
//#define __cpp_lib_generic_associative_lookup 201304

  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<>
    struct negate<void>
    {
      template <typename _Tp>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t) const
	noexcept(noexcept(-std::forward<_Tp>(__t)))
	-> decltype(-std::forward<_Tp>(__t))
	{ return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
#endif
# 319 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
  /** @}  */

  // 20.3.3 comparisons
  /** @defgroup comparison_functors Comparison Classes
   * @ingroup functors
   *
   *  The library provides six wrapper functors for all the basic comparisons
   *  in C++, like @c <.
   *
   *  @{
   */
#if __cplusplus > 201103L
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;
#endif
# 349 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };

#if __cplusplus > 201103L
  /// One of the @link comparison_functors comparison functors@endlink.
  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link comparison_functors comparison functors@endlink.
  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
#endif
# 501 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
  /** @}  */

  // 20.3.4 logical operations
  /** @defgroup logical_functors Boolean Operations Classes
   * @ingroup functors
   *
   *  Here are wrapper functors for Boolean operations: @c &&, @c ||,
   *  and @c !.
   *
   *  @{
   */
#if __cplusplus > 201103L
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;
#endif
# 522 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3

  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };

  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };

  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };

#if __cplusplus > 201103L
  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  /// One of the @link logical_functors Boolean operations functors@endlink.
  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t) const
	noexcept(noexcept(!std::forward<_Tp>(__t)))
	-> decltype(!std::forward<_Tp>(__t))
	{ return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
#endif
# 599 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
  /** @}  */

#if __cplusplus > 201103L
  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;
#endif
# 614 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // DR 660. Missing Bitwise Operations.
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    _GLIBCXX14_CONSTEXPR
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };

#if __cplusplus > 201103L
  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t, _Up&& __u) const
	noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
	-> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
	{ return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
	_GLIBCXX14_CONSTEXPR
	auto
	operator()(_Tp&& __t) const
	noexcept(noexcept(~std::forward<_Tp>(__t)))
	-> decltype(~std::forward<_Tp>(__t))
	{ return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
#endif
# 710 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3

  // 20.3.5 negators
  /** @defgroup negators Negators
   * @ingroup functors
   *
   *  The functions @c not1 and @c not2 each take a predicate functor
   *  and return an instance of @c unary_negate or
   *  @c binary_negate, respectively.  These classes are functors whose
   *  @c operator() performs the stored predicate function and then returns
   *  the negation of the result.
   *
   *  For example, given a vector of integers and a trivial predicate,
   *  \code
   *  struct IntGreaterThanThree
   *    : public std::unary_function<int, bool>
   *  {
   *      bool operator() (int x) { return x > 3; }
   *  };
   *
   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
   *  \endcode
   *  The call to @c find_if will locate the first index (i) of @c v for which
   *  <code>!(v[i] > 3)</code> is true.
   *
   *  The not1/unary_negate combination works on predicates taking a single
   *  argument.  The not2/binary_negate combination works on predicates which
   *  take two arguments.
   *
   *  @{
   */
  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      _GLIBCXX14_CONSTEXPR
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };

  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    _GLIBCXX14_CONSTEXPR
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }

  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
			     typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      _GLIBCXX14_CONSTEXPR
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
		 const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };

  /// One of the @link negators negation functors@endlink.
  template<typename _Predicate>
    _GLIBCXX14_CONSTEXPR
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
  /** @}  */

  // 20.3.7 adaptors pointers functions
  /** @defgroup pointer_adaptors Adaptors for pointers to functions
   * @ingroup functors
   *
   *  The advantage of function objects over pointers to functions is that
   *  the objects in the standard library declare nested typedefs describing
   *  their argument and result types with uniform names (e.g., @c result_type
   *  from the base classes @c unary_function and @c binary_function).
   *  Sometimes those typedefs are required, not just optional.
   *
   *  Adaptors are provided to turn pointers to unary (single-argument) and
   *  binary (double-argument) functions into function objects.  The
   *  long-winded functor @c pointer_to_unary_function is constructed with a
   *  function pointer @c f, and its @c operator() called with argument @c x
   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
   *  thing, but with a double-argument @c f and @c operator().
   *
   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
   *  an instance of the appropriate functor.
   *
   *  @{
   */
  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };

  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }

  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };

  /// One of the @link pointer_adaptors adaptors for function pointers@endlink.
  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
  /** @}  */

  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }

#if __cplusplus >= 201103L
      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }
#endif
# 905 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };

  // 20.3.8 adaptors pointers members
  /** @defgroup memory_adaptors Adaptors for pointers to members
   * @ingroup functors
   *
   *  There are a total of 8 = 2^3 function objects in this family.
   *   (1) Member functions taking no arguments vs member functions taking
   *        one argument.
   *   (2) Call through pointer vs call through reference.
   *   (3) Const vs non-const member function.
   *
   *  All of this complexity is in the function objects themselves.  You can
   *   ignore it by using the helper function mem_fun and mem_fun_ref,
   *   which create whichever type of adaptor is appropriate.
   *
   *  @{
   */
  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };

  /// One of the @link memory_adaptors adaptors for member
  /// pointers@endlink.
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };

  // Mem_fun adaptor helper functions.  There are only two:
  // mem_fun and mem_fun_ref.
  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  /** @}  */

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if (__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED
#if 0 /* expanded by -frewrite-includes */
# include <backward/binders.h>
#endif /* expanded by -frewrite-includes */
# 1128 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/backward/binders.h" 1 3
// Functor implementations -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file backward/binders.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */

#ifndef _BACKWARD_BINDERS_H
#define _BACKWARD_BINDERS_H 1

// Suppress deprecated warning for this file.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // 20.3.6 binders
  /** @defgroup binders Binder Classes
   * @ingroup functors
   *
   *  Binders turn functions/functors with two arguments into functors
   *  with a single argument, storing an argument to be applied later.
   *  For example, a variable @c B of type @c binder1st is constructed
   *  from a functor @c f and an argument @c x. Later, B's @c
   *  operator() is called with a single argument @c y. The return
   *  value is the value of @c f(x,y). @c B can be @a called with
   *  various arguments (y1, y2, ...) and will in turn call @c
   *  f(x,y1), @c f(x,y2), ...
   *
   *  The function @c bind1st is provided to save some typing. It takes the
   *  function and an argument as parameters, and returns an instance of
   *  @c binder1st.
   *
   *  The type @c binder2nd and its creator function @c bind2nd do the same
   *  thing, but the stored argument is passed as the second parameter instead
   *  of the first, e.g., @c bind2nd(std::minus<float>(),1.3) will create a
   *  functor whose @c operator() accepts a floating-point number, subtracts
   *  1.3 from it, and returns the result. (If @c bind1st had been used,
   *  the functor would perform <em>1.3 - x</em> instead.
   *
   *  Creator-wrapper functions like @c bind1st are intended to be used in
   *  calling algorithms. Their return values will be temporary objects.
   *  (The goal is to not require you to type names like
   *  @c std::binder1st<std::plus<int>> for declaring a variable to hold the
   *  return value from @c bind1st(std::plus<int>(),5).
   *
   *  These become more useful when combined with the composition functions.
   *
   *  These functions are deprecated in C++11 and can be replaced by
   *  @c std::bind (or @c std::tr1::bind) which is more powerful and flexible,
   *  supporting functions with any number of arguments.  Uses of @c bind1st
   *  can be replaced by @c std::bind(f, x, std::placeholders::_1) and
   *  @c bind2nd by @c std::bind(f, std::placeholders::_1, x).
   *  @{
   */
  /// One of the @link binders binder functors@endlink.
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
			    typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
		const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 109.  Missing binders for non-const sequence elements
      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } _GLIBCXX_DEPRECATED;

  /// One of the @link binders binder functors@endlink.
  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }

  /// One of the @link binders binder functors@endlink.
  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
			    typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
		const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 109.  Missing binders for non-const sequence elements
      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } _GLIBCXX_DEPRECATED;

  /// One of the @link binders binder functors@endlink.
  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    } 
  /** @}  */

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#pragma GCC diagnostic pop

#endif /* _BACKWARD_BINDERS_H */
# 183 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/backward/binders.h" 3
# 1129 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 2 3
#endif
# 1130 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3

#endif /* _STL_FUNCTION_H */
# 1132 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_function.h" 3
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/numeric_traits.h> 
#endif /* expanded by -frewrite-includes */
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 50 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h> 
#endif /* expanded by -frewrite-includes */
# 50 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 51 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/range_access.h>
#endif /* expanded by -frewrite-includes */
# 51 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 52 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/basic_string.h>
#endif /* expanded by -frewrite-includes */
# 52 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 1 3
// Components for manipulating sequences of characters -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_string.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21 Strings library
//

#ifndef _BASIC_STRING_H
#define _BASIC_STRING_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <ext/atomicity.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/alloc_traits.h>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 1 3
// Allocator traits -*- C++ -*-

// Copyright (C) 2011-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file ext/alloc_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */

#ifndef _EXT_ALLOC_TRAITS_H
#define _EXT_ALLOC_TRAITS_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3

#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
# include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
#if 0 /* expanded by -frewrite-includes */
# include <bits/alloc_traits.h>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
#else
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
#if 0 /* expanded by -frewrite-includes */
# include <bits/allocator.h>  // for __alloc_swap
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
#endif
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#if __cplusplus >= 201103L
  template<typename _Alloc>
    struct __allocator_always_compares_equal : std::false_type { };

  template<typename _Tp>
    struct __allocator_always_compares_equal<std::allocator<_Tp>>
    : std::true_type { };

  template<typename, typename> struct array_allocator;

  template<typename _Tp, typename _Array>
    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
    : std::true_type { };

  template<typename> struct bitmap_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct malloc_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<malloc_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct mt_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct new_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<new_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct pool_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
    : std::true_type { };
#endif
# 89 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3

/**
 * @brief  Uniform interface to C++98 and C++0x allocators.
 * @ingroup allocators
*/
template<typename _Alloc>
  struct __alloc_traits
#if __cplusplus >= 201103L
  : std::allocator_traits<_Alloc>
#endif
# 99 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
  {
    typedef _Alloc allocator_type;
#if __cplusplus >= 201103L
    typedef std::allocator_traits<_Alloc>           _Base_type;
    typedef typename _Base_type::value_type         value_type;
    typedef typename _Base_type::pointer            pointer;
    typedef typename _Base_type::const_pointer      const_pointer;
    typedef typename _Base_type::size_type          size_type;
    typedef typename _Base_type::difference_type    difference_type;
    // C++11 allocators do not define reference or const_reference
    typedef value_type&                             reference;
    typedef const value_type&                       const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
	= std::__and_<std::is_same<pointer, _Ptr>,
		      std::__not_<std::is_pointer<_Ptr>>>;

  public:
    // overload construct for non-standard pointer types
    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
	_Base_type::construct(__a, std::addressof(*__p),
			      std::forward<_Args>(__args)...);
      }

    // overload destroy for non-standard pointer types
    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return __allocator_always_compares_equal<_Alloc>::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    static constexpr bool _S_nothrow_swap()
    {
      using std::swap;
      return !_S_propagate_on_swap()
       	|| noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
#else
# 171 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3

    typedef typename _Alloc::pointer                pointer;
    typedef typename _Alloc::const_pointer          const_pointer;
    typedef typename _Alloc::value_type             value_type;
    typedef typename _Alloc::reference              reference;
    typedef typename _Alloc::const_reference        const_reference;
    typedef typename _Alloc::size_type              size_type;
    typedef typename _Alloc::difference_type        difference_type;

    static pointer
    allocate(_Alloc& __a, size_type __n)
    { return __a.allocate(__n); }

    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
    { __a.deallocate(__p, __n); }

    template<typename _Tp>
      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
      { __a.construct(__p, __arg); }

    static void destroy(_Alloc& __a, pointer __p)
    { __a.destroy(__p); }

    static size_type max_size(const _Alloc& __a)
    { return __a.max_size(); }

    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 431. Swapping containers with unequal allocators.
      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Alloc::template rebind<_Tp>::other other; };
#endif
# 210 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
  };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace __gnu_cxx

#endif
# 216 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ext/alloc_traits.h" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <debug/debug.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
#endif
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#if _GLIBCXX_USE_CXX11_ABI
_GLIBCXX_BEGIN_NAMESPACE_CXX11
  /**
   *  @class basic_string basic_string.h <string>
   *  @brief  Managing sequences of characters and character-like objects.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  @tparam _CharT  Type of character
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.  Of the
   *  <a href="tables.html#68">optional sequence requirements</a>, only
   *  @c push_back, @c at, and @c %array access are supported.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
	rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;

      // Types:
    public:
      typedef _Traits					traits_type;
      typedef typename _Traits::char_type		value_type;
      typedef _Char_alloc_type				allocator_type;
      typedef typename _Alloc_traits::size_type		size_type;
      typedef typename _Alloc_traits::difference_type	difference_type;
      typedef typename _Alloc_traits::reference		reference;
      typedef typename _Alloc_traits::const_reference	const_reference;
      typedef typename _Alloc_traits::pointer		pointer;
      typedef typename _Alloc_traits::const_pointer	const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
							const_iterator;
      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
      typedef std::reverse_iterator<iterator>		reverse_iterator;

      ///  Value returned by various member functions when they fail.
      static const size_type	npos = static_cast<size_type>(-1);

    private:
      // type used for positions in insert, erase etc.
#if __cplusplus < 201103L
      typedef iterator __const_iterator;
#else
# 102 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      typedef const_iterator __const_iterator;
#endif
# 104 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : allocator_type // TODO check __is_final
      {
	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
	: allocator_type(__a), _M_p(__dat) { }

	pointer _M_p; // The actual data.
      };

      _Alloc_hider	_M_dataplus;
      size_type		_M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
	_CharT           _M_local_buf[_S_local_capacity + 1];
	size_type        _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {
#if __cplusplus >= 201103L
	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
#else
# 143 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
	return pointer(_M_local_buf);
#endif
# 145 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      }

      const_pointer
      _M_local_data() const
      {
#if __cplusplus >= 201103L
	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
#else
# 153 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
	return const_pointer(_M_local_buf);
#endif
# 155 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
	_M_length(__n);
	traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }

      // Create & Destroy
      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
	if (!_M_is_local())
	  _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }

      // _M_construct_aux is used to implement the 21.3.1 para 15 which
      // requires special behaviour if _InIterator is an integral type
      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
			 std::__false_type)
	{
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
	}

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
	{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
	{
	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
	  _M_construct_aux(__beg, __end, _Integral());
        }

      // For Input Iterators, used in istreambuf_iterators, etc.
      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
		     std::input_iterator_tag);

      // For forward_iterators up to random_access_iterators, used for
      // string::iterator, _CharT*, etc.
      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
		     std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:

#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
      // The explicit instantiations in misc-inst.cc require this due to
      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063
      template<typename _Tp, bool _Requires =
	       !__are_same<_Tp, _CharT*>::__value
	       && !__are_same<_Tp, const _CharT*>::__value
	       && !__are_same<_Tp, iterator>::__value
	       && !__are_same<_Tp, const_iterator>::__value>
	struct __enable_if_not_native_iterator
	{ typedef basic_string& __type; };
      template<typename _Tp>
	struct __enable_if_not_native_iterator<_Tp, false> { };
#endif
# 256 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
				       "this->size() (which is %zu)"),
				   __s, __pos, this->size());
	return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
	if (this->max_size() - (this->size() - __n1) < __n2)
	  __throw_length_error(__N(__s));
      }


      // NB: _M_limit doesn't check for a bad __pos value.
      size_type
      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
      {
	const bool __testoff =  __off < this->size() - __pos;
	return __testoff ? __off : this->size() - __pos;
      }

      // True if _Rep and source do not overlap.
      bool
      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
      {
	return (less<const _CharT*>()(__s, _M_data())
		|| less<const _CharT*>()(_M_data() + this->size(), __s));
      }

      // When __n = 1 way faster than the general multichar
      // traits_type::copy/move/assign.
      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
	if (__n == 1)
	  traits_type::assign(*__d, *__s);
	else
	  traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
	if (__n == 1)
	  traits_type::assign(*__d, *__s);
	else
	  traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
	if (__n == 1)
	  traits_type::assign(*__d, __c);
	else
	  traits_type::assign(__d, __n, __c);
      }

      // _S_copy_chars is a separate template to permit specialization
      // to optimize for the common case of pointers as iterators.
      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
	_GLIBCXX_NOEXCEPT
        {
	  for (; __k1 != __k2; ++__k1, ++__p)
	    traits_type::assign(*__p, *__k1); // These types are off.
	}

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      _GLIBCXX_NOEXCEPT
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      _GLIBCXX_NOEXCEPT
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
      }

      void
      _M_assign(const basic_string& __rcs);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
		size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:
      // Construct/copy/destroy:
      // NB: We overload ctors in some cases instead of using default
      // arguments, per 17.4.4.4 para. 2 item 2.

      /**
       *  @brief  Default constructor creates an empty string.
       */
      basic_string()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
#endif
# 384 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }

      /**
       *  @brief  Construct an empty string using allocator @a a.
       */
      explicit
      basic_string(const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }

      /**
       *  @brief  Construct string with copy of value of @a __str.
       *  @param  __str  Source string.
       */
      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(), __str._M_get_allocator()) // TODO A traits
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }

      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy (default remainder).
       */
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 2402. [this constructor] shouldn't use Allocator()
      basic_string(const basic_string& __str, size_type __pos,
		   size_type __n = npos)
      : _M_dataplus(_M_local_data())
      {
	const _CharT* __start = __str._M_data()
	  + __str._M_check(__pos, "basic_string::basic_string");
	_M_construct(__start, __start + __str._M_limit(__pos, __n));
      }

      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy (default remainder).
       *  @param  __a  Allocator to use.
       */
      basic_string(const basic_string& __str, size_type __pos,
		   size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
	const _CharT* __start
	  = __str._M_data() + __str._M_check(__pos, "string::string");
	_M_construct(__start, __start + __str._M_limit(__pos, __n));
      }

      /**
       *  @brief  Construct string initialized by a character %array.
       *  @param  __s  Source character %array.
       *  @param  __n  Number of characters to copy.
       *  @param  __a  Allocator to use (default is default allocator).
       *
       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
       *  has no special meaning.
       */
      basic_string(const _CharT* __s, size_type __n,
		   const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }

      /**
       *  @brief  Construct string as copy of a C string.
       *  @param  __s  Source C string.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }

      /**
       *  @brief  Construct string as multiple characters.
       *  @param  __n  Number of characters.
       *  @param  __c  Character to use.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Move construct string.
       *  @param  __str  Source string.
       *
       *  The newly-created string contains the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       **/
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
	if (__str._M_is_local())
	  {
	    traits_type::copy(_M_local_buf, __str._M_local_buf,
			      _S_local_capacity + 1);
	  }
	else
	  {
	    _M_data(__str._M_data());
	    _M_capacity(__str._M_allocated_capacity);
	  }

	// Must use _M_length() here not _M_set_length() because
	// basic_stringbuf relies on writing into unallocated capacity so
	// we mess up the contents if we put a '\0' in the string.
	_M_length(__str.length());
	__str._M_data(__str._M_local_data());
	__str._M_set_length(0);
      }

      /**
       *  @brief  Construct string from an initializer %list.
       *  @param  __l  std::initializer_list of characters.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
	if (__str.get_allocator() == __a)
	  *this = std::move(__str);
	else
	  _M_construct(__str.begin(), __str.end());
      }

#endif // C++11
# 522 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Construct string as copy of a range.
       *  @param  __beg  Start of range.
       *  @param  __end  End of range.
       *  @param  __a  Allocator to use (default is default allocator).
       */
#if __cplusplus >= 201103L
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
#else
# 533 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      template<typename _InputIterator>
#endif
# 535 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
        basic_string(_InputIterator __beg, _InputIterator __end,
		     const _Alloc& __a = _Alloc())
	: _M_dataplus(_M_local_data(), __a)
	{ _M_construct(__beg, __end); }

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string()
      { _M_dispose(); }

      /**
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }

      /**
       *  @brief  Copy contents of @a s into this string.
       *  @param  __s  Source null-terminated string.
       */
      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }

      /**
       *  @brief  Set value to string of length 1.
       *  @param  __c  Source character.
       *
       *  Assigning to a character makes this string length 1 and
       *  (*this)[0] == @a c.
       */
      basic_string&
      operator=(_CharT __c)
      {
	this->assign(1, __c);
	return *this;
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Move assign the value of @a str to this string.
       *  @param  __str  Source string.
       *
       *  The contents of @a str are moved into this string (without copying).
       *  @a str is a valid, but unspecified string.
       **/
      // PR 58265, this should be noexcept.
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 2063. Contradictory requirements for string move assignment
      basic_string&
      operator=(basic_string&& __str)
      {
	this->swap(__str);
	return *this;
      }

      /**
       *  @brief  Set value to string constructed from initializer %list.
       *  @param  __l  std::initializer_list.
       */
      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
	this->assign(__l.begin(), __l.size());
	return *this;
      }
#endif // C++11
# 605 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      // Iterators:
      /**
       *  Returns a read/write iterator that points to the first character in
       *  the %string.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return iterator(_M_data()); }

      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return const_iterator(_M_data()); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  character in the %string.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(_M_data() + this->size()); }

      /**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return const_iterator(_M_data() + this->size()); }

      /**
       *  Returns a read/write reverse iterator that points to the last
       *  character in the %string.  Iteration is done in reverse element
       *  order.
       */
      reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(this->end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(this->end()); }

      /**
       *  Returns a read/write reverse iterator that points to one before the
       *  first character in the %string.  Iteration is done in reverse
       *  element order.
       */
      reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(this->begin()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(this->begin()); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       */
      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }

      /**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       */
      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }
#endif
# 710 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

    public:
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_string_length; }

      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      length() const _GLIBCXX_NOEXCEPT
      { return _M_string_length; }

      ///  Returns the size() of the largest possible %string.
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }

      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *  @param  __c  Character to fill any new elements.
       *
       *  This function will %resize the %string to the specified
       *  number of characters.  If the number is smaller than the
       *  %string's current size the %string is truncated, otherwise
       *  the %string is extended and new elements are %set to @a __c.
       */
      void
      resize(size_type __n, _CharT __c);

      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *
       *  This function will resize the %string to the specified length.  If
       *  the new size is smaller than the %string's current size the %string
       *  is truncated, otherwise the %string is extended and new characters
       *  are default-constructed.  For basic types such as char, this means
       *  setting them to 0.
       */
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }

#if __cplusplus >= 201103L
      ///  A non-binding request to reduce capacity() to size().
      void
      shrink_to_fit() noexcept
      {
	if (capacity() > size())
	  {
	    __try
	      { reserve(0); }
	    __catch(...)
	      { }
	  }
      }
#endif
# 771 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  Returns the total number of characters that the %string can hold
       *  before needing to allocate more memory.
       */
      size_type
      capacity() const _GLIBCXX_NOEXCEPT
      {
	return _M_is_local() ? size_type(_S_local_capacity)
	                     : _M_allocated_capacity;
      }

      /**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          characters.
       *  @param  __res_arg  Number of characters required.
       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %string to hold the specified number of characters.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the string length that will be
       *  required, the user can reserve the memory in %advance, and thus
       *  prevent a possible reallocation of memory and copying of %string
       *  data.
       */
      void
      reserve(size_type __res_arg = 0);

      /**
       *  Erases the string, making it empty.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      { _M_set_length(0); }

      /**
       *  Returns true if the %string is empty.  Equivalent to 
       *  <code>*this == ""</code>.
       */
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return this->size() == 0; }

      // Element access:
      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read-only (constant) reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      const_reference
      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
      {
	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
	return _M_data()[__pos];
      }

      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read/write reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      reference
      operator[](size_type __pos)
      {
        // Allow pos == size() both in C++98 mode, as v3 extension,
	// and in C++11 mode.
	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
        // In pedantic mode be strict in C++98 mode.
	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
	return _M_data()[__pos];
      }

      /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read-only (const) reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */
      const_reference
      at(size_type __n) const
      {
	if (__n >= this->size())
	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
				       "(which is %zu) >= this->size() "
				       "(which is %zu)"),
				   __n, this->size());
	return _M_data()[__n];
      }

      /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read/write reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */
      reference
      at(size_type __n)
      {
	if (__n >= size())
	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
				       "(which is %zu) >= this->size() "
				       "(which is %zu)"),
				   __n, this->size());
	return _M_data()[__n];
      }

#if __cplusplus >= 201103L
      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %string.
       */
      reference
      front() noexcept
      { return operator[](0); }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %string.
       */
      const_reference
      front() const noexcept
      { return operator[](0); }

      /**
       *  Returns a read/write reference to the data at the last
       *  element of the %string.
       */
      reference
      back() noexcept
      { return operator[](this->size() - 1); }

      /**
       *  Returns a read-only (constant) reference to the data at the
       *  last element of the %string.
       */
      const_reference
      back() const noexcept
      { return operator[](this->size() - 1); }
#endif
# 932 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      // Modifiers:
      /**
       *  @brief  Append a string to this string.
       *  @param __str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }

      /**
       *  @brief  Append a C string.
       *  @param __s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }

      /**
       *  @brief  Append a character.
       *  @param __c  The character to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(_CharT __c)
      {
	this->push_back(__c);
	return *this;
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to be appended.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
#endif // C++11
# 974 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Append a string to this string.
       *  @param __str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }

      /**
       *  @brief  Append a substring.
       *  @param __str  The string to append.
       *  @param __pos  Index of the first character of str to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a __pos is not a valid index.
       *
       *  This function appends @a __n characters from @a __str
       *  starting at @a __pos to this string.  If @a __n is is larger
       *  than the number of available characters in @a __str, the
       *  remainder of @a __str is appended.
       */
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
			 + __str._M_check(__pos, "basic_string::append"),
			 __str._M_limit(__pos, __n)); }

      /**
       *  @brief  Append a C substring.
       *  @param __s  The C string to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s, size_type __n)
      {
	__glibcxx_requires_string_len(__s, __n);
	_M_check_length(size_type(0), __n, "basic_string::append");
	return _M_append(__s, __n);
      }

      /**
       *  @brief  Append a C string.
       *  @param __s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	const size_type __n = traits_type::length(__s);
	_M_check_length(size_type(0), __n, "basic_string::append");
	return _M_append(__s, __n);
      }

      /**
       *  @brief  Append multiple characters.
       *  @param __n  The number of characters to append.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  Appends __n copies of __c to this string.
       */
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
#endif // C++11
# 1053 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Append a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Appends characters in the range [__first,__last) to this string.
       */
#if __cplusplus >= 201103L
      template<class _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
#else
# 1066 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      template<class _InputIterator>
#endif
# 1068 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }

      /**
       *  @brief  Append a single character.
       *  @param __c  Character to append.
       */
      void
      push_back(_CharT __c)
      {
	const size_type __size = this->size();
	if (__size + 1 > this->capacity())
	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
	traits_type::assign(this->_M_data()[__size], __c);
	this->_M_set_length(__size + 1);
      }

      /**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       */
      basic_string&
      assign(const basic_string& __str)
      {
	this->_M_assign(__str);
	return *this;
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       *
       *  This function sets this string to the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       */
      basic_string&
      assign(basic_string&& __str)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 2063. Contradictory requirements for string move assignment
	return *this = std::move(__str);
      }
#endif // C++11
# 1115 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Set value to a substring of a string.
       *  @param __str  The string to use.
       *  @param __pos  Index of the first character of str.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function sets this string to the substring of @a __str
       *  consisting of @a __n characters at @a __pos.  If @a __n is
       *  is larger than the number of available characters in @a
       *  __str, the remainder of @a __str is used.
       */
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
			  + __str._M_check(__pos, "basic_string::assign"),
			  __str._M_limit(__pos, __n)); }

      /**
       *  @brief  Set value to a C substring.
       *  @param __s  The C string to use.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the first @a __n
       *  characters of @a __s.  If @a __n is is larger than the number of
       *  available characters in @a __s, the remainder of @a __s is used.
       */
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
	__glibcxx_requires_string_len(__s, __n);
	return _M_replace(size_type(0), this->size(), __s, __n);
      }

      /**
       *  @brief  Set value to contents of a C string.
       *  @param __s  The C string to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the value of @a __s.
       *  The data is copied, so there is no dependence on @a __s once the
       *  function returns.
       */
      basic_string&
      assign(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return _M_replace(size_type(0), this->size(), __s,
			  traits_type::length(__s));
      }

      /**
       *  @brief  Set value to multiple characters.
       *  @param __n  Length of the resulting string.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to @a __n copies of
       *  character @a __c.
       */
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }

      /**
       *  @brief  Set value to a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Sets value of string to characters in the range [__first,__last).
      */
#if __cplusplus >= 201103L
      template<class _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
#else
# 1194 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      template<class _InputIterator>
#endif
# 1196 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Set value to an initializer_list of characters.
       *  @param __l  The initializer_list of characters to assign.
       *  @return  Reference to this string.
       */
      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
#endif // C++11
# 1210 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert multiple characters.
       *  @param __p  Const_iterator referencing location in string to
       *              insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @return  Iterator referencing the first inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
	const size_type __pos = __p - begin();
	this->replace(__p, __p, __n, __c);
	return iterator(this->_M_data() + __pos);
      }
#else
# 1236 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      /**
       *  @brief  Insert multiple characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      void
      insert(iterator __p, size_type __n, _CharT __c)
      {	this->replace(__p, __p, __n, __c);  }
#endif
# 1253 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert a range of characters.
       *  @param __p  Const_iterator referencing location in string to
       *              insert at.
       *  @param __beg  Start of range.
       *  @param __end  End of range.
       *  @return  Iterator referencing the first inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [beg,end).  If adding characters
       *  causes the length to exceed max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      */
      template<class _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
	iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
	  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
	  const size_type __pos = __p - begin();
	  this->replace(__p, __p, __beg, __end);
	  return iterator(this->_M_data() + __pos);
	}
#else
# 1280 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      /**
       *  @brief  Insert a range of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __beg  Start of range.
       *  @param __end  End of range.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [__beg,__end).  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
#endif
# 1297 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert an initializer_list of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __l  The initializer_list of characters to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       */
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
	this->insert(__p - begin(), __l.begin(), __l.size());
      }
#endif // C++11
# 1312 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Insert value of a string.
       *  @param __pos1  Iterator referencing location in string to insert at.
       *  @param __str  The string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts value of @a __str starting at @a __pos1.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
			     __str._M_data(), __str.size()); }

      /**
       *  @brief  Insert a substring.
       *  @param __pos1  Iterator referencing location in string to insert at.
       *  @param __str  The string to insert.
       *  @param __pos2  Start of characters in str to insert.
       *  @param __n  Number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos1 > size() or
       *  @a __pos2 > @a str.size().
       *
       *  Starting at @a pos1, insert @a __n character of @a __str
       *  beginning with @a __pos2.  If adding characters causes the
       *  length to exceed max_size(), length_error is thrown.  If @a
       *  __pos1 is beyond the end of this string or @a __pos2 is
       *  beyond the end of @a __str, out_of_range is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
	     size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
			     + __str._M_check(__pos2, "basic_string::insert"),
			     __str._M_limit(__pos2, __n)); }

      /**
       *  @brief  Insert a C substring.
       *  @param __pos  Iterator referencing location in string to insert at.
       *  @param __s  The C string to insert.
       *  @param __n  The number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a __n characters of @a __s starting at @a
       *  __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos is beyond
       *  end(), out_of_range is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }

      /**
       *  @brief  Insert a C string.
       *  @param __pos  Iterator referencing location in string to insert at.
       *  @param __s  The C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->replace(__pos, size_type(0), __s,
			     traits_type::length(__s));
      }

      /**
       *  @brief  Insert multiple characters.
       *  @param __pos  Index in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts @a __n copies of character @a __c starting at index
       *  @a __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos > length(),
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
			      size_type(0), __n, __c); }

      /**
       *  @brief  Insert one character.
       *  @param __p  Iterator referencing position in string to insert at.
       *  @param __c  The character to insert.
       *  @return  Iterator referencing newly inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts character @a __c at position referenced by @a __p.
       *  If adding character causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
	const size_type __pos = __p - begin();
	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
	return iterator(_M_data() + __pos);
      }

      /**
       *  @brief  Remove characters.
       *  @param __pos  Index of first character to remove (default 0).
       *  @param __n  Number of characters to remove (default remainder).
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Removes @a __n characters from this string starting at @a
       *  __pos.  The length of the string is reduced by @a __n.  If
       *  there are < @a __n characters to remove, the remainder of
       *  the string is truncated.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
	this->_M_erase(_M_check(__pos, "basic_string::erase"),
		       _M_limit(__pos, __n));
	return *this;
      }

      /**
       *  @brief  Remove one character.
       *  @param __position  Iterator referencing the character to remove.
       *  @return  iterator referencing same location after removal.
       *
       *  Removes the character at @a __position from this string. The value
       *  of the string doesn't change if an error is thrown.
      */
      iterator
      erase(__const_iterator __position)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()
				 && __position < end());
	const size_type __pos = __position - begin();
	this->_M_erase(__pos, size_type(1));
	return iterator(_M_data() + __pos);
      }

      /**
       *  @brief  Remove a range of characters.
       *  @param __first  Iterator referencing the first character to remove.
       *  @param __last  Iterator referencing the end of the range.
       *  @return  Iterator referencing location of first after removal.
       *
       *  Removes the characters in the range [first,last) from this string.
       *  The value of the string doesn't change if an error is thrown.
      */
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last
				 && __last <= end());
        const size_type __pos = __first - begin();
	this->_M_erase(__pos, __last - __first);
	return iterator(this->_M_data() + __pos);
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Remove the last character.
       *
       *  The string must be non-empty.
       */
      void
      pop_back() noexcept
      { _M_erase(size()-1, 1); }
#endif // C++11
# 1511 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Replace characters with value from another string.
       *  @param __pos  Index of first character to replace.
       *  @param __n  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos+__n) from
       *  this string.  In place, the value of @a __str is inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of the result exceeds max_size(), length_error
       *  is thrown.  The value of the string doesn't change if an
       *  error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }

      /**
       *  @brief  Replace characters with value from another string.
       *  @param __pos1  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @param __pos2  Index of first character of str to use.
       *  @param __n2  Number of characters from str to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
       *  __str.size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos1,__pos1 + n) from this
       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
       *  beyond end of string, out_of_range is thrown.  If the length of the
       *  result exceeds max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
	      size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
			     + __str._M_check(__pos2, "basic_string::replace"),
			     __str._M_limit(__pos2, __n2)); }

      /**
       *  @brief  Replace characters with value of a C substring.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @param __n2  Number of characters from @a s to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the first @a __n2 characters of
       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
       *  @a __pos is beyond end of string, out_of_range is thrown.  If
       *  the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
	      size_type __n2)
      {
	__glibcxx_requires_string_len(__s, __n2);
	return _M_replace(_M_check(__pos, "basic_string::replace"),
			  _M_limit(__pos, __n1), __s, __n2);
      }

      /**
       *  @brief  Replace characters with value of a C string.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the characters of @a __s are
       *  inserted.  If @a __pos is beyond end of string, out_of_range
       *  is thrown.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Replace characters with multiple characters.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __n2  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this
       *  string.  In place, @a __n2 copies of @a __c are inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
			      _M_limit(__pos, __n1), __n2, __c); }

      /**
       *  @brief  Replace range of characters with string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __str  String value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the value of @a __str is inserted.  If the length of result
       *  exceeds max_size(), length_error is thrown.  The value of
       *  the string doesn't change if an error is thrown.
      */
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
	      const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }

      /**
       *  @brief  Replace range of characters with C substring.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @param __n  Number of characters from s to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the first @a __n characters of @a __s are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
	      const _CharT* __s, size_type __n)
      {
	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				 && __i2 <= end());
	return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }

      /**
       *  @brief  Replace range of characters with C string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the characters of @a __s are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Replace range of characters with multiple characters
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __n  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  @a __n copies of @a __c are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
	      _CharT __c)
      {
	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				 && __i2 <= end());
	return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }

      /**
       *  @brief  Replace range of characters with range.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __k1  Iterator referencing start of range to insert.
       *  @param __k2  Iterator referencing end of range to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */
#if __cplusplus >= 201103L
      template<class _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
		_InputIterator __k1, _InputIterator __k2)
        {
	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				   && __i2 <= end());
	  __glibcxx_requires_valid_range(__k1, __k2);
	  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
					   std::__false_type());
	}
#else
# 1744 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      template<class _InputIterator>
#ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
        typename __enable_if_not_native_iterator<_InputIterator>::__type
#else
# 1748 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
        basic_string&
#endif
# 1750 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
        replace(iterator __i1, iterator __i2,
		_InputIterator __k1, _InputIterator __k2)
        {
	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				   && __i2 <= end());
	  __glibcxx_requires_valid_range(__k1, __k2);
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
	}
#endif
# 1760 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      // Specializations for the common case of pointer and iterator:
      // useful to avoid the overhead of temporary buffering in _M_replace.
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
	      _CharT* __k1, _CharT* __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				 && __i2 <= end());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - begin(), __i2 - __i1,
			     __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
	      const _CharT* __k1, const _CharT* __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				 && __i2 <= end());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - begin(), __i2 - __i1,
			     __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
	      iterator __k1, iterator __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				 && __i2 <= end());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - begin(), __i2 - __i1,
			     __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
	      const_iterator __k1, const_iterator __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
				 && __i2 <= end());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - begin(), __i2 - __i1,
			     __k1.base(), __k2 - __k1);
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Replace range of characters with initializer_list.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __l  The initializer_list of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string& replace(const_iterator __i1, const_iterator __i2,
			    initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
#endif // C++11
# 1826 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

    private:
      template<class _Integer>
	basic_string&
	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
			    _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
	basic_string&
	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
			    _InputIterator __k1, _InputIterator __k2,
			    __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
		     _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
		 const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:

      /**
       *  @brief  Copy substring into C string.
       *  @param __s  C string to copy value into.
       *  @param __n  Number of characters to copy.
       *  @param __pos  Index of first character to copy.
       *  @return  Number of characters actually copied
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Copies up to @a __n characters starting at @a __pos into the
       *  C string @a __s.  If @a __pos is %greater than size(),
       *  out_of_range is thrown.
      */
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;

      /**
       *  @brief  Swap contents with another string.
       *  @param __s  String to swap with.
       *
       *  Exchanges the contents of this string with that of @a __s in constant
       *  time.
      */
      void
      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;

      // String operations:
      /**
       *  @brief  Return const pointer to null-terminated contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      c_str() const _GLIBCXX_NOEXCEPT
      { return _M_data(); }

      /**
       *  @brief  Return const pointer to contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      data() const _GLIBCXX_NOEXCEPT
      { return _M_data(); }

      /**
       *  @brief  Return copy of allocator used to construct this string.
      */
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return _M_get_allocator(); }

      /**
       *  @brief  Find position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from @a s to search for.
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for value of @a __str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the value of @a
       *  __s within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
	__glibcxx_requires_string(__s);
	return this->find(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Find last position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for value of @a
       *  __str within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      */
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT
      { return this->rfind(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find last position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to start search at (default end).
       *  @return  Index of start of  last occurrence.
       *
       *  Starting from @a __pos, searches backward for the value of
       *  @a __s within this string.  If found, returns the index
       *  where it begins.  If not found, returns npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
	__glibcxx_requires_string(__s);
	return this->rfind(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Find position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a character of C substring.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find position of a character of C string.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
	__glibcxx_requires_string(__s);
	return this->find_first_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the character
       *  @a __c within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
       *
       *  Note: equivalent to find(__c, __pos).
      */
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
      { return this->find(__c, __pos); }

      /**
       *  @brief  Find last position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT
      { return this->find_last_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a character of C substring.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find last position of a character of C string.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
	__glibcxx_requires_string(__s);
	return this->find_last_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
       *
       *  Note: equivalent to rfind(__c, __pos).
      */
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
      { return this->rfind(__c, __pos); }

      /**
       *  @brief  Find position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not contained
       *  in @a __str within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from __s to consider.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in the first @a __n characters of @a __s within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
			size_type __n) const;

      /**
       *  @brief  Find position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
	__glibcxx_requires_string(__s);
	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character
       *  other than @a __c within this string.  If found, returns the
       *  index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Find last position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to consider.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character not
       *  contained in the first @a __n characters of @a __s within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
		       size_type __n) const;
      /**
       *  @brief  Find last position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __s within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
	__glibcxx_requires_string(__s);
	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character other than
       *  @a __c within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Get a substring.
       *  @param __pos  Index of first character (default 0).
       *  @param __n  Number of characters in substring (default remainder).
       *  @return  The new string.
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Construct and return a new string using the @a __n
       *  characters starting at @a __pos.  If the string is too
       *  short, use the remainder of the characters.  If @a __pos is
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }

      /**
       *  @brief  Compare to a string.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a
       *  __str, 0 if their values are equivalent, or > 0 if this
       *  string is ordered after @a __str.  Determines the effective
       *  length rlen of the strings to compare as the smallest of
       *  size() and str.size().  The function then compares the two
       *  strings by calling traits::compare(data(), str.data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      */
      int
      compare(const basic_string& __str) const
      {
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
	  __r = _S_compare(__size, __osize);
	return __r;
      }

      /**
       *  @brief  Compare substring to a string.
       *  @param __pos  Index of first character of substring.
       *  @param __n  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n characters
       *  starting at @a __pos.  Returns an integer < 0 if the
       *  substring is ordered before @a __str, 0 if their values are
       *  equivalent, or > 0 if the substring is ordered after @a
       *  __str.  Determines the effective length rlen of the strings
       *  to compare as the smallest of the length of the substring
       *  and @a __str.size().  The function then compares the two
       *  strings by calling
       *  traits::compare(substring.data(),str.data(),rlen).  If the
       *  result of the comparison is nonzero returns it, otherwise
       *  the shorter one is ordered first.
      */
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;

      /**
       *  @brief  Compare substring to a substring.
       *  @param __pos1  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @param __pos2  Index of first character of substring of str.
       *  @param __n2  Number of characters in substring of str.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos1.  Form the substring of @a
       *  __str from the @a __n2 characters starting at @a __pos2.
       *  Returns an integer < 0 if this substring is ordered before
       *  the substring of @a __str, 0 if their values are equivalent,
       *  or > 0 if this substring is ordered after the substring of
       *  @a __str.  Determines the effective length rlen of the
       *  strings to compare as the smallest of the lengths of the
       *  substrings.  The function then compares the two strings by
       *  calling
       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      */
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
	      size_type __pos2, size_type __n2) const;

      /**
       *  @brief  Compare to a C string.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and the length of a string
       *  constructed from @a __s.  The function then compares the two strings
       *  by calling traits::compare(data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      */
      int
      compare(const _CharT* __s) const;

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 5 String::compare specification questionable
      /**
       *  @brief  Compare substring to a C string.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a pos.  Returns an integer < 0 if
       *  the substring is ordered before @a __s, 0 if their values
       *  are equivalent, or > 0 if the substring is ordered after @a
       *  __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of the length of the substring and
       *  the length of a string constructed from @a __s.  The
       *  function then compares the two string by calling
       *  traits::compare(substring.data(),__s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;

      /**
       *  @brief  Compare substring against a character %array.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  character %array to compare against.
       *  @param __n2  Number of characters of s.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos.  Form a string from the
       *  first @a __n2 characters of @a __s.  Returns an integer < 0
       *  if this substring is ordered before the string from @a __s,
       *  0 if their values are equivalent, or > 0 if this substring
       *  is ordered after the string from @a __s.  Determines the
       *  effective length rlen of the strings to compare as the
       *  smallest of the length of the substring and @a __n2.  The
       *  function then compares the two strings by calling
       *  traits::compare(substring.data(),s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
       *
       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
       *  no special meaning.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
	      size_type __n2) const;
  };
_GLIBCXX_END_NAMESPACE_CXX11
#else  // !_GLIBCXX_USE_CXX11_ABI
# 2443 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
  // Reference-counted COW string implentation

  /**
   *  @class basic_string basic_string.h <string>
   *  @brief  Managing sequences of characters and character-like objects.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  @tparam _CharT  Type of character
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.  Of the
   *  <a href="tables.html#68">optional sequence requirements</a>, only
   *  @c push_back, @c at, and @c %array access are supported.
   *
   *  @doctodo
   *
   *
   *  Documentation?  What's that?
   *  Nathan Myers <ncm@cantrip.org>.
   *
   *  A string looks like this:
   *
   *  @code
   *                                        [_Rep]
   *                                        _M_length
   *   [basic_string<char_type>]            _M_capacity
   *   _M_dataplus                          _M_refcount
   *   _M_p ---------------->               unnamed array of char_type
   *  @endcode
   *
   *  Where the _M_p points to the first character in the string, and
   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
   *  pointer to the header.
   *
   *  This approach has the enormous advantage that a string object
   *  requires only one allocation.  All the ugliness is confined
   *  within a single %pair of inline functions, which each compile to
   *  a single @a add instruction: _Rep::_M_data(), and
   *  string::_M_rep(); and the allocation function which gets a
   *  block of raw bytes and with room enough and constructs a _Rep
   *  object at the front.
   *
   *  The reason you want _M_data pointing to the character %array and
   *  not the _Rep is so that the debugger can see the string
   *  contents. (Probably we should add a non-inline member to get
   *  the _Rep for the debugger to use, so users can check the actual
   *  string length.)
   *
   *  Note that the _Rep object is a POD so that you can have a
   *  static <em>empty string</em> _Rep object already @a constructed before
   *  static constructors have run.  The reference-count encoding is
   *  chosen so that a 0 indicates one reference, so you never try to
   *  destroy the empty-string _Rep object.
   *
   *  All but the last paragraph is considered pretty conventional
   *  for a C++ string implementation.
  */
  // 21.3  Template class basic_string
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;

      // Types:
    public:
      typedef _Traits					    traits_type;
      typedef typename _Traits::char_type		    value_type;
      typedef _Alloc					    allocator_type;
      typedef typename _CharT_alloc_type::size_type	    size_type;
      typedef typename _CharT_alloc_type::difference_type   difference_type;
      typedef typename _CharT_alloc_type::reference	    reference;
      typedef typename _CharT_alloc_type::const_reference   const_reference;
      typedef typename _CharT_alloc_type::pointer	    pointer;
      typedef typename _CharT_alloc_type::const_pointer	    const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
      typedef std::reverse_iterator<iterator>		    reverse_iterator;

    private:
      // _Rep: string representation
      //   Invariants:
      //   1. String really contains _M_length + 1 characters: due to 21.3.4
      //      must be kept null-terminated.
      //   2. _M_capacity >= _M_length
      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
      //   3. _M_refcount has three states:
      //      -1: leaked, one reference, no ref-copies allowed, non-const.
      //       0: one reference, non-const.
      //     n>0: n + 1 references, operations require a lock, const.
      //   4. All fields==0 is an empty string, given the extra storage
      //      beyond-the-end for a null terminator; thus, the shared
      //      empty string representation needs no constructor.

      struct _Rep_base
      {
	size_type		_M_length;
	size_type		_M_capacity;
	_Atomic_word		_M_refcount;
      };

      struct _Rep : _Rep_base
      {
	// Types:
	typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;

	// (Public) Data members:

	// The maximum number of individual char_type elements of an
	// individual string is determined by _S_max_size. This is the
	// value that will be returned by max_size().  (Whereas npos
	// is the maximum number of bytes the allocator can allocate.)
	// If one was to divvy up the theoretical largest size string,
	// with a terminating character and m _CharT elements, it'd
	// look like this:
	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
	// Solving for m:
	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
	// In addition, this implementation quarters this amount.
	static const size_type	_S_max_size;
	static const _CharT	_S_terminal;

	// The following storage is init'd to 0 by the linker, resulting
        // (carefully) in an empty string with one reference.
        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep() _GLIBCXX_NOEXCEPT
        { 
	  // NB: Mild hack to avoid strict-aliasing warnings.  Note that
	  // _S_empty_rep_storage is never modified and the punning should
	  // be reasonably safe in this case.
	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
	  return *reinterpret_cast<_Rep*>(__p);
	}

        bool
	_M_is_leaked() const _GLIBCXX_NOEXCEPT
        { return this->_M_refcount < 0; }

        bool
	_M_is_shared() const _GLIBCXX_NOEXCEPT
        { return this->_M_refcount > 0; }

        void
	_M_set_leaked() _GLIBCXX_NOEXCEPT
        { this->_M_refcount = -1; }

        void
	_M_set_sharable() _GLIBCXX_NOEXCEPT
        { this->_M_refcount = 0; }

	void
	_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
# 2608 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
	    {
	      this->_M_set_sharable();  // One reference.
	      this->_M_length = __n;
	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
	      // grrr. (per 21.3.4)
	      // You cannot leave those LWG people alone for a second.
	    }
	}

	_CharT*
	_M_refdata() throw()
	{ return reinterpret_cast<_CharT*>(this + 1); }

	_CharT*
	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
	{
	  return (!_M_is_leaked() && __alloc1 == __alloc2)
	          ? _M_refcopy() : _M_clone(__alloc1);
	}

	// Create & Destroy
	static _Rep*
	_S_create(size_type, size_type, const _Alloc&);

	void
	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
# 2638 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
	    {
	      // Be race-detector-friendly.  For more info see bits/c++config.
	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
							 -1) <= 0)
		{
		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
		  _M_destroy(__a);
		}
	    }
	}  // XXX MT

	void
	_M_destroy(const _Alloc&) throw();

	_CharT*
	_M_refcopy() throw()
	{
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	  if (__builtin_expect(this != &_S_empty_rep(), false))
#endif
# 2659 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
	  return _M_refdata();
	}  // XXX MT

	_CharT*
	_M_clone(const _Alloc&, size_type __res = 0);
      };

      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
      struct _Alloc_hider : _Alloc
      {
	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
	: _Alloc(__a), _M_p(__dat) { }

	_CharT* _M_p; // The actual data.
      };

    public:
      // Data Members (public):
      // NB: This is an unsigned type, and thus represents the maximum
      // size that the allocator can hold.
      ///  Value returned by various member functions when they fail.
      static const size_type	npos = static_cast<size_type>(-1);

    private:
      // Data Members (private):
      mutable _Alloc_hider	_M_dataplus;

      _CharT*
      _M_data() const _GLIBCXX_NOEXCEPT
      { return  _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const _GLIBCXX_NOEXCEPT
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }

      // For the internal use we have functions similar to `begin'/`end'
      // but they do not call _M_leak.
      iterator
      _M_ibegin() const _GLIBCXX_NOEXCEPT
      { return iterator(_M_data()); }

      iterator
      _M_iend() const _GLIBCXX_NOEXCEPT
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()    // for use in begin() & non-const op[]
      {
	if (!_M_rep()->_M_is_leaked())
	  _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
	if (__pos > this->size())
	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
				       "this->size() (which is %zu)"),
				   __s, __pos, this->size());
	return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
	if (this->max_size() - (this->size() - __n1) < __n2)
	  __throw_length_error(__N(__s));
      }

      // NB: _M_limit doesn't check for a bad __pos value.
      size_type
      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
      {
	const bool __testoff =  __off < this->size() - __pos;
	return __testoff ? __off : this->size() - __pos;
      }

      // True if _Rep and source do not overlap.
      bool
      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
      {
	return (less<const _CharT*>()(__s, _M_data())
		|| less<const _CharT*>()(_M_data() + this->size(), __s));
      }

      // When __n = 1 way faster than the general multichar
      // traits_type::copy/move/assign.
      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
      {
	if (__n == 1)
	  traits_type::assign(*__d, *__s);
	else
	  traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
      {
	if (__n == 1)
	  traits_type::assign(*__d, *__s);
	else
	  traits_type::move(__d, __s, __n);	  
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT
      {
	if (__n == 1)
	  traits_type::assign(*__d, __c);
	else
	  traits_type::assign(__d, __n, __c);	  
      }

      // _S_copy_chars is a separate template to permit specialization
      // to optimize for the common case of pointers as iterators.
      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
	_GLIBCXX_NOEXCEPT
        {
	  for (; __k1 != __k2; ++__k1, ++__p)
	    traits_type::assign(*__p, *__k1); // These types are off.
	}

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      _GLIBCXX_NOEXCEPT
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      _GLIBCXX_NOEXCEPT
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
      {
	const difference_type __d = difference_type(__n1 - __n2);

	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
	  return __gnu_cxx::__numeric_traits<int>::__max;
	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
	  return __gnu_cxx::__numeric_traits<int>::__min;
	else
	  return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep() _GLIBCXX_NOEXCEPT
      { return _Rep::_S_empty_rep(); }

    public:
      // Construct/copy/destroy:
      // NB: We overload ctors in some cases instead of using default
      // arguments, per 17.4.4.4 para. 2 item 2.

      /**
       *  @brief  Default constructor creates an empty string.
       */
      basic_string()
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
#else
# 2842 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ }
#endif
# 2844 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Construct an empty string using allocator @a a.
       */
      explicit
      basic_string(const _Alloc& __a);

      // NB: per LWG issue 42, semantics different from IS:
      /**
       *  @brief  Construct string with copy of value of @a str.
       *  @param  __str  Source string.
       */
      basic_string(const basic_string& __str);
      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy (default remainder).
       */
      basic_string(const basic_string& __str, size_type __pos,
		   size_type __n = npos);
      /**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy.
       *  @param  __a  Allocator to use.
       */
      basic_string(const basic_string& __str, size_type __pos,
		   size_type __n, const _Alloc& __a);

      /**
       *  @brief  Construct string initialized by a character %array.
       *  @param  __s  Source character %array.
       *  @param  __n  Number of characters to copy.
       *  @param  __a  Allocator to use (default is default allocator).
       *
       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
       *  has no special meaning.
       */
      basic_string(const _CharT* __s, size_type __n,
		   const _Alloc& __a = _Alloc());
      /**
       *  @brief  Construct string as copy of a C string.
       *  @param  __s  Source C string.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      /**
       *  @brief  Construct string as multiple characters.
       *  @param  __n  Number of characters.
       *  @param  __c  Character to use.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());

#if __cplusplus >= 201103L
      /**
       *  @brief  Move construct string.
       *  @param  __str  Source string.
       *
       *  The newly-created string contains the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       **/
      basic_string(basic_string&& __str)
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      noexcept // FIXME C++11: should always be noexcept.
#endif
# 2912 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      : _M_dataplus(__str._M_dataplus)
      {
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	__str._M_data(_S_empty_rep()._M_refdata());
#else
# 2917 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
	__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));
#endif
# 2919 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
      }

      /**
       *  @brief  Construct string from an initializer %list.
       *  @param  __l  std::initializer_list of characters.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
#endif // C++11
# 2928 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Construct string as copy of a range.
       *  @param  __beg  Start of range.
       *  @param  __end  End of range.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
		     const _Alloc& __a = _Alloc());

      /**
       *  @brief  Destroy the string instance.
       */
      ~basic_string() _GLIBCXX_NOEXCEPT
      { _M_rep()->_M_dispose(this->get_allocator()); }

      /**
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       */
      basic_string&
      operator=(const basic_string& __str) 
      { return this->assign(__str); }

      /**
       *  @brief  Copy contents of @a s into this string.
       *  @param  __s  Source null-terminated string.
       */
      basic_string&
      operator=(const _CharT* __s) 
      { return this->assign(__s); }

      /**
       *  @brief  Set value to string of length 1.
       *  @param  __c  Source character.
       *
       *  Assigning to a character makes this string length 1 and
       *  (*this)[0] == @a c.
       */
      basic_string&
      operator=(_CharT __c) 
      { 
	this->assign(1, __c); 
	return *this;
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Move assign the value of @a str to this string.
       *  @param  __str  Source string.
       *
       *  The contents of @a str are moved into this string (without copying).
       *  @a str is a valid, but unspecified string.
       **/
      // PR 58265, this should be noexcept.
      basic_string&
      operator=(basic_string&& __str)
      {
	// NB: DR 1204.
	this->swap(__str);
	return *this;
      }

      /**
       *  @brief  Set value to string constructed from initializer %list.
       *  @param  __l  std::initializer_list.
       */
      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
	this->assign(__l.begin(), __l.size());
	return *this;
      }
#endif // C++11
# 3003 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      // Iterators:
      /**
       *  Returns a read/write iterator that points to the first character in
       *  the %string.  Unshares the string.
       */
      iterator
      begin() // FIXME C++11: should be noexcept.
      {
	_M_leak();
	return iterator(_M_data());
      }

      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return const_iterator(_M_data()); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  character in the %string.  Unshares the string.
       */
      iterator
      end() // FIXME C++11: should be noexcept.
      {
	_M_leak();
	return iterator(_M_data() + this->size());
      }

      /**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return const_iterator(_M_data() + this->size()); }

      /**
       *  Returns a read/write reverse iterator that points to the last
       *  character in the %string.  Iteration is done in reverse element
       *  order.  Unshares the string.
       */
      reverse_iterator
      rbegin() // FIXME C++11: should be noexcept.
      { return reverse_iterator(this->end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(this->end()); }

      /**
       *  Returns a read/write reverse iterator that points to one before the
       *  first character in the %string.  Iteration is done in reverse
       *  element order.  Unshares the string.
       */
      reverse_iterator
      rend() // FIXME C++11: should be noexcept.
      { return reverse_iterator(this->begin()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(this->begin()); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       */
      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }

      /**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       */
      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }
#endif
# 3114 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

    public:
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }

      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      length() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }

      ///  Returns the size() of the largest possible %string.
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _Rep::_S_max_size; }

      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *  @param  __c  Character to fill any new elements.
       *
       *  This function will %resize the %string to the specified
       *  number of characters.  If the number is smaller than the
       *  %string's current size the %string is truncated, otherwise
       *  the %string is extended and new elements are %set to @a __c.
       */
      void
      resize(size_type __n, _CharT __c);

      /**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *
       *  This function will resize the %string to the specified length.  If
       *  the new size is smaller than the %string's current size the %string
       *  is truncated, otherwise the %string is extended and new characters
       *  are default-constructed.  For basic types such as char, this means
       *  setting them to 0.
       */
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }

#if __cplusplus >= 201103L
      ///  A non-binding request to reduce capacity() to size().
      void
      shrink_to_fit() _GLIBCXX_NOEXCEPT
      {
	if (capacity() > size())
	  {
	    __try
	      { reserve(0); }
	    __catch(...)
	      { }
	  }
      }
#endif
# 3175 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  Returns the total number of characters that the %string can hold
       *  before needing to allocate more memory.
       */
      size_type
      capacity() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_capacity; }

      /**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          characters.
       *  @param  __res_arg  Number of characters required.
       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %string to hold the specified number of characters.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the string length that will be
       *  required, the user can reserve the memory in %advance, and thus
       *  prevent a possible reallocation of memory and copying of %string
       *  data.
       */
      void
      reserve(size_type __res_arg = 0);

      /**
       *  Erases the string, making it empty.
       */
      // PR 56166: this should not throw.
      void
      clear()
      { _M_mutate(0, this->size(), 0); }

      /**
       *  Returns true if the %string is empty.  Equivalent to 
       *  <code>*this == ""</code>.
       */
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return this->size() == 0; }

      // Element access:
      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read-only (constant) reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      const_reference
      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
      {
	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
	return _M_data()[__pos];
      }

      /**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read/write reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)  Unshares the string.
       */
      reference
      operator[](size_type __pos)
      {
        // Allow pos == size() both in C++98 mode, as v3 extension,
	// and in C++11 mode.
	_GLIBCXX_DEBUG_ASSERT(__pos <= size());
        // In pedantic mode be strict in C++98 mode.
	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
	_M_leak();
	return _M_data()[__pos];
      }

      /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read-only (const) reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */
      const_reference
      at(size_type __n) const
      {
	if (__n >= this->size())
	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
				       "(which is %zu) >= this->size() "
				       "(which is %zu)"),
				   __n, this->size());
	return _M_data()[__n];
      }

      /**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read/write reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.  Success results in
       *  unsharing the string.
       */
      reference
      at(size_type __n)
      {
	if (__n >= size())
	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
				       "(which is %zu) >= this->size() "
				       "(which is %zu)"),
				   __n, this->size());
	_M_leak();
	return _M_data()[__n];
      }

#if __cplusplus >= 201103L
      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %string.
       */
      reference
      front()
      { return operator[](0); }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %string.
       */
      const_reference
      front() const _GLIBCXX_NOEXCEPT
      { return operator[](0); }

      /**
       *  Returns a read/write reference to the data at the last
       *  element of the %string.
       */
      reference
      back()
      { return operator[](this->size() - 1); }

      /**
       *  Returns a read-only (constant) reference to the data at the
       *  last element of the %string.
       */
      const_reference
      back() const _GLIBCXX_NOEXCEPT
      { return operator[](this->size() - 1); }
#endif
# 3337 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      // Modifiers:
      /**
       *  @brief  Append a string to this string.
       *  @param __str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }

      /**
       *  @brief  Append a C string.
       *  @param __s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }

      /**
       *  @brief  Append a character.
       *  @param __c  The character to append.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(_CharT __c)
      { 
	this->push_back(__c);
	return *this;
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to be appended.
       *  @return  Reference to this string.
       */
      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
#endif // C++11
# 3379 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Append a string to this string.
       *  @param __str  The string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const basic_string& __str);

      /**
       *  @brief  Append a substring.
       *  @param __str  The string to append.
       *  @param __pos  Index of the first character of str to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a __pos is not a valid index.
       *
       *  This function appends @a __n characters from @a __str
       *  starting at @a __pos to this string.  If @a __n is is larger
       *  than the number of available characters in @a __str, the
       *  remainder of @a __str is appended.
       */
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);

      /**
       *  @brief  Append a C substring.
       *  @param __s  The C string to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s, size_type __n);

      /**
       *  @brief  Append a C string.
       *  @param __s  The C string to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->append(__s, traits_type::length(__s));
      }

      /**
       *  @brief  Append multiple characters.
       *  @param __n  The number of characters to append.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  Appends __n copies of __c to this string.
       */
      basic_string&
      append(size_type __n, _CharT __c);

#if __cplusplus >= 201103L
      /**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to append.
       *  @return  Reference to this string.
       */
      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
#endif // C++11
# 3446 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Append a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Appends characters in the range [__first,__last) to this string.
       */
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }

      /**
       *  @brief  Append a single character.
       *  @param __c  Character to append.
       */
      void
      push_back(_CharT __c)
      { 
	const size_type __len = 1 + this->size();
	if (__len > this->capacity() || _M_rep()->_M_is_shared())
	  this->reserve(__len);
	traits_type::assign(_M_data()[this->size()], __c);
	_M_rep()->_M_set_length_and_sharable(__len);
      }

      /**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       */
      basic_string&
      assign(const basic_string& __str);

#if __cplusplus >= 201103L
      /**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       *
       *  This function sets this string to the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       */
      // PR 58265, this should be noexcept.
      basic_string&
      assign(basic_string&& __str)
      {
	this->swap(__str);
	return *this;
      }
#endif // C++11
# 3499 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Set value to a substring of a string.
       *  @param __str  The string to use.
       *  @param __pos  Index of the first character of str.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function sets this string to the substring of @a __str
       *  consisting of @a __n characters at @a __pos.  If @a __n is
       *  is larger than the number of available characters in @a
       *  __str, the remainder of @a __str is used.
       */
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
			    + __str._M_check(__pos, "basic_string::assign"),
			    __str._M_limit(__pos, __n)); }

      /**
       *  @brief  Set value to a C substring.
       *  @param __s  The C string to use.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the first @a __n
       *  characters of @a __s.  If @a __n is is larger than the number of
       *  available characters in @a __s, the remainder of @a __s is used.
       */
      basic_string&
      assign(const _CharT* __s, size_type __n);

      /**
       *  @brief  Set value to contents of a C string.
       *  @param __s  The C string to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the value of @a __s.
       *  The data is copied, so there is no dependence on @a __s once the
       *  function returns.
       */
      basic_string&
      assign(const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->assign(__s, traits_type::length(__s));
      }

      /**
       *  @brief  Set value to multiple characters.
       *  @param __n  Length of the resulting string.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to @a __n copies of
       *  character @a __c.
       */
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }

      /**
       *  @brief  Set value to a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Sets value of string to characters in the range [__first,__last).
      */
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Set value to an initializer_list of characters.
       *  @param __l  The initializer_list of characters to assign.
       *  @return  Reference to this string.
       */
      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
#endif // C++11
# 3584 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Insert multiple characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      void
      insert(iterator __p, size_type __n, _CharT __c)
      {	this->replace(__p, __p, __n, __c);  }

      /**
       *  @brief  Insert a range of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __beg  Start of range.
       *  @param __end  End of range.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [__beg,__end).  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Insert an initializer_list of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __l  The initializer_list of characters to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       */
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
	this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
#endif // C++11
# 3633 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Insert value of a string.
       *  @param __pos1  Iterator referencing location in string to insert at.
       *  @param __str  The string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts value of @a __str starting at @a __pos1.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }

      /**
       *  @brief  Insert a substring.
       *  @param __pos1  Iterator referencing location in string to insert at.
       *  @param __str  The string to insert.
       *  @param __pos2  Start of characters in str to insert.
       *  @param __n  Number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos1 > size() or
       *  @a __pos2 > @a str.size().
       *
       *  Starting at @a pos1, insert @a __n character of @a __str
       *  beginning with @a __pos2.  If adding characters causes the
       *  length to exceed max_size(), length_error is thrown.  If @a
       *  __pos1 is beyond the end of this string or @a __pos2 is
       *  beyond the end of @a __str, out_of_range is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
	     size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
			    + __str._M_check(__pos2, "basic_string::insert"),
			    __str._M_limit(__pos2, __n)); }

      /**
       *  @brief  Insert a C substring.
       *  @param __pos  Iterator referencing location in string to insert at.
       *  @param __s  The C string to insert.
       *  @param __n  The number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a __n characters of @a __s starting at @a
       *  __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos is beyond
       *  end(), out_of_range is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);

      /**
       *  @brief  Insert a C string.
       *  @param __pos  Iterator referencing location in string to insert at.
       *  @param __s  The C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->insert(__pos, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Insert multiple characters.
       *  @param __pos  Index in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts @a __n copies of character @a __c starting at index
       *  @a __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos > length(),
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
			      size_type(0), __n, __c); }

      /**
       *  @brief  Insert one character.
       *  @param __p  Iterator referencing position in string to insert at.
       *  @param __c  The character to insert.
       *  @return  Iterator referencing newly inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts character @a __c at position referenced by @a __p.
       *  If adding character causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      iterator
      insert(iterator __p, _CharT __c)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
	const size_type __pos = __p - _M_ibegin();
	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
	_M_rep()->_M_set_leaked();
	return iterator(_M_data() + __pos);
      }

      /**
       *  @brief  Remove characters.
       *  @param __pos  Index of first character to remove (default 0).
       *  @param __n  Number of characters to remove (default remainder).
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Removes @a __n characters from this string starting at @a
       *  __pos.  The length of the string is reduced by @a __n.  If
       *  there are < @a __n characters to remove, the remainder of
       *  the string is truncated.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      { 
	_M_mutate(_M_check(__pos, "basic_string::erase"),
		  _M_limit(__pos, __n), size_type(0));
	return *this;
      }

      /**
       *  @brief  Remove one character.
       *  @param __position  Iterator referencing the character to remove.
       *  @return  iterator referencing same location after removal.
       *
       *  Removes the character at @a __position from this string. The value
       *  of the string doesn't change if an error is thrown.
      */
      iterator
      erase(iterator __position)
      {
	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
				 && __position < _M_iend());
	const size_type __pos = __position - _M_ibegin();
	_M_mutate(__pos, size_type(1), size_type(0));
	_M_rep()->_M_set_leaked();
	return iterator(_M_data() + __pos);
      }

      /**
       *  @brief  Remove a range of characters.
       *  @param __first  Iterator referencing the first character to remove.
       *  @param __last  Iterator referencing the end of the range.
       *  @return  Iterator referencing location of first after removal.
       *
       *  Removes the characters in the range [first,last) from this string.
       *  The value of the string doesn't change if an error is thrown.
      */
      iterator
      erase(iterator __first, iterator __last);
 
#if __cplusplus >= 201103L
      /**
       *  @brief  Remove the last character.
       *
       *  The string must be non-empty.
       */
      void
      pop_back() // FIXME C++11: should be noexcept.
      { erase(size()-1, 1); }
#endif // C++11
# 3824 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

      /**
       *  @brief  Replace characters with value from another string.
       *  @param __pos  Index of first character to replace.
       *  @param __n  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos+__n) from
       *  this string.  In place, the value of @a __str is inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of the result exceeds max_size(), length_error
       *  is thrown.  The value of the string doesn't change if an
       *  error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }

      /**
       *  @brief  Replace characters with value from another string.
       *  @param __pos1  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @param __pos2  Index of first character of str to use.
       *  @param __n2  Number of characters from str to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
       *  __str.size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos1,__pos1 + n) from this
       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
       *  beyond end of string, out_of_range is thrown.  If the length of the
       *  result exceeds max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
	      size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
			     + __str._M_check(__pos2, "basic_string::replace"),
			     __str._M_limit(__pos2, __n2)); }

      /**
       *  @brief  Replace characters with value of a C substring.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @param __n2  Number of characters from @a s to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the first @a __n2 characters of
       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
       *  @a __pos is beyond end of string, out_of_range is thrown.  If
       *  the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
	      size_type __n2);

      /**
       *  @brief  Replace characters with value of a C string.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the characters of @a __s are
       *  inserted.  If @a __pos is beyond end of string, out_of_range
       *  is thrown.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Replace characters with multiple characters.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __n2  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this
       *  string.  In place, @a __n2 copies of @a __c are inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      */
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
			      _M_limit(__pos, __n1), __n2, __c); }

      /**
       *  @brief  Replace range of characters with string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __str  String value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the value of @a __str is inserted.  If the length of result
       *  exceeds max_size(), length_error is thrown.  The value of
       *  the string doesn't change if an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }

      /**
       *  @brief  Replace range of characters with C substring.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @param __n  Number of characters from s to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the first @a __n characters of @a __s are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
				 && __i2 <= _M_iend());
	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }

      /**
       *  @brief  Replace range of characters with C string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the characters of @a __s are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
	__glibcxx_requires_string(__s);
	return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }

      /**
       *  @brief  Replace range of characters with multiple characters
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __n  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  @a __n copies of @a __c are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      */
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
				 && __i2 <= _M_iend());
	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }

      /**
       *  @brief  Replace range of characters with range.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __k1  Iterator referencing start of range to insert.
       *  @param __k2  Iterator referencing end of range to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
		_InputIterator __k1, _InputIterator __k2)
        {
	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
				   && __i2 <= _M_iend());
	  __glibcxx_requires_valid_range(__k1, __k2);
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
	}

      // Specializations for the common case of pointer and iterator:
      // useful to avoid the overhead of temporary buffering in _M_replace.
      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
				 && __i2 <= _M_iend());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
			     __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
	      const _CharT* __k1, const _CharT* __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
				 && __i2 <= _M_iend());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
			     __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
				 && __i2 <= _M_iend());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
			     __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
	      const_iterator __k1, const_iterator __k2)
      {
	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
				 && __i2 <= _M_iend());
	__glibcxx_requires_valid_range(__k1, __k2);
	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
			     __k1.base(), __k2 - __k1);
      }
      
#if __cplusplus >= 201103L
      /**
       *  @brief  Replace range of characters with initializer_list.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __l  The initializer_list of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */
      basic_string& replace(iterator __i1, iterator __i2,
			    initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
#endif // C++11
# 4110 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

    private:
      template<class _Integer>
	basic_string&
	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
			    _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
	basic_string&
	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
			    _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
		     _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
		      size_type __n2);

      // _S_construct_aux is used to implement the 21.3.1 para 15 which
      // requires special behaviour if _InIter is an integral type
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
			 const _Alloc& __a, __false_type)
	{
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
	}

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
			 const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
				    __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
	{
	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
	  return _S_construct_aux(__beg, __end, __a, _Integral());
        }

      // For Input Iterators, used in istreambuf_iterators, etc.
      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
		      input_iterator_tag);

      // For forward_iterators up to random_access_iterators, used for
      // string::iterator, _CharT*, etc.
      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
		     forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:

      /**
       *  @brief  Copy substring into C string.
       *  @param __s  C string to copy value into.
       *  @param __n  Number of characters to copy.
       *  @param __pos  Index of first character to copy.
       *  @return  Number of characters actually copied
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Copies up to @a __n characters starting at @a __pos into the
       *  C string @a __s.  If @a __pos is %greater than size(),
       *  out_of_range is thrown.
      */
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;

      /**
       *  @brief  Swap contents with another string.
       *  @param __s  String to swap with.
       *
       *  Exchanges the contents of this string with that of @a __s in constant
       *  time.
      */
      // PR 58265, this should be noexcept.
      void
      swap(basic_string& __s);

      // String operations:
      /**
       *  @brief  Return const pointer to null-terminated contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      c_str() const _GLIBCXX_NOEXCEPT
      { return _M_data(); }

      /**
       *  @brief  Return const pointer to contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */
      const _CharT*
      data() const _GLIBCXX_NOEXCEPT
      { return _M_data(); }

      /**
       *  @brief  Return copy of allocator used to construct this string.
      */
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return _M_dataplus; }

      /**
       *  @brief  Find position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from @a s to search for.
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for value of @a __str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      */
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the value of @a
       *  __s within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      */
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
	__glibcxx_requires_string(__s);
	return this->find(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Find last position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for value of @a
       *  __str within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      */
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT
      { return this->rfind(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find last position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to start search at (default end).
       *  @return  Index of start of  last occurrence.
       *
       *  Starting from @a __pos, searches backward for the value of
       *  @a __s within this string.  If found, returns the index
       *  where it begins.  If not found, returns npos.
      */
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
	__glibcxx_requires_string(__s);
	return this->rfind(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Find position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a character of C substring.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find position of a character of C string.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
	__glibcxx_requires_string(__s);
	return this->find_first_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the character
       *  @a __c within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
       *
       *  Note: equivalent to find(__c, __pos).
      */
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
      { return this->find(__c, __pos); }

      /**
       *  @brief  Find last position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT
      { return this->find_last_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a character of C substring.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

      /**
       *  @brief  Find last position of a character of C string.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      */
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
	__glibcxx_requires_string(__s);
	return this->find_last_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
       *
       *  Note: equivalent to rfind(__c, __pos).
      */
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
      { return this->rfind(__c, __pos); }

      /**
       *  @brief  Find position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not contained
       *  in @a __str within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from __s to consider.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in the first @a __n characters of @a __s within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
			size_type __n) const;

      /**
       *  @brief  Find position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
	__glibcxx_requires_string(__s);
	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character
       *  other than @a __c within this string.  If found, returns the
       *  index where it was found.  If not found, returns npos.
      */
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
	_GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Find last position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }

      /**
       *  @brief  Find last position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to consider.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character not
       *  contained in the first @a __n characters of @a __s within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
		       size_type __n) const;
      /**
       *  @brief  Find last position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __s within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      */
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
	__glibcxx_requires_string(__s);
	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }

      /**
       *  @brief  Find last position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character other than
       *  @a __c within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
	_GLIBCXX_NOEXCEPT;

      /**
       *  @brief  Get a substring.
       *  @param __pos  Index of first character (default 0).
       *  @param __n  Number of characters in substring (default remainder).
       *  @return  The new string.
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Construct and return a new string using the @a __n
       *  characters starting at @a __pos.  If the string is too
       *  short, use the remainder of the characters.  If @a __pos is
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }

      /**
       *  @brief  Compare to a string.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a
       *  __str, 0 if their values are equivalent, or > 0 if this
       *  string is ordered after @a __str.  Determines the effective
       *  length rlen of the strings to compare as the smallest of
       *  size() and str.size().  The function then compares the two
       *  strings by calling traits::compare(data(), str.data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      */
      int
      compare(const basic_string& __str) const
      {
	const size_type __size = this->size();
	const size_type __osize = __str.size();
	const size_type __len = std::min(__size, __osize);

	int __r = traits_type::compare(_M_data(), __str.data(), __len);
	if (!__r)
	  __r = _S_compare(__size, __osize);
	return __r;
      }

      /**
       *  @brief  Compare substring to a string.
       *  @param __pos  Index of first character of substring.
       *  @param __n  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n characters
       *  starting at @a __pos.  Returns an integer < 0 if the
       *  substring is ordered before @a __str, 0 if their values are
       *  equivalent, or > 0 if the substring is ordered after @a
       *  __str.  Determines the effective length rlen of the strings
       *  to compare as the smallest of the length of the substring
       *  and @a __str.size().  The function then compares the two
       *  strings by calling
       *  traits::compare(substring.data(),str.data(),rlen).  If the
       *  result of the comparison is nonzero returns it, otherwise
       *  the shorter one is ordered first.
      */
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;

      /**
       *  @brief  Compare substring to a substring.
       *  @param __pos1  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @param __pos2  Index of first character of substring of str.
       *  @param __n2  Number of characters in substring of str.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos1.  Form the substring of @a
       *  __str from the @a __n2 characters starting at @a __pos2.
       *  Returns an integer < 0 if this substring is ordered before
       *  the substring of @a __str, 0 if their values are equivalent,
       *  or > 0 if this substring is ordered after the substring of
       *  @a __str.  Determines the effective length rlen of the
       *  strings to compare as the smallest of the lengths of the
       *  substrings.  The function then compares the two strings by
       *  calling
       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      */
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
	      size_type __pos2, size_type __n2) const;

      /**
       *  @brief  Compare to a C string.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and the length of a string
       *  constructed from @a __s.  The function then compares the two strings
       *  by calling traits::compare(data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      */
      int
      compare(const _CharT* __s) const;

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 5 String::compare specification questionable
      /**
       *  @brief  Compare substring to a C string.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a pos.  Returns an integer < 0 if
       *  the substring is ordered before @a __s, 0 if their values
       *  are equivalent, or > 0 if the substring is ordered after @a
       *  __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of the length of the substring and
       *  the length of a string constructed from @a __s.  The
       *  function then compares the two string by calling
       *  traits::compare(substring.data(),__s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;

      /**
       *  @brief  Compare substring against a character %array.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  character %array to compare against.
       *  @param __n2  Number of characters of s.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos.  Form a string from the
       *  first @a __n2 characters of @a __s.  Returns an integer < 0
       *  if this substring is ordered before the string from @a __s,
       *  0 if their values are equivalent, or > 0 if this substring
       *  is ordered after the string from @a __s.  Determines the
       *  effective length rlen of the strings to compare as the
       *  smallest of the length of the substring and @a __n2.  The
       *  function then compares the two strings by calling
       *  traits::compare(substring.data(),s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
       *
       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
       *  no special meaning.
      */
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
	      size_type __n2) const;
  };
#endif  // !_GLIBCXX_USE_CXX11_ABI
# 4771 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

  // operator+
  /**
   *  @brief  Concatenate two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with value of @a __lhs followed by @a __rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  /**
   *  @brief  Concatenate C string and string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with value of @a __lhs followed by @a __rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  /**
   *  @brief  Concatenate character and string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  /**
   *  @brief  Concatenate string and C string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  /**
   *  @brief  Concatenate string and character.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
      typedef typename __string_type::size_type		__size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }

#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
			   && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
	            : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
	      _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
#endif
# 4892 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

  // operator ==
  /**
   *  @brief  Test equivalence of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }

  /**
   *  @brief  Test equivalence of C string and string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }

  /**
   *  @brief  Test equivalence of string and C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }

  // operator !=
  /**
   *  @brief  Test difference of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   *  @brief  Test difference of C string and string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }

  /**
   *  @brief  Test difference of string and C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const _CharT* __rhs)
    { return !(__lhs == __rhs); }

  // operator <
  /**
   *  @brief  Test if string precedes string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }

  /**
   *  @brief  Test if string precedes C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }

  /**
   *  @brief  Test if C string precedes string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }

  // operator >
  /**
   *  @brief  Test if string follows string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }

  /**
   *  @brief  Test if string follows C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }

  /**
   *  @brief  Test if C string follows string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }

  // operator <=
  /**
   *  @brief  Test if string doesn't follow string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  /**
   *  @brief  Test if string doesn't follow C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  /**
   *  @brief  Test if C string doesn't follow string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }

  // operator >=
  /**
   *  @brief  Test if string doesn't precede string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  /**
   *  @brief  Test if string doesn't precede C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	       const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  /**
   *  @brief  Test if C string doesn't precede string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }

  /**
   *  @brief  Swap contents of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *
   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
	 basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }


  /**
   *  @brief  Read stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a __is into @a __str until whitespace is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  If is.width() is non-zero, that is the limit on the
   *  number of characters stored into @a __str.  Any previous
   *  contents of @a __str are erased.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
	       basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);

  /**
   *  @brief  Write string to a stream.
   *  @param __os  Output stream.
   *  @param __str  String to write out.
   *  @return  Reference to the output stream.
   *
   *  Output characters of @a __str into os following the same rules as for
   *  writing a C string.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
	       const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 586. string inserter not a formatted function
      return __ostream_insert(__os, __str.data(), __str.size());
    }

  /**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @param __delim  Character marking end of line.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a __is into @a __str until @a __delim is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  @a __delim is encountered, it is extracted but not stored into
   *  @a __str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);

  /**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from is into @a __str until &apos;\n&apos; is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  end of line is encountered, it is extracted but not stored into
   *  @a __str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }

#if __cplusplus >= 201103L
  /// Read a line from an rvalue stream into a string.
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }

  /// Read a line from an rvalue stream into a string.
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }
#endif
# 5229 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
	    char __delim);

#ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
	    wchar_t __delim);
#endif  
# 5241 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if __cplusplus >= 201103L && defined(_GLIBCXX_USE_C99)

#if 0 /* expanded by -frewrite-includes */
#include <ext/string_conversions.h>
#endif /* expanded by -frewrite-includes */
# 5247 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
# 5248 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION
_GLIBCXX_BEGIN_NAMESPACE_CXX11

  // 21.4 Numeric Conversions [string.conversions].
  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
					__idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
			     __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
			     __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
			     __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
			     __idx, __base); }

  // NB: strtof vs strtod.
  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }

  // NB: (v)snprintf vs sprintf.

  // DR 1261.
  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
					   "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
					   4 * sizeof(unsigned),
					   "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
					   "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
					   4 * sizeof(unsigned long),
					   "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
					   4 * sizeof(long long),
					   "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
					   4 * sizeof(unsigned long long),
					   "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n = 
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
					   "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n = 
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
					   "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n = 
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
					   "%Lf", __val);
  }

#ifdef _GLIBCXX_USE_WCHAR_T
  inline int 
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
					__idx, __base); }

  inline long 
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
			     __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
			     __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
			     __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
			     __idx, __base); }

  // NB: wcstof vs wcstod.
  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }

#ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
  // DR 1261.
  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
					    L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
					    4 * sizeof(unsigned),
					    L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
					    L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
					    4 * sizeof(unsigned long),
					    L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
					    4 * sizeof(long long),
					    L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
					    4 * sizeof(unsigned long long),
					    L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
					    L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
					    L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
					    L"%Lf", __val);
  }
#endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF
# 5459 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
#endif
# 5460 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

_GLIBCXX_END_NAMESPACE_CXX11
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* C++11 && _GLIBCXX_USE_C99 ... */
# 5466 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#if __cplusplus >= 201103L

#if 0 /* expanded by -frewrite-includes */
#include <bits/functional_hash.h>
#endif /* expanded by -frewrite-includes */
# 5469 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
# 5470 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // DR 1182.

#ifndef _GLIBCXX_COMPATIBILITY_CXX0X
  /// std::hash specialization for string.
  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };

#ifdef _GLIBCXX_USE_WCHAR_T
  /// std::hash specialization for wstring.
  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };
#endif
# 5508 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
#endif /* _GLIBCXX_COMPATIBILITY_CXX0X */
# 5509 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#ifdef _GLIBCXX_USE_C99_STDINT_TR1
  /// std::hash specialization for u16string.
  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };

  /// std::hash specialization for u32string.
  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
#endif
# 5541 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#if __cplusplus > 201103L

#define __cpp_lib_string_udls 201304

  inline namespace literals
  {
  inline namespace string_literals
  {

    _GLIBCXX_DEFAULT_ABI_TAG
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }

#ifdef _GLIBCXX_USE_WCHAR_T
    _GLIBCXX_DEFAULT_ABI_TAG
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }
#endif
# 5562 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#ifdef _GLIBCXX_USE_C99_STDINT_TR1
    _GLIBCXX_DEFAULT_ABI_TAG
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    _GLIBCXX_DEFAULT_ABI_TAG
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }
#endif
# 5574 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

  } // inline namespace string_literals
  } // inline namespace literals

#endif // __cplusplus > 201103L
# 5579 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // C++11
# 5584 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3

#endif /* _BASIC_STRING_H */
# 5586 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.h" 3
# 53 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/basic_string.tcc> 
#endif /* expanded by -frewrite-includes */
# 53 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 1 3
// Components for manipulating sequences of characters -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_string.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */

//
// ISO C++ 14882: 21  Strings library
//

// Written by Jason Merrill based upon the specification by Takanori Adachi
// in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.
// Non-reference-counted implementation written by Paolo Carlini and
// updated by Jonathan Wakely for ISO-14882-2011.

#ifndef _BASIC_STRING_TCC
#define _BASIC_STRING_TCC 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/cxxabi_forced.h>
#endif /* expanded by -frewrite-includes */
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#if _GLIBCXX_USE_CXX11_ABI

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) _GLIBCXX_NOEXCEPT
    {
      if (this == &__s)
	return;

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 431. Swapping containers with unequal allocators.
      // TODO propagation traits
      std::__alloc_swap<allocator_type>::_S_do_it(_M_get_allocator(),
						  __s._M_get_allocator());

      if (_M_is_local())
	if (__s._M_is_local())
	  {
	    if (length() && __s.length())
	      {
		_CharT __tmp_data[_S_local_capacity + 1];
		traits_type::copy(__tmp_data, __s._M_local_buf,
				  _S_local_capacity + 1);
		traits_type::copy(__s._M_local_buf, _M_local_buf,
				  _S_local_capacity + 1);
		traits_type::copy(_M_local_buf, __tmp_data,
				  _S_local_capacity + 1);
	      }
	    else if (__s.length())
	      {
		traits_type::copy(_M_local_buf, __s._M_local_buf,
				  _S_local_capacity + 1);
		_M_length(__s.length());
		__s._M_set_length(0);
		return;
	      }
	    else if (length())
	      {
		traits_type::copy(__s._M_local_buf, _M_local_buf,
				  _S_local_capacity + 1);
		__s._M_length(length());
		_M_set_length(0);
		return;
	      }
	  }
	else
	  {
	    const size_type __tmp_capacity = __s._M_allocated_capacity;
	    traits_type::copy(__s._M_local_buf, _M_local_buf,
			      _S_local_capacity + 1);
	    _M_data(__s._M_data());
	    __s._M_data(__s._M_local_buf);
	    _M_capacity(__tmp_capacity);
	  }
      else
	{
	  const size_type __tmp_capacity = _M_allocated_capacity;
	  if (__s._M_is_local())
	    {
	      traits_type::copy(_M_local_buf, __s._M_local_buf,
				_S_local_capacity + 1);
	      __s._M_data(_M_data());
	      _M_data(_M_local_buf);
	    }
	  else
	    {
	      pointer __tmp_ptr = _M_data();
	      _M_data(__s._M_data());
	      __s._M_data(__tmp_ptr);
	      _M_capacity(__s._M_allocated_capacity);
	    }
	  __s._M_capacity(__tmp_capacity);
	}

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 83.  String::npos vs. string::max_size()
      if (__capacity > max_size())
	std::__throw_length_error(__N("basic_string::_M_create"));

      // The below implements an exponential growth policy, necessary to
      // meet amortized linear time requirements of the library: see
      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
	{
	  __capacity = 2 * __old_capacity;
	  // Never allocate a string bigger than max_size.
	  if (__capacity > max_size())
	    __capacity = max_size();
	}

      // NB: Need an array of char_type[__capacity], plus a terminating
      // null char_type() element.
      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }

  // NB: This is the special case for Input Iterators, used in
  // istreambuf_iterators, etc.
  // Input Iterators have a cost structure very different from
  // pointers, calling for a different coding style.
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
		   std::input_iterator_tag)
      {
	size_type __len = 0;
	size_type __capacity = size_type(_S_local_capacity);

	while (__beg != __end && __len < __capacity)
	  {
	    _M_data()[__len++] = *__beg;
	    ++__beg;
	  }

	__try
	  {
	    while (__beg != __end)
	      {
		if (__len == __capacity)
		  {
		    // Allocate more space.
		    __capacity = __len + 1;
		    pointer __another = _M_create(__capacity, __len);
		    this->_S_copy(__another, _M_data(), __len);
		    _M_dispose();
		    _M_data(__another);
		    _M_capacity(__capacity);
		  }
		_M_data()[__len++] = *__beg;
		++__beg;
	      }
	  }
	__catch(...)
	  {
	    _M_dispose();
	    __throw_exception_again;
	  }

	_M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
		   std::forward_iterator_tag)
      {
	// NB: Not required, but considered best practice.
	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
	  std::__throw_logic_error(__N("basic_string::"
				       "_M_construct null not valid"));

	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

	if (__dnew > size_type(_S_local_capacity))
	  {
	    _M_data(_M_create(__dnew, size_type(0)));
	    _M_capacity(__dnew);
	  }

	// Check for out_of_range and length_error exceptions.
	__try
	  { this->_S_copy_chars(_M_data(), __beg, __end); }
	__catch(...)
	  {
	    _M_dispose();
	    __throw_exception_again;
	  }

	_M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
	{
	  _M_data(_M_create(__n, size_type(0)));
	  _M_capacity(__n);
	}

      if (__n)
	this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
	{
	  const size_type __rsize = __str.length();
	  const size_type __capacity = capacity();

	  if (__rsize > __capacity)
	    {
	      size_type __new_capacity = __rsize;
	      pointer __tmp = _M_create(__new_capacity, __capacity);
	      _M_dispose();
	      _M_data(__tmp);
	      _M_capacity(__new_capacity);
	    }

	  if (__rsize)
	    this->_S_copy(_M_data(), __str._M_data(), __rsize);

	  _M_set_length(__rsize);
	}
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      // Make sure we don't shrink below the current size.
      if (__res < length())
	__res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
	{
	  if (__res > __capacity
	      || __res > size_type(_S_local_capacity))
	    {
	      pointer __tmp = _M_create(__res, __capacity);
	      this->_S_copy(__tmp, _M_data(), length() + 1);
	      _M_dispose();
	      _M_data(__tmp);
	      _M_capacity(__res);
	    }
	  else if (!_M_is_local())
	    {
	      this->_S_copy(_M_local_data(), _M_data(), length() + 1);
	      _M_destroy(__capacity);
	      _M_data(_M_local_data());
	    }
	}
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
	      size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
	this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
	this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
	this->_S_copy(__r + __pos + __len2,
		      _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
	this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
	this->append(__n - __size, __c);
      else if (__n < __size)
	this->_M_erase(__n, __size - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
	{
	  if (__n)
	    this->_S_copy(this->_M_data() + this->size(), __s, __n);
	}
      else
	this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
			  _InputIterator __k1, _InputIterator __k2,
			  std::__false_type)
      {
	const basic_string __s(__k1, __k2);
	const size_type __n1 = __i2 - __i1;
	return _M_replace(__i1 - begin(), __n1, __s._M_data(),
			  __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
		   _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
	{
	  _CharT* __p = this->_M_data() + __pos1;

	  const size_type __how_much = __old_size - __pos1 - __n1;
	  if (__how_much && __n1 != __n2)
	    this->_S_move(__p + __n2, __p + __n1, __how_much);
	}
      else
	this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
	this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
	       const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
	{
	  _CharT* __p = this->_M_data() + __pos;

	  const size_type __how_much = __old_size - __pos - __len1;
	  if (_M_disjunct(__s))
	    {
	      if (__how_much && __len1 != __len2)
		this->_S_move(__p + __len2, __p + __len1, __how_much);
	      if (__len2)
		this->_S_copy(__p, __s, __len2);
	    }
	  else
	    {
	      // Work in-place.
	      if (__len2 && __len2 <= __len1)
		this->_S_move(__p, __s, __len2);
	      if (__how_much && __len1 != __len2)
		this->_S_move(__p + __len2, __p + __len1, __how_much);
	      if (__len2 > __len1)
		{
		  if (__s + __len2 <= __p + __len1)
		    this->_S_move(__p, __s, __len2);
		  else if (__s >= __p + __len1)
		    this->_S_copy(__p, __s + __len2 - __len1, __len2);
		  else
		    {
		      const size_type __nleft = (__p + __len1) - __s;
		      this->_S_move(__p, __s, __nleft);
		      this->_S_copy(__p + __nleft, __p + __len2,
				    __len2 - __nleft);
		    }
		}
	    }
	}
      else
	this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      __glibcxx_requires_string_len(__s, __n);
      if (__n)
	_S_copy(__s, _M_data() + __pos, __n);
      // 21.3.5.7 par 3: do not append null.  (good.)
      return __n;
    }

#else  // !_GLIBCXX_USE_CXX11_ABI
# 491 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)
  // at static init time (before static ctors are run).
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];

  // NB: This is the special case for Input Iterators, used in
  // istreambuf_iterators, etc.
  // Input Iterators have a cost structure very different from
  // pointers, calling for a different coding style.
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
		   input_iterator_tag)
      {
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	if (__beg == __end && __a == _Alloc())
	  return _S_empty_rep()._M_refdata();
#endif
# 529 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
	// Avoid reallocation for common case.
	_CharT __buf[128];
	size_type __len = 0;
	while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
	  {
	    __buf[__len++] = *__beg;
	    ++__beg;
	  }
	_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
	_M_copy(__r->_M_refdata(), __buf, __len);
	__try
	  {
	    while (__beg != __end)
	      {
		if (__len == __r->_M_capacity)
		  {
		    // Allocate more space.
		    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
		    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
		    __r->_M_destroy(__a);
		    __r = __another;
		  }
		__r->_M_refdata()[__len++] = *__beg;
		++__beg;
	      }
	  }
	__catch(...)
	  {
	    __r->_M_destroy(__a);
	    __throw_exception_again;
	  }
	__r->_M_set_length_and_sharable(__len);
	return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
		   forward_iterator_tag)
      {
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
	if (__beg == __end && __a == _Alloc())
	  return _S_empty_rep()._M_refdata();
#endif
# 575 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
	// NB: Not required, but considered best practice.
	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
	  __throw_logic_error(__N("basic_string::_S_construct null not valid"));

	const size_type __dnew = static_cast<size_type>(std::distance(__beg,
								      __end));
	// Check for out_of_range and length_error exceptions.
	_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
	__try
	  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
	__catch(...)
	  {
	    __r->_M_destroy(__a);
	    __throw_exception_again;
	  }
	__r->_M_set_length_and_sharable(__dnew);
	return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      if (__n == 0 && __a == _Alloc())
	return _S_empty_rep()._M_refdata();
#endif
# 603 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
      // Check for out_of_range and length_error exceptions.
      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
	_M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
					  __str.get_allocator()),
		  __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
			       + __str._M_check(__pos,
						"basic_string::basic_string"),
			       __str._M_data() + __str._M_limit(__pos, __n)
			       + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
		 size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
			       + __str._M_check(__pos,
						"basic_string::basic_string"),
			       __str._M_data() + __str._M_limit(__pos, __n)
			       + __pos, __a), __a)
    { }

  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }

  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
			       __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }

  // TBD: DPG annotate
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }
#endif
# 683 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
	{
	  // XXX MT
	  const allocator_type __a = this->get_allocator();
	  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
	  _M_rep()->_M_dispose(__a);
	  _M_data(__tmp);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      __glibcxx_requires_string_len(__s, __n);
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
	return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
	{
	  // Work in-place.
	  const size_type __pos = __s - _M_data();
	  if (__pos >= __n)
	    _M_copy(_M_data(), __s, __n);
	  else if (__pos)
	    _M_move(_M_data(), __s, __n);
	  _M_rep()->_M_set_length_and_sharable(__n);
	  return *this;
	}
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
	{
	  _M_check_length(size_type(0), __n, "basic_string::append");	  
	  const size_type __len = __n + this->size();
	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
	    this->reserve(__len);
	  _M_assign(_M_data() + this->size(), __n, __c);
	  _M_rep()->_M_set_length_and_sharable(__len);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      __glibcxx_requires_string_len(__s, __n);
      if (__n)
	{
	  _M_check_length(size_type(0), __n, "basic_string::append");
	  const size_type __len = __n + this->size();
	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
	    {
	      if (_M_disjunct(__s))
		this->reserve(__len);
	      else
		{
		  const size_type __off = __s - _M_data();
		  this->reserve(__len);
		  __s = _M_data() + __off;
		}
	    }
	  _M_copy(_M_data() + this->size(), __s, __n);
	  _M_rep()->_M_set_length_and_sharable(__len);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
	{
	  const size_type __len = __size + this->size();
	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
	    this->reserve(__len);
	  _M_copy(_M_data() + this->size(), __str._M_data(), __size);
	  _M_rep()->_M_set_length_and_sharable(__len);
	}
      return *this;
    }    

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
	{
	  const size_type __len = __n + this->size();
	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
	    this->reserve(__len);
	  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
	  _M_rep()->_M_set_length_and_sharable(__len);	  
	}
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       __glibcxx_requires_string_len(__s, __n);
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {
           // Work in-place.
           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s  + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
	       const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
       _GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last
				&& __last <= _M_iend());

       // NB: This isn't just an optimization (bail out early when
       // there is nothing to do, really), it's also a correctness
       // issue vs MT, see libstdc++/40518.
       const size_type __size = __last - __first;
       if (__size)
	 {
	   const size_type __pos = __first - _M_ibegin();
	   _M_mutate(__pos, __size, size_type(0));
	   _M_rep()->_M_set_leaked();
	   return iterator(_M_data() + __pos);
	 }
       else
	 return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
	     size_type __n2)
     {
       __glibcxx_requires_string_len(__s, __n2);
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
		|| _M_data() + __pos + __n1 <= __s)
	 {
	   // Work in-place: non-overlapping case.
	   size_type __off = __s - _M_data();
	   __left ? __off : (__off += __n2 - __n1);
	   _M_mutate(__pos, __n1, __n2);
	   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
	   return *this;
	 }
       else
	 {
	   // Todo: overlapping case.
	   const basic_string __tmp(__s, __n2);
	   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
	 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
	                       (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {
#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
      if (_M_rep() == &_S_empty_rep())
	return;
#endif
# 905 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
      if (_M_rep()->_M_is_shared())
	_M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
	{
	  // Must reallocate.
	  const allocator_type __a = get_allocator();
	  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

	  if (__pos)
	    _M_copy(__r->_M_refdata(), _M_data(), __pos);
	  if (__how_much)
	    _M_copy(__r->_M_refdata() + __pos + __len2,
		    _M_data() + __pos + __len1, __how_much);

	  _M_rep()->_M_dispose(__a);
	  _M_data(__r->_M_refdata());
	}
      else if (__how_much && __len1 != __len2)
	{
	  // Work in-place.
	  _M_move(_M_data() + __pos + __len2,
		  _M_data() + __pos + __len1, __how_much);
	}
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
	  // Make sure we don't shrink below the current size
	  if (__res < this->size())
	    __res = this->size();
	  const allocator_type __a = get_allocator();
	  _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
	  _M_rep()->_M_dispose(__a);
	  _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
	_M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
	__s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
	{
	  _CharT* __tmp = _M_data();
	  _M_data(__s._M_data());
	  __s._M_data(__tmp);
	}
      // The code below can usually be optimized away.
      else
	{
	  const basic_string __tmp1(_M_ibegin(), _M_iend(),
				    __s.get_allocator());
	  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
				    this->get_allocator());
	  *this = __tmp2;
	  __s = __tmp1;
	}
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
	      const _Alloc& __alloc)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 83.  String::npos vs. string::max_size()
      if (__capacity > _S_max_size)
	__throw_length_error(__N("basic_string::_S_create"));

      // The standard places no restriction on allocating more memory
      // than is strictly needed within this layer at the moment or as
      // requested by an explicit application call to reserve().

      // Many malloc implementations perform quite poorly when an
      // application attempts to allocate memory in a stepwise fashion
      // growing each allocation size by only 1 char.  Additionally,
      // it makes little sense to allocate less linear memory than the
      // natural blocking size of the malloc implementation.
      // Unfortunately, we would need a somewhat low-level calculation
      // with tuned parameters to get this perfect for any particular
      // malloc implementation.  Fortunately, generalizations about
      // common features seen among implementations seems to suffice.

      // __pagesize need not match the actual VM page size for good
      // results in practice, thus we pick a common value on the low
      // side.  __malloc_header_size is an estimate of the amount of
      // overhead per memory allocation (in practice seen N * sizeof
      // (void*) where N is 0, 2 or 4).  According to folklore,
      // picking this value on the high side is better than
      // low-balling it (especially when this algorithm is used with
      // malloc implementations that allocate memory blocks rounded up
      // to a size which is a power of 2).
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);

      // The below implements an exponential growth policy, necessary to
      // meet amortized linear time requirements of the library: see
      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
      // It's active for allocations requiring an amount of memory above
      // system pagesize. This is consistent with the requirements of the
      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
	__capacity = 2 * __old_capacity;

      // NB: Need an array of char_type[__capacity], plus a terminating
      // null char_type() element, plus enough for the _Rep data structure.
      // Whew. Seemingly so needy, yet so elemental.
      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
	{
	  const size_type __extra = __pagesize - __adj_size % __pagesize;
	  __capacity += __extra / sizeof(_CharT);
	  // Never allocate a string bigger than _S_max_size.
	  if (__capacity > _S_max_size)
	    __capacity = _S_max_size;
	  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
	}

      // NB: Might throw, but no worries about a leak, mate: _Rep()
      // does not throw.
      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      // ABI compatibility - 3.4.x set in _S_create both
      // _M_refcount and _M_length.  All callers of _S_create
      // in basic_string.tcc then set just _M_length.
      // In 4.0.x and later both _M_refcount and _M_length
      // are initialized in the callers, unfortunately we can
      // have 3.4.x compiled code with _S_create callers inlined
      // calling 4.0.x+ _S_create.
      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {
      // Requested capacity of the clone.
      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
				  __alloc);
      if (this->_M_length)
	_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
	this->append(__n - __size, __c);
      else if (__n < __size)
	this->erase(__n);
      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
			  _InputIterator __k2, __false_type)
      {
	const basic_string __s(__k1, __k2);
	const size_type __n1 = __i2 - __i1;
	_M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
	return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
			       __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
		   _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
	_M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
		    size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
	_M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

    template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      __glibcxx_requires_string_len(__s, __n);
      if (__n)
	_M_copy(__s, _M_data() + __pos, __n);
      // 21.3.5.7 par 3: do not append null.  (good.)
      return __n;
    }
#endif  // !_GLIBCXX_USE_CXX11_ABI
# 1148 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
   
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      __glibcxx_requires_string(__lhs);
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type	  __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type	  __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      __glibcxx_requires_string_len(__s, __n);
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
	return __pos <= __size ? __pos : npos;

      if (__n <= __size)
	{
	  for (; __pos <= __size - __n; ++__pos)
	    if (traits_type::eq(__data[__pos], __s[0])
		&& traits_type::compare(__data + __pos + 1,
					__s + 1, __n - 1) == 0)
	      return __pos;
	}
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
	{
	  const _CharT* __data = _M_data();
	  const size_type __n = __size - __pos;
	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
	  if (__p)
	    __ret = __p - __data;
	}
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      __glibcxx_requires_string_len(__s, __n);
      const size_type __size = this->size();
      if (__n <= __size)
	{
	  __pos = std::min(size_type(__size - __n), __pos);
	  const _CharT* __data = _M_data();
	  do
	    {
	      if (traits_type::compare(__data + __pos, __s, __n) == 0)
		return __pos;
	    }
	  while (__pos-- > 0);
	}
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
    {
      size_type __size = this->size();
      if (__size)
	{
	  if (--__size > __pos)
	    __size = __pos;
	  for (++__size; __size-- > 0; )
	    if (traits_type::eq(_M_data()[__size], __c))
	      return __size;
	}
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      __glibcxx_requires_string_len(__s, __n);
      for (; __n && __pos < this->size(); ++__pos)
	{
	  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
	  if (__p)
	    return __pos;
	}
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      __glibcxx_requires_string_len(__s, __n);
      size_type __size = this->size();
      if (__size && __n)
	{
	  if (--__size > __pos)
	    __size = __pos;
	  do
	    {
	      if (traits_type::find(__s, __n, _M_data()[__size]))
		return __size;
	    }
	  while (__size-- != 0);
	}
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      __glibcxx_requires_string_len(__s, __n);
      for (; __pos < this->size(); ++__pos)
	if (!traits_type::find(__s, __n, _M_data()[__pos]))
	  return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
    {
      for (; __pos < this->size(); ++__pos)
	if (!traits_type::eq(_M_data()[__pos], __c))
	  return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      __glibcxx_requires_string_len(__s, __n);
      size_type __size = this->size();
      if (__size)
	{
	  if (--__size > __pos)
	    __size = __pos;
	  do
	    {
	      if (!traits_type::find(__s, __n, _M_data()[__size]))
		return __size;
	    }
	  while (__size--);
	}
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
    {
      size_type __size = this->size();
      if (__size)
	{
	  if (--__size > __pos)
	    __size = __pos;
	  do
	    {
	      if (!traits_type::eq(_M_data()[__size], __c))
		return __size;
	    }
	  while (__size--);
	}
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
	__r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
	    size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
				     __str.data() + __pos2, __len);
      if (!__r)
	__r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      __glibcxx_requires_string(__s);
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
	__r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      __glibcxx_requires_string(__s);
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
	__r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
	    size_type __n2) const
    {
      __glibcxx_requires_string_len(__s, __n2);
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
	__r = _S_compare(__n1, __n2);
      return __r;
    }

  // 21.3.7.9 basic_string::getline and operators
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
	       basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits>		__istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
      typedef typename __istream_type::ios_base         __ios_base;
      typedef typename __istream_type::int_type		__int_type;
      typedef typename __string_type::size_type		__size_type;
      typedef ctype<_CharT>				__ctype_type;
      typedef typename __ctype_type::ctype_base         __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
	{
	  __try
	    {
	      // Avoid reallocation for common case.
	      __str.erase();
	      _CharT __buf[128];
	      __size_type __len = 0;	      
	      const streamsize __w = __in.width();
	      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
		                              : __str.max_size();
	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
	      const __int_type __eof = _Traits::eof();
	      __int_type __c = __in.rdbuf()->sgetc();

	      while (__extracted < __n
		     && !_Traits::eq_int_type(__c, __eof)
		     && !__ct.is(__ctype_base::space,
				 _Traits::to_char_type(__c)))
		{
		  if (__len == sizeof(__buf) / sizeof(_CharT))
		    {
		      __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
		      __len = 0;
		    }
		  __buf[__len++] = _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __in.rdbuf()->snextc();
		}
	      __str.append(__buf, __len);

	      if (_Traits::eq_int_type(__c, __eof))
		__err |= __ios_base::eofbit;
	      __in.width(0);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      __in._M_setstate(__ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 91. Description of operator>> and getline() for string<>
	      // might cause endless loop
	      __in._M_setstate(__ios_base::badbit);
	    }
	}
      // 211.  operator>>(istream&, string&) doesn't set failbit
      if (!__extracted)
	__err |= __ios_base::failbit;
      if (__err)
	__in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits>		__istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
      typedef typename __istream_type::ios_base         __ios_base;
      typedef typename __istream_type::int_type		__int_type;
      typedef typename __string_type::size_type		__size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
	{
	  __try
	    {
	      __str.erase();
	      const __int_type __idelim = _Traits::to_int_type(__delim);
	      const __int_type __eof = _Traits::eof();
	      __int_type __c = __in.rdbuf()->sgetc();

	      while (__extracted < __n
		     && !_Traits::eq_int_type(__c, __eof)
		     && !_Traits::eq_int_type(__c, __idelim))
		{
		  __str += _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __in.rdbuf()->snextc();
		}

	      if (_Traits::eq_int_type(__c, __eof))
		__err |= __ios_base::eofbit;
	      else if (_Traits::eq_int_type(__c, __idelim))
		{
		  ++__extracted;		  
		  __in.rdbuf()->sbumpc();
		}
	      else
		__err |= __ios_base::failbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      __in._M_setstate(__ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 91. Description of operator>> and getline() for string<>
	      // might cause endless loop
	      __in._M_setstate(__ios_base::badbit);
	    }
	}
      if (!__extracted)
	__err |= __ios_base::failbit;
      if (__err)
	__in.setstate(__err);
      return __in;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE > 0
  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);
#endif
# 1606 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
#endif
# 1607 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 1612 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_string.tcc" 3
# 54 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 2 3

#endif /* _GLIBCXX_STRING */
# 56 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/string" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/atomicity.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // 22.1.1 Class locale
  /**
   *  @brief  Container class for localization functionality.
   *  @ingroup locales
   *
   *  The locale class is first a class wrapper for C library locales.  It is
   *  also an extensible container for user-defined localization.  A locale is
   *  a collection of facets that implement various localization features such
   *  as money, time, and number printing.
   *
   *  Constructing C++ locales does not change the C library locale.
   *
   *  This library supports efficient construction and copying of locales
   *  through a reference counting implementation of the locale class.
  */
  class locale
  {
  public:
    // Types:
    /// Definition of locale::category.
    typedef int	category;

    // Forward decls and friends:
    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

    //@{
    /**
     *  @brief  Category values.
     *
     *  The standard category values are none, ctype, numeric, collate, time,
     *  monetary, and messages.  They form a bitmask that supports union and
     *  intersection.  The category all is the union of these values.
     *
     *  NB: Order must match _S_facet_categories definition in locale.cc
    */
    static const category none		= 0;
    static const category ctype		= 1L << 0;
    static const category numeric	= 1L << 1;
    static const category collate	= 1L << 2;
    static const category time		= 1L << 3;
    static const category monetary	= 1L << 4;
    static const category messages	= 1L << 5;
    static const category all		= (ctype | numeric | collate |
					   time  | monetary | messages);
    //@}

    // Construct/copy/destroy:

    /**
     *  @brief  Default constructor.
     *
     *  Constructs a copy of the global locale.  If no locale has been
     *  explicitly set, this is the C locale.
    */
    locale() throw();

    /**
     *  @brief  Copy constructor.
     *
     *  Constructs a copy of @a other.
     *
     *  @param  __other  The locale to copy.
    */
    locale(const locale& __other) throw();

    /**
     *  @brief  Named locale constructor.
     *
     *  Constructs a copy of the named C library locale.
     *
     *  @param  __s  Name of the locale to construct.
     *  @throw  std::runtime_error if __s is null or an undefined locale.
    */
    explicit
    locale(const char* __s);

    /**
     *  @brief  Construct locale with facets from another locale.
     *
     *  Constructs a copy of the locale @a base.  The facets specified by @a
     *  cat are replaced with those from the locale named by @a s.  If base is
     *  named, this locale instance will also be named.
     *
     *  @param  __base  The locale to copy.
     *  @param  __s  Name of the locale to use facets from.
     *  @param  __cat  Set of categories defining the facets to use from __s.
     *  @throw  std::runtime_error if __s is null or an undefined locale.
    */
    locale(const locale& __base, const char* __s, category __cat);

#if __cplusplus >= 201103L
    /**
     *  @brief  Named locale constructor.
     *
     *  Constructs a copy of the named C library locale.
     *
     *  @param  __s  Name of the locale to construct.
     *  @throw  std::runtime_error if __s is an undefined locale.
    */
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }

    /**
     *  @brief  Construct locale with facets from another locale.
     *
     *  Constructs a copy of the locale @a base.  The facets specified by @a
     *  cat are replaced with those from the locale named by @a s.  If base is
     *  named, this locale instance will also be named.
     *
     *  @param  __base  The locale to copy.
     *  @param  __s  Name of the locale to use facets from.
     *  @param  __cat  Set of categories defining the facets to use from __s.
     *  @throw  std::runtime_error if __s is an undefined locale.
    */
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
#endif
# 180 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3

    /**
     *  @brief  Construct locale with facets from another locale.
     *
     *  Constructs a copy of the locale @a base.  The facets specified by @a
     *  cat are replaced with those from the locale @a add.  If @a base and @a
     *  add are named, this locale instance will also be named.
     *
     *  @param  __base  The locale to copy.
     *  @param  __add  The locale to use facets from.
     *  @param  __cat  Set of categories defining the facets to use from add.
    */
    locale(const locale& __base, const locale& __add, category __cat);

    /**
     *  @brief  Construct locale with another facet.
     *
     *  Constructs a copy of the locale @a __other.  The facet @a __f
     *  is added to @a __other, replacing an existing facet of type
     *  Facet if there is one.  If @a __f is null, this locale is a
     *  copy of @a __other.
     *
     *  @param  __other  The locale to copy.
     *  @param  __f  The facet to add in.
    */
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);

    /// Locale destructor.
    ~locale() throw();

    /**
     *  @brief  Assignment operator.
     *
     *  Set this locale to be a copy of @a other.
     *
     *  @param  __other  The locale to copy.
     *  @return  A reference to this locale.
    */
    const locale&
    operator=(const locale& __other) throw();

    /**
     *  @brief  Construct locale with another facet.
     *
     *  Constructs and returns a new copy of this locale.  Adds or replaces an
     *  existing facet of type Facet from the locale @a other into the new
     *  locale.
     *
     *  @tparam  _Facet  The facet type to copy from other
     *  @param  __other  The locale to copy from.
     *  @return  Newly constructed locale.
     *  @throw  std::runtime_error if __other has no facet of type _Facet.
    */
    template<typename _Facet>
      locale
      combine(const locale& __other) const;

    // Locale operations:
    /**
     *  @brief  Return locale name.
     *  @return  Locale name or "*" if unnamed.
    */
    _GLIBCXX_DEFAULT_ABI_TAG
    string
    name() const;

    /**
     *  @brief  Locale equality.
     *
     *  @param  __other  The locale to compare against.
     *  @return  True if other and this refer to the same locale instance, are
     *		 copies, or have the same name.  False otherwise.
    */
    bool
    operator==(const locale& __other) const throw();

    /**
     *  @brief  Locale inequality.
     *
     *  @param  __other  The locale to compare against.
     *  @return  ! (*this == __other)
    */
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }

    /**
     *  @brief  Compare two strings according to collate.
     *
     *  Template operator to compare two strings using the compare function of
     *  the collate facet in this locale.  One use is to provide the locale to
     *  the sort function.  For example, a vector v of strings could be sorted
     *  according to locale loc by doing:
     *  @code
     *  std::sort(v.begin(), v.end(), loc);
     *  @endcode
     *
     *  @param  __s1  First string to compare.
     *  @param  __s2  Second string to compare.
     *  @return  True if collate<_Char> facet compares __s1 < __s2, else false.
    */
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
		 const basic_string<_Char, _Traits, _Alloc>& __s2) const;

    // Global locale objects:
    /**
     *  @brief  Set global locale
     *
     *  This function sets the global locale to the argument and returns a
     *  copy of the previous global locale.  If the argument has a name, it
     *  will also call std::setlocale(LC_ALL, loc.name()).
     *
     *  @param  __loc  The new locale to make global.
     *  @return  Copy of the old global locale.
    */
    static locale
    global(const locale& __loc);

    /**
     *  @brief  Return reference to the C locale.
    */
    static const locale&
    classic();

  private:
    // The (shared) implementation
    _Impl*		_M_impl;

    // The "C" reference locale
    static _Impl*       _S_classic;

    // Current global locale
    static _Impl*	_S_global;

    // Names of underlying locale categories.
    // NB: locale::global() has to know how to modify all the
    // underlying categories, not just the ones required by the C++
    // standard.
    static const char* const* const _S_categories;

    // Number of standard categories. For C++, these categories are
    // collate, ctype, monetary, numeric, time, and messages. These
    // directly correspond to ISO C99 macros LC_COLLATE, LC_CTYPE,
    // LC_MONETARY, LC_NUMERIC, and LC_TIME. In addition, POSIX (IEEE
    // 1003.1-2001) specifies LC_MESSAGES.
    // In addition to the standard categories, the underlying
    // operating system is allowed to define extra LC_*
    // macros. For GNU systems, the following are also valid:
    // LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT,
    // and LC_IDENTIFICATION.
    enum { _S_categories_size = 6 + _GLIBCXX_NUM_CATEGORIES };

#ifdef __GTHREADS
    static __gthread_once_t _S_once;
#endif
# 338 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3

    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);

#if _GLIBCXX_USE_CXX11_ABI
    static const id* const _S_twinned_facets[];
#endif
# 357 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3
  };


  // 22.1.1.1.2  Class locale::facet
  /**
   *  @brief  Localization functionality base class.
   *  @ingroup locales
   *
   *  The facet class is the base class for a localization feature, such as
   *  money, time, and number printing.  It provides common support for facets
   *  and reference management.
   *
   *  Facets may not be copied or assigned.
  */
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word		_M_refcount;

    // Contains data from the underlying "C" library for the classic locale.
    static __c_locale                   _S_c_locale;

    // String literal for the name of the classic locale.
    static const char			_S_c_name[2];

#ifdef __GTHREADS
    static __gthread_once_t		_S_once;
#endif
# 388 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3

    static void
    _S_initialize_once();

  protected:
    /**
     *  @brief  Facet constructor.
     *
     *  This is the constructor provided by the standard.  If refs is 0, the
     *  facet is destroyed when the last referencing locale is destroyed.
     *  Otherwise the facet will never be destroyed.
     *
     *  @param __refs  The initial value for reference count.
    */
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }

    /// Facet destructor.
    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
		       __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);

    // Returns data from the underlying "C" library data for the
    // classic locale.
    static __c_locale
    _S_get_c_locale();

    _GLIBCXX_CONST static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      // Be race-detector-friendly.  For more info see bits/c++config.
      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
	{
          _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);
	  __try
	    { delete this; }
	  __catch(...)
	    { }
	}
    }

    facet(const facet&);  // Not defined.

    facet&
    operator=(const facet&);  // Not defined.

    class __shim;

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;
  };


  // 22.1.1.1.3 Class locale::id
  /**
   *  @brief  Facet ID class.
   *  @ingroup locales
   *
   *  The ID class provides facets with an index used to identify them.
   *  Every facet class must define a public static member locale::id, or be
   *  derived from a facet that provides this member, otherwise the facet
   *  cannot be used in a locale.  The locale::id ensures that each class
   *  type gets a unique identifier.
  */
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    // NB: There is no accessor for _M_index because it may be used
    // before the constructor is run; the effect of calling a member
    // function (even an inline) would be undefined.
    mutable size_t		_M_index;

    // Last id number assigned.
    static _Atomic_word		_S_refcount;

    void
    operator=(const id&);  // Not defined.

    id(const id&);  // Not defined.

  public:
    // NB: This class is always a static data member, and thus can be
    // counted on to be zero-initialized.
    /// Constructor.
    id() { }

    size_t
    _M_id() const throw();
  };


  // Implementation object for locale.
  class locale::_Impl
  {
  public:
    // Friends.
    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:
    // Data Members.
    _Atomic_word			_M_refcount;
    const facet**			_M_facets;
    size_t				_M_facets_size;
    const facet**			_M_caches;
    char**				_M_names;
    static const locale::id* const	_S_id_ctype[];
    static const locale::id* const	_S_id_numeric[];
    static const locale::id* const	_S_id_collate[];
    static const locale::id* const	_S_id_time[];
    static const locale::id* const	_S_id_monetary[];
    static const locale::id* const	_S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      // Be race-detector-friendly.  For more info see bits/c++config.
      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
	{
          _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);
	  __try
	    { delete this; }
	  __catch(...)
	    { }
	}
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);  // Not defined.

    void
    operator=(const _Impl&);  // Not defined.

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])
	// We must actually compare all the _M_names: can be all equal!
	for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
	  __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
	__facet->_M_add_reference();
	_M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };


  /**
   *  @brief  Facet for localized string comparison.
   *
   *  This facet encapsulates the code to compare strings in a localized
   *  manner.
   *
   *  The collate template uses protected virtual functions to provide
   *  the actual results.  The public accessors forward the call to
   *  the virtual functions.  These virtual functions are hooks for
   *  developers to implement the behavior they require from the
   *  collate facet.
  */
  template<typename _CharT>
    class _GLIBCXX_NAMESPACE_CXX11 collate : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT			char_type;
      typedef basic_string<_CharT>	string_type;
      //@}

    protected:
      // Underlying "C" library locale information saved from
      // initialization, needed by collate_byname as well.
      __c_locale			_M_c_locale_collate;

    public:
      /// Numpunct facet id.
      static locale::id			id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }

      /**
       *  @brief  Internal constructor. Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param __cloc  The C locale.
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }

      /**
       *  @brief  Compare two strings.
       *
       *  This function compares two strings and returns the result by calling
       *  collate::do_compare().
       *
       *  @param __lo1  Start of string 1.
       *  @param __hi1  End of string 1.
       *  @param __lo2  Start of string 2.
       *  @param __hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
	      const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }

      /**
       *  @brief  Transform string to comparable form.
       *
       *  This function is a wrapper for strxfrm functionality.  It takes the
       *  input string and returns a modified string that can be directly
       *  compared to other transformed strings.  In the C locale, this
       *  function just returns a copy of the input string.  In some other
       *  locales, it may replace two chars with one, change a char for
       *  another, etc.  It does so by returning collate::do_transform().
       *
       *  @param __lo  Start of string.
       *  @param __hi  End of string.
       *  @return  Transformed string_type.
      */
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }

      /**
       *  @brief  Return hash of a string.
       *
       *  This function computes and returns a hash on the input string.  It
       *  does so by returning collate::do_hash().
       *
       *  @param __lo  Start of string.
       *  @param __hi  End of string.
       *  @return  Hash value.
      */
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }

      // Used to abstract out _CharT bits in virtual member functions, below.
      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:
      /// Destructor.
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }

      /**
       *  @brief  Compare two strings.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.  @see compare().
       *
       *  @param __lo1  Start of string 1.
       *  @param __hi1  End of string 1.
       *  @param __lo2  Start of string 2.
       *  @param __hi2  End of string 2.
       *  @return  1 if string1 > string2, -1 if string1 < string2, else 0.
      */
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
		 const _CharT* __lo2, const _CharT* __hi2) const;

      /**
       *  @brief  Transform string to comparable form.
       *
       *  This function is a hook for derived classes to change the value
       *  returned.
       *
       *  @param __lo  Start.
       *  @param __hi  End.
       *  @return  transformed string.
      */
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;

      /**
       *  @brief  Return hash of a string.
       *
       *  This function computes and returns a hash on the input string.  This
       *  function is a hook for derived classes to change the value returned.
       *
       *  @param __lo  Start of string.
       *  @param __hi  End of string.
       *  @return  Hash value.
      */
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;

  // Specializations.
  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();

#ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();
#endif
# 804 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3

  /// class collate_byname [22.2.4.2].
  template<typename _CharT>
    class _GLIBCXX_NAMESPACE_CXX11 collate_byname : public collate<_CharT>
    {
    public:
      //@{
      /// Public typedefs
      typedef _CharT               char_type;
      typedef basic_string<_CharT> string_type;
      //@}

      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
	if (__builtin_strcmp(__s, "C") != 0
	    && __builtin_strcmp(__s, "POSIX") != 0)
	  {
	    this->_S_destroy_c_locale(this->_M_c_locale_collate);
	    this->_S_create_c_locale(this->_M_c_locale_collate, __s);
	  }
      }

#if __cplusplus >= 201103L
      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }
#endif
# 833 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3

    protected:
      virtual
      ~collate_byname() { }
    };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if 0 /* expanded by -frewrite-includes */
# include <bits/locale_classes.tcc>
#endif /* expanded by -frewrite-includes */
# 842 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 2007-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_classes.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

#ifndef _LOCALE_CLASSES_TCC
#define _LOCALE_CLASSES_TCC 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      __try
	{ _M_impl->_M_install_facet(&_Facet::id, __f); }
      __catch(...)
	{
	  _M_impl->_M_remove_reference();
	  __throw_exception_again;
	}
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;   // Unnamed.
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      __try
	{
	  __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
	}
      __catch(...)
	{
	  __tmp->_M_remove_reference();
	  __throw_exception_again;
	}
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
	       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
				__s2.data(), __s2.data() + __s2.length()) < 0);
    }

  /**
   *  @brief  Test for the presence of a facet.
   *  @ingroup locales
   *
   *  has_facet tests the locale argument for the presence of the facet type
   *  provided as the template parameter.  Facets derived from the facet
   *  parameter will also return true.
   *
   *  @tparam  _Facet  The facet type to test the presence of.
   *  @param  __loc  The locale to test.
   *  @return  true if @p __loc contains a facet of type _Facet, else false.
  */
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size
#if __cpp_rtti
	      && dynamic_cast<const _Facet*>(__facets[__i]));
#else
# 112 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3
              && static_cast<const _Facet*>(__facets[__i]));
#endif
# 114 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3
    }

  /**
   *  @brief  Return a facet.
   *  @ingroup locales
   *
   *  use_facet looks for and returns a reference to a facet of type Facet
   *  where Facet is the template parameter.  If has_facet(locale) is true,
   *  there is a suitable facet to return.  It throws std::bad_cast if the
   *  locale doesn't contain a facet of type Facet.
   *
   *  @tparam  _Facet  The facet type to access.
   *  @param  __loc  The locale to use.
   *  @return  Reference to facet of type Facet.
   *  @throw  std::bad_cast if @p __loc doesn't contain a facet of type _Facet.
  */
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();
#if __cpp_rtti
      return dynamic_cast<const _Facet&>(*__facets[__i]);
#else
# 141 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3
      return static_cast<const _Facet&>(*__facets[__i]);
#endif
# 143 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3
    }


  // Generic version does nothing.
  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }

  // Generic version does nothing.
  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
	       const _CharT* __lo2, const _CharT* __hi2) const
    {
      // strcoll assumes zero-terminated strings so we make a copy
      // and then put a zero at the end.
      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();

      // strcoll stops when it sees a nul character so we break
      // the strings into zero-terminated substrings and pass those
      // to strcoll.
      for (;;)
	{
	  const int __res = _M_compare(__p, __q);
	  if (__res)
	    return __res;

	  __p += char_traits<_CharT>::length(__p);
	  __q += char_traits<_CharT>::length(__q);
	  if (__p == __pend && __q == __qend)
	    return 0;
	  else if (__p == __pend)
	    return -1;
	  else if (__q == __qend)
	    return 1;

	  __p++;
	  __q++;
	}
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;

      // strxfrm assumes zero-terminated strings so we make a copy
      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      __try
	{
	  // strxfrm stops when it sees a nul character so we break
	  // the string into zero-terminated substrings and pass those
	  // to strxfrm.
	  for (;;)
	    {
	      // First try a buffer perhaps big enough.
	      size_t __res = _M_transform(__c, __p, __len);
	      // If the buffer was not large enough, try again with the
	      // correct size.
	      if (__res >= __len)
		{
		  __len = __res + 1;
		  delete [] __c, __c = 0;
		  __c = new _CharT[__len];
		  __res = _M_transform(__c, __p, __len);
		}

	      __ret.append(__c, __res);
	      __p += char_traits<_CharT>::length(__p);
	      if (__p == __pend)
		break;

	      __p++;
	      __ret.push_back(_CharT());
	    }
	}
      __catch(...)
	{
	  delete [] __c;
	  __throw_exception_again;
	}

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
	__val =
	  *__lo + ((__val << 7)
		   | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
				__digits - 7)));
      return static_cast<long>(__val);
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);
#endif
# 293 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3
#endif
# 294 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 299 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.tcc" 3
# 843 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 2 3

#endif
# 845 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_classes.h" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 2 3

#if __cplusplus < 201103L
#if 0 /* expanded by -frewrite-includes */
# include <stdexcept>
#endif /* expanded by -frewrite-includes */
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 1 3
// Standard exception classes  -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/stdexcept
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 19.1  Exception classes
//

#ifndef _GLIBCXX_STDEXCEPT
#define _GLIBCXX_STDEXCEPT 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3

#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#if _GLIBCXX_USE_DUAL_ABI
#if _GLIBCXX_USE_CXX11_ABI
  // Emulates an old COW string when the new std::string is in use.
  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) _GLIBCXX_USE_NOEXCEPT;
    __cow_string& operator=(const __cow_string&) _GLIBCXX_USE_NOEXCEPT;
    ~__cow_string();
#if __cplusplus >= 201103L
    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;
#endif
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
  };

  typedef basic_string<char> __sso_string;
#else // _GLIBCXX_USE_CXX11_ABI
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
  typedef basic_string<char> __cow_string;

  // Emulates a new SSO string when the old std::string is in use.
  struct __sso_string
  {
    struct __str
    {
      const char* _M_p;
      size_t _M_string_length;
      char _M_local_buf[16];
    };

    union {
      __str _M_s;
      char _M_bytes[sizeof(__str)];
    };

    __sso_string() _GLIBCXX_USE_NOEXCEPT;
    __sso_string(const std::string&);
    __sso_string(const char*, size_t);
    __sso_string(const __sso_string&);
    __sso_string& operator=(const __sso_string&);
    ~__sso_string();
#if __cplusplus >= 201103L
    __sso_string(__sso_string&&) noexcept;
    __sso_string& operator=(__sso_string&&) noexcept;
#endif
# 96 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
  };
#endif // _GLIBCXX_USE_CXX11_ABI
# 98 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
#else  // _GLIBCXX_USE_DUAL_ABI
# 99 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
  typedef basic_string<char> __sso_string;
  typedef basic_string<char> __cow_string;
#endif
# 102 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3

  /**
   * @addtogroup exceptions
   * @{
   */

  /** Logic errors represent problems in the internal logic of a program;
   *  in theory, these are preventable, and even detectable before the
   *  program runs (e.g., violations of class invariants).
   *  @brief One of two subclasses of exception.
   */
  class logic_error : public exception 
  {
    __cow_string _M_msg;

  public:
    /** Takes a character string describing the error.  */
    explicit 
    logic_error(const string& __arg);

#if __cplusplus >= 201103L
    explicit
    logic_error(const char*);
#endif
# 126 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3

#if _GLIBCXX_USE_CXX11_ABI || _GLIBCXX_DEFINE_STDEXCEPT_COPY_OPS
    logic_error(const logic_error&) _GLIBCXX_USE_NOEXCEPT;
    logic_error& operator=(const logic_error&) _GLIBCXX_USE_NOEXCEPT;
#endif
# 131 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3

    virtual ~logic_error() _GLIBCXX_USE_NOEXCEPT;

    /** Returns a C-style character string describing the general cause of
     *  the current error (the same string passed to the ctor).  */
    virtual const char* 
    what() const _GLIBCXX_USE_NOEXCEPT;
  };

  /** Thrown by the library, or by you, to report domain errors (domain in
   *  the mathematical sense).  */
  class domain_error : public logic_error 
  {
  public:
    explicit domain_error(const string& __arg);
#if __cplusplus >= 201103L
    explicit domain_error(const char*);
#endif
# 149 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
    virtual ~domain_error() _GLIBCXX_USE_NOEXCEPT;
  };

  /** Thrown to report invalid arguments to functions.  */
  class invalid_argument : public logic_error 
  {
  public:
    explicit invalid_argument(const string& __arg);
#if __cplusplus >= 201103L
    explicit invalid_argument(const char*);
#endif
# 160 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
    virtual ~invalid_argument() _GLIBCXX_USE_NOEXCEPT;
  };

  /** Thrown when an object is constructed that would exceed its maximum
   *  permitted size (e.g., a basic_string instance).  */
  class length_error : public logic_error 
  {
  public:
    explicit length_error(const string& __arg);
#if __cplusplus >= 201103L
    explicit length_error(const char*);
#endif
# 172 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
    virtual ~length_error() _GLIBCXX_USE_NOEXCEPT;
  };

  /** This represents an argument whose value is not within the expected
   *  range (e.g., boundary checks in basic_string).  */
  class out_of_range : public logic_error 
  {
  public:
    explicit out_of_range(const string& __arg);
#if __cplusplus >= 201103L
    explicit out_of_range(const char*);
#endif
# 184 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
    virtual ~out_of_range() _GLIBCXX_USE_NOEXCEPT;
  };

  /** Runtime errors represent problems outside the scope of a program;
   *  they cannot be easily predicted and can generally only be caught as
   *  the program executes.
   *  @brief One of two subclasses of exception.
   */
  class runtime_error : public exception 
  {
    __cow_string _M_msg;

  public:
    /** Takes a character string describing the error.  */
    explicit 
    runtime_error(const string& __arg);

#if __cplusplus >= 201103L
    explicit
    runtime_error(const char*);
#endif
# 205 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3

#if _GLIBCXX_USE_CXX11_ABI || _GLIBCXX_DEFINE_STDEXCEPT_COPY_OPS
    runtime_error(const runtime_error&) _GLIBCXX_USE_NOEXCEPT;
    runtime_error& operator=(const runtime_error&) _GLIBCXX_USE_NOEXCEPT;
#endif
# 210 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3

    virtual ~runtime_error() _GLIBCXX_USE_NOEXCEPT;

    /** Returns a C-style character string describing the general cause of
     *  the current error (the same string passed to the ctor).  */
    virtual const char* 
    what() const _GLIBCXX_USE_NOEXCEPT;
  };

  /** Thrown to indicate range errors in internal computations.  */
  class range_error : public runtime_error 
  {
  public:
    explicit range_error(const string& __arg);
#if __cplusplus >= 201103L
    explicit range_error(const char*);
#endif
# 227 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
    virtual ~range_error() _GLIBCXX_USE_NOEXCEPT;
  };

  /** Thrown to indicate arithmetic overflow.  */
  class overflow_error : public runtime_error 
  {
  public:
    explicit overflow_error(const string& __arg);
#if __cplusplus >= 201103L
    explicit overflow_error(const char*);
#endif
# 238 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
    virtual ~overflow_error() _GLIBCXX_USE_NOEXCEPT;
  };

  /** Thrown to indicate arithmetic underflow.  */
  class underflow_error : public runtime_error 
  {
  public:
    explicit underflow_error(const string& __arg);
#if __cplusplus >= 201103L
    explicit underflow_error(const char*);
#endif
# 249 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
    virtual ~underflow_error() _GLIBCXX_USE_NOEXCEPT;
  };

  // @} group exceptions

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _GLIBCXX_STDEXCEPT */
# 258 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stdexcept" 3
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 2 3
#else
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
#if 0 /* expanded by -frewrite-includes */
# include <system_error>
#endif /* expanded by -frewrite-includes */
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
#endif
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // The following definitions of bitmask types are enums, not ints,
  // as permitted (but not required) in the standard, in order to provide
  // better type safety in iostream calls.  A side effect is that
  // expressions involving them are no longer compile-time constants.
  enum _Ios_Fmtflags 
    { 
      _S_boolalpha 	= 1L << 0,
      _S_dec 		= 1L << 1,
      _S_fixed 		= 1L << 2,
      _S_hex 		= 1L << 3,
      _S_internal 	= 1L << 4,
      _S_left 		= 1L << 5,
      _S_oct 		= 1L << 6,
      _S_right 		= 1L << 7,
      _S_scientific 	= 1L << 8,
      _S_showbase 	= 1L << 9,
      _S_showpoint 	= 1L << 10,
      _S_showpos 	= 1L << 11,
      _S_skipws 	= 1L << 12,
      _S_unitbuf 	= 1L << 13,
      _S_uppercase 	= 1L << 14,
      _S_adjustfield 	= _S_left | _S_right | _S_internal,
      _S_basefield 	= _S_dec | _S_oct | _S_hex,
      _S_floatfield 	= _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16 
    };

  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode 
    { 
      _S_app 		= 1L << 0,
      _S_ate 		= 1L << 1,
      _S_bin 		= 1L << 2,
      _S_in 		= 1L << 3,
      _S_out 		= 1L << 4,
      _S_trunc 		= 1L << 5,
      _S_ios_openmode_end = 1L << 16 
    };

  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    { 
      _S_goodbit 		= 0,
      _S_badbit 		= 1L << 0,
      _S_eofbit 		= 1L << 1,
      _S_failbit		= 1L << 2,
      _S_ios_iostate_end = 1L << 16 
    };

  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _GLIBCXX_CONSTEXPR _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const  _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir 
    { 
      _S_beg = 0,
      _S_cur = _GLIBCXX_STDIO_SEEK_CUR,
      _S_end = _GLIBCXX_STDIO_SEEK_END,
      _S_ios_seekdir_end = 1L << 16 
    };

#if __cplusplus >= 201103L
  /// I/O error code
  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc e) noexcept
  { return error_code(static_cast<int>(e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc e) noexcept
  { return error_condition(static_cast<int>(e), iostream_category()); }
#endif
# 211 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3

  // 27.4.2  Class ios_base
  /**
   *  @brief  The base of the I/O class hierarchy.
   *  @ingroup io
   *
   *  This class defines everything that can be defined about I/O that does
   *  not depend on the type of characters being input or output.  Most
   *  people will only see @c ios_base when they need to specify the full
   *  name of the various I/O flags (e.g., the openmodes).
  */
  class ios_base
  {
#if _GLIBCXX_USE_CXX11_ABI
#if __cplusplus < 201103L
    // Type that is layout-compatible with std::system_error
    struct system_error : std::runtime_error
    {
      // Type that is layout-compatible with std::error_code
      struct error_code
      {
	error_code() { }
      private:
	int		_M_value;
	const void*	_M_cat;
      } _M_code;
    };
#endif
# 239 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
#endif
# 240 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
  public:

    /** 
     *  @brief These are thrown to indicate problems with io.
     *  @ingroup exceptions
     *
     *  27.4.2.1.1  Class ios_base::failure
     */
#if _GLIBCXX_USE_CXX11_ABI
    class _GLIBCXX_ABI_TAG_CXX11 failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);

#if __cplusplus >= 201103L
      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);
#endif
# 262 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3

      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
#else
# 270 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
    class failure : public exception
    {
    public:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 48.  Use of non-existent exception constructor
      explicit
      failure(const string& __str) throw();

      // This declaration is not useless:
      // http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Vague-Linkage.html
      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
#endif
# 290 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3

    // 27.4.2.1.2  Type ios_base::fmtflags
    /**
     *  @brief This is a bitmask type.
     *
     *  @c @a _Ios_Fmtflags is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type fmtflags are:
     *  - boolalpha
     *  - dec
     *  - fixed
     *  - hex
     *  - internal
     *  - left
     *  - oct
     *  - right
     *  - scientific
     *  - showbase
     *  - showpoint
     *  - showpos
     *  - skipws
     *  - unitbuf
     *  - uppercase
     *  - adjustfield
     *  - basefield
     *  - floatfield
    */
    typedef _Ios_Fmtflags fmtflags;

    /// Insert/extract @c bool in alphabetic rather than numeric format.
    static const fmtflags boolalpha =   _S_boolalpha;

    /// Converts integer input or generates integer output in decimal base.
    static const fmtflags dec =         _S_dec;

    /// Generate floating-point output in fixed-point notation.
    static const fmtflags fixed =       _S_fixed;

    /// Converts integer input or generates integer output in hexadecimal base.
    static const fmtflags hex =         _S_hex;

    /// Adds fill characters at a designated internal point in certain
    /// generated output, or identical to @c right if no such point is
    /// designated.
    static const fmtflags internal =    _S_internal;

    /// Adds fill characters on the right (final positions) of certain
    /// generated output.  (I.e., the thing you print is flush left.)
    static const fmtflags left =        _S_left;

    /// Converts integer input or generates integer output in octal base.
    static const fmtflags oct =         _S_oct;

    /// Adds fill characters on the left (initial positions) of certain
    /// generated output.  (I.e., the thing you print is flush right.)
    static const fmtflags right =       _S_right;

    /// Generates floating-point output in scientific notation.
    static const fmtflags scientific =  _S_scientific;

    /// Generates a prefix indicating the numeric base of generated integer
    /// output.
    static const fmtflags showbase =    _S_showbase;

    /// Generates a decimal-point character unconditionally in generated
    /// floating-point output.
    static const fmtflags showpoint =   _S_showpoint;

    /// Generates a + sign in non-negative generated numeric output.
    static const fmtflags showpos =     _S_showpos;

    /// Skips leading white space before certain input operations.
    static const fmtflags skipws =      _S_skipws;

    /// Flushes output after each output operation.
    static const fmtflags unitbuf =     _S_unitbuf;

    /// Replaces certain lowercase letters with their uppercase equivalents
    /// in generated output.
    static const fmtflags uppercase =   _S_uppercase;

    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.
    static const fmtflags adjustfield = _S_adjustfield;

    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.
    static const fmtflags basefield =   _S_basefield;

    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.
    static const fmtflags floatfield =  _S_floatfield;

    // 27.4.2.1.3  Type ios_base::iostate
    /**
     *  @brief This is a bitmask type.
     *
     *  @c @a _Ios_Iostate is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type iostate are:
     *  - badbit
     *  - eofbit
     *  - failbit
     *  - goodbit
    */
    typedef _Ios_Iostate iostate;

    /// Indicates a loss of integrity in an input or output sequence (such
    /// as an irrecoverable read error from a file).
    static const iostate badbit =	_S_badbit;

    /// Indicates that an input operation reached the end of an input sequence.
    static const iostate eofbit =	_S_eofbit;

    /// Indicates that an input operation failed to read the expected
    /// characters, or that an output operation failed to generate the
    /// desired characters.
    static const iostate failbit =	_S_failbit;

    /// Indicates all is well.
    static const iostate goodbit =	_S_goodbit;

    // 27.4.2.1.4  Type ios_base::openmode
    /**
     *  @brief This is a bitmask type.
     *
     *  @c @a _Ios_Openmode is implementation-defined, but it is valid to
     *  perform bitwise operations on these values and expect the Right
     *  Thing to happen.  Defined objects of type openmode are:
     *  - app
     *  - ate
     *  - binary
     *  - in
     *  - out
     *  - trunc
    */
    typedef _Ios_Openmode openmode;

    /// Seek to end before each write.
    static const openmode app =		_S_app;

    /// Open and seek to end immediately after opening.
    static const openmode ate =		_S_ate;

    /// Perform input and output in binary mode (as opposed to text mode).
    /// This is probably not what you think it is; see
    /// https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary
    static const openmode binary =	_S_bin;

    /// Open for input.  Default for @c ifstream and fstream.
    static const openmode in =		_S_in;

    /// Open for output.  Default for @c ofstream and fstream.
    static const openmode out =		_S_out;

    /// Open for input.  Default for @c ofstream.
    static const openmode trunc =	_S_trunc;

    // 27.4.2.1.5  Type ios_base::seekdir
    /**
     *  @brief This is an enumerated type.
     *
     *  @c @a _Ios_Seekdir is implementation-defined.  Defined values
     *  of type seekdir are:
     *  - beg
     *  - cur, equivalent to @c SEEK_CUR in the C standard library.
     *  - end, equivalent to @c SEEK_END in the C standard library.
    */
    typedef _Ios_Seekdir seekdir;

    /// Request a seek relative to the beginning of the stream.
    static const seekdir beg =		_S_beg;

    /// Request a seek relative to the current position within the sequence.
    static const seekdir cur =		_S_cur;

    /// Request a seek relative to the current end of the sequence.
    static const seekdir end =		_S_end;

    // Annex D.6
    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;

    // Callbacks;
    /**
     *  @brief  The set of events that may be passed to an event callback.
     *
     *  erase_event is used during ~ios() and copyfmt().  imbue_event is used
     *  during imbue().  copyfmt_event is used during copyfmt().
    */
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };

    /**
     *  @brief  The type of an event callback function.
     *  @param  __e  One of the members of the event enum.
     *  @param  __b  Reference to the ios_base object.
     *  @param  __i  The integer provided when the callback was registered.
     *
     *  Event callbacks are user defined functions that get called during
     *  several ios_base and basic_ios functions, specifically imbue(),
     *  copyfmt(), and ~ios().
    */
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);

    /**
     *  @brief  Add the callback __fn with parameter __index.
     *  @param  __fn  The function to add.
     *  @param  __index  The integer to pass to the function when invoked.
     *
     *  Registers a function as an event callback with an integer parameter to
     *  be passed to the function when invoked.  Multiple copies of the
     *  function are allowed.  If there are multiple callbacks, they are
     *  invoked in the order they were registered.
    */
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize		_M_precision;
    streamsize		_M_width;
    fmtflags		_M_flags;
    iostate		_M_exception;
    iostate		_M_streambuf_state;

    // 27.4.2.6  Members for callbacks
    // 27.4.2.6  ios_base callbacks
    struct _Callback_list
    {
      // Data Members
      _Callback_list*		_M_next;
      ios_base::event_callback	_M_fn;
      int			_M_index;
      _Atomic_word		_M_refcount;  // 0 means one reference.

      _Callback_list(ios_base::event_callback __fn, int __index,
		     _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

      // 0 => OK to delete.
      int
      _M_remove_reference() 
      {
        // Be race-detector-friendly.  For more info see bits/c++config.
        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);
          }
        return __res;
      }
    };

     _Callback_list*	_M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();

    // 27.4.2.5  Members for iword/pword storage
    struct _Words
    {
      void*	_M_pword;
      long	_M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };

    // Only for failed iword/pword calls.
    _Words		_M_word_zero;

    // Guaranteed storage.
    // The first 5 iword and pword slots are reserved for internal use.
    enum { _S_local_word_size = 8 };
    _Words		_M_local_word[_S_local_word_size];

    // Allocated storage.
    int			_M_word_size;
    _Words*		_M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);

    // Members for locale and locale caching.
    locale		_M_ios_locale;

    void
    _M_init() throw();

  public:

    // 27.4.2.1.6  Class ios_base::Init
    // Used to initialize standard streams. In theory, g++ could use
    // -finit-priority to order this stuff correctly without going
    // through these machinations.
    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word	_S_refcount;
      static bool		_S_synced_with_stdio;
    };

    // [27.4.2.2] fmtflags state functions
    /**
     *  @brief  Access to format flags.
     *  @return  The format control flags for both input and output.
    */
    fmtflags
    flags() const
    { return _M_flags; }

    /**
     *  @brief  Setting new format flags all at once.
     *  @param  __fmtfl  The new flags to set.
     *  @return  The previous format control flags.
     *
     *  This function overwrites all the format flags with @a __fmtfl.
    */
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }

    /**
     *  @brief  Setting new format flags.
     *  @param  __fmtfl  Additional flags to set.
     *  @return  The previous format control flags.
     *
     *  This function sets additional flags in format control.  Flags that
     *  were previously set remain set.
    */
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }

    /**
     *  @brief  Setting new format flags.
     *  @param  __fmtfl  Additional flags to set.
     *  @param  __mask  The flags mask for @a fmtfl.
     *  @return  The previous format control flags.
     *
     *  This function clears @a mask in the format flags, then sets
     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.
    */
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }

    /**
     *  @brief  Clearing format flags.
     *  @param  __mask  The flags to unset.
     *
     *  This function clears @a __mask in the format flags.
    */
    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }

    /**
     *  @brief  Flags access.
     *  @return  The precision to generate on certain output operations.
     *
     *  Be careful if you try to give a definition of @a precision here; see
     *  DR 189.
    */
    streamsize
    precision() const
    { return _M_precision; }

    /**
     *  @brief  Changing flags.
     *  @param  __prec  The new precision value.
     *  @return  The previous value of precision().
    */
    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }

    /**
     *  @brief  Flags access.
     *  @return  The minimum field width to generate on output operations.
     *
     *  <em>Minimum field width</em> refers to the number of characters.
    */
    streamsize
    width() const
    { return _M_width; }

    /**
     *  @brief  Changing flags.
     *  @param  __wide  The new width value.
     *  @return  The previous value of width().
    */
    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }

    // [27.4.2.4] ios_base static members
    /**
     *  @brief  Interaction with the standard C I/O objects.
     *  @param  __sync  Whether to synchronize or not.
     *  @return  True if the standard streams were previously synchronized.
     *
     *  The synchronization referred to is @e only that between the standard
     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,
     *  cout).  User-declared streams are unaffected.  See
     *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary
    */
    static bool
    sync_with_stdio(bool __sync = true);

    // [27.4.2.3] ios_base locale functions
    /**
     *  @brief  Setting a new locale.
     *  @param  __loc  The new locale.
     *  @return  The previous locale.
     *
     *  Sets the new locale for this stream, and then invokes each callback
     *  with imbue_event.
    */
    locale
    imbue(const locale& __loc) throw();

    /**
     *  @brief  Locale access
     *  @return  A copy of the current locale.
     *
     *  If @c imbue(loc) has previously been called, then this function
     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),
     *  the global C++ locale.
    */
    locale
    getloc() const
    { return _M_ios_locale; }

    /**
     *  @brief  Locale access
     *  @return  A reference to the current locale.
     *
     *  Like getloc above, but returns a reference instead of
     *  generating a copy.
    */
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }

    // [27.4.2.5] ios_base storage functions
    /**
     *  @brief  Access to unique indices.
     *  @return  An integer different from all previous calls.
     *
     *  This function returns a unique integer every time it is called.  It
     *  can be used for any purpose, but is primarily intended to be a unique
     *  index for the iword and pword functions.  The expectation is that an
     *  application calls xalloc in order to obtain an index in the iword and
     *  pword arrays that can be used without fear of conflict.
     *
     *  The implementation maintains a static variable that is incremented and
     *  returned on each invocation.  xalloc is guaranteed to return an index
     *  that is safe to use in the iword and pword arrays.
    */
    static int
    xalloc() throw();

    /**
     *  @brief  Access to integer array.
     *  @param  __ix  Index into the array.
     *  @return  A reference to an integer associated with the index.
     *
     *  The iword function provides access to an array of integers that can be
     *  used for any purpose.  The array grows as required to hold the
     *  supplied index.  All integers in the array are initialized to 0.
     *
     *  The implementation reserves several indices.  You should use xalloc to
     *  obtain an index that is safe to use.  Also note that since the array
     *  can grow dynamically, it is not safe to hold onto the reference.
    */
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
			? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }

    /**
     *  @brief  Access to void pointer array.
     *  @param  __ix  Index into the array.
     *  @return  A reference to a void* associated with the index.
     *
     *  The pword function provides access to an array of pointers that can be
     *  used for any purpose.  The array grows as required to hold the
     *  supplied index.  All pointers in the array are initialized to 0.
     *
     *  The implementation reserves several indices.  You should use xalloc to
     *  obtain an index that is safe to use.  Also note that since the array
     *  can grow dynamically, it is not safe to hold onto the reference.
    */
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
			? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }

    // Destructor
    /**
     *  Invokes each callback with erase_event.  Destroys local storage.
     *
     *  Note that the ios_base object for the standard streams never gets
     *  destroyed.  As a result, any callbacks registered with the standard
     *  streams will not get invoked with erase_event (unless copyfmt is
     *  used).
    */
    virtual ~ios_base();

  protected:
    ios_base() throw ();

#if __cplusplus < 201103L
  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 50.  Copy constructor and assignment operator of ios_base
  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
#else
# 854 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;
#endif
# 867 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
  };

  // [27.4.5.1] fmtflags manipulators
  /// Calls base.setf(ios_base::boolalpha).
  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }

  /// Calls base.unsetf(ios_base::boolalpha).
  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }

  /// Calls base.setf(ios_base::showbase).
  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }

  /// Calls base.unsetf(ios_base::showbase).
  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }

  /// Calls base.setf(ios_base::showpoint).
  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }

  /// Calls base.unsetf(ios_base::showpoint).
  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }

  /// Calls base.setf(ios_base::showpos).
  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }

  /// Calls base.unsetf(ios_base::showpos).
  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }

  /// Calls base.setf(ios_base::skipws).
  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }

  /// Calls base.unsetf(ios_base::skipws).
  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }

  /// Calls base.setf(ios_base::uppercase).
  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }

  /// Calls base.unsetf(ios_base::uppercase).
  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }

  /// Calls base.setf(ios_base::unitbuf).
  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }

  /// Calls base.unsetf(ios_base::unitbuf).
  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }

  // [27.4.5.2] adjustfield manipulators
  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).
  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }

  /// Calls base.setf(ios_base::left, ios_base::adjustfield).
  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }

  /// Calls base.setf(ios_base::right, ios_base::adjustfield).
  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }

  // [27.4.5.3] basefield manipulators
  /// Calls base.setf(ios_base::dec, ios_base::basefield).
  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }

  /// Calls base.setf(ios_base::hex, ios_base::basefield).
  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }

  /// Calls base.setf(ios_base::oct, ios_base::basefield).
  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }

  // [27.4.5.4] floatfield manipulators
  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).
  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }

  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).
  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

#if __cplusplus >= 201103L
  // New C++11 floatfield manipulators

  /// Calls
  /// base.setf(ios_base::fixed|ios_base::scientific, ios_base::floatfield)
  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }

  /// Calls @c base.unsetf(ios_base::floatfield)
  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }
#endif
# 1069 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _IOS_BASE_H */
# 1074 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ios_base.h" 3
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <streambuf>
#endif /* expanded by -frewrite-includes */
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 1 3
// Stream buffer classes -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/streambuf
 *  This is a Standard C++ Library header.
 */

//
// ISO C++ 14882: 27.5  Stream buffers
//

#ifndef _GLIBXX_STREAMBUF
#define _GLIBXX_STREAMBUF 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
#if 0 /* expanded by -frewrite-includes */
#include <iosfwd>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/localefwd.h>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/ios_base.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/type_traits.h>
#endif /* expanded by -frewrite-includes */
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
			  basic_streambuf<_CharT, _Traits>*, bool&);

  /**
   *  @brief  The actual work of input and output (interface).
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is a base class.  Derived stream buffers each control a
   *  pair of character sequences:  one for input, and one for output.
   *
   *  Section [27.5.1] of the standard describes the requirements and
   *  behavior of stream buffer classes.  That section (three paragraphs)
   *  is reproduced here, for simplicity and accuracy.
   *
   *  -# Stream buffers can impose various constraints on the sequences
   *     they control.  Some constraints are:
   *     - The controlled input sequence can be not readable.
   *     - The controlled output sequence can be not writable.
   *     - The controlled sequences can be associated with the contents of
   *       other representations for character sequences, such as external
   *       files.
   *     - The controlled sequences can support operations @e directly to or
   *       from associated sequences.
   *     - The controlled sequences can impose limitations on how the
   *       program can read characters from a sequence, write characters to
   *       a sequence, put characters back into an input sequence, or alter
   *       the stream position.
   *     .
   *  -# Each sequence is characterized by three pointers which, if non-null,
   *     all point into the same @c charT array object.  The array object
   *     represents, at any moment, a (sub)sequence of characters from the
   *     sequence.  Operations performed on a sequence alter the values
   *     stored in these pointers, perform reads and writes directly to or
   *     from associated sequences, and alter <em>the stream position</em> and
   *     conversion state as needed to maintain this subsequence relationship.
   *     The three pointers are:
   *     - the <em>beginning pointer</em>, or lowest element address in the
   *       array (called @e xbeg here);
   *     - the <em>next pointer</em>, or next element address that is a
   *       current candidate for reading or writing (called @e xnext here);
   *     - the <em>end pointer</em>, or first element address beyond the
   *       end of the array (called @e xend here).
   *     .
   *  -# The following semantic constraints shall always apply for any set
   *     of three pointers for a sequence, using the pointer names given
   *     immediately above:
   *     - If @e xnext is not a null pointer, then @e xbeg and @e xend shall
   *       also be non-null pointers into the same @c charT array, as
   *       described above; otherwise, @e xbeg and @e xend shall also be null.
   *     - If @e xnext is not a null pointer and @e xnext < @e xend for an
   *       output sequence, then a <em>write position</em> is available.
   *       In this case, @e *xnext shall be assignable as the next element
   *       to write (to put, or to store a character value, into the sequence).
   *     - If @e xnext is not a null pointer and @e xbeg < @e xnext for an
   *       input sequence, then a <em>putback position</em> is available.
   *       In this case, @e xnext[-1] shall have a defined value and is the
   *       next (preceding) element to store a character that is put back
   *       into the input sequence.
   *     - If @e xnext is not a null pointer and @e xnext< @e xend for an
   *       input sequence, then a <em>read position</em> is available.
   *       In this case, @e *xnext shall have a defined value and is the
   *       next element to read (to get, or to obtain a character value,
   *       from the sequence).
  */
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:
      //@{
      /**
       *  These are standard types.  They permit a standardized way of
       *  referring to names of (or names dependent on) the template
       *  parameters, which are specific to the implementation.
      */
      typedef _CharT 					char_type;
      typedef _Traits 					traits_type;
      typedef typename traits_type::int_type 		int_type;
      typedef typename traits_type::pos_type 		pos_type;
      typedef typename traits_type::off_type 		off_type;
      //@}

      //@{
      /// This is a non-standard type.
      typedef basic_streambuf<char_type, traits_type>  	__streambuf_type;
      //@}

      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
					       _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
		       istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
				  istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
	     const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
		   basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
		basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
      /*
       *  This is based on _IO_FILE, just reordered to be more consistent,
       *  and is intended to be the most minimal abstraction for an
       *  internal buffer.
       *  -  get == input == read
       *  -  put == output == write
      */
      char_type* 		_M_in_beg;     ///< Start of get area.
      char_type* 		_M_in_cur;     ///< Current read area.
      char_type* 		_M_in_end;     ///< End of get area.
      char_type* 		_M_out_beg;    ///< Start of put area.
      char_type* 		_M_out_cur;    ///< Current put area.
      char_type* 		_M_out_end;    ///< End of put area.

      /// Current locale setting.
      locale 			_M_buf_locale;

  public:
      /// Destructor deallocates no buffer space.
      virtual
      ~basic_streambuf()
      { }

      // [27.5.2.2.1] locales
      /**
       *  @brief  Entry point for imbue().
       *  @param  __loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls the derived imbue(__loc).
      */
      locale
      pubimbue(const locale& __loc)
      {
	locale __tmp(this->getloc());
	this->imbue(__loc);
	_M_buf_locale = __loc;
	return __tmp;
      }

      /**
       *  @brief  Locale access.
       *  @return  The current locale in effect.
       *
       *  If pubimbue(loc) has been called, then the most recent @c loc
       *  is returned.  Otherwise the global locale in effect at the time
       *  of construction is returned.
      */
      locale
      getloc() const
      { return _M_buf_locale; }

      // [27.5.2.2.2] buffer management and positioning
      //@{
      /**
       *  @brief  Entry points for derived buffer functions.
       *
       *  The public versions of @c pubfoo dispatch to the protected
       *  derived @c foo member functions, passing the arguments (if any)
       *  and returning the result unchanged.
      */
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      /**
       *  @brief  Alters the stream position.
       *  @param  __off  Offset.
       *  @param  __way  Value for ios_base::seekdir.
       *  @param  __mode Value for ios_base::openmode.
       *
       *  Calls virtual seekoff function.
      */
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
		 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      /**
       *  @brief  Alters the stream position.
       *  @param  __sp  Position
       *  @param  __mode Value for ios_base::openmode.
       *
       *  Calls virtual seekpos function.
      */
      pos_type
      pubseekpos(pos_type __sp,
		 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      /**
       *  @brief  Calls virtual sync function.
      */
      int
      pubsync() { return this->sync(); }
      //@}

      // [27.5.2.2.3] get area
      /**
       *  @brief  Looking ahead into the stream.
       *  @return  The number of characters available.
       *
       *  If a read position is available, returns the number of characters
       *  available for reading before the buffer must be refilled.
       *  Otherwise returns the derived @c showmanyc().
      */
      streamsize
      in_avail()
      {
	const streamsize __ret = this->egptr() - this->gptr();
	return __ret ? __ret : this->showmanyc();
      }

      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  Calls @c sbumpc(), and if that function returns
       *  @c traits::eof(), so does this function.  Otherwise, @c sgetc().
      */
      int_type
      snextc()
      {
	int_type __ret = traits_type::eof();
	if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
						       __ret), true))
	  __ret = this->sgetc();
	return __ret;
      }

      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  If the input read position is available, returns that character
       *  and increments the read pointer, otherwise calls and returns
       *  @c uflow().
      */
      int_type
      sbumpc()
      {
	int_type __ret;
	if (__builtin_expect(this->gptr() < this->egptr(), true))
	  {
	    __ret = traits_type::to_int_type(*this->gptr());
	    this->gbump(1);
	  }
	else
	  __ret = this->uflow();
	return __ret;
      }

      /**
       *  @brief  Getting the next character.
       *  @return  The next character, or eof.
       *
       *  If the input read position is available, returns that character,
       *  otherwise calls and returns @c underflow().  Does not move the
       *  read position after fetching the character.
      */
      int_type
      sgetc()
      {
	int_type __ret;
	if (__builtin_expect(this->gptr() < this->egptr(), true))
	  __ret = traits_type::to_int_type(*this->gptr());
	else
	  __ret = this->underflow();
	return __ret;
      }

      /**
       *  @brief  Entry point for xsgetn.
       *  @param  __s  A buffer area.
       *  @param  __n  A count.
       *
       *  Returns xsgetn(__s,__n).  The effect is to fill @a __s[0] through
       *  @a __s[__n-1] with characters from the input sequence, if possible.
      */
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }

      // [27.5.2.2.4] putback
      /**
       *  @brief  Pushing characters back into the input stream.
       *  @param  __c  The character to push back.
       *  @return  The previous character, if possible.
       *
       *  Similar to sungetc(), but @a __c is pushed onto the stream
       *  instead of <em>the previous character.</em> If successful,
       *  the next character fetched from the input stream will be @a
       *  __c.
      */
      int_type
      sputbackc(char_type __c)
      {
	int_type __ret;
	const bool __testpos = this->eback() < this->gptr();
	if (__builtin_expect(!__testpos ||
			     !traits_type::eq(__c, this->gptr()[-1]), false))
	  __ret = this->pbackfail(traits_type::to_int_type(__c));
	else
	  {
	    this->gbump(-1);
	    __ret = traits_type::to_int_type(*this->gptr());
	  }
	return __ret;
      }

      /**
       *  @brief  Moving backwards in the input stream.
       *  @return  The previous character, if possible.
       *
       *  If a putback position is available, this function decrements
       *  the input pointer and returns that character.  Otherwise,
       *  calls and returns pbackfail().  The effect is to @a unget
       *  the last character @a gotten.
      */
      int_type
      sungetc()
      {
	int_type __ret;
	if (__builtin_expect(this->eback() < this->gptr(), true))
	  {
	    this->gbump(-1);
	    __ret = traits_type::to_int_type(*this->gptr());
	  }
	else
	  __ret = this->pbackfail();
	return __ret;
      }

      // [27.5.2.2.5] put area
      /**
       *  @brief  Entry point for all single-character output functions.
       *  @param  __c  A character to output.
       *  @return  @a __c, if possible.
       *
       *  One of two public output functions.
       *
       *  If a write position is available for the output sequence (i.e.,
       *  the buffer is not full), stores @a __c in that position, increments
       *  the position, and returns @c traits::to_int_type(__c).  If a write
       *  position is not available, returns @c overflow(__c).
      */
      int_type
      sputc(char_type __c)
      {
	int_type __ret;
	if (__builtin_expect(this->pptr() < this->epptr(), true))
	  {
	    *this->pptr() = __c;
	    this->pbump(1);
	    __ret = traits_type::to_int_type(__c);
	  }
	else
	  __ret = this->overflow(traits_type::to_int_type(__c));
	return __ret;
      }

      /**
       *  @brief  Entry point for all single-character output functions.
       *  @param  __s  A buffer read area.
       *  @param  __n  A count.
       *
       *  One of two public output functions.
       *
       *
       *  Returns xsputn(__s,__n).  The effect is to write @a __s[0] through
       *  @a __s[__n-1] to the output sequence, if possible.
      */
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
      /**
       *  @brief  Base constructor.
       *
       *  Only called from derived constructors, and sets up all the
       *  buffer data to zero, including the pointers described in the
       *  basic_streambuf class description.  Note that, as a result,
       *  - the class starts with no read nor write positions available,
       *  - this is not an error
      */
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }

      // [27.5.2.3.1] get area access
      //@{
      /**
       *  @brief  Access to the get area.
       *
       *  These functions are only available to other protected functions,
       *  including derived classes.
       *
       *  - eback() returns the beginning pointer for the input sequence
       *  - gptr() returns the next pointer for the input sequence
       *  - egptr() returns the end pointer for the input sequence
      */
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr()  const { return _M_in_cur;  }

      char_type*
      egptr() const { return _M_in_end; }
      //@}

      /**
       *  @brief  Moving the read position.
       *  @param  __n  The delta by which to move.
       *
       *  This just advances the read position without returning any data.
      */
      void
      gbump(int __n) { _M_in_cur += __n; }

      /**
       *  @brief  Setting the three read area pointers.
       *  @param  __gbeg  A pointer.
       *  @param  __gnext  A pointer.
       *  @param  __gend  A pointer.
       *  @post  @a __gbeg == @c eback(), @a __gnext == @c gptr(), and
       *         @a __gend == @c egptr()
      */
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
	_M_in_beg = __gbeg;
	_M_in_cur = __gnext;
	_M_in_end = __gend;
      }

      // [27.5.2.3.2] put area access
      //@{
      /**
       *  @brief  Access to the put area.
       *
       *  These functions are only available to other protected functions,
       *  including derived classes.
       *
       *  - pbase() returns the beginning pointer for the output sequence
       *  - pptr() returns the next pointer for the output sequence
       *  - epptr() returns the end pointer for the output sequence
      */
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
      //@}

      /**
       *  @brief  Moving the write position.
       *  @param  __n  The delta by which to move.
       *
       *  This just advances the write position without returning any data.
      */
      void
      pbump(int __n) { _M_out_cur += __n; }

      /**
       *  @brief  Setting the three write area pointers.
       *  @param  __pbeg  A pointer.
       *  @param  __pend  A pointer.
       *  @post  @a __pbeg == @c pbase(), @a __pbeg == @c pptr(), and
       *         @a __pend == @c epptr()
      */
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
	_M_out_beg = _M_out_cur = __pbeg;
	_M_out_end = __pend;
      }

      // [27.5.2.4] virtual functions
      // [27.5.2.4.1] locales
      /**
       *  @brief  Changes translations.
       *  @param  __loc  A new locale.
       *
       *  Translations done during I/O which depend on the current
       *  locale are changed by this call.  The standard adds,
       *  <em>Between invocations of this function a class derived
       *  from streambuf can safely cache results of calls to locale
       *  functions and to members of facets so obtained.</em>
       *
       *  @note  Base class version does nothing.
      */
      virtual void
      imbue(const locale& __loc)
      { }

      // [27.5.2.4.2] buffer management and positioning
      /**
       *  @brief  Manipulates the buffer.
       *
       *  Each derived class provides its own appropriate behavior.  See
       *  the next-to-last paragraph of
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
       *  for more on this function.
       *
       *  @note  Base class version does nothing, returns @c this.
      */
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      {	return this; }

      /**
       *  @brief  Alters the stream positions.
       *
       *  Each derived class provides its own appropriate behavior.
       *  @note  Base class version does nothing, returns a @c pos_type
       *         that represents an invalid stream position.
      */
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
	      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }

      /**
       *  @brief  Alters the stream positions.
       *
       *  Each derived class provides its own appropriate behavior.
       *  @note  Base class version does nothing, returns a @c pos_type
       *         that represents an invalid stream position.
      */
      virtual pos_type
      seekpos(pos_type,
	      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }

      /**
       *  @brief  Synchronizes the buffer arrays with the controlled sequences.
       *  @return  -1 on failure.
       *
       *  Each derived class provides its own appropriate behavior,
       *  including the definition of @a failure.
       *  @note  Base class version does nothing, returns zero.
      */
      virtual int
      sync() { return 0; }

      // [27.5.2.4.3] get area
      /**
       *  @brief  Investigating the data available.
       *  @return  An estimate of the number of characters available in the
       *           input sequence, or -1.
       *
       *  <em>If it returns a positive value, then successive calls to
       *  @c underflow() will not return @c traits::eof() until at
       *  least that number of characters have been supplied.  If @c
       *  showmanyc() returns -1, then calls to @c underflow() or @c
       *  uflow() will fail.</em> [27.5.2.4.3]/1
       *
       *  @note  Base class version does nothing, returns zero.
       *  @note  The standard adds that <em>the intention is not only that the
       *         calls [to underflow or uflow] will not return @c eof() but
       *         that they will return immediately.</em>
       *  @note  The standard adds that <em>the morphemes of @c showmanyc are
       *         @b es-how-many-see, not @b show-manic.</em>
      */
      virtual streamsize
      showmanyc() { return 0; }

      /**
       *  @brief  Multiple character extraction.
       *  @param  __s  A buffer area.
       *  @param  __n  Maximum number of characters to assign.
       *  @return  The number of characters assigned.
       *
       *  Fills @a __s[0] through @a __s[__n-1] with characters from the input
       *  sequence, as if by @c sbumpc().  Stops when either @a __n characters
       *  have been copied, or when @c traits::eof() would be copied.
       *
       *  It is expected that derived classes provide a more efficient
       *  implementation by overriding this definition.
      */
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      /**
       *  @brief  Fetches more data from the controlled sequence.
       *  @return  The first character from the <em>pending sequence</em>.
       *
       *  Informally, this function is called when the input buffer is
       *  exhausted (or does not exist, as buffering need not actually be
       *  done).  If a buffer exists, it is @a refilled.  In either case, the
       *  next available character is returned, or @c traits::eof() to
       *  indicate a null pending sequence.
       *
       *  For a formal definition of the pending sequence, see a good text
       *  such as Langer & Kreft, or [27.5.2.4.3]/7-14.
       *
       *  A functioning input streambuf can be created by overriding only
       *  this function (no buffer area will be used).  For an example, see
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      underflow()
      { return traits_type::eof(); }

      /**
       *  @brief  Fetches more data from the controlled sequence.
       *  @return  The first character from the <em>pending sequence</em>.
       *
       *  Informally, this function does the same thing as @c underflow(),
       *  and in fact is required to call that function.  It also returns
       *  the new character, like @c underflow() does.  However, this
       *  function also moves the read position forward by one.
      */
      virtual int_type
      uflow()
      {
	int_type __ret = traits_type::eof();
	const bool __testeof = traits_type::eq_int_type(this->underflow(),
							__ret);
	if (!__testeof)
	  {
	    __ret = traits_type::to_int_type(*this->gptr());
	    this->gbump(1);
	  }
	return __ret;
      }

      // [27.5.2.4.4] putback
      /**
       *  @brief  Tries to back up the input sequence.
       *  @param  __c  The character to be inserted back into the sequence.
       *  @return  eof() on failure, <em>some other value</em> on success
       *  @post  The constraints of @c gptr(), @c eback(), and @c pptr()
       *         are the same as for @c underflow().
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      pbackfail(int_type __c  = traits_type::eof())
      { return traits_type::eof(); }

      // Put area:
      /**
       *  @brief  Multiple character insertion.
       *  @param  __s  A buffer area.
       *  @param  __n  Maximum number of characters to write.
       *  @return  The number of characters written.
       *
       *  Writes @a __s[0] through @a __s[__n-1] to the output sequence, as if
       *  by @c sputc().  Stops when either @a n characters have been
       *  copied, or when @c sputc() would return @c traits::eof().
       *
       *  It is expected that derived classes provide a more efficient
       *  implementation by overriding this definition.
      */
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);

      /**
       *  @brief  Consumes data from the buffer; writes to the
       *          controlled sequence.
       *  @param  __c  An additional character to consume.
       *  @return  eof() to indicate failure, something else (usually
       *           @a __c, or not_eof())
       *
       *  Informally, this function is called when the output buffer
       *  is full (or does not exist, as buffering need not actually
       *  be done).  If a buffer exists, it is @a consumed, with
       *  <em>some effect</em> on the controlled sequence.
       *  (Typically, the buffer is written out to the sequence
       *  verbatim.)  In either case, the character @a c is also
       *  written out, if @a __c is not @c eof().
       *
       *  For a formal definition of this function, see a good text
       *  such as Langer & Kreft, or [27.5.2.4.5]/3-7.
       *
       *  A functioning output streambuf can be created by overriding only
       *  this function (no buffer area will be used).
       *
       *  @note  Base class version does nothing, returns eof().
      */
      virtual int_type
      overflow(int_type __c  = traits_type::eof())
      { return traits_type::eof(); }

#if _GLIBCXX_USE_DEPRECATED
    // Annex D.6
    public:
      /**
       *  @brief  Tosses a character.
       *
       *  Advances the read pointer, ignoring the character that would have
       *  been read.
       *
       *  See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html
       */
      void
      stossc()
      {
	if (this->gptr() < this->egptr())
	  this->gbump(1);
	else
	  this->uflow();
      }
#endif
# 791 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3

      // Also used by specializations for char and wchar_t in src.
      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

#if __cplusplus < 201103L
    private:
#else
# 802 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
    protected:
#endif
# 804 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);

#if __cplusplus >= 201103L
      void
      swap(basic_streambuf& __sb)
      {
	std::swap(_M_in_beg, __sb._M_in_beg);
	std::swap(_M_in_cur, __sb._M_in_cur);
	std::swap(_M_in_end, __sb._M_in_end);
	std::swap(_M_out_beg, __sb._M_out_beg);
	std::swap(_M_out_cur, __sb._M_out_cur);
	std::swap(_M_out_end, __sb._M_out_end);
	std::swap(_M_buf_locale, __sb._M_buf_locale);
      }
#endif
# 822 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
    };

#if __cplusplus >= 201103L
  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;
#endif
# 834 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3

  // Explicit specialization declarations, defined in src/streambuf.cc.
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
			  basic_streambuf<char>* __sbout, bool& __ineof);
#ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
			  basic_streambuf<wchar_t>* __sbout, bool& __ineof);
#endif
# 846 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if 0 /* expanded by -frewrite-includes */
#include <bits/streambuf.tcc>
#endif /* expanded by -frewrite-includes */
# 850 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf.tcc" 1 3
// Stream buffer classes -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/streambuf.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{streambuf}
 */

//
// ISO C++ 14882: 27.5  Stream buffers
//

#ifndef _STREAMBUF_TCC
#define _STREAMBUF_TCC 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf.tcc" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
	{
	  const streamsize __buf_len = this->egptr() - this->gptr();
	  if (__buf_len)
	    {
	      const streamsize __remaining = __n - __ret;
	      const streamsize __len = std::min(__buf_len, __remaining);
	      traits_type::copy(__s, this->gptr(), __len);
	      __ret += __len;
	      __s += __len;
	      this->__safe_gbump(__len);
	    }

	  if (__ret < __n)
	    {
	      const int_type __c = this->uflow();
	      if (!traits_type::eq_int_type(__c, traits_type::eof()))
		{
		  traits_type::assign(*__s++, traits_type::to_char_type(__c));
		  ++__ret;
		}
	      else
		break;
	    }
	}
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
	{
	  const streamsize __buf_len = this->epptr() - this->pptr();
	  if (__buf_len)
	    {
	      const streamsize __remaining = __n - __ret;
	      const streamsize __len = std::min(__buf_len, __remaining);
	      traits_type::copy(this->pptr(), __s, __len);
	      __ret += __len;
	      __s += __len;
	      this->__safe_pbump(__len);
	    }

	  if (__ret < __n)
	    {
	      int_type __c = this->overflow(traits_type::to_int_type(*__s));
	      if (!traits_type::eq_int_type(__c, traits_type::eof()))
		{
		  ++__ret;
		  ++__s;
		}
	      else
		break;
	    }
	}
      return __ret;
    }

  // Conceivably, this could be used to implement buffer-to-buffer
  // copies, if this was ever desired in an un-ambiguous way by the
  // standard.
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
			  basic_streambuf<_CharT, _Traits>* __sbout,
			  bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
	{
	  __c = __sbout->sputc(_Traits::to_char_type(__c));
	  if (_Traits::eq_int_type(__c, _Traits::eof()))
	    {
	      __ineof = false;
	      break;
	    }
	  ++__ret;
	  __c = __sbin->snextc();
	}
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
		      basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
		      basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
			  basic_streambuf<char>*, bool&);

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
		      basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
			  basic_streambuf<wchar_t>*, bool&);
#endif
# 170 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf.tcc" 3
#endif
# 171 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf.tcc" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 176 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf.tcc" 3
# 851 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 2 3

#endif /* _GLIBCXX_STREAMBUF */
# 853 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/streambuf" 3
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/basic_ios.h>
#endif /* expanded by -frewrite-includes */
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 1 3
// Iostreams base classes -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_ios.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */

#ifndef _BASIC_IOS_H
#define _BASIC_IOS_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/localefwd.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/locale_classes.h>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/locale_facets.h>
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_facets.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

#ifndef _LOCALE_FACETS_H
#define _LOCALE_FACETS_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <cwctype>	// For wctype_t
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cwctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c wctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: <cwctype>
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3

#if _GLIBCXX_HAVE_WCTYPE_H

#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 10
// Work around glibc BZ 9694
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3
#endif
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3

#if 0 /* expanded by -frewrite-includes */
#include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 50 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
/* Copyright (C) 1996-2002,2005,2007-2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.25
 *	Wide character classification and mapping utilities  <wctype.h>
 */

#ifndef _WCTYPE_H

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 26 "/usr/include/wctype.h" 3 4
# 27 "/usr/include/wctype.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/wctype.h" 3 4
# 28 "/usr/include/wctype.h" 3 4

#ifndef __need_iswxxx
# define _WCTYPE_H	1

/* Get wint_t from <wchar.h>.  */
# define __need_wint_t
#if 0 /* expanded by -frewrite-includes */
# include <wchar.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */

#ifndef _WCHAR_H

#if !defined __need_mbstate_t && !defined __need_wint_t
# define _WCHAR_H 1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/wchar.h" 3 4
# 29 "/usr/include/wchar.h" 3 4
#endif
# 30 "/usr/include/wchar.h" 3 4

#ifdef _WCHAR_H
/* Get FILE definition.  */
# define __need___FILE
# if defined __USE_UNIX98 || defined __USE_XOPEN2K
#  define __need_FILE
# endif
# 37 "/usr/include/wchar.h" 3 4
#if 0 /* expanded by -frewrite-includes */
# include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/wchar.h" 3 4
# 38 "/usr/include/wchar.h" 3 4
/* Get va_list definition.  */
# define __need___va_list
#if 0 /* expanded by -frewrite-includes */
# include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/wchar.h" 3 4
# 41 "/usr/include/wchar.h" 3 4

#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/wchar.h" 3 4
# 43 "/usr/include/wchar.h" 3 4

/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
# define __need_size_t
# define __need_wchar_t
# define __need_NULL
#endif
# 49 "/usr/include/wchar.h" 3 4
#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__
# undef __need_wint_t
# define __need_wint_t
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 52 "/usr/include/wchar.h" 3 4
# 53 "/usr/include/wchar.h" 3 4

/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
   there.  So define it ourselves if it remains undefined.  */
# ifndef _WINT_T
/* Integral type unchanged by default argument promotions that can
   hold any value corresponding to members of the extended character
   set, as well as at least one value that does not correspond to any
   member of the extended character set.  */
#  define _WINT_T
typedef unsigned int wint_t;
# else
# 64 "/usr/include/wchar.h" 3 4
/* Work around problems with the <stddef.h> file which doesn't put
   wint_t in the std namespace.  */
#  if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES \
      && defined __WINT_TYPE__
__BEGIN_NAMESPACE_STD
typedef __WINT_TYPE__ wint_t;
__END_NAMESPACE_STD
#  endif
# 72 "/usr/include/wchar.h" 3 4
# endif
# 73 "/usr/include/wchar.h" 3 4

/* Tell the caller that we provide correct C++ prototypes.  */
# if defined __cplusplus && __GNUC_PREREQ (4, 4)
#  define __CORRECT_ISO_CPP_WCHAR_H_PROTO
# endif
# 78 "/usr/include/wchar.h" 3 4
#endif
# 79 "/usr/include/wchar.h" 3 4

#if (defined _WCHAR_H || defined __need_mbstate_t) && !defined __mbstate_t_defined
# define __mbstate_t_defined	1
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
# ifdef __WINT_TYPE__
    __WINT_TYPE__ __wch;
# else
# 91 "/usr/include/wchar.h" 3 4
    wint_t __wch;
# endif
# 93 "/usr/include/wchar.h" 3 4
    char __wchb[4];
  } __value;		/* Value so far.  */
} __mbstate_t;
#endif
# 97 "/usr/include/wchar.h" 3 4
#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
#ifdef _WCHAR_H

__BEGIN_NAMESPACE_C99
/* Public type.  */
typedef __mbstate_t mbstate_t;
__END_NAMESPACE_C99
#ifdef __USE_GNU
__USING_NAMESPACE_C99(mbstate_t)
#endif
# 111 "/usr/include/wchar.h" 3 4

#ifndef WCHAR_MIN
/* These constants might also be defined in <inttypes.h>.  */
# define WCHAR_MIN __WCHAR_MIN
# define WCHAR_MAX __WCHAR_MAX
#endif
# 117 "/usr/include/wchar.h" 3 4

#ifndef WEOF
# define WEOF (0xffffffffu)
#endif
# 121 "/usr/include/wchar.h" 3 4

/* For XPG4 compliance we have to define the stuff from <wctype.h> here
   as well.  */
#if defined __USE_XOPEN && !defined __USE_UNIX98
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 125 "/usr/include/wchar.h" 3 4
# 126 "/usr/include/wchar.h" 3 4
#endif
# 127 "/usr/include/wchar.h" 3 4


__BEGIN_DECLS

__BEGIN_NAMESPACE_STD
/* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  */
struct tm;
__END_NAMESPACE_STD
/* XXX We have to clean this up at some point.  Since tm is in the std
   namespace but wcsftime is in __c99 the type wouldn't be found
   without inserting it in the global namespace.  */
__USING_NAMESPACE_STD(tm)


__BEGIN_NAMESPACE_STD
/* Copy SRC to DEST.  */
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Copy no more than N wide-characters of SRC to DEST.  */
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Append SRC onto DEST.  */
extern wchar_t *wcscat (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Append no more than N wide-characters of SRC onto DEST.  */
extern wchar_t *wcsncat (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Compare S1 and S2.  */
extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     __THROW __attribute_pure__;
/* Compare N wide-characters of S1 and S2.  */
extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Compare S1 and S2, ignoring case.  */
extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
			size_t __n) __THROW;

/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 177 "/usr/include/wchar.h" 3 4
# 178 "/usr/include/wchar.h" 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			 __locale_t __loc) __THROW;

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			  size_t __n, __locale_t __loc) __THROW;
#endif
# 185 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  */
extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;
/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm (wchar_t *__restrict __s1,
		       __const wchar_t *__restrict __s2, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */

/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  */
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
		      __locale_t __loc) __THROW;

/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
			 size_t __n, __locale_t __loc) __THROW;

/* Duplicate S, returning an identical malloc'd string.  */
extern wchar_t *wcsdup (__const wchar_t *__s) __THROW __attribute_malloc__;
#endif
# 215 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Find the first occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
#else
# 224 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 227 "/usr/include/wchar.h" 3 4
/* Find the last occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
#else
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 237 "/usr/include/wchar.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  */
extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 245 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  */
extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     __THROW __attribute_pure__;
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  */
extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
/* Find the first occurrence in WCS of any character in ACCEPT.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
				       __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
#else
# 263 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
#endif
# 266 "/usr/include/wchar.h" 3 4
/* Find the first occurrence of NEEDLE in HAYSTACK.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
#else
# 274 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
#endif
# 277 "/usr/include/wchar.h" 3 4

/* Divide WCS into tokens separated by characters in DELIM.  */
extern wchar_t *wcstok (wchar_t *__restrict __s,
			__const wchar_t *__restrict __delim,
			wchar_t **__restrict __ptr) __THROW;

/* Return the number of wide characters in S.  */
extern size_t wcslen (__const wchar_t *__s) __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN
/* Another name for `wcsstr' from XPG4.  */
# ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
# else
# 296 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
# endif
# 299 "/usr/include/wchar.h" 3 4
#endif
# 300 "/usr/include/wchar.h" 3 4

#ifdef __USE_XOPEN2K8
/* Return the number of wide characters in S, but at most MAXLEN.  */
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     __THROW __attribute_pure__;
#endif
# 306 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Search N wide characters of S for C.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
				       size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
#else
# 317 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __attribute_pure__;
#endif
# 320 "/usr/include/wchar.h" 3 4

/* Compare N wide characters of S1 and S2.  */
extern int wmemcmp (__const wchar_t *__restrict __s1,
		    __const wchar_t *__restrict __s2, size_t __n)
     __THROW __attribute_pure__;

/* Copy N wide characters of SRC to DEST.  */
extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
			 __const wchar_t *__restrict __s2, size_t __n) __THROW;

/* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW;

/* Set N wide characters of S to C.  */
extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  */
extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
			  __const wchar_t *__restrict __s2, size_t __n)
     __THROW;
#endif
# 346 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Determine whether C constitutes a valid (one-byte) multibyte
   character.  */
extern wint_t btowc (int __c) __THROW;

/* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) __THROW;

/* Determine whether PS points to an object representing the initial
   state.  */
extern int mbsinit (__const mbstate_t *__ps) __THROW __attribute_pure__;

/* Write wide character representation of multibyte character pointed
   to by S to PWC.  */
extern size_t mbrtowc (wchar_t *__restrict __pwc,
		       __const char *__restrict __s, size_t __n,
		       mbstate_t *__p) __THROW;

/* Write multibyte representation of wide character WC to S.  */
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
		       mbstate_t *__restrict __ps) __THROW;

/* Return number of bytes in multibyte character pointed to by S.  */
extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
			mbstate_t *__restrict __ps) __THROW;
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
		      mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_EXTERN_INLINES
/* Define inline function as optimization.  */

/* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  */
extern wint_t __btowc_alias (int __c) __asm ("btowc");
__extern_inline wint_t
__NTH (btowc (int __c))
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
	  ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
__extern_inline int
__NTH (wctob (wint_t __wc))
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
	  ? (int) __wc : __wctob_alias (__wc)); }

__extern_inline size_t
__NTH (mbrlen (__const char *__restrict __s, size_t __n,
	       mbstate_t *__restrict __ps))
{ return (__ps != NULL
	  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL)); }
#endif
# 402 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Write wide character representation of multibyte character string
   SRC to DST.  */
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
			 __const char **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of wide character string
   SRC to DST.  */
extern size_t wcsrtombs (char *__restrict __dst,
			 __const wchar_t **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD


#ifdef	__USE_XOPEN2K8
/* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  */
extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
			  __const char **__restrict __src, size_t __nmc,
			  size_t __len, mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  */
extern size_t wcsnrtombs (char *__restrict __dst,
			  __const wchar_t **__restrict __src,
			  size_t __nwc, size_t __len,
			  mbstate_t *__restrict __ps) __THROW;
#endif	/* use POSIX 2008 */
# 432 "/usr/include/wchar.h" 3 4


/* The following functions are extensions found in X/Open CAE.  */
#ifdef __USE_XOPEN
/* Determine number of column positions required for C.  */
extern int wcwidth (wchar_t __c) __THROW;

/* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  */
extern int wcswidth (__const wchar_t *__s, size_t __n) __THROW;
#endif	/* Use X/Open.  */
# 443 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of the wide string NPTR to `double'
   representation.  */
extern double wcstod (__const wchar_t *__restrict __nptr,
		      wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float wcstof (__const wchar_t *__restrict __nptr,
		     wchar_t **__restrict __endptr) __THROW;
extern long double wcstold (__const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_C99
#endif /* C99 */
# 461 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of wide string NPTR to `long int'
   representation.  */
extern long int wcstol (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, int __base) __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  */
extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
				  wchar_t **__restrict __endptr, int __base)
     __THROW;
__END_NAMESPACE_STD

#if defined __USE_ISOC99 || (defined __GNUC__ && defined __USE_GNU)
__BEGIN_NAMESPACE_C99
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
					wchar_t **__restrict __endptr,
					int __base) __THROW;
__END_NAMESPACE_C99
#endif /* ISO C99 or GCC and GNU.  */
# 493 "/usr/include/wchar.h" 3 4

#if defined __GNUC__ && defined __USE_GNU
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
			     wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
				       wchar_t **__restrict __endptr,
				       int __base) __THROW;
#endif /* GCC and use GNU.  */
# 509 "/usr/include/wchar.h" 3 4

#ifdef __USE_GNU
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 524 "/usr/include/wchar.h" 3 4
# 525 "/usr/include/wchar.h" 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
			  wchar_t **__restrict __endptr, int __base,
			  __locale_t __loc) __THROW;

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
				    wchar_t **__restrict __endptr,
				    int __base, __locale_t __loc) __THROW;

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
				wchar_t **__restrict __endptr,
				int __base, __locale_t __loc) __THROW;

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
					  wchar_t **__restrict __endptr,
					  int __base, __locale_t __loc)
     __THROW;

extern double wcstod_l (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern float wcstof_l (__const wchar_t *__restrict __nptr,
		       wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr,
			      __locale_t __loc) __THROW;


/* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  */
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;
#endif	/* use GNU */
# 571 "/usr/include/wchar.h" 3 4


/* Wide character I/O functions.  */

#ifdef	__USE_XOPEN2K8
/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  */
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __THROW;
#endif
# 580 "/usr/include/wchar.h" 3 4

#if defined __USE_ISOC95 || defined __USE_UNIX98
__BEGIN_NAMESPACE_STD

/* Select orientation for stream.  */
extern int fwide (__FILE *__fp, int __mode) __THROW;


/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwprintf (__FILE *__restrict __stream,
		     __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wprintf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
/* Write formatted output of at most N characters to S.  */
extern int swprintf (wchar_t *__restrict __s, size_t __n,
		     __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwprintf (__FILE *__restrict __s,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwprintf (__const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
/* Write formatted output of at most N character to S from argument
   list ARG.  */
extern int vswprintf (wchar_t *__restrict __s, size_t __n,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;


/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwscanf (__FILE *__restrict __stream,
		    __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wscanf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
/* Read formatted input from S.  */
extern int swscanf (__const wchar_t *__restrict __s,
		    __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;

# if defined __USE_ISOC99 && !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_fwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
extern int __REDIRECT (wscanf, (__const wchar_t *__restrict __format, ...),
		       __isoc99_wscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
extern int __REDIRECT (swscanf, (__const wchar_t *__restrict __s,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_swscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
#  else
# 666 "/usr/include/wchar.h" 3 4
extern int __isoc99_fwscanf (__FILE *__restrict __stream,
			     __const wchar_t *__restrict __format, ...);
extern int __isoc99_wscanf (__const wchar_t *__restrict __format, ...);
extern int __isoc99_swscanf (__const wchar_t *__restrict __s,
			     __const wchar_t *__restrict __format, ...)
     __THROW;
#   define fwscanf __isoc99_fwscanf
#   define wscanf __isoc99_wscanf
#   define swscanf __isoc99_swscanf
#  endif
# 676 "/usr/include/wchar.h" 3 4
# endif
# 677 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_STD
#endif /* Use ISO C95, C99 and Unix98. */
# 680 "/usr/include/wchar.h" 3 4

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwscanf (__FILE *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwscanf (__const wchar_t *__restrict __format,
		    __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
/* Read formatted input from S into argument list ARG.  */
extern int vswscanf (__const wchar_t *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;

# if !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
extern int __REDIRECT (vfwscanf, (__FILE *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vfwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
extern int __REDIRECT (vwscanf, (__const wchar_t *__restrict __format,
				 __gnuc_va_list __arg), __isoc99_vwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
extern int __REDIRECT (vswscanf, (__const wchar_t *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vswscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
#  else
# 720 "/usr/include/wchar.h" 3 4
extern int __isoc99_vfwscanf (__FILE *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg);
extern int __isoc99_vwscanf (__const wchar_t *__restrict __format,
			     __gnuc_va_list __arg);
extern int __isoc99_vswscanf (__const wchar_t *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg) __THROW;
#   define vfwscanf __isoc99_vfwscanf
#   define vwscanf __isoc99_vwscanf
#   define vswscanf __isoc99_vswscanf
#  endif
# 732 "/usr/include/wchar.h" 3 4
# endif
# 733 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_C99
#endif /* Use ISO C99. */
# 736 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t getwchar (void);


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t putwchar (wchar_t __wc);


/* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
			__FILE *__restrict __stream);

/* Write a string to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int fputws (__const wchar_t *__restrict __ws,
		   __FILE *__restrict __stream);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
__END_NAMESPACE_STD


#ifdef __USE_GNU
/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);

/* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fgetwc_unlocked (__FILE *__stream);

/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);

/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);


/* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
				 __FILE *__restrict __stream);

/* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputws_unlocked (__const wchar_t *__restrict __ws,
			    __FILE *__restrict __stream);
#endif
# 847 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_C99
/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
			__const wchar_t *__restrict __format,
			__const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_C99

# ifdef __USE_GNU
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 859 "/usr/include/wchar.h" 3 4
# 860 "/usr/include/wchar.h" 3 4

/* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  */
extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
			  __const wchar_t *__restrict __format,
			  __const struct tm *__restrict __tp,
			  __locale_t __loc) __THROW;
# endif
# 868 "/usr/include/wchar.h" 3 4

/* The X/Open standard demands that most of the functions defined in
   the <wctype.h> header must also appear here.  This is probably
   because some X/Open members wrote their implementation before the
   ISO C standard was published and introduced the better solution.
   We have to provide these definitions for compliance reasons but we
   do this nonsense only if really necessary.  */
#if defined __USE_UNIX98 && !defined __USE_GNU
# define __need_iswxxx
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 877 "/usr/include/wchar.h" 3 4
# 878 "/usr/include/wchar.h" 3 4
#endif
# 879 "/usr/include/wchar.h" 3 4

/* Define some macros helping to catch buffer overflows.  */
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar2.h>
#endif /* expanded by -frewrite-includes */
# 882 "/usr/include/wchar.h" 3 4
# 883 "/usr/include/wchar.h" 3 4
#endif
# 884 "/usr/include/wchar.h" 3 4

#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 886 "/usr/include/wchar.h" 3 4
# 887 "/usr/include/wchar.h" 3 4
#endif
# 888 "/usr/include/wchar.h" 3 4

__END_DECLS

#endif	/* _WCHAR_H defined */
# 892 "/usr/include/wchar.h" 3 4

#endif /* wchar.h  */
# 894 "/usr/include/wchar.h" 3 4

/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 35 "/usr/include/wctype.h" 2 3 4

/* Constant expression of type `wint_t' whose value does not correspond
   to any member of the extended character set.  */
# ifndef WEOF
#  define WEOF (0xffffffffu)
# endif
# 41 "/usr/include/wctype.h" 3 4
#endif
# 42 "/usr/include/wctype.h" 3 4
#undef __need_iswxxx


/* The following part is also used in the <wcsmbs.h> header when compiled
   in the Unix98 compatibility mode.  */
#ifndef __iswxxx_defined
# define __iswxxx_defined	1

__BEGIN_NAMESPACE_C99
/* Scalar type that can hold values which represent locale-specific
   character classifications.  */
typedef unsigned long int wctype_t;
__END_NAMESPACE_C99

# ifndef _ISwbit
/* The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */

#if 0 /* expanded by -frewrite-includes */
#  include <endian.h>
#endif /* expanded by -frewrite-includes */
# 61 "/usr/include/wctype.h" 3 4
# 62 "/usr/include/wctype.h" 3 4
#  if __BYTE_ORDER == __BIG_ENDIAN
#   define _ISwbit(bit)	(1 << (bit))
#  else /* __BYTE_ORDER == __LITTLE_ENDIAN */
# 65 "/usr/include/wctype.h" 3 4
#   define _ISwbit(bit)	\
	((bit) < 8 ? (int) ((1UL << (bit)) << 24)			      \
	 : ((bit) < 16 ? (int) ((1UL << (bit)) << 8)			      \
	    : ((bit) < 24 ? (int) ((1UL << (bit)) >> 8)			      \
	       : (int) ((1UL << (bit)) >> 24))))
#  endif
# 71 "/usr/include/wctype.h" 3 4

enum
{
  __ISwupper = 0,			/* UPPERCASE.  */
  __ISwlower = 1,			/* lowercase.  */
  __ISwalpha = 2,			/* Alphabetic.  */
  __ISwdigit = 3,			/* Numeric.  */
  __ISwxdigit = 4,			/* Hexadecimal numeric.  */
  __ISwspace = 5,			/* Whitespace.  */
  __ISwprint = 6,			/* Printing.  */
  __ISwgraph = 7,			/* Graphical.  */
  __ISwblank = 8,			/* Blank (usually SPC and TAB).  */
  __ISwcntrl = 9,			/* Control character.  */
  __ISwpunct = 10,			/* Punctuation.  */
  __ISwalnum = 11,			/* Alphanumeric.  */

  _ISwupper = _ISwbit (__ISwupper),	/* UPPERCASE.  */
  _ISwlower = _ISwbit (__ISwlower),	/* lowercase.  */
  _ISwalpha = _ISwbit (__ISwalpha),	/* Alphabetic.  */
  _ISwdigit = _ISwbit (__ISwdigit),	/* Numeric.  */
  _ISwxdigit = _ISwbit (__ISwxdigit),	/* Hexadecimal numeric.  */
  _ISwspace = _ISwbit (__ISwspace),	/* Whitespace.  */
  _ISwprint = _ISwbit (__ISwprint),	/* Printing.  */
  _ISwgraph = _ISwbit (__ISwgraph),	/* Graphical.  */
  _ISwblank = _ISwbit (__ISwblank),	/* Blank (usually SPC and TAB).  */
  _ISwcntrl = _ISwbit (__ISwcntrl),	/* Control character.  */
  _ISwpunct = _ISwbit (__ISwpunct),	/* Punctuation.  */
  _ISwalnum = _ISwbit (__ISwalnum)	/* Alphanumeric.  */
};
# endif /* Not _ISwbit  */
# 101 "/usr/include/wctype.h" 3 4


__BEGIN_DECLS

__BEGIN_NAMESPACE_C99
/*
 * Wide-character classification functions: 7.15.2.1.
 */

/* Test for any wide character for which `iswalpha' or `iswdigit' is
   true.  */
extern int iswalnum (wint_t __wc) __THROW;

/* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  */
extern int iswalpha (wint_t __wc) __THROW;

/* Test for any control wide character.  */
extern int iswcntrl (wint_t __wc) __THROW;

/* Test for any wide character that corresponds to a decimal-digit
   character.  */
extern int iswdigit (wint_t __wc) __THROW;

/* Test for any wide character for which `iswprint' is true and
   `iswspace' is false.  */
extern int iswgraph (wint_t __wc) __THROW;

/* Test for any wide character that corresponds to a lowercase letter
   or is one of a locale-specific set of wide characters for which
   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswlower (wint_t __wc) __THROW;

/* Test for any printing wide character.  */
extern int iswprint (wint_t __wc) __THROW;

/* Test for any printing wide character that is one of a
   locale-specific et of wide characters for which neither `iswspace'
   nor `iswalnum' is true.  */
extern int iswpunct (wint_t __wc) __THROW;

/* Test for any wide character that corresponds to a locale-specific
   set of wide characters for which none of `iswalnum', `iswgraph', or
   `iswpunct' is true.  */
extern int iswspace (wint_t __wc) __THROW;

/* Test for any wide character that corresponds to an uppercase letter
   or is one of a locale-specific set of wide character for which none
   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswupper (wint_t __wc) __THROW;

/* Test for any wide character that corresponds to a hexadecimal-digit
   character equivalent to that performed be the functions described
   in the previous subclause.  */
extern int iswxdigit (wint_t __wc) __THROW;

/* Test for any wide character that corresponds to a standard blank
   wide character or a locale-specific set of wide characters for
   which `iswalnum' is false.  */
# ifdef __USE_ISOC99
extern int iswblank (wint_t __wc) __THROW;
# endif
# 165 "/usr/include/wctype.h" 3 4

/*
 * Extensible wide-character classification functions: 7.15.2.2.
 */

/* Construct value that describes a class of wide characters identified
   by the string argument PROPERTY.  */
extern wctype_t wctype (__const char *__property) __THROW;

/* Determine whether the wide-character WC has the property described by
   DESC.  */
extern int iswctype (wint_t __wc, wctype_t __desc) __THROW;
__END_NAMESPACE_C99


/*
 * Wide-character case-mapping functions: 7.15.3.1.
 */

__BEGIN_NAMESPACE_C99
/* Scalar type that can hold values which represent locale-specific
   character mappings.  */
typedef __const __int32_t *wctrans_t;
__END_NAMESPACE_C99
#ifdef __USE_GNU
__USING_NAMESPACE_C99(wctrans_t)
#endif
# 192 "/usr/include/wctype.h" 3 4

__BEGIN_NAMESPACE_C99
/* Converts an uppercase letter to the corresponding lowercase letter.  */
extern wint_t towlower (wint_t __wc) __THROW;

/* Converts an lowercase letter to the corresponding uppercase letter.  */
extern wint_t towupper (wint_t __wc) __THROW;
__END_NAMESPACE_C99

__END_DECLS

#endif	/* need iswxxx.  */
# 204 "/usr/include/wctype.h" 3 4


/* The remaining definitions and declarations must not appear in the
   <wchar.h> header.  */
#ifdef _WCTYPE_H

/*
 * Extensible wide-character mapping functions: 7.15.3.2.
 */

__BEGIN_DECLS

__BEGIN_NAMESPACE_C99
/* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  */
extern wctrans_t wctrans (__const char *__property) __THROW;

/* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans (wint_t __wc, wctrans_t __desc) __THROW;
__END_NAMESPACE_C99

# ifdef __USE_XOPEN2K8
/* Declare the interface to extended locale model.  */
#if 0 /* expanded by -frewrite-includes */
#  include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 227 "/usr/include/wctype.h" 3 4
# 228 "/usr/include/wctype.h" 3 4

/* Test for any wide character for which `iswalpha' or `iswdigit' is
   true.  */
extern int iswalnum_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  */
extern int iswalpha_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any control wide character.  */
extern int iswcntrl_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character that corresponds to a decimal-digit
   character.  */
extern int iswdigit_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character for which `iswprint' is true and
   `iswspace' is false.  */
extern int iswgraph_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character that corresponds to a lowercase letter
   or is one of a locale-specific set of wide characters for which
   none of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswlower_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any printing wide character.  */
extern int iswprint_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any printing wide character that is one of a
   locale-specific et of wide characters for which neither `iswspace'
   nor `iswalnum' is true.  */
extern int iswpunct_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character that corresponds to a locale-specific
   set of wide characters for which none of `iswalnum', `iswgraph', or
   `iswpunct' is true.  */
extern int iswspace_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character that corresponds to an uppercase letter
   or is one of a locale-specific set of wide character for which none
   of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true.  */
extern int iswupper_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character that corresponds to a hexadecimal-digit
   character equivalent to that performed be the functions described
   in the previous subclause.  */
extern int iswxdigit_l (wint_t __wc, __locale_t __locale) __THROW;

/* Test for any wide character that corresponds to a standard blank
   wide character or a locale-specific set of wide characters for
   which `iswalnum' is false.  */
extern int iswblank_l (wint_t __wc, __locale_t __locale) __THROW;

/* Construct value that describes a class of wide characters identified
   by the string argument PROPERTY.  */
extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     __THROW;

/* Determine whether the wide-character WC has the property described by
   DESC.  */
extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     __THROW;


/*
 * Wide-character case-mapping functions.
 */

/* Converts an uppercase letter to the corresponding lowercase letter.  */
extern wint_t towlower_l (wint_t __wc, __locale_t __locale) __THROW;

/* Converts an lowercase letter to the corresponding uppercase letter.  */
extern wint_t towupper_l (wint_t __wc, __locale_t __locale) __THROW;

/* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  */
extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     __THROW;

/* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
			   __locale_t __locale) __THROW;

# endif /* Use POSIX 2008.  */
# 314 "/usr/include/wctype.h" 3 4

__END_DECLS

#endif	/* __WCTYPE_H defined.  */
# 318 "/usr/include/wctype.h" 3 4

#endif /* wctype.h  */
# 320 "/usr/include/wctype.h" 3 4
# 51 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 2 3
#endif // _GLIBCXX_HAVE_WCTYPE_H
# 52 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3

#ifndef _GLIBCXX_CWCTYPE
#define _GLIBCXX_CWCTYPE 1

// Get rid of those macros defined in <wctype.h> in lieu of real functions.
#undef iswalnum
#undef iswalpha
#if _GLIBCXX_HAVE_ISWBLANK
# undef iswblank
#endif
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3
#undef iswcntrl
#undef iswctype
#undef iswdigit
#undef iswgraph
#undef iswlower
#undef iswprint
#undef iswpunct
#undef iswspace
#undef iswupper
#undef iswxdigit
#undef towctrans
#undef towlower
#undef towupper
#undef wctrans
#undef wctype

#if _GLIBCXX_USE_WCHAR_T

namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;
#if _GLIBCXX_HAVE_ISWBLANK
  using ::iswblank;
#endif
# 91 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
} // namespace

#endif //_GLIBCXX_USE_WCHAR_T
# 109 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3

#endif // _GLIBCXX_CWCTYPE
# 111 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cwctype" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <cctype>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cctype
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c ctype.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: <ccytpe>
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
#if 0 /* expanded by -frewrite-includes */
#include <ctype.h>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3

#ifndef _GLIBCXX_CCTYPE
#define _GLIBCXX_CCTYPE 1

// Get rid of those macros defined in <ctype.h> in lieu of real functions.
#undef isalnum
#undef isalpha
#undef iscntrl
#undef isdigit
#undef isgraph
#undef islower
#undef isprint
#undef ispunct
#undef isspace
#undef isupper
#undef isxdigit
#undef tolower
#undef toupper

namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
} // namespace std

#if __cplusplus >= 201103L

#ifdef _GLIBCXX_USE_C99_CTYPE_TR1

#undef isblank

namespace std
{
  using ::isblank;
} // namespace std

#endif // _GLIBCXX_USE_C99_CTYPE_TR1
# 91 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3

#endif // C++11
# 93 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3

#endif
# 95 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cctype" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/ctype_base.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/ctype_base.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ctype_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

// Information as gleaned from /usr/include/ctype.h

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /// @brief  Base class for ctype.
  struct ctype_base
  {
    // Non-standard typedefs.
    typedef const int* 		__to_type;

    // NB: Offsets into ctype<char>::_M_table force a particular size
    // on the mask type. Because of this, we don't use an enum.
    typedef unsigned short 	mask;
    static const mask upper    	= _ISupper;
    static const mask lower 	= _ISlower;
    static const mask alpha 	= _ISalpha;
    static const mask digit 	= _ISdigit;
    static const mask xdigit 	= _ISxdigit;
    static const mask space 	= _ISspace;
    static const mask print 	= _ISprint;
    static const mask graph 	= _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl 	= _IScntrl;
    static const mask punct 	= _ISpunct;
    static const mask alnum 	= _ISalpha | _ISdigit;
#if __cplusplus >= 201103L
    static const mask blank	= _ISblank;
#endif
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/ctype_base.h" 3
  };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <iosfwd>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/ios_base.h>  // For ios_base, ios_base::iostate
#endif /* expanded by -frewrite-includes */
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <streambuf>
#endif /* expanded by -frewrite-includes */
# 44 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/type_traits.h>
#endif /* expanded by -frewrite-includes */
# 46 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/numeric_traits.h>
#endif /* expanded by -frewrite-includes */
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/streambuf_iterator.h>
#endif /* expanded by -frewrite-includes */
# 48 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 1 3
// Streambuf iterators

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/streambuf_iterator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */

#ifndef _STREAMBUF_ITERATOR_H
#define _STREAMBUF_ITERATOR_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <streambuf>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <debug/debug.h>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION
     
  /**
   * @addtogroup iterators
   * @{
   */

  // 24.5.3 Template class istreambuf_iterator
  /// Provides input iterator semantics for streambufs.
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,
#if __cplusplus >= 201103L
    // LWG 445.
		      _CharT>
#else
# 57 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3
		      _CharT&>
#endif
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT					char_type;
      typedef _Traits					traits_type;
      typedef typename _Traits::int_type		int_type;
      typedef basic_streambuf<_CharT, _Traits>		streambuf_type;
      typedef basic_istream<_CharT, _Traits>		istream_type;
      //@}

      template<typename _CharT2>
	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
		                    ostreambuf_iterator<_CharT2> >::__type
	copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
	     ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, 
					       _CharT2*>::__type
	__copy_move_a2(istreambuf_iterator<_CharT2>,
		       istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
			            istreambuf_iterator<_CharT2> >::__type
	find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
	     const _CharT2&);

    private:
      // 24.5.3 istreambuf_iterator
      // p 1
      // If the end of stream is reached (streambuf_type::sgetc()
      // returns traits_type::eof()), the iterator becomes equal to
      // the "end of stream" iterator value.
      // NB: This implementation assumes the "end of stream" value
      // is EOF, or -1.
      mutable streambuf_type*	_M_sbuf;
      mutable int_type		_M_c;

    public:
      ///  Construct end of input stream iterator.
      _GLIBCXX_CONSTEXPR istreambuf_iterator() _GLIBCXX_USE_NOEXCEPT
      : _M_sbuf(0), _M_c(traits_type::eof()) { }

#if __cplusplus >= 201103L
      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;
#endif
# 110 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3

      ///  Construct start of input stream iterator.
      istreambuf_iterator(istream_type& __s) _GLIBCXX_USE_NOEXCEPT
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }

      ///  Construct start of streambuf iterator.
      istreambuf_iterator(streambuf_type* __s) _GLIBCXX_USE_NOEXCEPT
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }

      ///  Return the current character pointed to by iterator.  This returns
      ///  streambuf.sgetc().  It cannot be assigned.  NB: The result of
      ///  operator*() on an end of stream is undefined.
      char_type
      operator*() const
      {
#ifdef _GLIBCXX_DEBUG_PEDANTIC
	// Dereferencing a past-the-end istreambuf_iterator is a
	// libstdc++ extension
	__glibcxx_requires_cond(!_M_at_eof(),
				_M_message(__gnu_debug::__msg_deref_istreambuf)
				._M_iterator(*this));
#endif
# 132 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3
	return traits_type::to_char_type(_M_get());
      }

      /// Advance the iterator.  Calls streambuf.sbumpc().
      istreambuf_iterator&
      operator++()
      {
	__glibcxx_requires_cond(!_M_at_eof(),
				_M_message(__gnu_debug::__msg_inc_istreambuf)
				._M_iterator(*this));
	if (_M_sbuf)
	  {
	    _M_sbuf->sbumpc();
	    _M_c = traits_type::eof();
	  }
	return *this;
      }

      /// Advance the iterator.  Calls streambuf.sbumpc().
      istreambuf_iterator
      operator++(int)
      {
	__glibcxx_requires_cond(!_M_at_eof(),
				_M_message(__gnu_debug::__msg_inc_istreambuf)
				._M_iterator(*this));

	istreambuf_iterator __old = *this;
	if (_M_sbuf)
	  {
	    __old._M_c = _M_sbuf->sbumpc();
	    _M_c = traits_type::eof();
	  }
	return __old;
      }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 110 istreambuf_iterator::equal not const
      // NB: there is also number 111 (NAD, Future) pending on this function.
      /// Return true both iterators are end or both are not end.
      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
	const int_type __eof = traits_type::eof();
	int_type __ret = __eof;
	if (_M_sbuf)
	  {
	    if (!traits_type::eq_int_type(_M_c, __eof))
	      __ret = _M_c;
	    else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
					       __eof))
	      _M_c = __ret;
	    else
	      _M_sbuf = 0;
	  }
	return __ret;
      }

      bool
      _M_at_eof() const
      {
	const int_type __eof = traits_type::eof();
	return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
	       const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
	       const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }

  /// Provides output iterator semantics for streambufs.
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT                           char_type;
      typedef _Traits                          traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits>   ostream_type;
      //@}

      template<typename _CharT2>
	friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
		                    ostreambuf_iterator<_CharT2> >::__type
	copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
	     ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type*	_M_sbuf;
      bool		_M_failed;

    public:
      ///  Construct output iterator from ostream.
      ostreambuf_iterator(ostream_type& __s) _GLIBCXX_USE_NOEXCEPT
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }

      ///  Construct output iterator from streambuf.
      ostreambuf_iterator(streambuf_type* __s) _GLIBCXX_USE_NOEXCEPT
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }

      ///  Write character to streambuf.  Calls streambuf.sputc().
      ostreambuf_iterator&
      operator=(_CharT __c)
      {
	if (!_M_failed &&
	    _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
	  _M_failed = true;
	return *this;
      }

      /// Return *this.
      ostreambuf_iterator&
      operator*()
      { return *this; }

      /// Return *this.
      ostreambuf_iterator&
      operator++(int)
      { return *this; }

      /// Return *this.
      ostreambuf_iterator&
      operator++()
      { return *this; }

      /// Return true if previous operator=() failed.
      bool
      failed() const _GLIBCXX_USE_NOEXCEPT
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
	if (__builtin_expect(!_M_failed, true)
	    && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
				false))
	  _M_failed = true;
	return *this;
      }
    };

  // Overloads for streambuf iterators.
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
    	                 	    ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
	 istreambuf_iterator<_CharT> __last,
	 ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
	{
	  bool __ineof;
	  __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
	  if (!__ineof)
	    __result._M_failed = true;
	}
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
    				    ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
		   ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
	__result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
				    ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
		   ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
	__result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
    				    _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
		   istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT>                  __is_iterator_type;
      typedef typename __is_iterator_type::traits_type     traits_type;
      typedef typename __is_iterator_type::streambuf_type  streambuf_type;
      typedef typename traits_type::int_type               int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
	{
	  streambuf_type* __sb = __first._M_sbuf;
	  int_type __c = __sb->sgetc();
	  while (!traits_type::eq_int_type(__c, traits_type::eof()))
	    {
	      const streamsize __n = __sb->egptr() - __sb->gptr();
	      if (__n > 1)
		{
		  traits_type::copy(__result, __sb->gptr(), __n);
		  __sb->__safe_gbump(__n);
		  __result += __n;
		  __c = __sb->underflow();
		}
	      else
		{
		  *__result++ = traits_type::to_char_type(__c);
		  __c = __sb->snextc();
		}
	    }
	}
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
		  		    istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
	 istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT>                  __is_iterator_type;
      typedef typename __is_iterator_type::traits_type     traits_type;
      typedef typename __is_iterator_type::streambuf_type  streambuf_type;
      typedef typename traits_type::int_type               int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
	{
	  const int_type __ival = traits_type::to_int_type(__val);
	  streambuf_type* __sb = __first._M_sbuf;
	  int_type __c = __sb->sgetc();
	  while (!traits_type::eq_int_type(__c, traits_type::eof())
		 && !traits_type::eq_int_type(__c, __ival))
	    {
	      streamsize __n = __sb->egptr() - __sb->gptr();
	      if (__n > 1)
		{
		  const _CharT* __p = traits_type::find(__sb->gptr(),
							__n, __val);
		  if (__p)
		    __n = __p - __sb->gptr();
		  __sb->__safe_gbump(__n);
		  __c = __sb->sgetc();
		}
	      else
		__c = __sb->snextc();
	    }

	  if (!traits_type::eq_int_type(__c, traits_type::eof()))
	    __first._M_c = __c;
	  else
	    __first._M_sbuf = 0;
	}
      return __first;
    }

// @} group iterators

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 413 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/streambuf_iterator.h" 3
# 49 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // NB: Don't instantiate required wchar_t facets if no wchar_t support.
#ifdef _GLIBCXX_USE_WCHAR_T
# define  _GLIBCXX_NUM_FACETS 28
# define  _GLIBCXX_NUM_CXX11_FACETS 16
#else
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# define  _GLIBCXX_NUM_FACETS 14
# define  _GLIBCXX_NUM_CXX11_FACETS 8
#endif
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
#ifdef _GLIBCXX_USE_C99_STDINT_TR1
# define _GLIBCXX_NUM_UNICODE_FACETS 2
#else
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# define _GLIBCXX_NUM_UNICODE_FACETS 0
#endif
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

  // Convert string to numeric value of type _Tp and store results.
  // NB: This is specialized for all required types, there is no
  // generic definition.
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
		   const __c_locale&) throw();

  // Explicit specializations for required types.
  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
		   const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
		   const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
		   const __c_locale&) throw();

  // NB: __pad is a struct, rather than a function, so it can be
  // partially-specialized.
  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
	     const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };

  // Used by both numeric and monetary facets.
  // Inserts "group separator" characters into an array of characters.
  // It's recursive, one iteration per group.  It moves the characters
  // in the buffer this way: "xxxx12345" -> "12,345xxx".  Call this
  // only with __gsize != 0.
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
		   const char* __gbeg, size_t __gsize,
		   const _CharT* __first, const _CharT* __last);

  // This template permits specializing facet output code for
  // ostreambuf_iterator.  For ostreambuf_iterator, sputn is
  // significantly more efficient than incrementing iterators.
  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }

  // This is the unspecialized form of the template.
  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
	*__s = __ws[__j];
      return __s;
    }


  // 22.2.1.1  Template class ctype
  // Include host and configuration specific ctype enums for ctype_base.

  /**
   *  @brief  Common base for ctype facet
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abstract stubs for the protected virtual
   *  functions.
  */
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:
      // Types:
      /// Typedef for the template parameter
      typedef _CharT char_type;

      /**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a __c and compares it to
       *  mask @a __m.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param __c  The char_type to compare the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      */
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the char array.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      */
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }

      /**
       *  @brief  Find char_type matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is true.  It does so by returning
       *  ctype<char_type>::do_scan_is().
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to matching char_type if found, else @a __hi.
      */
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }

      /**
       *  @brief  Find char_type not matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is false.  It does so by returning
       *  ctype<char_type>::do_scan_not().
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to non-matching char if found, else @a __hi.
      */
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }

      /**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.  It does
       *  so by returning ctype<char_type>::do_toupper().
       *
       *  @param __c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a __c.
      */
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char_type in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_toupper(lo, hi).
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }

      /**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the argument to lowercase if possible.  If
       *  not possible (for example, '2'), returns the argument.  It does so
       *  by returning ctype<char_type>::do_tolower(c).
       *
       *  @param __c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a __c.
      */
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char_type in the range [__lo,__hi) to
       *  lowercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_tolower(__lo, __hi).
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }

      /**
       *  @brief  Widen char to char_type
       *
       *  This function converts the char argument to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted char_type.
      */
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }

      /**
       *  @brief  Widen array to char_type
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }

      /**
       *  @brief  Narrow char_type to char
       *
       *  This function converts the char_type to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  It does so by returning
       *  ctype<char_type>::do_narrow(__c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char_type to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }

      /**
       *  @brief  Narrow array to char array
       *
       *  This function converts each char_type in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char_type in the input that cannot be
       *  converted, @a dfault is used instead.  It does so by returning
       *  ctype<char_type>::do_narrow(__lo, __hi, __dfault, __to).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
	      char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }

      /**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __c  The char_type to find the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      */
      virtual bool
      do_is(mask __m, char_type __c) const = 0;

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
	    mask* __vec) const = 0;

      /**
       *  @brief  Find char_type matching mask
       *
       *  This function searches for and returns the first char_type c in
       *  [__lo,__hi) for which is(__m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching char_type if found, else @a __hi.
      */
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
		 const char_type* __hi) const = 0;

      /**
       *  @brief  Find char_type not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  char_type c of [lo,hi) for which is(m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char_type if found, else @a __hi.
      */
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
		  const char_type* __hi) const = 0;

      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char_type argument to uppercase
       *  if possible.  If not possible (for example, '2'), returns the
       *  argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a __c.
      */
      virtual char_type
      do_toupper(char_type __c) const = 0;

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char_type in the range [__lo,__hi)
       *  to uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;

      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a __c.
      */
      virtual char_type
      do_tolower(char_type __c) const = 0;

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char_type in the range [__lo,__hi)
       *  to lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;

      /**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted char_type
      */
      virtual char_type
      do_widen(char __c) const = 0;

      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;

      /**
       *  @brief  Narrow char_type to char
       *
       *  This virtual function converts the argument to char using the
       *  simplest reasonable transformation.  If the conversion fails, dfault
       *  is returned instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char_type to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;

      /**
       *  @brief  Narrow char_type array to char
       *
       *  This virtual function converts each char_type in the range
       *  [__lo,__hi) to char using the simplest reasonable
       *  transformation and writes the results to the destination
       *  array.  For any element in the input that cannot be
       *  converted, @a __dfault is used instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
		char __dfault, char* __to) const = 0;
    };

  /**
   *  @brief  Primary class template ctype facet.
   *  @ingroup locales
   *
   *  This template class defines classification and conversion functions for
   *  character sets.  It wraps cctype functionality.  Ctype gets used by
   *  streams for many I/O operations.
   *
   *  This template provides the protected virtual functions the developer
   *  will have to replace in a derived class or specialization to make a
   *  working facet.  The public functions that access them are defined in
   *  __ctype_abstract_base, to allow for implementation flexibility.  See
   *  ctype<wchar_t> for an example.  The functions are documented in
   *  __ctype_abstract_base.
   *
   *  Note: implementations are provided for all the protected virtual
   *  functions, but will likely not be useful.
  */
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:
      // Types:
      typedef _CharT			char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;

      /// The facet id for ctype<char_type>
      static locale::id			id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
		  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
		char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;

  /**
   *  @brief  The ctype<char> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for
   *  the char type.  It gets used by char streams for many I/O
   *  operations.  The char specialization provides a number of
   *  optimizations as well.
  */
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:
      // Types:
      /// Typedef for the template parameter char.
      typedef char		char_type;

    protected:
      // Data Members:
      __c_locale		_M_c_locale_ctype;
      bool			_M_del;
      __to_type			_M_toupper;
      __to_type			_M_tolower;
      const mask*		_M_table;
      mutable char		_M_widen_ok;
      mutable char		_M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char		_M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char		_M_narrow_ok;	// 0 uninitialized, 1 init,
						// 2 memcpy can't be used

    public:
      /// The facet id for ctype<char>
      static locale::id        id;
      /// The size of the mask table.  It is SCHAR_MAX + 1.
      static const size_t      table_size = 1 + static_cast<unsigned char>(-1);

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __table If non-zero, table is used as the per-char mask.
       *               Else classic_table() is used.
       *  @param __del   If true, passes ownership of table to this facet.
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);

      /**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param __cloc  Handle to C locale data.
       *  @param __table If non-zero, table is used as the per-char mask.
       *  @param __del   If true, passes ownership of table to this facet.
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
	    size_t __refs = 0);

      /**
       *  @brief  Test char classification.
       *
       *  This function compares the mask table[c] to @a __m.
       *
       *  @param __c  The char to compare the mask of.
       *  @param __m  The mask to compare against.
       *  @return  True if __m & table[__c] is true, false otherwise.
      */
      inline bool
      is(mask __m, char __c) const;

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char in the range [lo, hi) and
       *  successively writes it to vec.  vec must have as many elements as
       *  the char array.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      */
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;

      /**
       *  @brief  Find char matching a mask
       *
       *  This function searches for and returns the first char in [lo,hi) for
       *  which is(m,char) is true.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching char if found, else @a __hi.
      */
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;

      /**
       *  @brief  Find char not matching a mask
       *
       *  This function searches for and returns a pointer to the first char
       *  in [__lo,__hi) for which is(m,char) is false.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char if found, else @a __hi.
      */
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;

      /**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the char argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  toupper() acts as if it returns ctype<char>::do_toupper(c).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The uppercase char if convertible, else @a __c.
      */
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char in the range [__lo,__hi) to uppercase
       *  if possible.  Other chars remain untouched.
       *
       *  toupper() acts as if it returns ctype<char>:: do_toupper(__lo, __hi).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }

      /**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the char argument to lowercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  tolower() acts as if it returns ctype<char>::do_tolower(__c).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The lowercase char if convertible, else @a __c.
      */
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char in the range [lo,hi) to lowercase
       *  if possible.  Other chars remain untouched.
       *
       *  tolower() acts as if it returns ctype<char>:: do_tolower(__lo, __hi).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }

      /**
       *  @brief  Widen char
       *
       *  This function converts the char to char_type using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted character.
      */
      char_type
      widen(char __c) const
      {
	if (_M_widen_ok)
	  return _M_widen[static_cast<unsigned char>(__c)];
	this->_M_widen_init();
	return this->do_widen(__c);
      }

      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
	if (_M_widen_ok == 1)
	  {
	    __builtin_memcpy(__to, __lo, __hi - __lo);
	    return __hi;
	  }
	if (!_M_widen_ok)
	  _M_widen_init();
	return this->do_widen(__lo, __hi, __to);
      }

      /**
       *  @brief  Narrow char
       *
       *  This function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c
       *  will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(c).
       *  do_narrow() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted character.
      */
      char
      narrow(char_type __c, char __dfault) const
      {
	if (_M_narrow[static_cast<unsigned char>(__c)])
	  return _M_narrow[static_cast<unsigned char>(__c)];
	const char __t = do_narrow(__c, __dfault);
	if (__t != __dfault)
	  _M_narrow[static_cast<unsigned char>(__c)] = __t;
	return __t;
      }

      /**
       *  @brief  Narrow char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char in the input that cannot be
       *  converted, @a dfault is used instead.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(lo, hi,
       *  dfault, to).  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
	     char __dfault, char* __to) const
      {
	if (__builtin_expect(_M_narrow_ok == 1, true))
	  {
	    __builtin_memcpy(__to, __lo, __hi - __lo);
	    return __hi;
	  }
	if (!_M_narrow_ok)
	  _M_narrow_init();
	return this->do_narrow(__lo, __hi, __dfault, __to);
      }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 695. ctype<char>::classic_table() not accessible.
      /// Returns a pointer to the mask table provided to the constructor, or
      /// the default from classic_table() if none was provided.
      const mask*
      table() const throw()
      { return _M_table; }

      /// Returns a pointer to the C locale mask table.
      static const mask*
      classic_table() throw();
    protected:

      /**
       *  @brief  Destructor.
       *
       *  This function deletes table() if @a del was true in the
       *  constructor.
      */
      virtual
      ~ctype();

      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The uppercase char if convertible, else @a __c.
      */
      virtual char_type
      do_toupper(char_type __c) const;

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  uppercase if possible.  Other chars remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the char argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The lowercase char if convertible, else @a __c.
      */
      virtual char_type
      do_tolower(char_type __c) const;

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  lowercase if possible.  Other chars remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted character.
      */
      virtual char_type
      do_widen(char __c) const
      { return __c; }

      /**
       *  @brief  Widen char array
       *
       *  This function converts each char in the range [lo,hi) to char using
       *  the simplest reasonable transformation.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
	__builtin_memcpy(__to, __lo, __hi - __lo);
	return __hi;
      }

      /**
       *  @brief  Narrow char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c will be
       *  returned unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }

      /**
       *  @brief  Narrow char array to char array
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any char in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
		char __dfault, char* __to) const
      {
	__builtin_memcpy(__to, __lo, __hi - __lo);
	return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };

#ifdef _GLIBCXX_USE_WCHAR_T
  /**
   *  @brief  The ctype<wchar_t> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for the
   *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.
   *  The wchar_t specialization provides a number of optimizations as well.
   *
   *  ctype<wchar_t> inherits its public methods from
   *  __ctype_abstract_base<wchar_t>.
  */
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:
      // Types:
      /// Typedef for the template parameter wchar_t.
      typedef wchar_t		char_type;
      typedef wctype_t		__wmask_type;

    protected:
      __c_locale		_M_c_locale_ctype;

      // Pre-computed narrowed and widened chars.
      bool                      _M_narrow_ok;
      char                      _M_narrow[128];
      wint_t                    _M_widen[1 + static_cast<unsigned char>(-1)];

      // Pre-computed elements for do_is.
      mask                      _M_bit[16];
      __wmask_type              _M_wmask[16];

    public:
      // Data Members:
      /// The facet id for ctype<wchar_t>
      static locale::id		id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      ctype(size_t __refs = 0);

      /**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param __cloc  Handle to C locale data.
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();

      /// Destructor
      virtual
      ~ctype();

      /**
       *  @brief  Test wchar_t classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __c  The wchar_t to find the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      */
      virtual bool
      do_is(mask __m, char_type __c) const;

      /**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each wchar_t in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      /**
       *  @brief  Find wchar_t matching mask
       *
       *  This function searches for and returns the first wchar_t c in
       *  [__lo,__hi) for which is(__m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching wchar_t if found, else @a __hi.
      */
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Find wchar_t not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  wchar_t c of [__lo,__hi) for which is(__m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching wchar_t if found, else @a __hi.
      */
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
		  const char_type* __hi) const;

      /**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the wchar_t argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The wchar_t to convert.
       *  @return  The uppercase wchar_t if convertible, else @a __c.
      */
      virtual char_type
      do_toupper(char_type __c) const;

      /**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The wchar_t to convert.
       *  @return  The lowercase wchar_t if convertible, else @a __c.
      */
      virtual char_type
      do_tolower(char_type __c) const;

      /**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      /**
       *  @brief  Widen char to wchar_t
       *
       *  This virtual function converts the char to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be cast to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted wchar_t.
      */
      virtual char_type
      do_widen(char __c) const;

      /**
       *  @brief  Widen char array to wchar_t array
       *
       *  This function converts each char in the input to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be copied, casting each element to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;

      /**
       *  @brief  Narrow wchar_t to char
       *
       *  This virtual function converts the argument to char using
       *  the simplest reasonable transformation.  If the conversion
       *  fails, dfault is returned instead.  For an underived
       *  ctype<wchar_t> facet, @a c will be cast to char and
       *  returned.
       *
       *  do_narrow() is a hook for a derived facet to change the
       *  behavior of narrowing.  do_narrow() must always return the
       *  same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The wchar_t to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      */
      virtual char
      do_narrow(char_type __c, char __dfault) const;

      /**
       *  @brief  Narrow wchar_t array to char array
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any wchar_t in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<wchar_t> facet, the argument will be copied, casting each
       *  element to char.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      */
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
		char __dfault, char* __to) const;

      // For use at construction time only.
      void
      _M_initialize_ctype() throw();
    };
#endif //_GLIBCXX_USE_WCHAR_T
# 1471 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

  /// class ctype_byname [22.2.1.2].
  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask  mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

#if __cplusplus >= 201103L
      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }
#endif
# 1487 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

    protected:
      virtual
      ~ctype_byname() { };
    };

  /// 22.2.1.4  Class ctype_byname specializations.
  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

#if __cplusplus >= 201103L
      explicit
      ctype_byname(const string& __s, size_t __refs = 0);
#endif
# 1505 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

    protected:
      virtual
      ~ctype_byname();
    };

#ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

#if __cplusplus >= 201103L
      explicit
      ctype_byname(const string& __s, size_t __refs = 0);
#endif
# 1523 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

    protected:
      virtual
      ~ctype_byname();
    };
#endif
# 1529 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

// Include host and configuration specific ctype inlines.
#if 0 /* expanded by -frewrite-includes */
#include <bits/ctype_inline.h>
#endif /* expanded by -frewrite-includes */
# 1534 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/x86_64-redhat-linux/bits/ctype_inline.h" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 2000-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ctype_inline.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

//
// ISO C++ 14882: 22.1  Locales
//

// ctype bits to be inlined go here. Non-inlinable (ie virtual do_*)
// functions go in ctype.cc

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
	   && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
	   && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace
# 1535 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // 22.2.2  The numeric category.
  class __num_base
  {
  public:
    // NB: Code depends on the order of _S_atoms_out elements.
    // Below are the indices into _S_atoms_out.
    enum
      {
	_S_ominus,
	_S_oplus,
	_S_ox,
	_S_oX,
	_S_odigits,
	_S_odigits_end = _S_odigits + 16,
	_S_oudigits = _S_odigits_end,
	_S_oudigits_end = _S_oudigits + 16,
	_S_oe = _S_odigits + 14,  // For scientific notation, 'e'
	_S_oE = _S_oudigits + 14, // For scientific notation, 'E'
	_S_oend = _S_oudigits_end
      };

    // A list of valid numeric literals for output.  This array
    // contains chars that will be passed through the current locale's
    // ctype<_CharT>.widen() and then used to render numbers.
    // For the standard "C" locale, this is
    // "-+xX0123456789abcdef0123456789ABCDEF".
    static const char* _S_atoms_out;

    // String literal of acceptable (narrow) input, for num_get.
    // "-+xX0123456789abcdefABCDEF"
    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };

    // num_put
    // Construct and return valid scanf format for floating point types.
    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char*			_M_grouping;
      size_t                            _M_grouping_size;
      bool				_M_use_grouping;
      const _CharT*			_M_truename;
      size_t                            _M_truename_size;
      const _CharT*			_M_falsename;
      size_t                            _M_falsename_size;
      _CharT				_M_decimal_point;
      _CharT				_M_thousands_sep;

      // A list of valid numeric literals for output: in the standard
      // "C" locale, this is "-+xX0123456789abcdef0123456789ABCDEF".
      // This array contains the chars after having been passed
      // through the current locale's ctype<_CharT>.widen().
      _CharT				_M_atoms_out[__num_base::_S_oend];

      // A list of valid numeric literals for input: in the standard
      // "C" locale, this is "-+xX0123456789abcdefABCDEF"
      // This array contains the chars after having been passed
      // through the current locale's ctype<_CharT>.widen().
      _CharT				_M_atoms_in[__num_base::_S_iend];

      bool				_M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
	_M_use_grouping(false),
	_M_truename(0), _M_truename_size(0), _M_falsename(0),
	_M_falsename_size(0), _M_decimal_point(_CharT()),
	_M_thousands_sep(_CharT()), _M_allocated(false)
	{ }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
	{
	  delete [] _M_grouping;
	  delete [] _M_truename;
	  delete [] _M_falsename;
	}
    }

_GLIBCXX_BEGIN_NAMESPACE_CXX11

  /**
   *  @brief  Primary class template numpunct.
   *  @ingroup locales
   *
   *  This facet stores several pieces of information related to printing and
   *  scanning numbers, such as the decimal point character.  It takes a
   *  template parameter specifying the char type.  The numpunct facet is
   *  used by streams for many I/O operations involving numbers.
   *
   *  The numpunct template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from a numpunct facet.
  */
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT			char_type;
      typedef basic_string<_CharT>	string_type;
      //@}
      typedef __numpunct_cache<_CharT>  __cache_type;

    protected:
      __cache_type*			_M_data;

    public:
      /// Numpunct facet id.
      static locale::id			id;

      /**
       *  @brief  Numpunct constructor.
       *
       *  @param  __refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }

      /**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up the
       *  predefined locale facets.
       *
       *  @param  __cache  __numpunct_cache object.
       *  @param  __refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }

      /**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param  __cloc  The C locale.
       *  @param  __refs  Refcount to pass to the base class.
       */
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }

      /**
       *  @brief  Return decimal point character.
       *
       *  This function returns a char_type to use as a decimal point.  It
       *  does so by returning returning
       *  numpunct<char_type>::do_decimal_point().
       *
       *  @return  @a char_type representing a decimal point.
      */
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      /**
       *  @brief  Return thousands separator character.
       *
       *  This function returns a char_type to use as a thousands
       *  separator.  It does so by returning returning
       *  numpunct<char_type>::do_thousands_sep().
       *
       *  @return  char_type representing a thousands separator.
      */
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      /**
       *  @brief  Return grouping specification.
       *
       *  This function returns a string representing groupings for the
       *  integer part of a number.  Groupings indicate where thousands
       *  separators should be inserted in the integer part of a number.
       *
       *  Each char in the return string is interpret as an integer
       *  rather than a character.  These numbers represent the number
       *  of digits in a group.  The first char in the string
       *  represents the number of digits in the least significant
       *  group.  If a char is negative, it indicates an unlimited
       *  number of digits for the group.  If more chars from the
       *  string are required to group a number, the last char is used
       *  repeatedly.
       *
       *  For example, if the grouping() returns "\003\002" and is
       *  applied to the number 123456789, this corresponds to
       *  12,34,56,789.  Note that if the string was "32", this would
       *  put more than 50 digits into the least significant group if
       *  the character set is ASCII.
       *
       *  The string is returned by calling
       *  numpunct<char_type>::do_grouping().
       *
       *  @return  string representing grouping specification.
      */
      string
      grouping() const
      { return this->do_grouping(); }

      /**
       *  @brief  Return string representation of bool true.
       *
       *  This function returns a string_type containing the text
       *  representation for true bool variables.  It does so by calling
       *  numpunct<char_type>::do_truename().
       *
       *  @return  string_type representing printed form of true.
      */
      string_type
      truename() const
      { return this->do_truename(); }

      /**
       *  @brief  Return string representation of bool false.
       *
       *  This function returns a string_type containing the text
       *  representation for false bool variables.  It does so by calling
       *  numpunct<char_type>::do_falsename().
       *
       *  @return  string_type representing printed form of false.
      */
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:
      /// Destructor.
      virtual
      ~numpunct();

      /**
       *  @brief  Return decimal point character.
       *
       *  Returns a char_type to use as a decimal point.  This function is a
       *  hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a decimal point.
      */
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }

      /**
       *  @brief  Return thousands separator character.
       *
       *  Returns a char_type to use as a thousands separator.  This function
       *  is a hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a thousands separator.
      */
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }

      /**
       *  @brief  Return grouping specification.
       *
       *  Returns a string representing groupings for the integer part of a
       *  number.  This function is a hook for derived classes to change the
       *  value returned.  @see grouping() for details.
       *
       *  @return  String representing grouping specification.
      */
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }

      /**
       *  @brief  Return string representation of bool true.
       *
       *  Returns a string_type containing the text representation for true
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of true.
      */
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }

      /**
       *  @brief  Return string representation of bool false.
       *
       *  Returns a string_type containing the text representation for false
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of false.
      */
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }

      // For use at construction time only.
      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);

#ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
#endif
# 1896 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

  /// class numpunct_byname [22.2.3.2].
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT			char_type;
      typedef basic_string<_CharT>	string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
	if (__builtin_strcmp(__s, "C") != 0
	    && __builtin_strcmp(__s, "POSIX") != 0)
	  {
	    __c_locale __tmp;
	    this->_S_create_c_locale(__tmp, __s);
	    this->_M_initialize_numpunct(__tmp);
	    this->_S_destroy_c_locale(__tmp);
	  }
      }

#if __cplusplus >= 201103L
      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }
#endif
# 1924 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

    protected:
      virtual
      ~numpunct_byname() { }
    };

_GLIBCXX_END_NAMESPACE_CXX11

_GLIBCXX_BEGIN_NAMESPACE_LDBL

  /**
   *  @brief  Primary class template num_get.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to parse and return a number
   *  from a string.  It is used by the istream numeric extraction
   *  operators.
   *
   *  The num_get template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_get facet.
  */
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT			char_type;
      typedef _InIter			iter_type;
      //@}

      /// Numpunct facet id.
      static locale::id			id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }

      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the bool @a v.  It does so by calling
       *  num_get::do_get().
       *
       *  If ios_base::boolalpha is set, attempts to read
       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets
       *  @a v to true or false if successful.  Sets err to
       *  ios_base::failbit if reading the string fails.  Sets err to
       *  ios_base::eofbit if the stream is emptied.
       *
       *  If ios_base::boolalpha is not set, proceeds as with reading a long,
       *  except if the value is 1, sets @a v to true, if the value is 0, sets
       *  @a v to false, and otherwise set err to ios_base::failbit.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  Parsing is affected by the flag settings in @a io.
       *
       *  The basic parse is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, parses like the
       *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X
       *  specifier.  Else if basefield equal to 0, parses like the %i
       *  specifier.  Otherwise, parses like %d for signed and %u for unsigned
       *  types.  The matching type length modifier is also used.
       *
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, unsigned int& __v)   const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, unsigned long& __v)  const
      { return this->do_get(__in, __end, __io, __err, __v); }

#ifdef _GLIBCXX_USE_LONG_LONG
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, unsigned long long& __v)  const
      { return this->do_get(__in, __end, __io, __err, __v); }
#endif
# 2062 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
      //@}

      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %g specifier.  The
       *  matching type length modifier is also used.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      //@}

      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the pointer variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %p specifier.
       *
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  Note that the digit grouping effect for pointers is a bit ambiguous
       *  in the standard and shouldn't be relied on.  See DR 344.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
	  ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:
      /// Destructor.
      virtual ~num_get() { }

      _GLIBCXX_DEFAULT_ABI_TAG
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
		       string&) const;

      template<typename _ValueT>
	_GLIBCXX_DEFAULT_ABI_TAG
	iter_type
	_M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
		       _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
	_M_find(const _CharT2*, size_t __len, _CharT2 __c) const
	{
	  int __ret = -1;
	  if (__len <= 10)
	    {
	      if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
		__ret = __c - _CharT2('0');
	    }
	  else
	    {
	      if (__c >= _CharT2('0') && __c <= _CharT2('9'))
		__ret = __c - _CharT2('0');
	      else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
		__ret = 10 + (__c - _CharT2('a'));
	      else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
		__ret = 10 + (__c - _CharT2('A'));
	    }
	  return __ret;
	}

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
				      int>::__type
	_M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
	{
	  int __ret = -1;
	  const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
	  if (__q)
	    {
	      __ret = __q - __zero;
	      if (__ret > 15)
		__ret -= 6;
	    }
	  return __ret;
	}

      //@{
      /**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the variable @a v.  This function is a
       *  hook for derived classes to change the value returned.  @see get()
       *  for more details.
       *
       *  @param  __beg  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      */
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
	     ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
	     ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
	     ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
	     ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

#ifdef _GLIBCXX_USE_LONG_LONG
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
	     ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
	     ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
#endif
# 2241 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
	     double&) const;

      // XXX GLIBCXX_ABI Deprecated
#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
      virtual iter_type
      __do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
	       double&) const;
#else
# 2255 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
	     long double&) const;
#endif
# 2259 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;

      // XXX GLIBCXX_ABI Deprecated
#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
	     long double&) const;
#endif
# 2269 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
      //@}
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;


  /**
   *  @brief  Primary class template num_put.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to convert a number to a string.  It is
   *  used by the ostream numeric insertion operators.
   *
   *  The num_put template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_put facet.
  */
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:
      // Types:
      //@{
      /// Public typedefs
      typedef _CharT		char_type;
      typedef _OutIter		iter_type;
      //@}

      /// Numpunct facet id.
      static locale::id		id;

      /**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __refs  Passed to the base facet class.
      */
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }

      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the boolean @a v and inserts it into a stream.  It does so
       *  by calling num_put::do_put().
       *
       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or
       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the integral value @a v and inserts it into a
       *  stream.  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, formats like the
       *  printf %o specifier.  Else if equal to ios_base::hex, formats like
       *  %x or %X with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu
       *  for unsigned values.  Note that if both oct and hex are set, neither
       *  will take effect.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showbase is set, '0' precedes octal values (except 0)
       *  and '0[xX]' precedes hex values.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Thousands separators are inserted according to
       *  numpunct::grouping() and numpunct::thousands_sep().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
	  unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

#ifdef _GLIBCXX_USE_LONG_LONG
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
	  unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
#endif
# 2388 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
      //@}

      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the floating point value @a v and inserts it into a stream.
       *  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the
       *  printf %f specifier.  Else if equal to ios_base::scientific, formats
       *  like %e or %E with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %g or %G depending on uppercase.  Note that
       *  if both fixed and scientific are set, the effect will also be like
       *  %g or %G.
       *
       *  The output precision is given by io.precision().  This precision is
       *  capped at numeric_limits::digits10 + 2 (different for double and
       *  long double).  The default precision is 6.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showpoint is set, a decimal point will always be
       *  output.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Thousands separators are inserted according to
       *  numpunct::grouping() and numpunct::thousands_sep().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
	  long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
      //@}

      /**
       *  @brief  Numeric formatting.
       *
       *  Formats the pointer value @a v and inserts it into a stream.  It
       *  does so by calling num_put::do_put().
       *
       *  This function formats @a v as an unsigned long with ios_base::hex
       *  and ios_base::showbase set.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
	  const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
	iter_type
	_M_insert_float(iter_type, ios_base& __io, char_type __fill,
			char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
		     char_type __sep, const char_type* __p, char_type* __new,
		     char_type* __cs, int& __len) const;

      template<typename _ValueT>
	iter_type
	_M_insert_int(iter_type, ios_base& __io, char_type __fill,
		      _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
		   char_type __sep, ios_base& __io, char_type* __new,
		   char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
	     char_type* __new, const char_type* __cs, int& __len) const;

      /// Destructor.
      virtual
      ~num_put() { };

      //@{
      /**
       *  @brief  Numeric formatting.
       *
       *  These functions do the work of formatting numeric values and
       *  inserting them into a stream. This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      */
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
	     unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

#ifdef _GLIBCXX_USE_LONG_LONG
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
	     long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
	     unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
#endif
# 2528 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;

      // XXX GLIBCXX_ABI Deprecated
#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
      virtual iter_type
      __do_put(iter_type, ios_base&, char_type, double) const;
#else
# 2537 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;
#endif
# 2540 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;

      // XXX GLIBCXX_ABI Deprecated
#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;
#endif
# 2549 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
      //@}
    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;

_GLIBCXX_END_NAMESPACE_LDBL

  // Subclause convenience interfaces, inlines.
  // NB: These are inline because, when used in a loop, some compilers
  // can hoist the body out of the loop; then it's just as fast as the
  // C is*() function.

  /// Convenience interface to ctype.is(ctype_base::space, __c).
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }

  /// Convenience interface to ctype.is(ctype_base::print, __c).
  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }

  /// Convenience interface to ctype.is(ctype_base::cntrl, __c).
  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }

  /// Convenience interface to ctype.is(ctype_base::upper, __c).
  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }

  /// Convenience interface to ctype.is(ctype_base::lower, __c).
  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }

  /// Convenience interface to ctype.is(ctype_base::alpha, __c).
  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }

  /// Convenience interface to ctype.is(ctype_base::digit, __c).
  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }

  /// Convenience interface to ctype.is(ctype_base::punct, __c).
  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }

  /// Convenience interface to ctype.is(ctype_base::xdigit, __c).
  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }

  /// Convenience interface to ctype.is(ctype_base::alnum, __c).
  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }

  /// Convenience interface to ctype.is(ctype_base::graph, __c).
  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }

#if __cplusplus >= 201103L
  /// Convenience interface to ctype.is(ctype_base::blank, __c).
  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }
#endif
# 2635 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3

  /// Convenience interface to ctype.toupper(__c).
  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }

  /// Convenience interface to ctype.tolower(__c).
  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#if 0 /* expanded by -frewrite-includes */
# include <bits/locale_facets.tcc>
#endif /* expanded by -frewrite-includes */
# 2651 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 1 3
// Locale support -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/locale_facets.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */

#ifndef _LOCALE_FACETS_TCC
#define _LOCALE_FACETS_TCC 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Routine to access a cache for the facet.  If the cache didn't
  // exist before, it gets constructed on the fly.
  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };

  // Specializations.
  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
	const size_t __i = numpunct<_CharT>::id._M_id();
	const locale::facet** __caches = __loc._M_impl->_M_caches;
	if (!__caches[__i])
	  {
	    __numpunct_cache<_CharT>* __tmp = 0;
	    __try
	      {
		__tmp = new __numpunct_cache<_CharT>;
		__tmp->_M_cache(__loc);
	      }
	    __catch(...)
	      {
		delete __tmp;
		__throw_exception_again;
	      }
	    __loc._M_impl->_M_install_cache(__tmp, __i);
	  }
	return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      __try
	{
	  const string& __g = __np.grouping();
	  _M_grouping_size = __g.size();
	  __grouping = new char[_M_grouping_size];
	  __g.copy(__grouping, _M_grouping_size);
	  _M_use_grouping = (_M_grouping_size
			     && static_cast<signed char>(__grouping[0]) > 0
			     && (__grouping[0]
				 != __gnu_cxx::__numeric_traits<char>::__max));

	  const basic_string<_CharT>& __tn = __np.truename();
	  _M_truename_size = __tn.size();
	  __truename = new _CharT[_M_truename_size];
	  __tn.copy(__truename, _M_truename_size);

	  const basic_string<_CharT>& __fn = __np.falsename();
	  _M_falsename_size = __fn.size();
	  __falsename = new _CharT[_M_falsename_size];
	  __fn.copy(__falsename, _M_falsename_size);

	  _M_decimal_point = __np.decimal_point();
	  _M_thousands_sep = __np.thousands_sep();

	  const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
	  __ct.widen(__num_base::_S_atoms_out,
		     __num_base::_S_atoms_out
		     + __num_base::_S_oend, _M_atoms_out);
	  __ct.widen(__num_base::_S_atoms_in,
		     __num_base::_S_atoms_in
		     + __num_base::_S_iend, _M_atoms_in);

	  _M_grouping = __grouping;
	  _M_truename = __truename;
	  _M_falsename = __falsename;
	  _M_allocated = true;
	}
      __catch(...)
	{
	  delete [] __grouping;
	  delete [] __truename;
	  delete [] __falsename;
	  __throw_exception_again;
	}
    }

  // Used by both numeric and monetary facets.
  // Check to make sure that the __grouping_tmp string constructed in
  // money_get or num_get matches the canonical grouping for a given
  // locale.
  // __grouping_tmp is parsed L to R
  // 1,222,444 == __grouping_tmp of "\1\3\3"
  // __grouping is parsed R to L
  // 1,222,444 == __grouping of "\3" == "\3\3\3"
  _GLIBCXX_PURE bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
		    const string& __grouping_tmp) throw ();

_GLIBCXX_BEGIN_NAMESPACE_LDBL

  template<typename _CharT, typename _InIter>
    _GLIBCXX_DEFAULT_ABI_TAG
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
		     ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT>			__traits_type;
      typedef __numpunct_cache<_CharT>                  __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();

      // True if __beg becomes equal to __end.
      bool __testeof = __beg == __end;

      // First check for sign.
      if (!__testeof)
	{
	  __c = *__beg;
	  const bool __plus = __c == __lit[__num_base::_S_iplus];
	  if ((__plus || __c == __lit[__num_base::_S_iminus])
	      && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
	      && !(__c == __lc->_M_decimal_point))
	    {
	      __xtrc += __plus ? '+' : '-';
	      if (++__beg != __end)
		__c = *__beg;
	      else
		__testeof = true;
	    }
	}

      // Next, look for leading zeros.
      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
	{
	  if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
	      || __c == __lc->_M_decimal_point)
	    break;
	  else if (__c == __lit[__num_base::_S_izero])
	    {
	      if (!__found_mantissa)
		{
		  __xtrc += '0';
		  __found_mantissa = true;
		}
	      ++__sep_pos;

	      if (++__beg != __end)
		__c = *__beg;
	      else
		__testeof = true;
	    }
	  else
	    break;
	}

      // Only need acceptable digits for floating point numbers.
      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
	__found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)
	// "C" locale
	while (!__testeof)
	  {
	    const int __digit = _M_find(__lit_zero, 10, __c);
	    if (__digit != -1)
	      {
		__xtrc += '0' + __digit;
		__found_mantissa = true;
	      }
	    else if (__c == __lc->_M_decimal_point
		     && !__found_dec && !__found_sci)
	      {
		__xtrc += '.';
		__found_dec = true;
	      }
	    else if ((__c == __lit[__num_base::_S_ie] 
		      || __c == __lit[__num_base::_S_iE])
		     && !__found_sci && __found_mantissa)
	      {
		// Scientific notation.
		__xtrc += 'e';
		__found_sci = true;
		
		// Remove optional plus or minus sign, if they exist.
		if (++__beg != __end)
		  {
		    __c = *__beg;
		    const bool __plus = __c == __lit[__num_base::_S_iplus];
		    if (__plus || __c == __lit[__num_base::_S_iminus])
		      __xtrc += __plus ? '+' : '-';
		    else
		      continue;
		  }
		else
		  {
		    __testeof = true;
		    break;
		  }
	      }
	    else
	      break;

	    if (++__beg != __end)
	      __c = *__beg;
	    else
	      __testeof = true;
	  }
      else
	while (!__testeof)
	  {
	    // According to 22.2.2.1.2, p8-9, first look for thousands_sep
	    // and decimal_point.
	    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
	      {
		if (!__found_dec && !__found_sci)
		  {
		    // NB: Thousands separator at the beginning of a string
		    // is a no-no, as is two consecutive thousands separators.
		    if (__sep_pos)
		      {
			__found_grouping += static_cast<char>(__sep_pos);
			__sep_pos = 0;
		      }
		    else
		      {
			// NB: __convert_to_v will not assign __v and will
			// set the failbit.
			__xtrc.clear();
			break;
		      }
		  }
		else
		  break;
	      }
	    else if (__c == __lc->_M_decimal_point)
	      {
		if (!__found_dec && !__found_sci)
		  {
		    // If no grouping chars are seen, no grouping check
		    // is applied. Therefore __found_grouping is adjusted
		    // only if decimal_point comes after some thousands_sep.
		    if (__found_grouping.size())
		      __found_grouping += static_cast<char>(__sep_pos);
		    __xtrc += '.';
		    __found_dec = true;
		  }
		else
		  break;
	      }
	    else
	      {
		const char_type* __q =
		  __traits_type::find(__lit_zero, 10, __c);
		if (__q)
		  {
		    __xtrc += '0' + (__q - __lit_zero);
		    __found_mantissa = true;
		    ++__sep_pos;
		  }
		else if ((__c == __lit[__num_base::_S_ie] 
			  || __c == __lit[__num_base::_S_iE])
			 && !__found_sci && __found_mantissa)
		  {
		    // Scientific notation.
		    if (__found_grouping.size() && !__found_dec)
		      __found_grouping += static_cast<char>(__sep_pos);
		    __xtrc += 'e';
		    __found_sci = true;
		    
		    // Remove optional plus or minus sign, if they exist.
		    if (++__beg != __end)
		      {
			__c = *__beg;
			const bool __plus = __c == __lit[__num_base::_S_iplus];
			if ((__plus || __c == __lit[__num_base::_S_iminus])
			    && !(__lc->_M_use_grouping
				 && __c == __lc->_M_thousands_sep)
			    && !(__c == __lc->_M_decimal_point))
		      __xtrc += __plus ? '+' : '-';
			else
			  continue;
		      }
		    else
		      {
			__testeof = true;
			break;
		      }
		  }
		else
		  break;
	      }
	    
	    if (++__beg != __end)
	      __c = *__beg;
	    else
	      __testeof = true;
	  }

      // Digit grouping is checked. If grouping and found_grouping don't
      // match, then get very very upset, and set failbit.
      if (__found_grouping.size())
        {
          // Add the ending grouping if a decimal or 'e'/'E' wasn't found.
	  if (!__found_dec && !__found_sci)
	    __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping, 
				      __lc->_M_grouping_size,
				      __found_grouping))
	    __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _GLIBCXX_DEFAULT_ABI_TAG
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
		     ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT>			     __traits_type;
	using __gnu_cxx::__add_unsigned;
	typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
	typedef __numpunct_cache<_CharT>                     __cache_type;
	__use_cache<__cache_type> __uc;
	const locale& __loc = __io._M_getloc();
	const __cache_type* __lc = __uc(__loc);
	const _CharT* __lit = __lc->_M_atoms_in;
	char_type __c = char_type();

	// NB: Iff __basefield == 0, __base can change based on contents.
	const ios_base::fmtflags __basefield = __io.flags()
	                                       & ios_base::basefield;
	const bool __oct = __basefield == ios_base::oct;
	int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);

	// True if __beg becomes equal to __end.
	bool __testeof = __beg == __end;

	// First check for sign.
	bool __negative = false;
	if (!__testeof)
	  {
	    __c = *__beg;
	    __negative = __c == __lit[__num_base::_S_iminus];
	    if ((__negative || __c == __lit[__num_base::_S_iplus])
		&& !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
		&& !(__c == __lc->_M_decimal_point))
	      {
		if (++__beg != __end)
		  __c = *__beg;
		else
		  __testeof = true;
	      }
	  }

	// Next, look for leading zeros and check required digits
	// for base formats.
	bool __found_zero = false;
	int __sep_pos = 0;
	while (!__testeof)
	  {
	    if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
		|| __c == __lc->_M_decimal_point)
	      break;
	    else if (__c == __lit[__num_base::_S_izero] 
		     && (!__found_zero || __base == 10))
	      {
		__found_zero = true;
		++__sep_pos;
		if (__basefield == 0)
		  __base = 8;
		if (__base == 8)
		  __sep_pos = 0;
	      }
	    else if (__found_zero
		     && (__c == __lit[__num_base::_S_ix]
			 || __c == __lit[__num_base::_S_iX]))
	      {
		if (__basefield == 0)
		  __base = 16;
		if (__base == 16)
		  {
		    __found_zero = false;
		    __sep_pos = 0;
		  }
		else
		  break;
	      }
	    else
	      break;

	    if (++__beg != __end)
	      {
		__c = *__beg;
		if (!__found_zero)
		  break;
	      }
	    else
	      __testeof = true;
	  }
	
	// At this point, base is determined. If not hex, only allow
	// base digits as valid input.
	const size_t __len = (__base == 16 ? __num_base::_S_iend
			      - __num_base::_S_izero : __base);

	// Extract.
	string __found_grouping;
	if (__lc->_M_use_grouping)
	  __found_grouping.reserve(32);
	bool __testfail = false;
	bool __testoverflow = false;
	const __unsigned_type __max =
	  (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
	  ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
	  : __gnu_cxx::__numeric_traits<_ValueT>::__max;
	const __unsigned_type __smax = __max / __base;
	__unsigned_type __result = 0;
	int __digit = 0;
	const char_type* __lit_zero = __lit + __num_base::_S_izero;

	if (!__lc->_M_allocated)
	  // "C" locale
	  while (!__testeof)
	    {
	      __digit = _M_find(__lit_zero, __len, __c);
	      if (__digit == -1)
		break;
	      
	      if (__result > __smax)
		__testoverflow = true;
	      else
		{
		  __result *= __base;
		  __testoverflow |= __result > __max - __digit;
		  __result += __digit;
		  ++__sep_pos;
		}
	      
	      if (++__beg != __end)
		__c = *__beg;
	      else
		__testeof = true;
	    }
	else
	  while (!__testeof)
	    {
	      // According to 22.2.2.1.2, p8-9, first look for thousands_sep
	      // and decimal_point.
	      if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
		{
		  // NB: Thousands separator at the beginning of a string
		  // is a no-no, as is two consecutive thousands separators.
		  if (__sep_pos)
		    {
		      __found_grouping += static_cast<char>(__sep_pos);
		      __sep_pos = 0;
		    }
		  else
		    {
		      __testfail = true;
		      break;
		    }
		}
	      else if (__c == __lc->_M_decimal_point)
		break;
	      else
		{
		  const char_type* __q =
		    __traits_type::find(__lit_zero, __len, __c);
		  if (!__q)
		    break;
		  
		  __digit = __q - __lit_zero;
		  if (__digit > 15)
		    __digit -= 6;
		  if (__result > __smax)
		    __testoverflow = true;
		  else
		    {
		      __result *= __base;
		      __testoverflow |= __result > __max - __digit;
		      __result += __digit;
		      ++__sep_pos;
		    }
		}
	      
	      if (++__beg != __end)
		__c = *__beg;
	      else
		__testeof = true;
	    }
	
	// Digit grouping is checked. If grouping and found_grouping don't
	// match, then get very very upset, and set failbit.
	if (__found_grouping.size())
	  {
	    // Add the ending grouping.
	    __found_grouping += static_cast<char>(__sep_pos);

	    if (!std::__verify_grouping(__lc->_M_grouping,
					__lc->_M_grouping_size,
					__found_grouping))
	      __err = ios_base::failbit;
	  }

	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 23. Num_get overflow result.
	if ((!__sep_pos && !__found_zero && !__found_grouping.size())
	    || __testfail)
	  {
	    __v = 0;
	    __err = ios_base::failbit;
	  }
	else if (__testoverflow)
	  {
	    if (__negative
		&& __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
	      __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
	    else
	      __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
	    __err = ios_base::failbit;
	  }
	else
	  __v = __negative ? -__result : __result;

	if (__testeof)
	  __err |= ios_base::eofbit;
	return __beg;
      }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // 17.  Bad bool parsing
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {
	  // Parse bool values as long.
          // NB: We can't just call do_get(long) here, as it might
          // refer to a derived class.
	  long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
	  if (__l == 0 || __l == 1)
	    __v = bool(__l);
	  else
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 23. Num_get overflow result.
	      __v = true;
	      __err = ios_base::failbit;
	      if (__beg == __end)
		__err |= ios_base::eofbit;
	    }
        }
      else
        {
	  // Parse bool values as alphanumeric.
	  typedef __numpunct_cache<_CharT>  __cache_type;
	  __use_cache<__cache_type> __uc;
	  const locale& __loc = __io._M_getloc();
	  const __cache_type* __lc = __uc(__loc);

	  bool __testf = true;
	  bool __testt = true;
	  bool __donef = __lc->_M_falsename_size == 0;
	  bool __donet = __lc->_M_truename_size == 0;
	  bool __testeof = false;
	  size_t __n = 0;
	  while (!__donef || !__donet)
	    {
	      if (__beg == __end)
		{
		  __testeof = true;
		  break;
		}

	      const char_type __c = *__beg;

	      if (!__donef)
		__testf = __c == __lc->_M_falsename[__n];

	      if (!__testf && __donet)
		break;

	      if (!__donet)
		__testt = __c == __lc->_M_truename[__n];

	      if (!__testt && __donef)
		break;

	      if (!__testt && !__testf)
		break;

	      ++__n;
	      ++__beg;

	      __donef = !__testf || __n >= __lc->_M_falsename_size;
	      __donet = !__testt || __n >= __lc->_M_truename_size;
	    }
	  if (__testf && __n == __lc->_M_falsename_size && __n)
	    {
	      __v = false;
	      if (__testt && __n == __lc->_M_truename_size)
		__err = ios_base::failbit;
	      else
		__err = __testeof ? ios_base::eofbit : ios_base::goodbit;
	    }
	  else if (__testt && __n == __lc->_M_truename_size && __n)
	    {
	      __v = true;
	      __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
	    }
	  else
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 23. Num_get overflow result.
	      __v = false;
	      __err = ios_base::failbit;
	      if (__testeof)
		__err |= ios_base::eofbit;
	    }
	}
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
	   ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
	__err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
	__err |= ios_base::eofbit;
      return __beg;
    }

#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    __do_get(iter_type __beg, iter_type __end, ios_base& __io,
	     ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
	__err |= ios_base::eofbit;
      return __beg;
    }
#endif
# 734 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
	__err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {
      // Prepare for hex formatted input.
      typedef ios_base::fmtflags        fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
					     <= sizeof(unsigned long)),
	unsigned long, unsigned long long>::__type _UIntPtrType;       

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);

      // Reset from hex formatted input.
      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }

  // For use by integer and floating-point types after they have been
  // converted into a char_type string.
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
	   _CharT* __new, const _CharT* __cs, int& __len) const
    {
      // [22.2.2.2.2] Stage 3.
      // If necessary, pad.
      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
						  __cs, __w, __len);
      __len = static_cast<int>(__w);
    }

_GLIBCXX_END_NAMESPACE_LDBL

  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
		  ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
	{
	  // Decimal.
	  do
	    {
	      *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
	      __v /= 10;
	    }
	  while (__v != 0);
	}
      else if ((__flags & ios_base::basefield) == ios_base::oct)
	{
	  // Octal.
	  do
	    {
	      *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
	      __v >>= 3;
	    }
	  while (__v != 0);
	}
      else
	{
	  // Hex.
	  const bool __uppercase = __flags & ios_base::uppercase;
	  const int __case_offset = __uppercase ? __num_base::_S_oudigits
	                                        : __num_base::_S_odigits;
	  do
	    {
	      *--__buf = __lit[(__v & 0xf) + __case_offset];
	      __v >>= 4;
	    }
	  while (__v != 0);
	}
      return __bufend - __buf;
    }

_GLIBCXX_BEGIN_NAMESPACE_LDBL

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
		 ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
					__grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }
  
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
		    _ValueT __v) const
      {
	using __gnu_cxx::__add_unsigned;
	typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
	typedef __numpunct_cache<_CharT>	             __cache_type;
	__use_cache<__cache_type> __uc;
	const locale& __loc = __io._M_getloc();
	const __cache_type* __lc = __uc(__loc);
	const _CharT* __lit = __lc->_M_atoms_out;
	const ios_base::fmtflags __flags = __io.flags();

	// Long enough to hold hex, dec, and octal representations.
	const int __ilen = 5 * sizeof(_ValueT);
	_CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
							     * __ilen));

	// [22.2.2.2.2] Stage 1, numeric conversion to character.
	// Result is returned right-justified in the buffer.
	const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
	const bool __dec = (__basefield != ios_base::oct
			    && __basefield != ios_base::hex);
	const __unsigned_type __u = ((__v > 0 || !__dec)
				     ? __unsigned_type(__v)
				     : -__unsigned_type(__v));
 	int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
	__cs += __ilen - __len;

	// Add grouping, if necessary.
	if (__lc->_M_use_grouping)
	  {
	    // Grouping can add (almost) as many separators as the number
	    // of digits + space is reserved for numeric base or sign.
	    _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
								  * (__len + 1)
								  * 2));
	    _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
			 __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
	    __cs = __cs2 + 2;
	  }

	// Complete Stage 1, prepend numeric base or sign.
	if (__builtin_expect(__dec, true))
	  {
	    // Decimal.
	    if (__v >= 0)
	      {
		if (bool(__flags & ios_base::showpos)
		    && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
		  *--__cs = __lit[__num_base::_S_oplus], ++__len;
	      }
	    else
	      *--__cs = __lit[__num_base::_S_ominus], ++__len;
	  }
	else if (bool(__flags & ios_base::showbase) && __v)
	  {
	    if (__basefield == ios_base::oct)
	      *--__cs = __lit[__num_base::_S_odigits], ++__len;
	    else
	      {
		// 'x' or 'X'
		const bool __uppercase = __flags & ios_base::uppercase;
		*--__cs = __lit[__num_base::_S_ox + __uppercase];
		// '0'
		*--__cs = __lit[__num_base::_S_odigits];
		__len += 2;
	      }
	  }

	// Pad.
	const streamsize __w = __io.width();
	if (__w > static_cast<streamsize>(__len))
	  {
	    _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
								  * __w));
	    _M_pad(__fill, __w, __io, __cs3, __cs, __len);
	    __cs = __cs3;
	  }
	__io.width(0);

	// [22.2.2.2.2] Stage 4.
	// Write resulting, fully-formatted string to output iterator.
	return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
		   _CharT __sep, const _CharT* __p, _CharT* __new,
		   _CharT* __cs, int& __len) const
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 282. What types does numpunct grouping refer to?
      // Add grouping, if necessary.
      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
					 __grouping_size,
					 __cs, __cs + __declen);

      // Tack on decimal part.
      int __newlen = __p2 - __new;
      if (__p)
	{
	  char_traits<_CharT>::copy(__p2, __p, __len - __declen);
	  __newlen += __len - __declen;
	}
      __len = __newlen;
    }

  // The following code uses vsnprintf (or vsprintf(), when
  // _GLIBCXX_USE_C99 is not defined) to convert floating point values
  // for insertion into a stream.  An optimization would be to replace
  // them with code that works directly on a wide buffer and then use
  // __pad to do the padding.  It would be good to replace them anyway
  // to gain back the efficiency that C++ provides by knowing up front
  // the type of the values to insert.  Also, sprintf is dangerous
  // since may lead to accidental buffer overruns.  This
  // implementation follows the C++ standard fairly directly as
  // outlined in 22.2.2.2 [lib.locale.num.put]
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
		       _ValueT __v) const
      {
	typedef __numpunct_cache<_CharT>                __cache_type;
	__use_cache<__cache_type> __uc;
	const locale& __loc = __io._M_getloc();
	const __cache_type* __lc = __uc(__loc);

	// Use default precision if out of range.
	const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

	const int __max_digits =
	  __gnu_cxx::__numeric_traits<_ValueT>::__digits10;

	// [22.2.2.2.2] Stage 1, numeric conversion to character.
	int __len;
	// Long enough for the max format spec.
	char __fbuf[16];
	__num_base::_S_format_float(__io, __fbuf, __mod);

#ifdef _GLIBCXX_USE_C99
	// Precision is always used except for hexfloat format.
	const bool __use_prec =
	  (__io.flags() & ios_base::floatfield) != ios_base::floatfield;

	// First try a buffer perhaps big enough (most probably sufficient
	// for non-ios_base::fixed outputs)
	int __cs_size = __max_digits * 3;
	char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
	if (__use_prec)
	  __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
					__fbuf, __prec, __v);
	else
	  __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
					__fbuf, __v);

	// If the buffer was not large enough, try again with the correct size.
	if (__len >= __cs_size)
	  {
	    __cs_size = __len + 1;
	    __cs = static_cast<char*>(__builtin_alloca(__cs_size));
	    if (__use_prec)
	      __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
					    __fbuf, __prec, __v);
	    else
	      __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
					    __fbuf, __v);
	  }
#else
# 1024 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3
	// Consider the possibility of long ios_base::fixed outputs
	const bool __fixed = __io.flags() & ios_base::fixed;
	const int __max_exp =
	  __gnu_cxx::__numeric_traits<_ValueT>::__max_exponent10;

	// The size of the output string is computed as follows.
	// ios_base::fixed outputs may need up to __max_exp + 1 chars
	// for the integer part + __prec chars for the fractional part
	// + 3 chars for sign, decimal point, '\0'. On the other hand,
	// for non-fixed outputs __max_digits * 2 + __prec chars are
	// largely sufficient.
	const int __cs_size = __fixed ? __max_exp + __prec + 4
	                              : __max_digits * 2 + __prec;
	char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
	__len = std::__convert_from_v(_S_get_c_locale(), __cs, 0, __fbuf, 
				      __prec, __v);
#endif
# 1041 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3

	// [22.2.2.2.2] Stage 2, convert to char_type, using correct
	// numpunct.decimal_point() values for '.' and adding grouping.
	const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
	
	_CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
							     * __len));
	__ctype.widen(__cs, __cs + __len, __ws);
	
	// Replace decimal point.
	_CharT* __wp = 0;
	const char* __p = char_traits<char>::find(__cs, __len, '.');
	if (__p)
	  {
	    __wp = __ws + (__p - __cs);
	    *__wp = __lc->_M_decimal_point;
	  }
	
	// Add grouping, if necessary.
	// N.B. Make sure to not group things like 2e20, i.e., no decimal
	// point, scientific notation.
	if (__lc->_M_use_grouping
	    && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
				      && __cs[1] >= '0' && __cs[2] >= '0')))
	  {
	    // Grouping can add (almost) as many separators as the
	    // number of digits, but no more.
	    _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
								  * __len * 2));
	    
	    streamsize __off = 0;
	    if (__cs[0] == '-' || __cs[0] == '+')
	      {
		__off = 1;
		__ws2[0] = __ws[0];
		__len -= 1;
	      }
	    
	    _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
			   __lc->_M_thousands_sep, __wp, __ws2 + __off,
			   __ws + __off, __len);
	    __len += __off;
	    
	    __ws = __ws2;
	  }

	// Pad.
	const streamsize __w = __io.width();
	if (__w > static_cast<streamsize>(__len))
	  {
	    _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
								  * __w));
	    _M_pad(__fill, __w, __io, __ws3, __ws, __len);
	    __ws = __ws3;
	  }
	__io.width(0);
	
	// [22.2.2.2.2] Stage 4.
	// Write resulting, fully-formatted string to output iterator.
	return std::__write(__s, __ws, __len);
      }
  
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
	  typedef __numpunct_cache<_CharT>              __cache_type;
	  __use_cache<__cache_type> __uc;
	  const locale& __loc = __io._M_getloc();
	  const __cache_type* __lc = __uc(__loc);

	  const _CharT* __name = __v ? __lc->_M_truename
	                             : __lc->_M_falsename;
	  int __len = __v ? __lc->_M_truename_size
	                  : __lc->_M_falsename_size;

	  const streamsize __w = __io.width();
	  if (__w > static_cast<streamsize>(__len))
	    {
	      const streamsize __plen = __w - __len;
	      _CharT* __ps
		= static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
							* __plen));

	      char_traits<_CharT>::assign(__ps, __plen, __fill);
	      __io.width(0);

	      if ((__flags & ios_base::adjustfield) == ios_base::left)
		{
		  __s = std::__write(__s, __name, __len);
		  __s = std::__write(__s, __ps, __plen);
		}
	      else
		{
		  __s = std::__write(__s, __ps, __plen);
		  __s = std::__write(__s, __name, __len);
		}
	      return __s;
	    }
	  __io.width(0);
	  __s = std::__write(__s, __name, __len);
	}
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }

#if defined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128__
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    __do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
#endif
# 1168 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
	   long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
					 | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
					     <= sizeof(unsigned long)),
	unsigned long, unsigned long long>::__type _UIntPtrType;       

      __s = _M_insert_int(__s, __io, __fill,
			  reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }

_GLIBCXX_END_NAMESPACE_LDBL

  // Construct correctly padded string, as per 22.2.2.2.2
  // Assumes
  // __newlen > __oldlen
  // __news is allocated for __newlen size

  // NB: Of the two parameters, _CharT can be deduced from the
  // function arguments. The other (_Traits) has to be explicitly specified.
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
				   _CharT* __news, const _CharT* __olds,
				   streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;

      // Padding last.
      if (__adjust == ios_base::left)
	{
	  _Traits::copy(__news, __olds, __oldlen);
	  _Traits::assign(__news + __oldlen, __plen, __fill);
	  return;
	}

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
	{
	  // Pad after the sign, if there is one.
	  // Pad after 0[xX], if there is one.
	  // Who came up with these rules, anyway? Jeeze.
          const locale& __loc = __io._M_getloc();
	  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

	  if (__ctype.widen('-') == __olds[0]
	      || __ctype.widen('+') == __olds[0])
	    {
	      __news[0] = __olds[0];
	      __mod = 1;
	      ++__news;
	    }
	  else if (__ctype.widen('0') == __olds[0]
		   && __oldlen > 1
		   && (__ctype.widen('x') == __olds[1]
		       || __ctype.widen('X') == __olds[1]))
	    {
	      __news[0] = __olds[0];
	      __news[1] = __olds[1];
	      __mod = 2;
	      __news += 2;
	    }
	  // else Padding first.
	}
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
		   const char* __gbeg, size_t __gsize,
		   const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
	     && static_cast<signed char>(__gbeg[__idx]) > 0
	     && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
	{
	  __last -= __gbeg[__idx];
	  __idx < __gsize - 1 ? ++__idx : ++__ctr;
	}

      while (__first != __last)
	*__s++ = *__first++;

      while (__ctr--)
	{
	  *__s++ = __sep;	  
	  for (char __i = __gbeg[__idx]; __i > 0; --__i)
	    *__s++ = *__first++;
	}

      while (__idx--)
	{
	  *__s++ = __sep;	  
	  for (char __i = __gbeg[__idx]; __i > 0; --__i)
	    *__s++ = *__first++;
	}

      return __s;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct<char>;
  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct_byname<char>;
  extern template class _GLIBCXX_NAMESPACE_LDBL num_get<char>;
  extern template class _GLIBCXX_NAMESPACE_LDBL num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct<wchar_t>;
  extern template class _GLIBCXX_NAMESPACE_CXX11 numpunct_byname<wchar_t>;
  extern template class _GLIBCXX_NAMESPACE_LDBL num_get<wchar_t>;
  extern template class _GLIBCXX_NAMESPACE_LDBL num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);
#endif
# 1372 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3
#endif
# 1373 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 1378 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.tcc" 3
# 2652 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 2 3

#endif
# 2654 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/locale_facets.h" 3
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/streambuf_iterator.h>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
	__throw_bad_cast();
      return *__f;
    }

  /**
   *  @brief Template class basic_ios, virtual base class for all
   *  stream classes. 
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  Most of the member functions called dispatched on stream objects
   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
  */
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:
      //@{
      /**
       *  These are standard types.  They permit a standardized way of
       *  referring to names of (or names dependent on) the template
       *  parameters, which are specific to the implementation.
      */
      typedef _CharT                                 char_type;
      typedef typename _Traits::int_type             int_type;
      typedef typename _Traits::pos_type             pos_type;
      typedef typename _Traits::off_type             off_type;
      typedef _Traits                                traits_type;
      //@}

      //@{
      /**
       *  These are non-standard types.
      */
      typedef ctype<_CharT>                          __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
						     __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
						     __num_get_type;
      //@}

      // Data members:
    protected:
      basic_ostream<_CharT, _Traits>*                _M_tie;
      mutable char_type                              _M_fill;
      mutable bool                                   _M_fill_init;
      basic_streambuf<_CharT, _Traits>*              _M_streambuf;

      // Cached use_facet<ctype>, which is based on the current locale info.
      const __ctype_type*                            _M_ctype;
      // For ostream.
      const __num_put_type*                          _M_num_put;
      // For istream.
      const __num_get_type*                          _M_num_get;

    public:
      //@{
      /**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  <code>if (!a_stream) ...</code> and <code>while (a_stream) ...</code>
      */
#if __cplusplus >= 201103L
      explicit operator bool() const
      { return !this->fail(); }
#else
# 120 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
#endif
# 123 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3

      bool
      operator!() const
      { return this->fail(); }
      //@}

      /**
       *  @brief  Returns the error state of the stream buffer.
       *  @return  A bit pattern (well, isn't everything?)
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will call one of the interpreting wrappers, e.g., good().
      */
      iostate
      rdstate() const
      { return _M_streambuf_state; }

      /**
       *  @brief  [Re]sets the error state.
       *  @param  __state  The new state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will not need to pass an argument.
      */
      void
      clear(iostate __state = goodbit);

      /**
       *  @brief  Sets additional flags in the error state.
       *  @param  __state  The additional state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.
      */
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }

      // Flip the internal state on for the proper state bits, then re
      // throws the propagated exception if bit also set in
      // exceptions().
      void
      _M_setstate(iostate __state)
      {
	// 27.6.1.2.1 Common requirements.
	// Turn this on without causing an ios::failure to be thrown.
	_M_streambuf_state |= __state;
	if (this->exceptions() & __state)
	  __throw_exception_again;
      }

      /**
       *  @brief  Fast error checking.
       *  @return  True if no error flags are set.
       *
       *  A wrapper around rdstate.
      */
      bool
      good() const
      { return this->rdstate() == 0; }

      /**
       *  @brief  Fast error checking.
       *  @return  True if the eofbit is set.
       *
       *  Note that other iostate flags may also be set.
      */
      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }

      /**
       *  @brief  Fast error checking.
       *  @return  True if either the badbit or the failbit is set.
       *
       *  Checking the badbit in fail() is historical practice.
       *  Note that other iostate flags may also be set.
      */
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }

      /**
       *  @brief  Fast error checking.
       *  @return  True if the badbit is set.
       *
       *  Note that other iostate flags may also be set.
      */
      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }

      /**
       *  @brief  Throwing exceptions on errors.
       *  @return  The current exceptions mask.
       *
       *  This changes nothing in the stream.  See the one-argument version
       *  of exceptions(iostate) for the meaning of the return value.
      */
      iostate
      exceptions() const
      { return _M_exception; }

      /**
       *  @brief  Throwing exceptions on errors.
       *  @param  __except  The new exceptions mask.
       *
       *  By default, error flags are set silently.  You can set an
       *  exceptions mask for each stream; if a bit in the mask becomes set
       *  in the error flags, then an exception of type
       *  std::ios_base::failure is thrown.
       *
       *  If the error flag is already set when the exceptions mask is
       *  added, the exception is immediately thrown.  Try running the
       *  following under GCC 3.1 or later:
       *  @code
       *  #include <iostream>
       *  #include <fstream>
       *  #include <exception>
       *
       *  int main()
       *  {
       *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);
       *
       *      std::ifstream f ("/etc/motd");
       *
       *      std::cerr << "Setting badbit\n";
       *      f.setstate (std::ios_base::badbit);
       *
       *      std::cerr << "Setting exception mask\n";
       *      f.exceptions (std::ios_base::badbit);
       *  }
       *  @endcode
      */
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }

      // Constructor/destructor:
      /**
       *  @brief  Constructor performs initialization.
       *
       *  The parameter is passed by derived streams.
      */
      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
	_M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }

      /**
       *  @brief  Empty.
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      */
      virtual
      ~basic_ios() { }

      // Members:
      /**
       *  @brief  Fetches the current @e tied stream.
       *  @return  A pointer to the tied stream, or NULL if the stream is
       *           not tied.
       *
       *  A stream may be @e tied (or synchronized) to a second output
       *  stream.  When this stream performs any I/O, the tied stream is
       *  first flushed.  For example, @c std::cin is tied to @c std::cout.
      */
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }

      /**
       *  @brief  Ties this stream to an output stream.
       *  @param  __tiestr  The output stream.
       *  @return  The previously tied output stream, or NULL if the stream
       *           was not tied.
       *
       *  This sets up a new tie; see tie() for more.
      */
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }

      /**
       *  @brief  Accessing the underlying buffer.
       *  @return  The current stream buffer.
       *
       *  This does not change the state of the stream.
      */
      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }

      /**
       *  @brief  Changing the underlying buffer.
       *  @param  __sb  The new stream buffer.
       *  @return  The previous stream buffer.
       *
       *  Associates a new buffer with the current stream, and clears the
       *  error state.
       *
       *  Due to historical accidents which the LWG refuses to correct, the
       *  I/O library suffers from a design error:  this function is hidden
       *  in derived classes by overrides of the zero-argument @c rdbuf(),
       *  which is non-virtual for hysterical raisins.  As a result, you
       *  must use explicit qualifications to access this function via any
       *  derived class.  For example:
       *
       *  @code
       *  std::fstream     foo;         // or some other derived type
       *  std::streambuf*  p = .....;
       *
       *  foo.ios::rdbuf(p);            // ios == basic_ios<char>
       *  @endcode
      */
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);

      /**
       *  @brief  Copies fields of __rhs into this.
       *  @param  __rhs  The source values for the copies.
       *  @return  Reference to this object.
       *
       *  All fields of __rhs are copied into this object except that rdbuf()
       *  and rdstate() remain unchanged.  All values in the pword and iword
       *  arrays are copied.  Before copying, each callback is invoked with
       *  erase_event.  After copying, each (new) callback is invoked with
       *  copyfmt_event.  The final step is to copy exceptions().
      */
      basic_ios&
      copyfmt(const basic_ios& __rhs);

      /**
       *  @brief  Retrieves the @a empty character.
       *  @return  The current fill character.
       *
       *  It defaults to a space (' ') in the current locale.
      */
      char_type
      fill() const
      {
	if (!_M_fill_init)
	  {
	    _M_fill = this->widen(' ');
	    _M_fill_init = true;
	  }
	return _M_fill;
      }

      /**
       *  @brief  Sets a new @a empty character.
       *  @param  __ch  The new character.
       *  @return  The previous fill character.
       *
       *  The fill character is used to fill out space when P+ characters
       *  have been requested (e.g., via setw), Q characters are actually
       *  used, and Q<P.  It defaults to a space (' ') in the current locale.
      */
      char_type
      fill(char_type __ch)
      {
	char_type __old = this->fill();
	_M_fill = __ch;
	return __old;
      }

      // Locales:
      /**
       *  @brief  Moves to a new locale.
       *  @param  __loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated
       *  with this stream, calls that buffer's @c pubimbue(loc).
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      locale
      imbue(const locale& __loc);

      /**
       *  @brief  Squeezes characters.
       *  @param  __c  The character to narrow.
       *  @param  __dfault  The character to narrow.
       *  @return  The narrowed character.
       *
       *  Maps a character of @c char_type to a character of @c char,
       *  if possible.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).narrow(c,dfault)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }

      /**
       *  @brief  Widens characters.
       *  @param  __c  The character to widen.
       *  @return  The widened character.
       *
       *  Maps a character of @c char to a character of @c char_type.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).widen(c)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:
      // 27.4.5.1  basic_ios constructors
      /**
       *  @brief  Empty.
       *
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false), 
	_M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }

      /**
       *  @brief  All setup is performed here.
       *
       *  This is called from the public constructor.  It is not virtual and
       *  cannot be redefined.
      */
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

#if __cplusplus >= 201103L
      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
	ios_base::_M_move(__rhs);
	_M_cache_locale(_M_ios_locale);
	this->tie(__rhs.tie(nullptr));
	_M_fill = __rhs._M_fill;
	_M_fill_init = __rhs._M_fill_init;
	_M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
	ios_base::_M_swap(__rhs);
	_M_cache_locale(_M_ios_locale);
	__rhs._M_cache_locale(__rhs._M_ios_locale);
	std::swap(_M_tie, __rhs._M_tie);
	std::swap(_M_fill, __rhs._M_fill);
	std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }
#endif
# 508 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3

      void
      _M_cache_locale(const locale& __loc);
    };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if 0 /* expanded by -frewrite-includes */
#include <bits/basic_ios.tcc>
#endif /* expanded by -frewrite-includes */
# 516 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.tcc" 1 3
// basic_ios member functions -*- C++ -*-

// Copyright (C) 1999-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/basic_ios.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */

#ifndef _BASIC_IOS_TCC
#define _BASIC_IOS_TCC 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.tcc" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
	_M_streambuf_state = __state;
      else
	  _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
	__throw_ios_failure(__N("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 292. effects of a.copyfmt (a)
      if (this != &__rhs)
	{
	  // Per 27.1.1, do not call imbue, yet must trash all caches
	  // associated with imbue()

	  // Alloc any new word array first, so if it fails we have "rollback".
	  _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
	                     _M_local_word : new _Words[__rhs._M_word_size];

	  // Bump refs before doing callbacks, for safety.
	  _Callback_list* __cb = __rhs._M_callbacks;
	  if (__cb)
	    __cb->_M_add_reference();
	  _M_call_callbacks(erase_event);
	  if (_M_word != _M_local_word)
	    {
	      delete [] _M_word;
	      _M_word = 0;
	    }
	  _M_dispose_callbacks();

	  // NB: Don't want any added during above.
	  _M_callbacks = __cb;
	  for (int __i = 0; __i < __rhs._M_word_size; ++__i)
	    __words[__i] = __rhs._M_word[__i];
	  _M_word = __words;
	  _M_word_size = __rhs._M_word_size;

	  this->flags(__rhs.flags());
	  this->width(__rhs.width());
	  this->precision(__rhs.precision());
	  this->tie(__rhs.tie());
	  this->fill(__rhs.fill());
	  _M_ios_locale = __rhs.getloc();
	  _M_cache_locale(_M_ios_locale);

	  _M_call_callbacks(copyfmt_event);

	  // The next is required to be the last assignment.
	  this->exceptions(__rhs.exceptions());
	}
      return *this;
    }

  // Locales:
  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
	this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {
      // NB: This may be called more than once on the same object.
      ios_base::_M_init();

      // Cache locale data and specific facets used by iostreams.
      _M_cache_locale(_M_ios_locale);

      // NB: The 27.4.4.1 Postconditions Table specifies requirements
      // after basic_ios::init() has been called. As part of this,
      // fill() must return widen(' ') any time after init() has been
      // called, which needs an imbued ctype facet of char_type to
      // return without throwing an exception. Unfortunately,
      // ctype<char_type> is not necessarily a required facet, so
      // streams with char_type != [char, wchar_t] will not have it by
      // default. Because of this, the correct value for _M_fill is
      // constructed on the first call of fill(). That way,
      // unformatted input and output with non-required basic_ios
      // instantiations is possible even without imbuing the expected
      // ctype<char_type> facet.
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
	_M_ctype = &use_facet<__ctype_type>(__loc);
      else
	_M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
	_M_num_put = &use_facet<__num_put_type>(__loc);
      else
	_M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
	_M_num_get = &use_facet<__num_get_type>(__loc);
      else
	_M_num_get = 0;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template class basic_ios<char>;

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template class basic_ios<wchar_t>;
#endif
# 183 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.tcc" 3
#endif
# 184 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.tcc" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 189 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.tcc" 3
# 517 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 2 3

#endif /* _BASIC_IOS_H */
# 519 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/basic_ios.h" 3
# 45 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 2 3

#endif	/* _GLIBCXX_IOS */
# 47 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ios" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/ostream_insert.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief  Template class basic_ostream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all output streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual output.
  */
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      // Types (inherited from basic_ios):
      typedef _CharT			 		char_type;
      typedef typename _Traits::int_type 		int_type;
      typedef typename _Traits::pos_type 		pos_type;
      typedef typename _Traits::off_type 		off_type;
      typedef _Traits			 		traits_type;

      // Non-standard Types:
      typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type;
      typedef basic_ios<_CharT, _Traits>		__ios_type;
      typedef basic_ostream<_CharT, _Traits>		__ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
      							__num_put_type;
      typedef ctype<_CharT>	      			__ctype_type;

      /**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }

      /**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_ostream() { }

      /// Safe prefix/suffix operations.
      class sentry;
      friend class sentry;

      //@{
      /**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::endl and @c std::hex use these
       *  functions in constructs like "std::cout << std::endl".  For more
       *  information, see the iomanip header.
      */
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// DR 60. What is a formatted input function?
	// The inserters for manipulators are *not* formatted output functions.
	return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// DR 60. What is a formatted input function?
	// The inserters for manipulators are *not* formatted output functions.
	__pf(*this);
	return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// DR 60. What is a formatted input function?
	// The inserters for manipulators are *not* formatted output functions.
	__pf(*this);
	return *this;
      }
      //@}

      //@{
      /**
       *  @name Inserters
       *
       *  All the @c operator<< functions (aka <em>formatted output
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_ostream::sentry.
       *  This can have several effects, concluding with the setting of a
       *  status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */

      //@{
      /**
       *  @brief Integer arithmetic inserters
       *  @param  __n A variable of builtin integral type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<unsigned long>(__n));
      }

#ifdef _GLIBCXX_USE_LONG_LONG
      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
#endif
# 208 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3
      //@}

      //@{
      /**
       *  @brief  Floating point arithmetic inserters
       *  @param  __f A variable of builtin floating point type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 117. basic_ostream uses nonexistent num_put member functions.
	return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
      //@}

      /**
       *  @brief  Pointer arithmetic inserters
       *  @param  __p A variable of pointer type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }

      /**
       *  @brief  Extracting from another streambuf.
       *  @param  __sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @p __sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from @p __sb and inserted into @c *this
       *  until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output sequence fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs while getting a character from @p __sb, which
       *    sets failbit in the error state
       *
       *  If the function inserts no characters, failbit is set.
      */
      __ostream_type&
      operator<<(__streambuf_type* __sb);
      //@}

      //@{
      /**
       *  @name Unformatted Output Functions
       *
       *  All the unformatted output functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_ostream::sentry.  This has several effects, concluding
       *  with the setting of a status flag; see the sentry documentation
       *  for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state.  If badbit is on in
       *  the stream's exceptions mask, the exception will be rethrown
       *  without completing its actions.
      */

      /**
       *  @brief  Simple insertion.
       *  @param  __c  The character to insert.
       *  @return  *this
       *
       *  Tries to insert @p __c.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __ostream_type&
      put(char_type __c);

      /**
       *  @brief  Core write functionality, without sentry.
       *  @param  __s  The array to insert.
       *  @param  __n  Maximum number of characters to insert.
      */
      void
      _M_write(const char_type* __s, streamsize __n)
      {
	const streamsize __put = this->rdbuf()->sputn(__s, __n);
	if (__put != __n)
	  this->setstate(ios_base::badbit);
      }

      /**
       *  @brief  Character string insertion.
       *  @param  __s  The array to insert.
       *  @param  __n  Maximum number of characters to insert.
       *  @return  *this
       *
       *  Characters are copied from @p __s and inserted into the stream until
       *  one of the following happens:
       *
       *  - @p __n characters are inserted
       *  - inserting into the output sequence fails (in this case, badbit
       *    will be set in the stream's error state)
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __ostream_type&
      write(const char_type* __s, streamsize __n);
      //@}

      /**
       *  @brief  Synchronizing the stream buffer.
       *  @return  *this
       *
       *  If @c rdbuf() is a null pointer, changes nothing.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit.
      */
      __ostream_type&
      flush();

      /**
       *  @brief  Getting the current write position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).
      */
      pos_type
      tellp();

      /**
       *  @brief  Changing the current write position.
       *  @param  __pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
       *  that function fails, sets failbit.
      */
      __ostream_type&
      seekp(pos_type);

      /**
       *  @brief  Changing the current write position.
       *  @param  __off  A file offset object.
       *  @param  __dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
       *  If that function fails, sets failbit.
      */
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

#if __cplusplus >= 201103L
      // Non-standard constructor that does not call init()
      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }

      // 27.7.3.3 Assign/swap

      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
	swap(__rhs);
	return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }
#endif
# 412 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3

      template<typename _ValueT>
	__ostream_type&
	_M_insert(_ValueT __v);
    };

  /**
   *  @brief  Performs setup work for output streams.
   *
   *  Objects of this class are created before all of the standard
   *  inserters are run.  It is responsible for <em>exception-safe prefix and
   *  suffix operations</em>.
  */
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {
      // Data Members.
      bool 				_M_ok;
      basic_ostream<_CharT, _Traits>& 	_M_os;

    public:
      /**
       *  @brief  The constructor performs preparatory work.
       *  @param  __os  The output stream to guard.
       *
       *  If the stream state is good (@a __os.good() is true), then if the
       *  stream is tied to another output stream, @c is.tie()->flush()
       *  is called to synchronize the output sequences.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      */
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

      /**
       *  @brief  Possibly flushes the stream.
       *
       *  If @c ios_base::unitbuf is set in @c os.flags(), and
       *  @c std::uncaught_exception() is true, the sentry destructor calls
       *  @c flush() on the output stream.
      */
      ~sentry()
      {
	// XXX MT
	if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
	  {
	    // Can't call flush directly or else will get into recursive lock.
	    if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
	      _M_os.setstate(ios_base::badbit);
	  }
      }

      /**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */
#if __cplusplus >= 201103L
      explicit
#endif
# 475 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3
      operator bool() const
      { return _M_ok; }
    };

  //@{
  /**
   *  @brief  Character inserters
   *  @param  __out  An output stream.
   *  @param  __c  A character.
   *  @return  out
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts a single character and any required
   *  padding (as determined by [22.2.2.2.2]).  @c __out.width(0) is then
   *  called.
   *
   *  If @p __c is of type @c char and the character type of the stream is not
   *  @c char, the character is widened before insertion.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }

  // Specialization
  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }

  // Signed and unsigned
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
  //@}

  //@{
  /**
   *  @brief  String inserters
   *  @param  __out  An output stream.
   *  @param  __s  A character string.
   *  @return  out
   *  @pre  @p __s must be a non-NULL pointer
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts @c traits::length(__s) characters starting
   *  at @p __s, widened if necessary, followed by any required padding (as
   *  determined by [22.2.2.2.2]).  @c __out.width(0) is then called.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
			 static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);

  // Partial specializations
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	__ostream_insert(__out, __s,
			 static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  // Signed and unsigned
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  //@}

  // Standard basic_ostream manipulators

  /**
   *  @brief  Write a newline and flush the stream.
   *
   *  This manipulator is often mistakenly used when a simple newline is
   *  desired, leading to poor buffering performance.  See
   *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
   *  for more on this subject.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }

  /**
   *  @brief  Write a null character into the output sequence.
   *
   *  <em>Null character</em> is @c CharT() by definition.  For CharT
   *  of @c char, this correctly writes the ASCII @c NUL character
   *  string terminator.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }

  /**
   *  @brief  Flushes the output stream.
   *
   *  This manipulator simply calls the stream's @c flush() member function.
  */
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

#if __cplusplus >= 201103L
  /**
   *  @brief  Generic inserter for rvalue stream
   *  @param  __os  An input stream.
   *  @param  __x  A reference to the object being inserted.
   *  @return  os
   *
   *  This is just a forwarding function to allow insertion to
   *  rvalue streams since they won't bind to the inserter functions
   *  that take an lvalue reference.
  */
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    {
      __os << __x;
      return __os;
    }
#endif // C++11
# 634 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#if 0 /* expanded by -frewrite-includes */
#include <bits/ostream.tcc>
#endif /* expanded by -frewrite-includes */
# 638 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 1 3
// ostream classes -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/ostream.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ostream}
 */

//
// ISO C++ 14882: 27.6.2  Output streams
//

#ifndef _OSTREAM_TCC
#define _OSTREAM_TCC 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/cxxabi_forced.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {
      // XXX MT
      if (__os.tie() && __os.good())
	__os.tie()->flush();

      if (__os.good())
	_M_ok = true;
      else
	__os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
	sentry __cerb(*this);
	if (__cerb)
	  {
	    ios_base::iostate __err = ios_base::goodbit;
	    __try
	      {
		const __num_put_type& __np = __check_facet(this->_M_num_put);
		if (__np.put(*this, *this, this->fill(), __v).failed())
		  __err |= ios_base::badbit;
	      }
	    __catch(__cxxabiv1::__forced_unwind&)
	      {
		this->_M_setstate(ios_base::badbit);		
		__throw_exception_again;
	      }
	    __catch(...)
	      { this->_M_setstate(ios_base::badbit); }
	    if (__err)
	      this->setstate(__err);
	  }
	return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 117. basic_ostream uses nonexistent num_put member functions.
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
	return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
	return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 117. basic_ostream uses nonexistent num_put member functions.
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
	return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
	return _M_insert(static_cast<long>(__n));
    }
  
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
	{
	  __try
	    {
	      if (!__copy_streambufs(__sbin, this->rdbuf()))
		__err |= ios_base::failbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);		
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::failbit); }
	}
      else if (!__sbin)
	__err |= ios_base::badbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::put(char_type) is an unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      const int_type __put = this->rdbuf()->sputc(__c);
	      if (traits_type::eq_int_type(__put, traits_type::eof()))
		__err |= ios_base::badbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);		
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::write(const char_type*, streamsize) is an
      // unformatted output function.
      // DR 63. Exception-handling policy for unformatted output.
      // Unformatted output functions should catch exceptions thrown
      // from streambuf members.
      sentry __cerb(*this);
      if (__cerb)
	{
	  __try
	    { _M_write(__s, __n); }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);		
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 60. What is a formatted input function?
      // basic_ostream::flush() is *not* an unformatted output function.
      ios_base::iostate __err = ios_base::goodbit;
      __try
	{
	  if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
	    __err |= ios_base::badbit;
	}
      __catch(__cxxabiv1::__forced_unwind&)
	{
	  this->_M_setstate(ios_base::badbit);		
	  __throw_exception_again;
	}
      __catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      __try
	{
	  if (!this->fail())
	    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
	}
      __catch(__cxxabiv1::__forced_unwind&)
	{
	  this->_M_setstate(ios_base::badbit);		
	  __throw_exception_again;
	}
      __catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      __try
	{
	  if (!this->fail())
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 136.  seekp, seekg setting wrong streams?
	      const pos_type __p = this->rdbuf()->pubseekpos(__pos,
							     ios_base::out);

	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
	}
      __catch(__cxxabiv1::__forced_unwind&)
	{
	  this->_M_setstate(ios_base::badbit);		
	  __throw_exception_again;
	}
      __catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      __try
	{
	  if (!this->fail())
	    {
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 136.  seekp, seekg setting wrong streams?
	      const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
							     ios_base::out);

	      // 129. Need error indication from seekp() and seekg()
	      if (__p == pos_type(off_type(-1)))
		__err |= ios_base::failbit;
	    }
	}
      __catch(__cxxabiv1::__forced_unwind&)
	{
	  this->_M_setstate(ios_base::badbit);		
	  __throw_exception_again;
	}
      __catch(...)
	{ this->_M_setstate(ios_base::badbit); }
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
	__out.setstate(ios_base::badbit);
      else
	{
	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
	  // 167.  Improper use of traits_type::length()
	  const size_t __clen = char_traits<char>::length(__s);
	  __try
	    {
	      struct __ptr_guard
	      {
		_CharT *__p;
		__ptr_guard (_CharT *__ip): __p(__ip) { }
		~__ptr_guard() { delete[] __p; }
		_CharT* __get() { return __p; }
	      } __pg (new _CharT[__clen]);

	      _CharT *__ws = __pg.__get();
	      for (size_t  __i = 0; __i < __clen; ++__i)
		__ws[__i] = __out.widen(__s[__i]);
	      __ostream_insert(__out, __ws, __clen);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      __out._M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { __out._M_setstate(ios_base::badbit); }
	}
      return __out;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);
#ifdef _GLIBCXX_USE_LONG_LONG
  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);
#endif
# 377 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3
  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);
#ifdef _GLIBCXX_USE_LONG_LONG
  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);
#endif
# 398 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3
  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);
#endif
# 402 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3
#endif
# 403 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 408 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/ostream.tcc" 3
# 639 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 2 3

#endif	/* _GLIBCXX_OSTREAM */
# 641 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/ostream" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <istream>
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 1 3
// Input streams -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

//
// ISO C++ 14882: 27.6.1  Input streams
//

/** @file include/istream
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_ISTREAM
#define _GLIBCXX_ISTREAM 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3

#if 0 /* expanded by -frewrite-includes */
#include <ios>
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
#if 0 /* expanded by -frewrite-includes */
#include <ostream>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief  Template class basic_istream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all input streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual input.
  */
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      // Types (inherited from basic_ios (27.4.4)):
      typedef _CharT			 		char_type;
      typedef typename _Traits::int_type 		int_type;
      typedef typename _Traits::pos_type 		pos_type;
      typedef typename _Traits::off_type 		off_type;
      typedef _Traits			 		traits_type;

      // Non-standard Types:
      typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type;
      typedef basic_ios<_CharT, _Traits>		__ios_type;
      typedef basic_istream<_CharT, _Traits>		__istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
 							__num_get_type;
      typedef ctype<_CharT>	      			__ctype_type;

    protected:
      // Data Members:
      /**
       *  The number of characters extracted in the previous unformatted
       *  function; see gcount().
      */
      streamsize 		_M_gcount;

    public:
      /**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }

      /**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      */
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }

      /// Safe prefix/suffix operations.
      class sentry;
      friend class sentry;

      //@{
      /**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::ws and @c std::dec use these
       *  functions in constructs like
       *  <code>std::cin >> std::ws</code>.
       *  For more information, see the iomanip header.
      */
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
	__pf(*this);
	return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
	__pf(*this);
	return *this;
      }
      //@}

      //@{
      /**
       *  @name Extractors
       *
       *  All the @c operator>> functions (aka <em>formatted input
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_istream::sentry
       *  with the second argument (noskipws) set to false.  This has several
       *  effects, concluding with the setting of a status flag; see the
       *  sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */

      //@{
      /**
       *  @brief  Integer arithmetic extractors
       *  @param  __n A variable of builtin integral type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      */
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }

#ifdef _GLIBCXX_USE_LONG_LONG
      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
#endif
# 202 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
      //@}

      //@{
      /**
       *  @brief  Floating point arithmetic extractors
       *  @param  __f A variable of builtin floating point type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      */
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
      //@}

      /**
       *  @brief  Basic arithmetic extractors
       *  @param  __p A variable of pointer type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      */
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }

      /**
       *  @brief  Extracting into another streambuf.
       *  @param  __sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @p __sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from this stream and inserted into the
       *  @p __sb streambuf until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs (and in this case is caught)
       *
       *  If the function inserts no characters, failbit is set.
      */
      __istream_type&
      operator>>(__streambuf_type* __sb);
      //@}

      // [27.6.1.3] unformatted input
      /**
       *  @brief  Character counting
       *  @return  The number of characters extracted by the previous
       *           unformatted input function dispatched for this stream.
      */
      streamsize
      gcount() const
      { return _M_gcount; }

      //@{
      /**
       *  @name Unformatted Input Functions
       *
       *  All the unformatted input functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_istream::sentry with the second argument (noskipws)
       *  set to true.  This has several effects, concluding with the
       *  setting of a status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  The number of characters extracted is stored for later retrieval
       *  by gcount().
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */

      /**
       *  @brief  Simple extraction.
       *  @return  A character, or eof().
       *
       *  Tries to extract a character.  If none are available, sets failbit
       *  and returns traits::eof().
      */
      int_type
      get();

      /**
       *  @brief  Simple extraction.
       *  @param  __c  The character in which to store data.
       *  @return  *this
       *
       *  Tries to extract a character and store it in @a __c.  If none are
       *  available, sets failbit and returns traits::eof().
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      get(char_type& __c);

      /**
       *  @brief  Simple multiple-character extraction.
       *  @param  __s  Pointer to an array.
       *  @param  __n  Maximum number of characters to store in @a __s.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and stored into @a __s until one of the
       *  following happens:
       *
       *  - @c __n-1 characters are stored
       *  - the input sequence reaches EOF
       *  - the next character equals @a __delim, in which case the character
       *    is not extracted
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
       *
       * In any case, a null character is stored into the next location in
       * the array.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);

      /**
       *  @brief  Simple multiple-character extraction.
       *  @param  __s  Pointer to an array.
       *  @param  __n  Maximum number of characters to store in @a s.
       *  @return  *this
       *
       *  Returns @c get(__s,__n,widen(&apos;\\n&apos;)).
      */
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }

      /**
       *  @brief  Extraction into another streambuf.
       *  @param  __sb  A streambuf in which to store data.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and inserted into @a __sb until one of the
       *  following happens:
       *
       *  - the input sequence reaches EOF
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted)
       *  - the next character equals @a __delim (in this case, the character
       *    is not extracted)
       *  - an exception occurs (and in this case is caught)
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
      */
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);

      /**
       *  @brief  Extraction into another streambuf.
       *  @param  __sb  A streambuf in which to store data.
       *  @return  *this
       *
       *  Returns @c get(__sb,widen(&apos;\\n&apos;)).
      */
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }

      /**
       *  @brief  String extraction.
       *  @param  __s  A character array in which to store the data.
       *  @param  __n  Maximum number of characters to extract.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts and stores characters into @a __s until one of the
       *  following happens.  Note that these criteria are required to be
       *  tested in the order listed here, to allow an input line to exactly
       *  fill the @a __s array without setting failbit.
       *
       *  -# the input sequence reaches end-of-file, in which case eofbit
       *     is set in the stream error state
       *  -# the next character equals @c __delim, in which case the character
       *     is extracted (and therefore counted in @c gcount()) but not stored
       *  -# @c __n-1 characters are stored, in which case failbit is set
       *     in the stream error state
       *
       *  If no characters are extracted, failbit is set.  (An empty line of
       *  input should therefore not cause failbit to be set.)
       *
       *  In any case, a null character is stored in the next location in
       *  the array.
      */
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);

      /**
       *  @brief  String extraction.
       *  @param  __s  A character array in which to store the data.
       *  @param  __n  Maximum number of characters to extract.
       *  @return  *this
       *
       *  Returns @c getline(__s,__n,widen(&apos;\\n&apos;)).
      */
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }

      /**
       *  @brief  Discarding characters
       *  @param  __n  Number of characters to discard.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts characters and throws them away until one of the
       *  following happens:
       *  - if @a __n @c != @c std::numeric_limits<int>::max(), @a __n
       *    characters are extracted
       *  - the input sequence reaches end-of-file
       *  - the next character equals @a __delim (in this case, the character
       *    is extracted); note that this condition will never occur if
       *    @a __delim equals @c traits::eof().
       *
       *  NB: Provide three overloads, instead of the single function
       *  (with defaults) mandated by the Standard: this leads to a
       *  better performing implementation, while still conforming to
       *  the Standard.
      */
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();

      /**
       *  @brief  Looking ahead in the stream
       *  @return  The next character, or eof().
       *
       *  If, after constructing the sentry object, @c good() is false,
       *  returns @c traits::eof().  Otherwise reads but does not extract
       *  the next input character.
      */
      int_type
      peek();

      /**
       *  @brief  Extraction without delimiters.
       *  @param  __s  A character array.
       *  @param  __n  Maximum number of characters to store.
       *  @return  *this
       *
       *  If the stream state is @c good(), extracts characters and stores
       *  them into @a __s until one of the following happens:
       *  - @a __n characters are stored
       *  - the input sequence reaches end-of-file, in which case the error
       *    state is set to @c failbit|eofbit.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      */
      __istream_type&
      read(char_type* __s, streamsize __n);

      /**
       *  @brief  Extraction until the buffer is exhausted, but no more.
       *  @param  __s  A character array.
       *  @param  __n  Maximum number of characters to store.
       *  @return  The number of characters extracted.
       *
       *  Extracts characters and stores them into @a __s depending on the
       *  number of characters remaining in the streambuf's buffer,
       *  @c rdbuf()->in_avail(), called @c A here:
       *  - if @c A @c == @c -1, sets eofbit and extracts no characters
       *  - if @c A @c == @c 0, extracts no characters
       *  - if @c A @c > @c 0, extracts @c min(A,n)
       *
       *  The goal is to empty the current buffer, and to not request any
       *  more from the external input sequence controlled by the streambuf.
      */
      streamsize
      readsome(char_type* __s, streamsize __n);

      /**
       *  @brief  Unextracting a single character.
       *  @param  __c  The character to push back into the input stream.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).
       *
       *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      */
      __istream_type&
      putback(char_type __c);

      /**
       *  @brief  Unextracting the previous character.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).
       *
       *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      */
      __istream_type&
      unget();

      /**
       *  @brief  Synchronizing the stream buffer.
       *  @return  0 on success, -1 on failure
       *
       *  If @c rdbuf() is a null pointer, returns -1.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit and returns -1.
       *
       *  Otherwise, returns 0.
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      */
      int
      sync();

      /**
       *  @brief  Getting the current read position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().  At variance with putback, unget and
       *         seekg, eofbit is not cleared first.
      */
      pos_type
      tellg();

      /**
       *  @brief  Changing the current read position.
       *  @param  __pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(__pos).  If
       *  that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      */
      __istream_type&
      seekg(pos_type);

      /**
       *  @brief  Changing the current read position.
       *  @param  __off  A file offset object.
       *  @param  __dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(__off,__dir).
       *  If that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      */
      __istream_type&
      seekg(off_type, ios_base::seekdir);
      //@}

    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

#if __cplusplus >= 201103L
      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
	__ios_type::move(__rhs);
	__rhs._M_gcount = 0;
      }

      // 27.7.3.3 Assign/swap

      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
	swap(__rhs);
	return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
	__ios_type::swap(__rhs);
	std::swap(_M_gcount, __rhs._M_gcount);
      }
#endif
# 638 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3

      template<typename _ValueT>
	__istream_type&
	_M_extract(_ValueT& __v);
    };

  /// Explicit specialization declarations, defined in src/istream.cc.
  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);

#ifdef _GLIBCXX_USE_WCHAR_T
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
#endif
# 676 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3

  /**
   *  @brief  Performs setup work for input streams.
   *
   *  Objects of this class are created before all of the standard
   *  extractors are run.  It is responsible for <em>exception-safe
   *  prefix and suffix operations,</em> although only prefix actions
   *  are currently required by the standard.
  */
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
      // Data Members.
      bool _M_ok;

    public:
      /// Easy access to dependent types.
      typedef _Traits 					traits_type;
      typedef basic_streambuf<_CharT, _Traits> 		__streambuf_type;
      typedef basic_istream<_CharT, _Traits> 		__istream_type;
      typedef typename __istream_type::__ctype_type 	__ctype_type;
      typedef typename _Traits::int_type		__int_type;

      /**
       *  @brief  The constructor performs all the work.
       *  @param  __is  The input stream to guard.
       *  @param  __noskipws  Whether to consume whitespace or not.
       *
       *  If the stream state is good (@a __is.good() is true), then the
       *  following actions are performed, otherwise the sentry state
       *  is false (<em>not okay</em>) and failbit is set in the
       *  stream state.
       *
       *  The sentry's preparatory actions are:
       *
       *  -# if the stream is tied to an output stream, @c is.tie()->flush()
       *     is called to synchronize the output sequence
       *  -# if @a __noskipws is false, and @c ios_base::skipws is set in
       *     @c is.flags(), the sentry extracts and discards whitespace
       *     characters from the stream.  The currently imbued locale is
       *     used to determine whether each character is whitespace.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      */
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);

      /**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */
#if __cplusplus >= 201103L
      explicit
#endif
# 734 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
      operator bool() const
      { return _M_ok; }
    };

  //@{
  /**
   *  @brief  Character extractors
   *  @param  __in  An input stream.
   *  @param  __c  A character reference.
   *  @return  in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts a character (if one is available) and
   *  stores it in @a __c.  Otherwise, sets failbit in the input stream.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  //@}

  //@{
  /**
   *  @brief  Character string extractors
   *  @param  __in  An input stream.
   *  @param  __s  A pointer to a character array.
   *  @return  __in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts up to @c n characters and stores them
   *  into the array starting at @a __s.  @c n is defined as:
   *
   *  - if @c width() is greater than zero, @c n is width() otherwise
   *  - @c n is <em>the number of elements of the largest array of *
   *  - @c char_type that can store a terminating @c eos.</em>
   *  - [27.6.1.2.3]/6
   *
   *  Characters are extracted and stored until one of the following happens:
   *  - @c n-1 characters are stored
   *  - EOF is reached
   *  - the next character is whitespace according to the current locale
   *  - the next character is a null byte (i.e., @c charT() )
   *
   *  @c width(0) is then called for the input stream.
   *
   *  If no characters are extracted, sets failbit.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  // Explicit specialization declaration, defined in src/istream.cc.
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  //@}

  /**
   *  @brief  Template class basic_iostream
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class multiply inherits from the input and output stream classes
   *  simply to provide a single interface.
  */
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 271. basic_iostream missing typedefs
      // Types (inherited):
      typedef _CharT			 		char_type;
      typedef typename _Traits::int_type 		int_type;
      typedef typename _Traits::pos_type 		pos_type;
      typedef typename _Traits::off_type 		off_type;
      typedef _Traits			 		traits_type;

      // Non-standard Types:
      typedef basic_istream<_CharT, _Traits>		__istream_type;
      typedef basic_ostream<_CharT, _Traits>		__ostream_type;

      /**
       *  @brief  Constructor does nothing.
       *
       *  Both of the parent classes are initialized with the same
       *  streambuf pointer passed to this constructor.
      */
      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }

      /**
       *  @brief  Destructor does nothing.
      */
      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }

#if __cplusplus >= 201103L
      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }

      // 27.7.3.3 Assign/swap

      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
	swap(__rhs);
	return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }
#endif
# 884 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
    };

  /**
   *  @brief  Quick and easy way to eat whitespace
   *
   *  This manipulator extracts whitespace characters, stopping when the
   *  next character is non-whitespace, or when the input sequence is empty.
   *  If the sequence is empty, @c eofbit is set in the stream, but not
   *  @c failbit.
   *
   *  The current locale is used to distinguish whitespace characters.
   *
   *  Example:
   *  @code
   *     MyClass   mc;
   *
   *     std::cin >> std::ws >> mc;
   *  @endcode
   *  will skip leading whitespace before calling operator>> on cin and your
   *  object.  Note that the same effect can be achieved by creating a
   *  std::basic_istream::sentry inside your definition of operator>>.
  */
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

#if __cplusplus >= 201103L
  // [27.7.1.6] Rvalue stream extraction
  /**
   *  @brief  Generic extractor for rvalue stream
   *  @param  __is  An input stream.
   *  @param  __x  A reference to the extraction target.
   *  @return  is
   *
   *  This is just a forwarding function to allow extraction from
   *  rvalue streams since they won't bind to the extractor functions
   *  that take an lvalue reference.
  */
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    { 
      __is >> __x;
      return __is;
    }
#endif // C++11
# 930 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if 0 /* expanded by -frewrite-includes */
#include <bits/istream.tcc>
#endif /* expanded by -frewrite-includes */
# 934 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 1 3
// istream classes -*- C++ -*-

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/istream.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{istream}
 */

//
// ISO C++ 14882: 27.6.1  Input streams
//

#ifndef _ISTREAM_TCC
#define _ISTREAM_TCC 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/cxxabi_forced.h>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
	{
	  if (__in.tie())
	    __in.tie()->flush();
	  if (!__noskip && bool(__in.flags() & ios_base::skipws))
	    {
	      const __int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = __in.rdbuf();
	      __int_type __c = __sb->sgetc();

	      const __ctype_type& __ct = __check_facet(__in._M_ctype);
	      while (!traits_type::eq_int_type(__c, __eof)
		     && __ct.is(ctype_base::space, 
				traits_type::to_char_type(__c)))
		__c = __sb->snextc();

	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 195. Should basic_istream::sentry's constructor ever
	      // set eofbit?
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	}

      if (__in.good() && __err == ios_base::goodbit)
	_M_ok = true;
      else
	{
	  __err |= ios_base::failbit;
	  __in.setstate(__err);
	}
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
	sentry __cerb(*this, false);
	if (__cerb)
	  {
	    ios_base::iostate __err = ios_base::goodbit;
	    __try
	      {
		const __num_get_type& __ng = __check_facet(this->_M_num_get);
		__ng.get(*this, 0, *this, __err, __v);
	      }
	    __catch(__cxxabiv1::__forced_unwind&)
	      {
		this->_M_setstate(ios_base::badbit);
		__throw_exception_again;
	      }
	    __catch(...)
	      { this->_M_setstate(ios_base::badbit); }
	    if (__err)
	      this->setstate(__err);
	  }
	return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 118. basic_istream uses nonexistent num_get member functions.
      sentry __cerb(*this, false);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      long __l;
	      const __num_get_type& __ng = __check_facet(this->_M_num_get);
	      __ng.get(*this, 0, *this, __err, __l);

	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 696. istream::operator>>(int&) broken.
	      if (__l < __gnu_cxx::__numeric_traits<short>::__min)
		{
		  __err |= ios_base::failbit;
		  __n = __gnu_cxx::__numeric_traits<short>::__min;
		}
	      else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
		{
		  __err |= ios_base::failbit;
		  __n = __gnu_cxx::__numeric_traits<short>::__max;
		}
	      else
		__n = short(__l);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 118. basic_istream uses nonexistent num_get member functions.
      sentry __cerb(*this, false);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      long __l;
	      const __num_get_type& __ng = __check_facet(this->_M_num_get);
	      __ng.get(*this, 0, *this, __err, __l);

	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 696. istream::operator>>(int&) broken.
	      if (__l < __gnu_cxx::__numeric_traits<int>::__min)
		{
		  __err |= ios_base::failbit;
		  __n = __gnu_cxx::__numeric_traits<int>::__min;
		}
	      else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
		{
		  __err |= ios_base::failbit;	      
		  __n = __gnu_cxx::__numeric_traits<int>::__max;
		}
	      else
		__n = int(__l);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
	{
	  __try
	    {
	      bool __ineof;
	      if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
		__err |= ios_base::failbit;
	      if (__ineof)
		__err |= ios_base::eofbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::failbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::failbit); }
	}
      else if (!__sbout)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  __try
	    {
	      __c = this->rdbuf()->sbumpc();
	      // 27.6.1.1 paragraph 3
	      if (!traits_type::eq_int_type(__c, __eof))
		_M_gcount = 1;
	      else
		__err |= ios_base::eofbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  __try
	    {
	      const int_type __cb = this->rdbuf()->sbumpc();
	      // 27.6.1.1 paragraph 3
	      if (!traits_type::eq_int_type(__cb, traits_type::eof()))
		{
		  _M_gcount = 1;
		  __c = traits_type::to_char_type(__cb);
		}
	      else
		__err |= ios_base::eofbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  __try
	    {
	      const int_type __idelim = traits_type::to_int_type(__delim);
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      int_type __c = __sb->sgetc();

	      while (_M_gcount + 1 < __n
		     && !traits_type::eq_int_type(__c, __eof)
		     && !traits_type::eq_int_type(__c, __idelim))
		{
		  *__s++ = traits_type::to_char_type(__c);
		  ++_M_gcount;
		  __c = __sb->snextc();
		}
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 243. get and getline when sentry reports failure.
      if (__n > 0)
	*__s = char_type();
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  __try
	    {
	      const int_type __idelim = traits_type::to_int_type(__delim);
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __this_sb = this->rdbuf();
	      int_type __c = __this_sb->sgetc();
	      char_type __c2 = traits_type::to_char_type(__c);

	      while (!traits_type::eq_int_type(__c, __eof)
		     && !traits_type::eq_int_type(__c, __idelim)
		     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
		{
		  ++_M_gcount;
		  __c = __this_sb->snextc();
		  __c2 = traits_type::to_char_type(__c);
		}
	      if (traits_type::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      if (!_M_gcount)
	__err |= ios_base::failbit;
      if (__err)
	this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          __try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
          __catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 243. get and getline when sentry reports failure.
      if (__n > 0)
	*__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }

  // We provide three overloads, since the first two are much simpler
  // than the general case. Also, the latter two can thus adopt the
  // same "batchy" strategy used by getline above.
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();

	      if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
		__err |= ios_base::eofbit;
	      else
		_M_gcount = 1;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          __try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

	      // N.B. On LFS-enabled platforms streamsize is still 32 bits
	      // wide: if we want to implement the standard mandated behavior
	      // for n == max() (see 27.6.1.3/24) we are at risk of signed
	      // integer overflow: thus these contortions. Also note that,
	      // by definition, when more than 2G chars are actually ignored,
	      // _M_gcount (the return value of gcount, that is) cannot be
	      // really correct, being unavoidably too small.
	      bool __large_ignore = false;
	      while (true)
		{
		  while (_M_gcount < __n
			 && !traits_type::eq_int_type(__c, __eof))
		    {
		      ++_M_gcount;
		      __c = __sb->snextc();
		    }
		  if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
		      && !traits_type::eq_int_type(__c, __eof))
		    {
		      _M_gcount =
			__gnu_cxx::__numeric_traits<streamsize>::__min;
		      __large_ignore = true;
		    }
		  else
		    break;
		}

	      if (__large_ignore)
		_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

	      if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
          __catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          __try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

	      // See comment above.
	      bool __large_ignore = false;
	      while (true)
		{
		  while (_M_gcount < __n
			 && !traits_type::eq_int_type(__c, __eof)
			 && !traits_type::eq_int_type(__c, __delim))
		    {
		      ++_M_gcount;
		      __c = __sb->snextc();
		    }
		  if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
		      && !traits_type::eq_int_type(__c, __eof)
		      && !traits_type::eq_int_type(__c, __delim))
		    {
		      _M_gcount =
			__gnu_cxx::__numeric_traits<streamsize>::__min;
		      __large_ignore = true;
		    }
		  else
		    break;
		}

	      if (__large_ignore)
		_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
	      else if (traits_type::eq_int_type(__c, __delim))
		{
		  if (_M_gcount
		      < __gnu_cxx::__numeric_traits<streamsize>::__max)
		    ++_M_gcount;
		  __sb->sbumpc();
		}
            }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
          __catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      __c = this->rdbuf()->sgetc();
	      if (traits_type::eq_int_type(__c, traits_type::eof()))
		__err |= ios_base::eofbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      _M_gcount = this->rdbuf()->sgetn(__s, __n);
	      if (_M_gcount != __n)
		__err |= (ios_base::eofbit | ios_base::failbit);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      // Cannot compare int_type with streamsize generically.
	      const streamsize __num = this->rdbuf()->in_avail();
	      if (__num > 0)
		_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
	      else if (__num == -1)
		__err |= ios_base::eofbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 60. What is a formatted input function?
      _M_gcount = 0;
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      if (!__sb
		  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
		__err |= ios_base::badbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 60. What is a formatted input function?
      _M_gcount = 0;
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      const int_type __eof = traits_type::eof();
	      __streambuf_type* __sb = this->rdbuf();
	      if (!__sb
		  || traits_type::eq_int_type(__sb->sungetc(), __eof))
		__err |= ios_base::badbit;
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      __streambuf_type* __sb = this->rdbuf();
	      if (__sb)
		{
		  if (__sb->pubsync() == -1)
		    __err |= ios_base::badbit;
		  else
		    __ret = 0;
		}
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  __try
	    {
	      if (!this->fail())
		__ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
						  ios_base::in);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	}
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      if (!this->fail())
		{
		  // 136.  seekp, seekg setting wrong streams?
		  const pos_type __p = this->rdbuf()->pubseekpos(__pos,
								 ios_base::in);
		  
		  // 129.  Need error indication from seekp() and seekg()
		  if (__p == pos_type(off_type(-1)))
		    __err |= ios_base::failbit;
		}
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR60.  Do not change _M_gcount.
      // Clear eofbit per N3168.
      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      if (!this->fail())
		{
		  // 136.  seekp, seekg setting wrong streams?
		  const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
								 ios_base::in);
	      
		  // 129.  Need error indication from seekp() and seekg()
		  if (__p == pos_type(off_type(-1)))
		    __err |= ios_base::failbit;
		}
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      this->_M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { this->_M_setstate(ios_base::badbit); }
	  if (__err)
	    this->setstate(__err);
	}
      return *this;
    }

  // 27.6.1.2.3 Character extraction templates
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits>		__istream_type;
      typedef typename __istream_type::int_type         __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
	{
	  ios_base::iostate __err = ios_base::goodbit;
	  __try
	    {
	      const __int_type __cb = __in.rdbuf()->sbumpc();
	      if (!_Traits::eq_int_type(__cb, _Traits::eof()))
		__c = _Traits::to_char_type(__cb);
	      else
		__err |= (ios_base::eofbit | ios_base::failbit);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      __in._M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { __in._M_setstate(ios_base::badbit); }
	  if (__err)
	    __in.setstate(__err);
	}
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits>		__istream_type;
      typedef basic_streambuf<_CharT, _Traits>          __streambuf_type;
      typedef typename _Traits::int_type		int_type;
      typedef _CharT					char_type;
      typedef ctype<_CharT>				__ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
	{
	  __try
	    {
	      // Figure out how many characters to extract.
	      streamsize __num = __in.width();
	      if (__num <= 0)
		__num = __gnu_cxx::__numeric_traits<streamsize>::__max;

	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

	      const int_type __eof = _Traits::eof();
	      __streambuf_type* __sb = __in.rdbuf();
	      int_type __c = __sb->sgetc();

	      while (__extracted < __num - 1
		     && !_Traits::eq_int_type(__c, __eof)
		     && !__ct.is(ctype_base::space,
				 _Traits::to_char_type(__c)))
		{
		  *__s++ = _Traits::to_char_type(__c);
		  ++__extracted;
		  __c = __sb->snextc();
		}
	      if (_Traits::eq_int_type(__c, __eof))
		__err |= ios_base::eofbit;

	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 68.  Extractors for char* should store null at end
	      *__s = char_type();
	      __in.width(0);
	    }
	  __catch(__cxxabiv1::__forced_unwind&)
	    {
	      __in._M_setstate(ios_base::badbit);
	      __throw_exception_again;
	    }
	  __catch(...)
	    { __in._M_setstate(ios_base::badbit); }
	}
      if (!__extracted)
	__err |= ios_base::failbit;
      if (__err)
	__in.setstate(__err);
      return __in;
    }

  // 27.6.1.4 Standard basic_istream manipulators
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits>		__istream_type;
      typedef basic_streambuf<_CharT, _Traits>          __streambuf_type;
      typedef typename __istream_type::int_type		__int_type;
      typedef ctype<_CharT>				__ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
	     && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
	__c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
	 __in.setstate(ios_base::eofbit);
      return __in;
    }

  // Inhibit implicit instantiations for required instantiations,
  // which are defined via explicit instantiations elsewhere.
#if _GLIBCXX_EXTERN_TEMPLATE
  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);  
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);
#ifdef _GLIBCXX_USE_LONG_LONG
  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);
#endif
# 1058 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3
  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;

#ifdef _GLIBCXX_USE_WCHAR_T
  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);  
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);
#ifdef _GLIBCXX_USE_LONG_LONG
  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);
#endif
# 1080 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3
  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;
#endif
# 1087 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3
#endif
# 1088 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif
# 1093 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/istream.tcc" 3
# 935 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 2 3

#endif	/* _GLIBCXX_ISTREAM */
# 937 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/istream" 3
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 2 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @name Standard Stream Objects
   *
   *  The &lt;iostream&gt; header declares the eight <em>standard stream
   *  objects</em>.  For other declarations, see
   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/io.html
   *  and the @link iosfwd I/O forward declarations @endlink
   *
   *  They are required by default to cooperate with the global C
   *  library's @c FILE streams, and to be available during program
   *  startup and termination. For more information, see the section of the
   *  manual linked to above.
  */
  //@{
  extern istream cin;		/// Linked to standard input
  extern ostream cout;		/// Linked to standard output
  extern ostream cerr;		/// Linked to standard error (unbuffered)
  extern ostream clog;		/// Linked to standard error (buffered)

#ifdef _GLIBCXX_USE_WCHAR_T
  extern wistream wcin;		/// Linked to standard input
  extern wostream wcout;	/// Linked to standard output
  extern wostream wcerr;	/// Linked to standard error (unbuffered)
  extern wostream wclog;	/// Linked to standard error (buffered)
#endif
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 3
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _GLIBCXX_IOSTREAM */
# 80 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/iostream" 3
# 10 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include <assert.h>
#endif /* expanded by -frewrite-includes */
# 10 "CpfRetentionStrategy.cc"
# 1 "/usr/include/assert.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2001,2003,2004,2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */

#ifdef	_ASSERT_H

# undef	_ASSERT_H
# undef	assert
# undef __ASSERT_VOID_CAST

# ifdef	__USE_GNU
#  undef assert_perror
# endif
# 33 "/usr/include/assert.h" 3 4

#endif /* assert.h	*/
# 35 "/usr/include/assert.h" 3 4

#define	_ASSERT_H	1
#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/assert.h" 3 4
# 38 "/usr/include/assert.h" 3 4

#if defined __cplusplus && __GNUC_PREREQ (2,95)
# define __ASSERT_VOID_CAST static_cast<void>
#else
# 42 "/usr/include/assert.h" 3 4
# define __ASSERT_VOID_CAST (void)
#endif
# 44 "/usr/include/assert.h" 3 4

/* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */

#ifdef	NDEBUG

# define assert(expr)		(__ASSERT_VOID_CAST (0))

/* void assert_perror (int errnum);

   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
   error message with the error text for ERRNUM and abort.
   (This is a GNU extension.) */

# ifdef	__USE_GNU
#  define assert_perror(errnum)	(__ASSERT_VOID_CAST (0))
# endif
# 63 "/usr/include/assert.h" 3 4

#else /* Not NDEBUG.  */
# 65 "/usr/include/assert.h" 3 4

__BEGIN_DECLS

/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (__const char *__assertion, __const char *__file,
			   unsigned int __line, __const char *__function)
     __THROW __attribute__ ((__noreturn__));

/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, __const char *__file,
				  unsigned int __line,
				  __const char *__function)
     __THROW __attribute__ ((__noreturn__));


/* The following is not at all used here but needed for standard
   compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
     __THROW __attribute__ ((__noreturn__));


__END_DECLS

# define assert(expr)							\
  ((expr)								\
   ? __ASSERT_VOID_CAST (0)						\
   : __assert_fail (__STRING(expr), __FILE__, __LINE__, __ASSERT_FUNCTION))

# ifdef	__USE_GNU
#  define assert_perror(errnum)						\
  (!(errnum)								\
   ? __ASSERT_VOID_CAST (0)						\
   : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))
# endif
# 99 "/usr/include/assert.h" 3 4

/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */
# if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
#   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
# else
# 108 "/usr/include/assert.h" 3 4
#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#   define __ASSERT_FUNCTION	__func__
#  else
# 111 "/usr/include/assert.h" 3 4
#   define __ASSERT_FUNCTION	((__const char *) 0)
#  endif
# 113 "/usr/include/assert.h" 3 4
# endif
# 114 "/usr/include/assert.h" 3 4

#endif /* NDEBUG.  */
# 116 "/usr/include/assert.h" 3 4
# 11 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "CpfRetentionStrategy.hh"
#endif /* expanded by -frewrite-includes */
# 11 "CpfRetentionStrategy.cc"
# 1 "./CpfRetentionStrategy.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author : Rajaditya Mukherjee

#ifndef _CPF_RETENTIONSTRATEGY_HH__
#define _CPF_RETENTIONSTRATEGY_HH__

#if 0 /* expanded by -frewrite-includes */
#include "UpfCommandInterface.hh"
#endif /* expanded by -frewrite-includes */
# 11 "./CpfRetentionStrategy.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

///@file UpfCommandInterface.hh
///This file will provide the interface to access all the UPF command
///information.

#ifndef  __UpfCommandInterface_hh__
#define  __UpfCommandInterface_hh__

#if 0 /* expanded by -frewrite-includes */
#include "UpfObj.hh"
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
#ifndef __UpfObj_hh__
#define __UpfObj_hh__

#if 0 /* expanded by -frewrite-includes */
#include "UpfTypeDef.hh"
#endif /* expanded by -frewrite-includes */
# 9 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
#ifndef __UpfTypeDef_hh__
#define __UpfTypeDef_hh__

#if 0 /* expanded by -frewrite-includes */
#include "list.hh"
#endif /* expanded by -frewrite-includes */
# 9 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh" 1
// synOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

// Copyright (C) 1995-1997 Radiant Design Tools.  All Rights Reserved.
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

#ifndef _LIST_HH_
#define _LIST_HH_

#ifndef _UTIL_HH_
#if 0 /* expanded by -frewrite-includes */
#    include "util.hh"
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 1
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

#ifndef _UTIL_HH_
#define _UTIL_HH_

#ifdef ENGINEER
#if 0 /* expanded by -frewrite-includes */
#include <stdlib.h>
#endif /* expanded by -frewrite-includes */
# 9 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 10 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
#endif
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
#if 0 /* expanded by -frewrite-includes */
#include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
#if 0 /* expanded by -frewrite-includes */
#include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/usr/include/stdio.h" 1 3 4
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */

#ifndef _STDIO_H

#if !defined __need_FILE && !defined __need___FILE
# define _STDIO_H	1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/stdio.h" 3 4
# 29 "/usr/include/stdio.h" 3 4

__BEGIN_DECLS

# define __need_size_t
# define __need_NULL
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/stdio.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 35 "/usr/include/stdio.h" 2 3 4

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 36 "/usr/include/stdio.h" 3 4
# 37 "/usr/include/stdio.h" 3 4
# define __need_FILE
# define __need___FILE
#endif /* Don't need FILE.  */
# 40 "/usr/include/stdio.h" 3 4


#if !defined __FILE_defined && defined __need_FILE

/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;

__BEGIN_NAMESPACE_STD
/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;
__END_NAMESPACE_STD
#if defined __USE_LARGEFILE64 || defined __USE_SVID || defined __USE_POSIX \
    || defined __USE_BSD || defined __USE_ISOC99 || defined __USE_XOPEN \
    || defined __USE_POSIX2
__USING_NAMESPACE_STD(FILE)
#endif
# 56 "/usr/include/stdio.h" 3 4

# define __FILE_defined	1
#endif /* FILE not defined.  */
# 59 "/usr/include/stdio.h" 3 4
#undef	__need_FILE


#if !defined ____FILE_defined && defined __need___FILE

/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;

# define ____FILE_defined	1
#endif /* __FILE not defined.  */
# 69 "/usr/include/stdio.h" 3 4
#undef	__need___FILE


#ifdef	_STDIO_H
#define _STDIO_USES_IOSTREAM

#if 0 /* expanded by -frewrite-includes */
#include <libio.h>
#endif /* expanded by -frewrite-includes */
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
/* Copyright (C) 1991-1995,1997-2006,2007,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Per Bothner <bothner@cygnus.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.

   As a special exception, if you link the code in this file with
   files compiled with a GNU compiler to produce an executable,
   that does not cause the resulting executable to be covered by
   the GNU Lesser General Public License.  This exception does not
   however invalidate any other reasons why the executable file
   might be covered by the GNU Lesser General Public License.
   This exception applies to code released by its copyright holders
   in files containing the exception.  */

#ifndef _IO_STDIO_H
#define _IO_STDIO_H

#if 0 /* expanded by -frewrite-includes */
#include <_G_config.h>
#endif /* expanded by -frewrite-includes */
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
/* This file is needed by libio to define various configuration parameters.
   These are always the same in the GNU C library.  */

#ifndef _G_config_h
#define _G_config_h 1

/* Define types for libio in terms of the standard internal type names.  */

#if 0 /* expanded by -frewrite-includes */
#include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 9 "/usr/include/_G_config.h" 3 4
# 10 "/usr/include/_G_config.h" 3 4
#define __need_size_t
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
# define __need_wchar_t
#endif
# 14 "/usr/include/_G_config.h" 3 4
#define __need_NULL
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 16 "/usr/include/_G_config.h" 2 3 4
#define __need_mbstate_t
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
# define __need_wint_t
#endif
# 20 "/usr/include/_G_config.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <wchar.h>
#endif /* expanded by -frewrite-includes */
# 20 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
/* Copyright (C) 1995-2008, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */

#ifndef _WCHAR_H

#if !defined __need_mbstate_t && !defined __need_wint_t
# define _WCHAR_H 1
#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/wchar.h" 3 4
# 29 "/usr/include/wchar.h" 3 4
#endif
# 30 "/usr/include/wchar.h" 3 4

#ifdef _WCHAR_H
/* Get FILE definition.  */
# define __need___FILE
# if defined __USE_UNIX98 || defined __USE_XOPEN2K
#  define __need_FILE
# endif
# 37 "/usr/include/wchar.h" 3 4
#if 0 /* expanded by -frewrite-includes */
# include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/wchar.h" 3 4
# 38 "/usr/include/wchar.h" 3 4
/* Get va_list definition.  */
# define __need___va_list
#if 0 /* expanded by -frewrite-includes */
# include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 40 "/usr/include/wchar.h" 3 4
# 41 "/usr/include/wchar.h" 3 4

#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/wchar.h" 3 4
# 43 "/usr/include/wchar.h" 3 4

/* Get size_t, wchar_t, wint_t and NULL from <stddef.h>.  */
# define __need_size_t
# define __need_wchar_t
# define __need_NULL
#endif
# 49 "/usr/include/wchar.h" 3 4
#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__
# undef __need_wint_t
# define __need_wint_t
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 52 "/usr/include/wchar.h" 3 4
# 53 "/usr/include/wchar.h" 3 4

/* We try to get wint_t from <stddef.h>, but not all GCC versions define it
   there.  So define it ourselves if it remains undefined.  */
# ifndef _WINT_T
/* Integral type unchanged by default argument promotions that can
   hold any value corresponding to members of the extended character
   set, as well as at least one value that does not correspond to any
   member of the extended character set.  */
#  define _WINT_T
typedef unsigned int wint_t;
# else
# 64 "/usr/include/wchar.h" 3 4
/* Work around problems with the <stddef.h> file which doesn't put
   wint_t in the std namespace.  */
#  if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES \
      && defined __WINT_TYPE__
__BEGIN_NAMESPACE_STD
typedef __WINT_TYPE__ wint_t;
__END_NAMESPACE_STD
#  endif
# 72 "/usr/include/wchar.h" 3 4
# endif
# 73 "/usr/include/wchar.h" 3 4

/* Tell the caller that we provide correct C++ prototypes.  */
# if defined __cplusplus && __GNUC_PREREQ (4, 4)
#  define __CORRECT_ISO_CPP_WCHAR_H_PROTO
# endif
# 78 "/usr/include/wchar.h" 3 4
#endif
# 79 "/usr/include/wchar.h" 3 4

#if (defined _WCHAR_H || defined __need_mbstate_t) && !defined __mbstate_t_defined
# define __mbstate_t_defined	1
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
# ifdef __WINT_TYPE__
    __WINT_TYPE__ __wch;
# else
# 91 "/usr/include/wchar.h" 3 4
    wint_t __wch;
# endif
# 93 "/usr/include/wchar.h" 3 4
    char __wchb[4];
  } __value;		/* Value so far.  */
} __mbstate_t;
#endif
# 97 "/usr/include/wchar.h" 3 4
#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
#ifdef _WCHAR_H

__BEGIN_NAMESPACE_C99
/* Public type.  */
typedef __mbstate_t mbstate_t;
__END_NAMESPACE_C99
#ifdef __USE_GNU
__USING_NAMESPACE_C99(mbstate_t)
#endif
# 111 "/usr/include/wchar.h" 3 4

#ifndef WCHAR_MIN
/* These constants might also be defined in <inttypes.h>.  */
# define WCHAR_MIN __WCHAR_MIN
# define WCHAR_MAX __WCHAR_MAX
#endif
# 117 "/usr/include/wchar.h" 3 4

#ifndef WEOF
# define WEOF (0xffffffffu)
#endif
# 121 "/usr/include/wchar.h" 3 4

/* For XPG4 compliance we have to define the stuff from <wctype.h> here
   as well.  */
#if defined __USE_XOPEN && !defined __USE_UNIX98
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 125 "/usr/include/wchar.h" 3 4
# 126 "/usr/include/wchar.h" 3 4
#endif
# 127 "/usr/include/wchar.h" 3 4


__BEGIN_DECLS

__BEGIN_NAMESPACE_STD
/* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  */
struct tm;
__END_NAMESPACE_STD
/* XXX We have to clean this up at some point.  Since tm is in the std
   namespace but wcsftime is in __c99 the type wouldn't be found
   without inserting it in the global namespace.  */
__USING_NAMESPACE_STD(tm)


__BEGIN_NAMESPACE_STD
/* Copy SRC to DEST.  */
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Copy no more than N wide-characters of SRC to DEST.  */
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Append SRC onto DEST.  */
extern wchar_t *wcscat (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;
/* Append no more than N wide-characters of SRC onto DEST.  */
extern wchar_t *wcsncat (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Compare S1 and S2.  */
extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     __THROW __attribute_pure__;
/* Compare N wide-characters of S1 and S2.  */
extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Compare S1 and S2, ignoring case.  */
extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
			size_t __n) __THROW;

/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 177 "/usr/include/wchar.h" 3 4
# 178 "/usr/include/wchar.h" 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			 __locale_t __loc) __THROW;

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
			  size_t __n, __locale_t __loc) __THROW;
#endif
# 185 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  */
extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) __THROW;
/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm (wchar_t *__restrict __s1,
		       __const wchar_t *__restrict __s2, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */

/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  */
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
		      __locale_t __loc) __THROW;

/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */
extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
			 size_t __n, __locale_t __loc) __THROW;

/* Duplicate S, returning an identical malloc'd string.  */
extern wchar_t *wcsdup (__const wchar_t *__s) __THROW __attribute_malloc__;
#endif
# 215 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Find the first occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcschr") __attribute_pure__;
#else
# 224 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 227 "/usr/include/wchar.h" 3 4
/* Find the last occurrence of WC in WCS.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __asm ("wcsrchr") __attribute_pure__;
#else
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 237 "/usr/include/wchar.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  */
extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     __THROW __attribute_pure__;
#endif
# 245 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  */
extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     __THROW __attribute_pure__;
/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  */
extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
/* Find the first occurrence in WCS of any character in ACCEPT.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
				       __const wchar_t *__accept)
     __THROW __asm ("wcspbrk") __attribute_pure__;
#else
# 263 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     __THROW __attribute_pure__;
#endif
# 266 "/usr/include/wchar.h" 3 4
/* Find the first occurrence of NEEDLE in HAYSTACK.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcsstr") __attribute_pure__;
#else
# 274 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
#endif
# 277 "/usr/include/wchar.h" 3 4

/* Divide WCS into tokens separated by characters in DELIM.  */
extern wchar_t *wcstok (wchar_t *__restrict __s,
			__const wchar_t *__restrict __delim,
			wchar_t **__restrict __ptr) __THROW;

/* Return the number of wide characters in S.  */
extern size_t wcslen (__const wchar_t *__s) __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN
/* Another name for `wcsstr' from XPG4.  */
# ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
				      __const wchar_t *__needle)
     __THROW __asm ("wcswcs") __attribute_pure__;
# else
# 296 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     __THROW __attribute_pure__;
# endif
# 299 "/usr/include/wchar.h" 3 4
#endif
# 300 "/usr/include/wchar.h" 3 4

#ifdef __USE_XOPEN2K8
/* Return the number of wide characters in S, but at most MAXLEN.  */
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     __THROW __attribute_pure__;
#endif
# 306 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Search N wide characters of S for C.  */
#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
				       size_t __n)
     __THROW __asm ("wmemchr") __attribute_pure__;
#else
# 317 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     __THROW __attribute_pure__;
#endif
# 320 "/usr/include/wchar.h" 3 4

/* Compare N wide characters of S1 and S2.  */
extern int wmemcmp (__const wchar_t *__restrict __s1,
		    __const wchar_t *__restrict __s2, size_t __n)
     __THROW __attribute_pure__;

/* Copy N wide characters of SRC to DEST.  */
extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
			 __const wchar_t *__restrict __s2, size_t __n) __THROW;

/* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     __THROW;

/* Set N wide characters of S to C.  */
extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  */
extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
			  __const wchar_t *__restrict __s2, size_t __n)
     __THROW;
#endif
# 346 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Determine whether C constitutes a valid (one-byte) multibyte
   character.  */
extern wint_t btowc (int __c) __THROW;

/* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) __THROW;

/* Determine whether PS points to an object representing the initial
   state.  */
extern int mbsinit (__const mbstate_t *__ps) __THROW __attribute_pure__;

/* Write wide character representation of multibyte character pointed
   to by S to PWC.  */
extern size_t mbrtowc (wchar_t *__restrict __pwc,
		       __const char *__restrict __s, size_t __n,
		       mbstate_t *__p) __THROW;

/* Write multibyte representation of wide character WC to S.  */
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
		       mbstate_t *__restrict __ps) __THROW;

/* Return number of bytes in multibyte character pointed to by S.  */
extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
			mbstate_t *__restrict __ps) __THROW;
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
		      mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_EXTERN_INLINES
/* Define inline function as optimization.  */

/* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  */
extern wint_t __btowc_alias (int __c) __asm ("btowc");
__extern_inline wint_t
__NTH (btowc (int __c))
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
	  ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
__extern_inline int
__NTH (wctob (wint_t __wc))
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
	  ? (int) __wc : __wctob_alias (__wc)); }

__extern_inline size_t
__NTH (mbrlen (__const char *__restrict __s, size_t __n,
	       mbstate_t *__restrict __ps))
{ return (__ps != NULL
	  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL)); }
#endif
# 402 "/usr/include/wchar.h" 3 4

__BEGIN_NAMESPACE_STD
/* Write wide character representation of multibyte character string
   SRC to DST.  */
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
			 __const char **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of wide character string
   SRC to DST.  */
extern size_t wcsrtombs (char *__restrict __dst,
			 __const wchar_t **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD


#ifdef	__USE_XOPEN2K8
/* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  */
extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
			  __const char **__restrict __src, size_t __nmc,
			  size_t __len, mbstate_t *__restrict __ps) __THROW;

/* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  */
extern size_t wcsnrtombs (char *__restrict __dst,
			  __const wchar_t **__restrict __src,
			  size_t __nwc, size_t __len,
			  mbstate_t *__restrict __ps) __THROW;
#endif	/* use POSIX 2008 */
# 432 "/usr/include/wchar.h" 3 4


/* The following functions are extensions found in X/Open CAE.  */
#ifdef __USE_XOPEN
/* Determine number of column positions required for C.  */
extern int wcwidth (wchar_t __c) __THROW;

/* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  */
extern int wcswidth (__const wchar_t *__s, size_t __n) __THROW;
#endif	/* Use X/Open.  */
# 443 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of the wide string NPTR to `double'
   representation.  */
extern double wcstod (__const wchar_t *__restrict __nptr,
		      wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float wcstof (__const wchar_t *__restrict __nptr,
		     wchar_t **__restrict __endptr) __THROW;
extern long double wcstold (__const wchar_t *__restrict __nptr,
			    wchar_t **__restrict __endptr) __THROW;
__END_NAMESPACE_C99
#endif /* C99 */
# 461 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Convert initial portion of wide string NPTR to `long int'
   representation.  */
extern long int wcstol (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, int __base) __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  */
extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
				  wchar_t **__restrict __endptr, int __base)
     __THROW;
__END_NAMESPACE_STD

#if defined __USE_ISOC99 || (defined __GNUC__ && defined __USE_GNU)
__BEGIN_NAMESPACE_C99
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
					wchar_t **__restrict __endptr,
					int __base) __THROW;
__END_NAMESPACE_C99
#endif /* ISO C99 or GCC and GNU.  */
# 493 "/usr/include/wchar.h" 3 4

#if defined __GNUC__ && defined __USE_GNU
/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */
__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
			     wchar_t **__restrict __endptr, int __base)
     __THROW;

/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */
__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
				       wchar_t **__restrict __endptr,
				       int __base) __THROW;
#endif /* GCC and use GNU.  */
# 509 "/usr/include/wchar.h" 3 4

#ifdef __USE_GNU
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 524 "/usr/include/wchar.h" 3 4
# 525 "/usr/include/wchar.h" 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
			  wchar_t **__restrict __endptr, int __base,
			  __locale_t __loc) __THROW;

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
				    wchar_t **__restrict __endptr,
				    int __base, __locale_t __loc) __THROW;

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
				wchar_t **__restrict __endptr,
				int __base, __locale_t __loc) __THROW;

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
					  wchar_t **__restrict __endptr,
					  int __base, __locale_t __loc)
     __THROW;

extern double wcstod_l (__const wchar_t *__restrict __nptr,
			wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern float wcstof_l (__const wchar_t *__restrict __nptr,
		       wchar_t **__restrict __endptr, __locale_t __loc)
     __THROW;

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
			      wchar_t **__restrict __endptr,
			      __locale_t __loc) __THROW;


/* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  */
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
			__const wchar_t *__restrict __src) __THROW;

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
			 __const wchar_t *__restrict __src, size_t __n)
     __THROW;
#endif	/* use GNU */
# 571 "/usr/include/wchar.h" 3 4


/* Wide character I/O functions.  */

#ifdef	__USE_XOPEN2K8
/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  */
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __THROW;
#endif
# 580 "/usr/include/wchar.h" 3 4

#if defined __USE_ISOC95 || defined __USE_UNIX98
__BEGIN_NAMESPACE_STD

/* Select orientation for stream.  */
extern int fwide (__FILE *__fp, int __mode) __THROW;


/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwprintf (__FILE *__restrict __stream,
		     __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 2, 3))) */;
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wprintf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wprintf__, 1, 2))) */;
/* Write formatted output of at most N characters to S.  */
extern int swprintf (wchar_t *__restrict __s, size_t __n,
		     __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 4))) */;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwprintf (__FILE *__restrict __s,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 2, 0))) */;
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwprintf (__const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wprintf__, 1, 0))) */;
/* Write formatted output of at most N character to S from argument
   list ARG.  */
extern int vswprintf (wchar_t *__restrict __s, size_t __n,
		      __const wchar_t *__restrict __format,
		      __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wprintf__, 3, 0))) */;


/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fwscanf (__FILE *__restrict __stream,
		    __const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int wscanf (__const wchar_t *__restrict __format, ...)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
/* Read formatted input from S.  */
extern int swscanf (__const wchar_t *__restrict __s,
		    __const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;

# if defined __USE_ISOC99 && !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_fwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
extern int __REDIRECT (wscanf, (__const wchar_t *__restrict __format, ...),
		       __isoc99_wscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 2))) */;
extern int __REDIRECT (swscanf, (__const wchar_t *__restrict __s,
				 __const wchar_t *__restrict __format, ...),
		       __isoc99_swscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
#  else
# 666 "/usr/include/wchar.h" 3 4
extern int __isoc99_fwscanf (__FILE *__restrict __stream,
			     __const wchar_t *__restrict __format, ...);
extern int __isoc99_wscanf (__const wchar_t *__restrict __format, ...);
extern int __isoc99_swscanf (__const wchar_t *__restrict __s,
			     __const wchar_t *__restrict __format, ...)
     __THROW;
#   define fwscanf __isoc99_fwscanf
#   define wscanf __isoc99_wscanf
#   define swscanf __isoc99_swscanf
#  endif
# 676 "/usr/include/wchar.h" 3 4
# endif
# 677 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_STD
#endif /* Use ISO C95, C99 and Unix98. */
# 680 "/usr/include/wchar.h" 3 4

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfwscanf (__FILE *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vwscanf (__const wchar_t *__restrict __format,
		    __gnuc_va_list __arg)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
/* Read formatted input from S into argument list ARG.  */
extern int vswscanf (__const wchar_t *__restrict __s,
		     __const wchar_t *__restrict __format,
		     __gnuc_va_list __arg)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;

# if !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
extern int __REDIRECT (vfwscanf, (__FILE *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vfwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
extern int __REDIRECT (vwscanf, (__const wchar_t *__restrict __format,
				 __gnuc_va_list __arg), __isoc99_vwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 1, 0))) */;
extern int __REDIRECT (vswscanf, (__const wchar_t *__restrict __s,
				  __const wchar_t *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vswscanf)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 0))) */;
#  else
# 720 "/usr/include/wchar.h" 3 4
extern int __isoc99_vfwscanf (__FILE *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg);
extern int __isoc99_vwscanf (__const wchar_t *__restrict __format,
			     __gnuc_va_list __arg);
extern int __isoc99_vswscanf (__const wchar_t *__restrict __s,
			      __const wchar_t *__restrict __format,
			      __gnuc_va_list __arg) __THROW;
#   define vfwscanf __isoc99_vfwscanf
#   define vwscanf __isoc99_vwscanf
#   define vswscanf __isoc99_vswscanf
#  endif
# 732 "/usr/include/wchar.h" 3 4
# endif
# 733 "/usr/include/wchar.h" 3 4

__END_NAMESPACE_C99
#endif /* Use ISO C99. */
# 736 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t getwchar (void);


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t putwchar (wchar_t __wc);


/* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
			__FILE *__restrict __stream);

/* Write a string to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int fputws (__const wchar_t *__restrict __ws,
		   __FILE *__restrict __stream);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
__END_NAMESPACE_STD


#ifdef __USE_GNU
/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);

/* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fgetwc_unlocked (__FILE *__stream);

/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);

/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);


/* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
				 __FILE *__restrict __stream);

/* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputws_unlocked (__const wchar_t *__restrict __ws,
			    __FILE *__restrict __stream);
#endif
# 847 "/usr/include/wchar.h" 3 4


__BEGIN_NAMESPACE_C99
/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
			__const wchar_t *__restrict __format,
			__const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_C99

# ifdef __USE_GNU
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 859 "/usr/include/wchar.h" 3 4
# 860 "/usr/include/wchar.h" 3 4

/* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  */
extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
			  __const wchar_t *__restrict __format,
			  __const struct tm *__restrict __tp,
			  __locale_t __loc) __THROW;
# endif
# 868 "/usr/include/wchar.h" 3 4

/* The X/Open standard demands that most of the functions defined in
   the <wctype.h> header must also appear here.  This is probably
   because some X/Open members wrote their implementation before the
   ISO C standard was published and introduced the better solution.
   We have to provide these definitions for compliance reasons but we
   do this nonsense only if really necessary.  */
#if defined __USE_UNIX98 && !defined __USE_GNU
# define __need_iswxxx
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
# 877 "/usr/include/wchar.h" 3 4
# 878 "/usr/include/wchar.h" 3 4
#endif
# 879 "/usr/include/wchar.h" 3 4

/* Define some macros helping to catch buffer overflows.  */
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar2.h>
#endif /* expanded by -frewrite-includes */
# 882 "/usr/include/wchar.h" 3 4
# 883 "/usr/include/wchar.h" 3 4
#endif
# 884 "/usr/include/wchar.h" 3 4

#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/wchar-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 886 "/usr/include/wchar.h" 3 4
# 887 "/usr/include/wchar.h" 3 4
#endif
# 888 "/usr/include/wchar.h" 3 4

__END_DECLS

#endif	/* _WCHAR_H defined */
# 892 "/usr/include/wchar.h" 3 4

#endif /* wchar.h  */
# 894 "/usr/include/wchar.h" 3 4

/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 21 "/usr/include/_G_config.h" 2 3 4
#define _G_size_t	size_t
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
#define _G_ssize_t	__ssize_t
#define _G_off_t	__off_t
#define _G_off64_t	__off64_t
#define	_G_pid_t	__pid_t
#define	_G_uid_t	__uid_t
#define _G_wchar_t	wchar_t
#define _G_wint_t	wint_t
#define _G_stat64	stat64
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
#if 0 /* expanded by -frewrite-includes */
# include <gconv.h>
#endif /* expanded by -frewrite-includes */
# 41 "/usr/include/_G_config.h" 3 4
# 42 "/usr/include/_G_config.h" 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;
#endif
# 52 "/usr/include/_G_config.h" 3 4

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));

#define _G_HAVE_BOOL 1


/* These library features are always available in the GNU C library.  */
#define _G_HAVE_ATEXIT 1
#define _G_HAVE_SYS_CDEFS 1
#define _G_HAVE_SYS_WAIT 1
#define _G_NEED_STDARG_H 1
#define _G_va_list __gnuc_va_list

#define _G_HAVE_PRINTF_FP 1
#define _G_HAVE_MMAP 1
#define _G_HAVE_MREMAP 1
#define _G_HAVE_LONG_DOUBLE_IO 1
#define _G_HAVE_IO_FILE_OPEN 1
#define _G_HAVE_IO_GETLINE_INFO 1

#define _G_IO_IO_FILE_VERSION 0x20001

#define _G_OPEN64	__open64
#define _G_LSEEK64	__lseek64
#define _G_MMAP64	__mmap64
#define _G_FSTAT64(fd,buf) __fxstat64 (_STAT_VER, fd, buf)

/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)

#define _G_BUFSIZ 8192

/* These are the vtbl details for ELF.  */
#define _G_NAMES_HAVE_UNDERSCORE 0
#define _G_VTABLE_LABEL_HAS_LENGTH 1
#define _G_USING_THUNKS	1
#define _G_VTABLE_LABEL_PREFIX "__vt_"
#define _G_VTABLE_LABEL_PREFIX_ID __vt_


#if defined __cplusplus || defined __STDC__
# define _G_ARGS(ARGLIST) ARGLIST
#else
# 98 "/usr/include/_G_config.h" 3 4
# define _G_ARGS(ARGLIST) ()
#endif
# 100 "/usr/include/_G_config.h" 3 4

#endif	/* _G_config.h */
# 102 "/usr/include/_G_config.h" 3 4
# 33 "/usr/include/libio.h" 2 3 4
/* ALL of these should be defined in _G_config.h */
#define _IO_pos_t _G_fpos_t /* obsolete */
#define _IO_fpos_t _G_fpos_t
#define _IO_fpos64_t _G_fpos64_t
#define _IO_size_t _G_size_t
#define _IO_ssize_t _G_ssize_t
#define _IO_off_t _G_off_t
#define _IO_off64_t _G_off64_t
#define _IO_pid_t _G_pid_t
#define _IO_uid_t _G_uid_t
#define _IO_iconv_t _G_iconv_t
#define _IO_HAVE_SYS_WAIT _G_HAVE_SYS_WAIT
#define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE
#define _IO_BUFSIZ _G_BUFSIZ
#define _IO_va_list _G_va_list
#define _IO_wint_t _G_wint_t

#ifdef _G_NEED_STDARG_H
/* This define avoids name pollution if we're using GNU stdarg.h */
# define __need___va_list
#if 0 /* expanded by -frewrite-includes */
# include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 53 "/usr/include/libio.h" 3 4
# 54 "/usr/include/libio.h" 3 4
# ifdef __GNUC_VA_LIST
#  undef _IO_va_list
#  define _IO_va_list __gnuc_va_list
# endif /* __GNUC_VA_LIST */
# 58 "/usr/include/libio.h" 3 4
#endif
# 59 "/usr/include/libio.h" 3 4

#ifndef __P
# if _G_HAVE_SYS_CDEFS
#if 0 /* expanded by -frewrite-includes */
#  include <sys/cdefs.h>
#endif /* expanded by -frewrite-includes */
# 62 "/usr/include/libio.h" 3 4
# 63 "/usr/include/libio.h" 3 4
# else
# 64 "/usr/include/libio.h" 3 4
#  ifdef __STDC__
#   define __P(p) p
#   define __PMT(p) p
#  else
# 68 "/usr/include/libio.h" 3 4
#   define __P(p) ()
#   define __PMT(p) ()
#  endif
# 71 "/usr/include/libio.h" 3 4
# endif
# 72 "/usr/include/libio.h" 3 4
#endif /*!__P*/
# 73 "/usr/include/libio.h" 3 4

/* For backward compatibility */
#ifndef _PARAMS
# define _PARAMS(protos) __P(protos)
#endif /*!_PARAMS*/
# 78 "/usr/include/libio.h" 3 4

#ifndef __STDC__
# ifndef const
#  define const
# endif
# 83 "/usr/include/libio.h" 3 4
#endif
# 84 "/usr/include/libio.h" 3 4
#define _IO_UNIFIED_JUMPTABLES 1
#ifndef _G_HAVE_PRINTF_FP
# define _IO_USE_DTOA 1
#endif
# 88 "/usr/include/libio.h" 3 4

#ifndef EOF
# define EOF (-1)
#endif
# 92 "/usr/include/libio.h" 3 4
#ifndef NULL
# if defined __GNUG__ && \
    (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))
#  define NULL (__null)
# else
# 97 "/usr/include/libio.h" 3 4
#  if !defined(__cplusplus)
#   define NULL ((void*)0)
#  else
# 100 "/usr/include/libio.h" 3 4
#   define NULL (0)
#  endif
# 102 "/usr/include/libio.h" 3 4
# endif
# 103 "/usr/include/libio.h" 3 4
#endif
# 104 "/usr/include/libio.h" 3 4

#define _IOS_INPUT	1
#define _IOS_OUTPUT	2
#define _IOS_ATEND	4
#define _IOS_APPEND	8
#define _IOS_TRUNC	16
#define _IOS_NOCREATE	32
#define _IOS_NOREPLACE	64
#define _IOS_BIN	128

/* Magic numbers and bits for the _flags field.
   The magic numbers use the high-order bits of _flags;
   the remaining bits are available for variable flags.
   Note: The magic numbers must all be negative if stdio
   emulation is desired. */

#define _IO_MAGIC 0xFBAD0000 /* Magic number */
#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */
#define _IO_MAGIC_MASK 0xFFFF0000
#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */
#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4 /* Reading not allowed */
#define _IO_NO_WRITES 8 /* Writing not allowd */
#define _IO_EOF_SEEN 0x10
#define _IO_ERR_SEEN 0x20
#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */
#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/
#define _IO_IN_BACKUP 0x100
#define _IO_LINE_BUF 0x200
#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */
#define _IO_CURRENTLY_PUTTING 0x800
#define _IO_IS_APPENDING 0x1000
#define _IO_IS_FILEBUF 0x2000
#define _IO_BAD_SEEN 0x4000
#define _IO_USER_LOCK 0x8000

#define _IO_FLAGS2_MMAP 1
#define _IO_FLAGS2_NOTCANCEL 2
#ifdef _LIBC
# define _IO_FLAGS2_FORTIFY 4
#endif
# 145 "/usr/include/libio.h" 3 4
#define _IO_FLAGS2_USER_WBUF 8
#ifdef _LIBC
# define _IO_FLAGS2_SCANF_STD 16
#endif
# 149 "/usr/include/libio.h" 3 4

/* These are "formatting flags" matching the iostream fmtflags enum values. */
#define _IO_SKIPWS 01
#define _IO_LEFT 02
#define _IO_RIGHT 04
#define _IO_INTERNAL 010
#define _IO_DEC 020
#define _IO_OCT 040
#define _IO_HEX 0100
#define _IO_SHOWBASE 0200
#define _IO_SHOWPOINT 0400
#define _IO_UPPERCASE 01000
#define _IO_SHOWPOS 02000
#define _IO_SCIENTIFIC 04000
#define _IO_FIXED 010000
#define _IO_UNITBUF 020000
#define _IO_STDIO 040000
#define _IO_DONT_CLOSE 0100000
#define _IO_BOOLALPHA 0200000


struct _IO_jump_t;  struct _IO_FILE;

/* Handle lock.  */
#ifdef _IO_MTSAFE_IO
# if defined __GLIBC__ && __GLIBC__ >= 2
#if 0 /* expanded by -frewrite-includes */
#  include <bits/stdio-lock.h>
#endif /* expanded by -frewrite-includes */
# 175 "/usr/include/libio.h" 3 4
# 176 "/usr/include/libio.h" 3 4
# else
# 177 "/usr/include/libio.h" 3 4
/*# include <comthread.h>*/
# endif
# 179 "/usr/include/libio.h" 3 4
#else
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;
#endif
# 182 "/usr/include/libio.h" 3 4


/* A streammarker remembers a position in a buffer. */

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  /* If _pos >= 0
 it points to _buf->Gbase()+_pos. FIXME comment */
  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */
  int _pos;
#if 0
    void set_streampos(streampos sp) { _spos = sp; }
    void set_offset(int offset) { _pos = offset; _spos = (streampos)(-2); }
  public:
    streammarker(streambuf *sb);
    ~streammarker();
    int saving() { return  _spos == -2; }
    int delta(streammarker&);
    int delta();
#endif
# 203 "/usr/include/libio.h" 3 4
};

/* This is the structure from the libstdc++ codecvt class.  */
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};

#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
/* The order of the elements in the following struct must match the order
   of the virtual functions in the libstdc++ codecvt class.  */
struct _IO_codecvt
{
  void (*__codecvt_destr) (struct _IO_codecvt *);
  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,
					     __mbstate_t *,
					     const wchar_t *,
					     const wchar_t *,
					     const wchar_t **, char *,
					     char *, char **);
  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,
						 __mbstate_t *, char *,
						 char *, char **);
  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,
					    __mbstate_t *,
					    const char *, const char *,
					    const char **, wchar_t *,
					    wchar_t *, wchar_t **);
  int (*__codecvt_do_encoding) (struct _IO_codecvt *);
  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);
  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,
			      const char *, const char *, _IO_size_t);
  int (*__codecvt_do_max_length) (struct _IO_codecvt *);

  _IO_iconv_t __cd_in;
  _IO_iconv_t __cd_out;
};

/* Extra data for wide character streams.  */
struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;	/* Current read pointer */
  wchar_t *_IO_read_end;	/* End of get area. */
  wchar_t *_IO_read_base;	/* Start of putback+get area. */
  wchar_t *_IO_write_base;	/* Start of put area. */
  wchar_t *_IO_write_ptr;	/* Current put pointer. */
  wchar_t *_IO_write_end;	/* End of put area. */
  wchar_t *_IO_buf_base;	/* Start of reserve area. */
  wchar_t *_IO_buf_end;		/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  wchar_t *_IO_save_base;	/* Pointer to start of non-current get area. */
  wchar_t *_IO_backup_base;	/* Pointer to first valid character of
				   backup area */
  wchar_t *_IO_save_end;	/* Pointer to end of non-current get area. */

  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  struct _IO_codecvt _codecvt;

  wchar_t _shortbuf[1];

  const struct _IO_jump_t *_wide_vtable;
};
#endif
# 270 "/usr/include/libio.h" 3 4

struct _IO_FILE {
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;	/* Current read pointer */
  char* _IO_read_end;	/* End of get area. */
  char* _IO_read_base;	/* Start of putback+get area. */
  char* _IO_write_base;	/* Start of put area. */
  char* _IO_write_ptr;	/* Current put pointer. */
  char* _IO_write_end;	/* End of put area. */
  char* _IO_buf_base;	/* Start of reserve area. */
  char* _IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
# 298 "/usr/include/libio.h" 3 4
  int _flags2;
#endif
# 300 "/usr/include/libio.h" 3 4
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

struct _IO_FILE_complete
{
  struct _IO_FILE _file;
#endif
# 318 "/usr/include/libio.h" 3 4
#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001
  _IO_off64_t _offset;
# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t _freeres_size;
# else
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;
# endif
# 334 "/usr/include/libio.h" 3 4
  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
#endif
# 338 "/usr/include/libio.h" 3 4
};

#ifndef __cplusplus
typedef struct _IO_FILE _IO_FILE;
#endif
# 343 "/usr/include/libio.h" 3 4

struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
#ifndef _LIBC
#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))
#define _IO_stdout ((_IO_FILE*)(&_IO_2_1_stdout_))
#define _IO_stderr ((_IO_FILE*)(&_IO_2_1_stderr_))
#else
# 354 "/usr/include/libio.h" 3 4
extern _IO_FILE *_IO_stdin attribute_hidden;
extern _IO_FILE *_IO_stdout attribute_hidden;
extern _IO_FILE *_IO_stderr attribute_hidden;
#endif
# 358 "/usr/include/libio.h" 3 4


/* Functions to do I/O and file management for a stream.  */

/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
   Return number of bytes read.  */
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);

/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes
   unless there is an error.  Return number of bytes written, or -1 if
   there is an error without writing anything.  If the file has been
   opened for append (__mode.__append set), then set the file pointer
   to the end of the file and then do the write; if not, just write at
   the current file pointer.  */
typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
				 size_t __n);

/* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  */
typedef int __io_seek_fn (void *__cookie, _IO_off64_t *__pos, int __w);

/* Close COOKIE.  */
typedef int __io_close_fn (void *__cookie);


#ifdef _GNU_SOURCE
/* User-visible names for the above.  */
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;

/* The structure with the cookie function pointers.  */
typedef struct
{
  __io_read_fn *read;		/* Read bytes.  */
  __io_write_fn *write;		/* Write bytes.  */
  __io_seek_fn *seek;		/* Seek/tell file position.  */
  __io_close_fn *close;		/* Close file.  */
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;

/* Initialize one of those.  */
extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
			     void *__cookie, _IO_cookie_io_functions_t __fns);
#endif
# 410 "/usr/include/libio.h" 3 4


#ifdef __cplusplus
extern "C" {
#endif
# 415 "/usr/include/libio.h" 3 4

extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
extern _IO_wint_t __wunderflow (_IO_FILE *);
extern _IO_wint_t __wuflow (_IO_FILE *);
extern _IO_wint_t __woverflow (_IO_FILE *, _IO_wint_t);
#endif
# 424 "/usr/include/libio.h" 3 4

#if  __GNUC__ >= 3
# define _IO_BE(expr, res) __builtin_expect ((expr), res)
#else
# 428 "/usr/include/libio.h" 3 4
# define _IO_BE(expr, res) (expr)
#endif
# 430 "/usr/include/libio.h" 3 4

#define _IO_getc_unlocked(_fp) \
       (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) \
	? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)
#define _IO_peekc_unlocked(_fp) \
       (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) \
	  && __underflow (_fp) == EOF ? EOF \
	: *(unsigned char *) (_fp)->_IO_read_ptr)
#define _IO_putc_unlocked(_ch, _fp) \
   (_IO_BE ((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end, 0) \
    ? __overflow (_fp, (unsigned char) (_ch)) \
    : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))

#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
# define _IO_getwc_unlocked(_fp) \
  (_IO_BE ((_fp)->_wide_data == NULL					\
	   || ((_fp)->_wide_data->_IO_read_ptr				\
	       >= (_fp)->_wide_data->_IO_read_end), 0)			\
   ? __wuflow (_fp) : (_IO_wint_t) *(_fp)->_wide_data->_IO_read_ptr++)
# define _IO_putwc_unlocked(_wch, _fp) \
  (_IO_BE ((_fp)->_wide_data == NULL					\
	   || ((_fp)->_wide_data->_IO_write_ptr				\
	       >= (_fp)->_wide_data->_IO_write_end), 0)			\
   ? __woverflow (_fp, _wch)						\
   : (_IO_wint_t) (*(_fp)->_wide_data->_IO_write_ptr++ = (_wch)))
#endif
# 456 "/usr/include/libio.h" 3 4

#define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)
#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)

extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __THROW;
extern int _IO_ferror (_IO_FILE *__fp) __THROW;

extern int _IO_peekc_locked (_IO_FILE *__fp);

/* This one is for Emacs. */
#define _IO_PENDING_OUTPUT_COUNT(_fp)	\
	((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)

extern void _IO_flockfile (_IO_FILE *) __THROW;
extern void _IO_funlockfile (_IO_FILE *) __THROW;
extern int _IO_ftrylockfile (_IO_FILE *) __THROW;

#ifdef _IO_MTSAFE_IO
# define _IO_peekc(_fp) _IO_peekc_locked (_fp)
# define _IO_flockfile(_fp) \
  if (((_fp)->_flags & _IO_USER_LOCK) == 0) _IO_flockfile (_fp)
# define _IO_funlockfile(_fp) \
  if (((_fp)->_flags & _IO_USER_LOCK) == 0) _IO_funlockfile (_fp)
#else
# 482 "/usr/include/libio.h" 3 4
# define _IO_peekc(_fp) _IO_peekc_unlocked (_fp)
# define _IO_flockfile(_fp) /**/
# define _IO_funlockfile(_fp) /**/
# define _IO_ftrylockfile(_fp) /**/
# define _IO_cleanup_region_start(_fct, _fp) /**/
# define _IO_cleanup_region_end(_Doit) /**/
#endif /* !_IO_MTSAFE_IO */
# 489 "/usr/include/libio.h" 3 4

extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
			_IO_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
			 _IO_va_list);
extern _IO_ssize_t _IO_padn (_IO_FILE *, int, _IO_ssize_t);
extern _IO_size_t _IO_sgetn (_IO_FILE *, void *, _IO_size_t);

extern _IO_off64_t _IO_seekoff (_IO_FILE *, _IO_off64_t, int, int);
extern _IO_off64_t _IO_seekpos (_IO_FILE *, _IO_off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __THROW;

#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
extern _IO_wint_t _IO_getwc (_IO_FILE *__fp);
extern _IO_wint_t _IO_putwc (wchar_t __wc, _IO_FILE *__fp);
extern int _IO_fwide (_IO_FILE *__fp, int __mode) __THROW;
# if __GNUC__ >= 2
/* While compiling glibc we have to handle compatibility with very old
   versions.  */
#  if defined _LIBC && defined SHARED
#if 0 /* expanded by -frewrite-includes */
#   include <shlib-compat.h>
#endif /* expanded by -frewrite-includes */
# 510 "/usr/include/libio.h" 3 4
# 511 "/usr/include/libio.h" 3 4
#   if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
#    define _IO_fwide_maybe_incompatible \
  (__builtin_expect (&_IO_stdin_used == NULL, 0))
extern const int _IO_stdin_used;
weak_extern (_IO_stdin_used);
#   endif
# 517 "/usr/include/libio.h" 3 4
#  endif
# 518 "/usr/include/libio.h" 3 4
#  ifndef _IO_fwide_maybe_incompatible
#   define _IO_fwide_maybe_incompatible (0)
#  endif
# 521 "/usr/include/libio.h" 3 4
/* A special optimized version of the function above.  It optimizes the
   case of initializing an unoriented byte stream.  */
#  define _IO_fwide(__fp, __mode) \
  ({ int __result = (__mode);						      \
     if (__result < 0 && ! _IO_fwide_maybe_incompatible)		      \
       {								      \
	 if ((__fp)->_mode == 0)					      \
	   /* We know that all we have to do is to set the flag.  */	      \
	   (__fp)->_mode = -1;						      \
	 __result = (__fp)->_mode;					      \
       }								      \
     else if (__builtin_constant_p (__mode) && (__mode) == 0)		      \
       __result = _IO_fwide_maybe_incompatible ? -1 : (__fp)->_mode;	      \
     else								      \
       __result = _IO_fwide (__fp, __result);				      \
     __result; })
# endif
# 538 "/usr/include/libio.h" 3 4

extern int _IO_vfwscanf (_IO_FILE * __restrict, const wchar_t * __restrict,
			 _IO_va_list, int *__restrict);
extern int _IO_vfwprintf (_IO_FILE *__restrict, const wchar_t *__restrict,
			  _IO_va_list);
extern _IO_ssize_t _IO_wpadn (_IO_FILE *, wint_t, _IO_ssize_t);
extern void _IO_free_wbackup_area (_IO_FILE *) __THROW;
#endif
# 546 "/usr/include/libio.h" 3 4

#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/libio-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 548 "/usr/include/libio.h" 3 4
# 549 "/usr/include/libio.h" 3 4
#endif
# 550 "/usr/include/libio.h" 3 4

#ifdef __cplusplus
}
#endif
# 554 "/usr/include/libio.h" 3 4

#endif /* _IO_STDIO_H */
# 556 "/usr/include/libio.h" 3 4
# 76 "/usr/include/stdio.h" 2 3 4

#if defined __USE_XOPEN || defined __USE_XOPEN2K8
# ifdef __GNUC__
#  ifndef _VA_LIST_DEFINED
typedef _G_va_list va_list;
#   define _VA_LIST_DEFINED
#  endif
# 83 "/usr/include/stdio.h" 3 4
# else
# 84 "/usr/include/stdio.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#  include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 84 "/usr/include/stdio.h" 3 4
# 85 "/usr/include/stdio.h" 3 4
# endif
# 86 "/usr/include/stdio.h" 3 4
#endif
# 87 "/usr/include/stdio.h" 3 4

#ifdef __USE_XOPEN2K8
# ifndef __off_t_defined
# ifndef __USE_FILE_OFFSET64
typedef __off_t off_t;
# else
# 93 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;
# endif
# 95 "/usr/include/stdio.h" 3 4
# define __off_t_defined
# endif
# 97 "/usr/include/stdio.h" 3 4
# if defined __USE_LARGEFILE64 && !defined __off64_t_defined
typedef __off64_t off64_t;
# define __off64_t_defined
# endif
# 101 "/usr/include/stdio.h" 3 4

# ifndef __ssize_t_defined
typedef __ssize_t ssize_t;
# define __ssize_t_defined
# endif
# 106 "/usr/include/stdio.h" 3 4
#endif
# 107 "/usr/include/stdio.h" 3 4

/* The type of the second argument to `fgetpos' and `fsetpos'.  */
__BEGIN_NAMESPACE_STD
#ifndef __USE_FILE_OFFSET64
typedef _G_fpos_t fpos_t;
#else
# 113 "/usr/include/stdio.h" 3 4
typedef _G_fpos64_t fpos_t;
#endif
# 115 "/usr/include/stdio.h" 3 4
__END_NAMESPACE_STD
#ifdef __USE_LARGEFILE64
typedef _G_fpos64_t fpos64_t;
#endif
# 119 "/usr/include/stdio.h" 3 4

/* The possibilities for the third argument to `setvbuf'.  */
#define _IOFBF 0 		/* Fully buffered.  */
#define _IOLBF 1		/* Line buffered.  */
#define _IONBF 2		/* No buffering.  */


/* Default buffer size.  */
#ifndef BUFSIZ
# define BUFSIZ _IO_BUFSIZ
#endif
# 130 "/usr/include/stdio.h" 3 4


/* End of file character.
   Some things throughout the library rely on this being -1.  */
#ifndef EOF
# define EOF (-1)
#endif
# 137 "/usr/include/stdio.h" 3 4


/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
#define SEEK_SET	0	/* Seek from beginning of file.  */
#define SEEK_CUR	1	/* Seek from current position.  */
#define SEEK_END	2	/* Seek from end of file.  */


#if defined __USE_SVID || defined __USE_XOPEN
/* Default path prefix for `tempnam' and `tmpnam'.  */
# define P_tmpdir	"/tmp"
#endif
# 150 "/usr/include/stdio.h" 3 4


/* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
   		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/stdio_lim.h>
#endif /* expanded by -frewrite-includes */
# 161 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994, 1997, 1998, 1999, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#if !defined _STDIO_H && !defined __need_FOPEN_MAX && !defined __need_IOV_MAX
# error "Never include <bits/stdio_lim.h> directly; use <stdio.h> instead."
#endif
# 22 "/usr/include/bits/stdio_lim.h" 3 4

#ifdef _STDIO_H
# define L_tmpnam 20
# define TMP_MAX 238328
# define FILENAME_MAX 4096

# ifdef __USE_POSIX
#  define L_ctermid 9
#  if !defined __USE_XOPEN2K || defined __USE_GNU
#   define L_cuserid 9
#  endif
# 33 "/usr/include/bits/stdio_lim.h" 3 4
# endif
# 34 "/usr/include/bits/stdio_lim.h" 3 4
#endif
# 35 "/usr/include/bits/stdio_lim.h" 3 4

#if defined __need_FOPEN_MAX || defined _STDIO_H
# undef  FOPEN_MAX
# define FOPEN_MAX 16
#endif
# 40 "/usr/include/bits/stdio_lim.h" 3 4

#if defined __need_IOV_MAX && !defined IOV_MAX
# define IOV_MAX 1024
#endif
# 44 "/usr/include/bits/stdio_lim.h" 3 4
# 162 "/usr/include/stdio.h" 2 3 4


/* Standard streams.  */
extern struct _IO_FILE *stdin;		/* Standard input stream.  */
extern struct _IO_FILE *stdout;		/* Standard output stream.  */
extern struct _IO_FILE *stderr;		/* Standard error output stream.  */
#ifdef __STDC__
/* C89/C99 say they're macros.  Make them happy.  */
#define stdin stdin
#define stdout stdout
#define stderr stderr
#endif
# 174 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
/* Remove file FILENAME.  */
extern int remove (__const char *__filename) __THROW;
/* Rename file OLD to NEW.  */
extern int rename (__const char *__old, __const char *__new) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_ATFILE
/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
extern int renameat (int __oldfd, __const char *__old, int __newfd,
		     __const char *__new) __THROW;
#endif
# 187 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
/* Create a temporary file and open it read/write.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
#ifndef __USE_FILE_OFFSET64
extern FILE *tmpfile (void) __wur;
#else
# 196 "/usr/include/stdio.h" 3 4
# ifdef __REDIRECT
extern FILE *__REDIRECT (tmpfile, (void), tmpfile64) __wur;
# else
# 199 "/usr/include/stdio.h" 3 4
#  define tmpfile tmpfile64
# endif
# 201 "/usr/include/stdio.h" 3 4
#endif
# 202 "/usr/include/stdio.h" 3 4

#ifdef __USE_LARGEFILE64
extern FILE *tmpfile64 (void) __wur;
#endif
# 206 "/usr/include/stdio.h" 3 4

/* Generate a temporary filename.  */
extern char *tmpnam (char *__s) __THROW __wur;
__END_NAMESPACE_STD

#ifdef __USE_MISC
/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s) __THROW __wur;
#endif
# 216 "/usr/include/stdio.h" 3 4


#if defined __USE_SVID || defined __USE_XOPEN
/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __THROW __attribute_malloc__ __wur;
#endif
# 229 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fclose (FILE *__stream);
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fflush (FILE *__stream);
__END_NAMESPACE_STD

#ifdef __USE_MISC
/* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fflush_unlocked (FILE *__stream);
#endif
# 253 "/usr/include/stdio.h" 3 4

#ifdef __USE_GNU
/* Close all streams.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fcloseall (void);
#endif
# 263 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
#ifndef __USE_FILE_OFFSET64
/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *fopen (__const char *__restrict __filename,
		    __const char *__restrict __modes) __wur;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *freopen (__const char *__restrict __filename,
		      __const char *__restrict __modes,
		      FILE *__restrict __stream) __wur;
#else
# 281 "/usr/include/stdio.h" 3 4
# ifdef __REDIRECT
extern FILE *__REDIRECT (fopen, (__const char *__restrict __filename,
				 __const char *__restrict __modes), fopen64)
  __wur;
extern FILE *__REDIRECT (freopen, (__const char *__restrict __filename,
				   __const char *__restrict __modes,
				   FILE *__restrict __stream), freopen64)
  __wur;
# else
# 290 "/usr/include/stdio.h" 3 4
#  define fopen fopen64
#  define freopen freopen64
# endif
# 293 "/usr/include/stdio.h" 3 4
#endif
# 294 "/usr/include/stdio.h" 3 4
__END_NAMESPACE_STD
#ifdef __USE_LARGEFILE64
extern FILE *fopen64 (__const char *__restrict __filename,
		      __const char *__restrict __modes) __wur;
extern FILE *freopen64 (__const char *__restrict __filename,
			__const char *__restrict __modes,
			FILE *__restrict __stream) __wur;
#endif
# 302 "/usr/include/stdio.h" 3 4

#ifdef	__USE_POSIX
/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, __const char *__modes) __THROW __wur;
#endif
# 307 "/usr/include/stdio.h" 3 4

#ifdef	__USE_GNU
/* Create a new stream that refers to the given magic cookie,
   and uses the given functions for input and output.  */
extern FILE *fopencookie (void *__restrict __magic_cookie,
			  __const char *__restrict __modes,
			  _IO_cookie_io_functions_t __io_funcs) __THROW __wur;
#endif
# 315 "/usr/include/stdio.h" 3 4

#ifdef __USE_XOPEN2K8
/* Create a new stream that refers to a memory buffer.  */
extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __THROW __wur;

/* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  */
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __THROW __wur;
#endif
# 326 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __THROW;
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
		    int __modes, size_t __n) __THROW;
__END_NAMESPACE_STD

#ifdef	__USE_BSD
/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
		       size_t __size) __THROW;

/* Make STREAM line-buffered.  */
extern void setlinebuf (FILE *__stream) __THROW;
#endif
# 348 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fprintf (FILE *__restrict __stream,
		    __const char *__restrict __format, ...);
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (__const char *__restrict __format, ...);
/* Write formatted output to S.  */
extern int sprintf (char *__restrict __s,
		    __const char *__restrict __format, ...) __THROW;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
		     _G_va_list __arg);
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vprintf (__const char *__restrict __format, _G_va_list __arg);
/* Write formatted output to S from argument list ARG.  */
extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
		     _G_va_list __arg) __THROW;
__END_NAMESPACE_STD

#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
__BEGIN_NAMESPACE_C99
/* Maximum chars of output to write in MAXLEN.  */
extern int snprintf (char *__restrict __s, size_t __maxlen,
		     __const char *__restrict __format, ...)
     __THROW __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
		      __const char *__restrict __format, _G_va_list __arg)
     __THROW __attribute__ ((__format__ (__printf__, 3, 0)));
__END_NAMESPACE_C99
#endif
# 394 "/usr/include/stdio.h" 3 4

#ifdef __USE_GNU
/* Write formatted output to a string dynamically allocated with `malloc'.
   Store the address of the string in *PTR.  */
extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
		      _G_va_list __arg)
     __THROW __attribute__ ((__format__ (__printf__, 2, 0))) __wur;
extern int __asprintf (char **__restrict __ptr,
		       __const char *__restrict __fmt, ...)
     __THROW __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
extern int asprintf (char **__restrict __ptr,
		     __const char *__restrict __fmt, ...)
     __THROW __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
#endif
# 408 "/usr/include/stdio.h" 3 4

#ifdef __USE_XOPEN2K8
/* Write formatted output to a file descriptor.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int vdprintf (int __fd, __const char *__restrict __fmt,
		     _G_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
#endif
# 422 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fscanf (FILE *__restrict __stream,
		   __const char *__restrict __format, ...) __wur;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int scanf (__const char *__restrict __format, ...) __wur;
/* Read formatted input from S.  */
extern int sscanf (__const char *__restrict __s,
		   __const char *__restrict __format, ...) __THROW;

#if defined __USE_ISOC99 && !defined __USE_GNU \
    && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
    && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
# ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fscanf, (FILE *__restrict __stream,
				__const char *__restrict __format, ...),
		       __isoc99_fscanf) __wur;
extern int __REDIRECT (scanf, (__const char *__restrict __format, ...),
		       __isoc99_scanf) __wur;
extern int __REDIRECT (sscanf, (__const char *__restrict __s,
				__const char *__restrict __format, ...),
		       __isoc99_sscanf) __THROW;
# else
# 456 "/usr/include/stdio.h" 3 4
extern int __isoc99_fscanf (FILE *__restrict __stream,
			    __const char *__restrict __format, ...) __wur;
extern int __isoc99_scanf (__const char *__restrict __format, ...) __wur;
extern int __isoc99_sscanf (__const char *__restrict __s,
			    __const char *__restrict __format, ...) __THROW;
#  define fscanf __isoc99_fscanf
#  define scanf __isoc99_scanf
#  define sscanf __isoc99_sscanf
# endif
# 465 "/usr/include/stdio.h" 3 4
#endif
# 466 "/usr/include/stdio.h" 3 4

__END_NAMESPACE_STD

#ifdef	__USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
		    _G_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;

/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vscanf (__const char *__restrict __format, _G_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;

/* Read formatted input from S into argument list ARG.  */
extern int vsscanf (__const char *__restrict __s,
		    __const char *__restrict __format, _G_va_list __arg)
     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));

# if !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (vfscanf,
		       (FILE *__restrict __s,
			__const char *__restrict __format, _G_va_list __arg),
		       __isoc99_vfscanf)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __wur;
extern int __REDIRECT (vscanf, (__const char *__restrict __format,
				_G_va_list __arg), __isoc99_vscanf)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __wur;
extern int __REDIRECT (vsscanf,
		       (__const char *__restrict __s,
			__const char *__restrict __format, _G_va_list __arg),
		       __isoc99_vsscanf)
     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));
#  else
# 512 "/usr/include/stdio.h" 3 4
extern int __isoc99_vfscanf (FILE *__restrict __s,
			     __const char *__restrict __format,
			     _G_va_list __arg) __wur;
extern int __isoc99_vscanf (__const char *__restrict __format,
			    _G_va_list __arg) __wur;
extern int __isoc99_vsscanf (__const char *__restrict __s,
			     __const char *__restrict __format,
			     _G_va_list __arg) __THROW;
#   define vfscanf __isoc99_vfscanf
#   define vscanf __isoc99_vscanf
#   define vsscanf __isoc99_vsscanf
#  endif
# 524 "/usr/include/stdio.h" 3 4
# endif
# 525 "/usr/include/stdio.h" 3 4

__END_NAMESPACE_C99
#endif /* Use ISO C9x.  */
# 528 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);
__END_NAMESPACE_STD

/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */
#define getc(_fp) _IO_getc (_fp)

#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
#endif /* Use POSIX or MISC.  */
# 557 "/usr/include/stdio.h" 3 4

#ifdef __USE_MISC
/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetc_unlocked (FILE *__stream);
#endif /* Use MISC.  */
# 567 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int putchar (int __c);
__END_NAMESPACE_STD

/* The C standard explicitly says this can be a macro,
   so we always do the optimization for it.  */
#define putc(_ch, _fp) _IO_putc (_ch, _fp)

#ifdef __USE_MISC
/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputc_unlocked (int __c, FILE *__stream);
#endif /* Use MISC.  */
# 600 "/usr/include/stdio.h" 3 4

#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
#endif /* Use POSIX or MISC.  */
# 609 "/usr/include/stdio.h" 3 4


#if defined __USE_SVID || defined __USE_MISC \
    || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
/* Get a word (int) from STREAM.  */
extern int getw (FILE *__stream);

/* Write a word (int) to STREAM.  */
extern int putw (int __w, FILE *__stream);
#endif
# 619 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __wur;

/* Get a newline-terminated string from stdin, removing the newline.
   DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *gets (char *__s) __wur;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function does the same as `fgets' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern char *fgets_unlocked (char *__restrict __s, int __n,
			     FILE *__restrict __stream) __wur;
#endif
# 647 "/usr/include/stdio.h" 3 4


#ifdef	__USE_XOPEN2K8
/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern _IO_ssize_t __getdelim (char **__restrict __lineptr,
			       size_t *__restrict __n, int __delimiter,
			       FILE *__restrict __stream) __wur;
extern _IO_ssize_t getdelim (char **__restrict __lineptr,
			     size_t *__restrict __n, int __delimiter,
			     FILE *__restrict __stream) __wur;

/* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern _IO_ssize_t getline (char **__restrict __lineptr,
			    size_t *__restrict __n,
			    FILE *__restrict __stream) __wur;
#endif
# 677 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Write a string to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int puts (__const char *__s);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern int ungetc (int __c, FILE *__stream);


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern size_t fread (void *__restrict __ptr, size_t __size,
		     size_t __n, FILE *__restrict __stream) __wur;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
		      size_t __n, FILE *__restrict __s) __wur;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function does the same as `fputs' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputs_unlocked (__const char *__restrict __s,
			   FILE *__restrict __stream);
#endif
# 724 "/usr/include/stdio.h" 3 4

#ifdef __USE_MISC
/* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
			      size_t __n, FILE *__restrict __stream) __wur;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
			       size_t __n, FILE *__restrict __stream) __wur;
#endif
# 737 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseek (FILE *__stream, long int __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern long int ftell (FILE *__stream) __wur;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void rewind (FILE *__stream);
__END_NAMESPACE_STD

/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */

#if defined __USE_LARGEFILE || defined __USE_XOPEN2K
# ifndef __USE_FILE_OFFSET64
/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern __off_t ftello (FILE *__stream) __wur;
# else
# 775 "/usr/include/stdio.h" 3 4
#  ifdef __REDIRECT
extern int __REDIRECT (fseeko,
		       (FILE *__stream, __off64_t __off, int __whence),
		       fseeko64);
extern __off64_t __REDIRECT (ftello, (FILE *__stream), ftello64);
#  else
# 781 "/usr/include/stdio.h" 3 4
#   define fseeko fseeko64
#   define ftello ftello64
#  endif
# 784 "/usr/include/stdio.h" 3 4
# endif
# 785 "/usr/include/stdio.h" 3 4
#endif
# 786 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
#ifndef __USE_FILE_OFFSET64
/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
#else
# 800 "/usr/include/stdio.h" 3 4
# ifdef __REDIRECT
extern int __REDIRECT (fgetpos, (FILE *__restrict __stream,
				 fpos_t *__restrict __pos), fgetpos64);
extern int __REDIRECT (fsetpos,
		       (FILE *__stream, __const fpos_t *__pos), fsetpos64);
# else
# 806 "/usr/include/stdio.h" 3 4
#  define fgetpos fgetpos64
#  define fsetpos fsetpos64
# endif
# 809 "/usr/include/stdio.h" 3 4
#endif
# 810 "/usr/include/stdio.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_LARGEFILE64
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __wur;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);
#endif
# 818 "/usr/include/stdio.h" 3 4

__BEGIN_NAMESPACE_STD
/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE *__stream) __THROW;
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE *__stream) __THROW __wur;
/* Return the error indicator for STREAM.  */
extern int ferror (FILE *__stream) __THROW __wur;
__END_NAMESPACE_STD

#ifdef __USE_MISC
/* Faster versions when locking is not required.  */
extern void clearerr_unlocked (FILE *__stream) __THROW;
extern int feof_unlocked (FILE *__stream) __THROW __wur;
extern int ferror_unlocked (FILE *__stream) __THROW __wur;
#endif
# 834 "/usr/include/stdio.h" 3 4


__BEGIN_NAMESPACE_STD
/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void perror (__const char *__s);
__END_NAMESPACE_STD

/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/sys_errlist.h>
#endif /* expanded by -frewrite-includes */
# 848 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
   Copyright (C) 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _STDIO_H
# error "Never include <bits/sys_errlist.h> directly; use <stdio.h> instead."
#endif
# 23 "/usr/include/bits/sys_errlist.h" 3 4

/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */

#ifdef  __USE_BSD
extern int sys_nerr;
extern __const char *__const sys_errlist[];
#endif
# 30 "/usr/include/bits/sys_errlist.h" 3 4
#ifdef  __USE_GNU
extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
#endif
# 34 "/usr/include/bits/sys_errlist.h" 3 4
# 849 "/usr/include/stdio.h" 2 3 4


#ifdef	__USE_POSIX
/* Return the system file descriptor for STREAM.  */
extern int fileno (FILE *__stream) __THROW __wur;
#endif /* Use POSIX.  */
# 855 "/usr/include/stdio.h" 3 4

#ifdef __USE_MISC
/* Faster version when locking is not required.  */
extern int fileno_unlocked (FILE *__stream) __THROW __wur;
#endif
# 860 "/usr/include/stdio.h" 3 4


#if (defined __USE_POSIX2 || defined __USE_SVID  || defined __USE_BSD || \
     defined __USE_MISC)
/* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *popen (__const char *__command, __const char *__modes) __wur;

/* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int pclose (FILE *__stream);
#endif
# 876 "/usr/include/stdio.h" 3 4


#ifdef	__USE_POSIX
/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) __THROW;
#endif /* Use POSIX.  */
# 882 "/usr/include/stdio.h" 3 4


#ifdef __USE_XOPEN
/* Return the name of the current user.  */
extern char *cuserid (char *__s);
#endif /* Use X/Open, but not issue 6.  */
# 888 "/usr/include/stdio.h" 3 4


#ifdef	__USE_GNU
struct obstack;			/* See <obstack.h>.  */

/* Write formatted output to an obstack.  */
extern int obstack_printf (struct obstack *__restrict __obstack,
			   __const char *__restrict __format, ...)
     __THROW __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
			    __const char *__restrict __format,
			    _G_va_list __args)
     __THROW __attribute__ ((__format__ (__printf__, 2, 0)));
#endif /* Use GNU.  */
# 902 "/usr/include/stdio.h" 3 4


#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.  */

/* Acquire ownership of STREAM.  */
extern void flockfile (FILE *__stream) __THROW;

/* Try to acquire ownership of STREAM but do not block if it is not
   possible.  */
extern int ftrylockfile (FILE *__stream) __THROW __wur;

/* Relinquish the ownership granted for STREAM.  */
extern void funlockfile (FILE *__stream) __THROW;
#endif /* POSIX || misc */
# 917 "/usr/include/stdio.h" 3 4

#if defined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU
/* The X/Open standard requires some functions and variables to be
   declared here which do not belong into this header.  But we have to
   follow.  In GNU mode we don't do this nonsense.  */
# define __need_getopt
#if 0 /* expanded by -frewrite-includes */
# include <getopt.h>
#endif /* expanded by -frewrite-includes */
# 923 "/usr/include/stdio.h" 3 4
# 924 "/usr/include/stdio.h" 3 4
#endif	/* X/Open, but not issue 6 and not for GNU.  */
# 925 "/usr/include/stdio.h" 3 4

/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
#ifdef __USE_EXTERN_INLINES
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio.h>
#endif /* expanded by -frewrite-includes */
# 929 "/usr/include/stdio.h" 3 4
# 930 "/usr/include/stdio.h" 3 4
#endif
# 931 "/usr/include/stdio.h" 3 4
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio2.h>
#endif /* expanded by -frewrite-includes */
# 932 "/usr/include/stdio.h" 3 4
# 933 "/usr/include/stdio.h" 3 4
#endif
# 934 "/usr/include/stdio.h" 3 4
#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 935 "/usr/include/stdio.h" 3 4
# 936 "/usr/include/stdio.h" 3 4
#endif
# 937 "/usr/include/stdio.h" 3 4

__END_DECLS

#endif /* <stdio.h> included.  */
# 941 "/usr/include/stdio.h" 3 4

#endif /* !_STDIO_H */
# 943 "/usr/include/stdio.h" 3 4
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include <string.h>
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/usr/include/string.h" 1 3 4
/* Copyright (C) 1991-1993,1995-2004,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */

#ifndef	_STRING_H
#define	_STRING_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/string.h" 3 4
# 28 "/usr/include/string.h" 3 4

__BEGIN_DECLS

/* Get size_t and NULL from <stddef.h>.  */
#define	__need_size_t
#define	__need_NULL
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/string.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 35 "/usr/include/string.h" 2 3 4

/* Tell the caller that we provide correct C++ prototypes.  */
#if defined __cplusplus && __GNUC_PREREQ (4, 4)
# define __CORRECT_ISO_CPP_STRING_H_PROTO
#endif
# 40 "/usr/include/string.h" 3 4


__BEGIN_NAMESPACE_STD
/* Copy N bytes of SRC to DEST.  */
extern void *memcpy (void *__restrict __dest,
		     __const void *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
/* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __THROW __nonnull ((1, 2));
__END_NAMESPACE_STD

/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  */
#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN
extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
		      int __c, size_t __n)
     __THROW __nonnull ((1, 2));
#endif /* SVID.  */
# 61 "/usr/include/string.h" 3 4


__BEGIN_NAMESPACE_STD
/* Set N bytes of S to C.  */
extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));

/* Compare N bytes of S1 and S2.  */
extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __THROW __attribute_pure__ __nonnull ((1, 2));

/* Search N bytes of S for C.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline void *
memchr (void *__s, int __c, size_t __n) __THROW
{
  return __builtin_memchr (__s, __c, __n);
}

__extern_always_inline __const void *
memchr (__const void *__s, int __c, size_t __n) __THROW
{
  return __builtin_memchr (__s, __c, __n);
}
# endif
# 93 "/usr/include/string.h" 3 4
}
#else
# 95 "/usr/include/string.h" 3 4
extern void *memchr (__const void *__s, int __c, size_t __n)
      __THROW __attribute_pure__ __nonnull ((1));
#endif
# 98 "/usr/include/string.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* Search in S for C.  This is similar to `memchr' but there is no
   length limit.  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" void *rawmemchr (void *__s, int __c)
     __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
# else
# 109 "/usr/include/string.h" 3 4
extern void *rawmemchr (__const void *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
# endif
# 112 "/usr/include/string.h" 3 4

/* Search N bytes of S for the final occurrence of C.  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1));
# else
# 120 "/usr/include/string.h" 3 4
extern void *memrchr (__const void *__s, int __c, size_t __n)
      __THROW __attribute_pure__ __nonnull ((1));
# endif
# 123 "/usr/include/string.h" 3 4
#endif
# 124 "/usr/include/string.h" 3 4


__BEGIN_NAMESPACE_STD
/* Copy SRC to DEST.  */
extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __THROW __nonnull ((1, 2));
/* Copy no more than N characters of SRC to DEST.  */
extern char *strncpy (char *__restrict __dest,
		      __const char *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));

/* Append SRC onto DEST.  */
extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __THROW __nonnull ((1, 2));
/* Append no more than N characters from SRC onto DEST.  */
extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
		      size_t __n) __THROW __nonnull ((1, 2));

/* Compare S1 and S2.  */
extern int strcmp (__const char *__s1, __const char *__s2)
     __THROW __attribute_pure__ __nonnull ((1, 2));
/* Compare N characters of S1 and S2.  */
extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __THROW __attribute_pure__ __nonnull ((1, 2));

/* Compare the collated forms of S1 and S2.  */
extern int strcoll (__const char *__s1, __const char *__s2)
     __THROW __attribute_pure__ __nonnull ((1, 2));
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm (char *__restrict __dest,
		       __const char *__restrict __src, size_t __n)
     __THROW __nonnull ((2));
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* The following functions are equivalent to the both above but they
   take the locale they use for the collation as an extra argument.
   This is not standardsized but something like will come.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 162 "/usr/include/string.h" 3 4
# 163 "/usr/include/string.h" 3 4

/* Compare the collated forms of S1 and S2 using rules from L.  */
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
			 __locale_t __l) __THROW __nonnull ((2, 4));
#endif
# 171 "/usr/include/string.h" 3 4

#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED \
    || defined __USE_XOPEN2K8
/* Duplicate S, returning an identical malloc'd string.  */
extern char *strdup (__const char *__s)
     __THROW __attribute_malloc__ __nonnull ((1));
#endif
# 178 "/usr/include/string.h" 3 4

/* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  */
#if defined __USE_XOPEN2K8
extern char *strndup (__const char *__string, size_t __n)
     __THROW __attribute_malloc__ __nonnull ((1));
#endif
# 186 "/usr/include/string.h" 3 4

#if defined __USE_GNU && defined __GNUC__
/* Duplicate S, returning an identical alloca'd string.  */
# define strdupa(s)							      \
  (__extension__							      \
    ({									      \
      __const char *__old = (s);					      \
      size_t __len = strlen (__old) + 1;				      \
      char *__new = (char *) __builtin_alloca (__len);			      \
      (char *) memcpy (__new, __old, __len);				      \
    }))

/* Return an alloca'd copy of at most N bytes of string.  */
# define strndupa(s, n)							      \
  (__extension__							      \
    ({									      \
      __const char *__old = (s);					      \
      size_t __len = strnlen (__old, (n));				      \
      char *__new = (char *) __builtin_alloca (__len + 1);		      \
      __new[__len] = '\0';						      \
      (char *) memcpy (__new, __old, __len);				      \
    }))
#endif
# 209 "/usr/include/string.h" 3 4

__BEGIN_NAMESPACE_STD
/* Find the first occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *strchr (char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
extern __const char *strchr (__const char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strchr (char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}

__extern_always_inline __const char *
strchr (__const char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}
# endif
# 233 "/usr/include/string.h" 3 4
}
#else
# 235 "/usr/include/string.h" 3 4
extern char *strchr (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#endif
# 238 "/usr/include/string.h" 3 4
/* Find the last occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *strrchr (char *__s, int __c)
     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
extern __const char *strrchr (__const char *__s, int __c)
     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strrchr (char *__s, int __c) __THROW
{
  return __builtin_strrchr (__s, __c);
}

__extern_always_inline __const char *
strrchr (__const char *__s, int __c) __THROW
{
  return __builtin_strrchr (__s, __c);
}
# endif
# 260 "/usr/include/string.h" 3 4
}
#else
# 262 "/usr/include/string.h" 3 4
extern char *strrchr (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#endif
# 265 "/usr/include/string.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* This function is similar to `strchr'.  But it returns a pointer to
   the closing NUL byte in case C is not found in S.  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" char *strchrnul (char *__s, int __c)
     __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
# else
# 276 "/usr/include/string.h" 3 4
extern char *strchrnul (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
# endif
# 279 "/usr/include/string.h" 3 4
#endif
# 280 "/usr/include/string.h" 3 4

__BEGIN_NAMESPACE_STD
/* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  */
extern size_t strcspn (__const char *__s, __const char *__reject)
     __THROW __attribute_pure__ __nonnull ((1, 2));
/* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  */
extern size_t strspn (__const char *__s, __const char *__accept)
     __THROW __attribute_pure__ __nonnull ((1, 2));
/* Find the first occurrence in S of any character in ACCEPT.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strpbrk (char *__s, __const char *__accept) __THROW
{
  return __builtin_strpbrk (__s, __accept);
}

__extern_always_inline __const char *
strpbrk (__const char *__s, __const char *__accept) __THROW
{
  return __builtin_strpbrk (__s, __accept);
}
# endif
# 312 "/usr/include/string.h" 3 4
}
#else
# 314 "/usr/include/string.h" 3 4
extern char *strpbrk (__const char *__s, __const char *__accept)
     __THROW __attribute_pure__ __nonnull ((1, 2));
#endif
# 317 "/usr/include/string.h" 3 4
/* Find the first occurrence of NEEDLE in HAYSTACK.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));
extern __const char *strstr (__const char *__haystack,
			     __const char *__needle)
     __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strstr (char *__haystack, __const char *__needle) __THROW
{
  return __builtin_strstr (__haystack, __needle);
}

__extern_always_inline __const char *
strstr (__const char *__haystack, __const char *__needle) __THROW
{
  return __builtin_strstr (__haystack, __needle);
}
# endif
# 340 "/usr/include/string.h" 3 4
}
#else
# 342 "/usr/include/string.h" 3 4
extern char *strstr (__const char *__haystack, __const char *__needle)
     __THROW __attribute_pure__ __nonnull ((1, 2));
#endif
# 345 "/usr/include/string.h" 3 4


/* Divide S into tokens separated by characters in DELIM.  */
extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __THROW __nonnull ((2));
__END_NAMESPACE_STD

/* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  */
extern char *__strtok_r (char *__restrict __s,
			 __const char *__restrict __delim,
			 char **__restrict __save_ptr)
     __THROW __nonnull ((2, 3));
#if defined __USE_POSIX || defined __USE_MISC
extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
		       char **__restrict __save_ptr)
     __THROW __nonnull ((2, 3));
#endif
# 363 "/usr/include/string.h" 3 4

#ifdef __USE_GNU
/* Similar to `strstr' but this function ignores the case of both strings.  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
extern "C++" __const char *strcasestr (__const char *__haystack,
				       __const char *__needle)
     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
# else
# 373 "/usr/include/string.h" 3 4
extern char *strcasestr (__const char *__haystack, __const char *__needle)
     __THROW __attribute_pure__ __nonnull ((1, 2));
# endif
# 376 "/usr/include/string.h" 3 4
#endif
# 377 "/usr/include/string.h" 3 4

#ifdef __USE_GNU
/* Find the first occurrence of NEEDLE in HAYSTACK.
   NEEDLE is NEEDLELEN bytes long;
   HAYSTACK is HAYSTACKLEN bytes long.  */
extern void *memmem (__const void *__haystack, size_t __haystacklen,
		     __const void *__needle, size_t __needlelen)
     __THROW __attribute_pure__ __nonnull ((1, 3));

/* Copy N bytes of SRC to DEST, return pointer to bytes after the
   last written byte.  */
extern void *__mempcpy (void *__restrict __dest,
			__const void *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
extern void *mempcpy (void *__restrict __dest,
		      __const void *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
#endif
# 395 "/usr/include/string.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return the length of S.  */
extern size_t strlen (__const char *__s)
     __THROW __attribute_pure__ __nonnull ((1));
__END_NAMESPACE_STD

#ifdef	__USE_XOPEN2K8
/* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  */
extern size_t strnlen (__const char *__string, size_t __maxlen)
     __THROW __attribute_pure__ __nonnull ((1));
#endif
# 409 "/usr/include/string.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
extern char *strerror (int __errnum) __THROW;
__END_NAMESPACE_STD
#if defined __USE_XOPEN2K || defined __USE_MISC
/* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  */
# if defined __USE_XOPEN2K && !defined __USE_GNU
/* Fill BUF with a string describing the meaning of the `errno' code in
   ERRNUM.  */
#  ifdef __REDIRECT_NTH
extern int __REDIRECT_NTH (strerror_r,
			   (int __errnum, char *__buf, size_t __buflen),
			   __xpg_strerror_r) __nonnull ((2));
#  else
# 431 "/usr/include/string.h" 3 4
extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)
     __THROW __nonnull ((2));
#   define strerror_r __xpg_strerror_r
#  endif
# 435 "/usr/include/string.h" 3 4
# else
# 436 "/usr/include/string.h" 3 4
/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
   used.  */
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __THROW __nonnull ((2));
# endif
# 441 "/usr/include/string.h" 3 4
#endif
# 442 "/usr/include/string.h" 3 4

#ifdef __USE_XOPEN2K8
/* Translate error number to string according to the locale L.  */
extern char *strerror_l (int __errnum, __locale_t __l) __THROW;
#endif
# 447 "/usr/include/string.h" 3 4


/* We define this function always since `bzero' is sometimes needed when
   the namespace rules does not allow this.  */
extern void __bzero (void *__s, size_t __n) __THROW __nonnull ((1));

#ifdef __USE_BSD
/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __THROW __nonnull ((1, 2));

/* Set N bytes of S to 0.  */
extern void bzero (void *__s, size_t __n) __THROW __nonnull ((1));

/* Compare N bytes of S1 and S2 (same as memcmp).  */
extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __THROW __attribute_pure__ __nonnull ((1, 2));

/* Find the first occurrence of C in S (same as strchr).  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *index (char *__s, int __c)
     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));
extern __const char *index (__const char *__s, int __c)
     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));

#  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
__extern_always_inline char *
index (char *__s, int __c) __THROW
{
  return __builtin_index (__s, __c);
}

__extern_always_inline __const char *
index (__const char *__s, int __c) __THROW
{
  return __builtin_index (__s, __c);
}
#  endif
# 487 "/usr/include/string.h" 3 4
}
# else
# 489 "/usr/include/string.h" 3 4
extern char *index (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
# endif
# 492 "/usr/include/string.h" 3 4

/* Find the last occurrence of C in S (same as strrchr).  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *rindex (char *__s, int __c)
     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));
extern __const char *rindex (__const char *__s, int __c)
     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));

#  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
__extern_always_inline char *
rindex (char *__s, int __c) __THROW
{
  return __builtin_rindex (__s, __c);
}

__extern_always_inline __const char *
rindex (__const char *__s, int __c) __THROW
{
  return __builtin_rindex (__s, __c);
}
#endif
# 515 "/usr/include/string.h" 3 4
}
# else
# 517 "/usr/include/string.h" 3 4
extern char *rindex (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
# endif
# 520 "/usr/include/string.h" 3 4

/* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  */
extern int ffs (int __i) __THROW __attribute__ ((__const__));

/* The following two functions are non-standard but necessary for non-32 bit
   platforms.  */
# ifdef	__USE_GNU
extern int ffsl (long int __l) __THROW __attribute__ ((__const__));
#  ifdef __GNUC__
__extension__ extern int ffsll (long long int __ll)
     __THROW __attribute__ ((__const__));
#  endif
# 533 "/usr/include/string.h" 3 4
# endif
# 534 "/usr/include/string.h" 3 4

/* Compare S1 and S2, ignoring case.  */
extern int strcasecmp (__const char *__s1, __const char *__s2)
     __THROW __attribute_pure__ __nonnull ((1, 2));

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __THROW __attribute_pure__ __nonnull ((1, 2));
#endif /* Use BSD.  */
# 543 "/usr/include/string.h" 3 4

#ifdef	__USE_GNU
/* Again versions of a few functions which use the given locale instead
   of the global one.  */
extern int strcasecmp_l (__const char *__s1, __const char *__s2,
			 __locale_t __loc)
     __THROW __attribute_pure__ __nonnull ((1, 2, 3));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
			  size_t __n, __locale_t __loc)
     __THROW __attribute_pure__ __nonnull ((1, 2, 4));
#endif
# 555 "/usr/include/string.h" 3 4

#ifdef	__USE_BSD
/* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  */
extern char *strsep (char **__restrict __stringp,
		     __const char *__restrict __delim)
     __THROW __nonnull ((1, 2));
#endif
# 563 "/usr/include/string.h" 3 4

#ifdef	__USE_XOPEN2K8
/* Return a string describing the meaning of the signal number in SIG.  */
extern char *strsignal (int __sig) __THROW;

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __THROW __nonnull ((1, 2));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __THROW __nonnull ((1, 2));

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern char *__stpncpy (char *__restrict __dest,
			__const char *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
extern char *stpncpy (char *__restrict __dest,
		      __const char *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
#endif
# 583 "/usr/include/string.h" 3 4

#ifdef	__USE_GNU
/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
extern int strverscmp (__const char *__s1, __const char *__s2)
     __THROW __attribute_pure__ __nonnull ((1, 2));

/* Sautee STRING briskly.  */
extern char *strfry (char *__string) __THROW __nonnull ((1));

/* Frobnicate N bytes of S.  */
extern void *memfrob (void *__s, size_t __n) __THROW __nonnull ((1));

# ifndef basename
/* Return the file name within directory of FILENAME.  We don't
   declare the function if the `basename' macro is available (defined
   in <libgen.h>) which makes the XPG version of this function
   available.  */
#  ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" char *basename (char *__filename)
     __THROW __asm ("basename") __nonnull ((1));
extern "C++" __const char *basename (__const char *__filename)
     __THROW __asm ("basename") __nonnull ((1));
#  else
# 606 "/usr/include/string.h" 3 4
extern char *basename (__const char *__filename) __THROW __nonnull ((1));
#  endif
# 608 "/usr/include/string.h" 3 4
# endif
# 609 "/usr/include/string.h" 3 4
#endif
# 610 "/usr/include/string.h" 3 4


#if defined __GNUC__ && __GNUC__ >= 2
# if defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__ \
     && !defined __NO_INLINE__ && !defined __cplusplus
/* When using GNU CC we provide some optimized versions of selected
   functions from this header.  There are two kinds of optimizations:

   - machine-dependent optimizations, most probably using inline
     assembler code; these might be quite expensive since the code
     size can increase significantly.
     These optimizations are not used unless the symbol
	__USE_STRING_INLINES
     is defined before including this header.

   - machine-independent optimizations which do not increase the
     code size significantly and which optimize mainly situations
     where one or more arguments are compile-time constants.
     These optimizations are used always when the compiler is
     taught to optimize.

   One can inhibit all optimizations by defining __NO_STRING_INLINES.  */

/* Get the machine-dependent optimizations (if any).  */
#if 0 /* expanded by -frewrite-includes */
#  include <bits/string.h>
#endif /* expanded by -frewrite-includes */
# 634 "/usr/include/string.h" 3 4
# 635 "/usr/include/string.h" 3 4

/* These are generic optimizations which do not add too much inline code.  */
#if 0 /* expanded by -frewrite-includes */
#  include <bits/string2.h>
#endif /* expanded by -frewrite-includes */
# 637 "/usr/include/string.h" 3 4
# 638 "/usr/include/string.h" 3 4
# endif
# 639 "/usr/include/string.h" 3 4

# if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
/* Functions with security checks.  */
#if 0 /* expanded by -frewrite-includes */
#  include <bits/string3.h>
#endif /* expanded by -frewrite-includes */
# 642 "/usr/include/string.h" 3 4
# 643 "/usr/include/string.h" 3 4
# endif
# 644 "/usr/include/string.h" 3 4
#endif
# 645 "/usr/include/string.h" 3 4

__END_DECLS

#endif /* string.h  */
# 649 "/usr/include/string.h" 3 4
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "basictypes.hh"
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh" 1
//=====================================================================
// Copyright (C) 1997-1998 Synopsys Inc. All Rights Reserved.
//
// $RCSfile: basictypes.hh,v $
//=====================================================================
#ifndef _BASICTYPES_HH_
#define _BASICTYPES_HH_

// #ident "$Id$ $Author$ $DateTime$"

#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 1 "/usr/include/sys/types.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */

#ifndef	_SYS_TYPES_H
#define	_SYS_TYPES_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 26 "/usr/include/sys/types.h" 3 4
# 27 "/usr/include/sys/types.h" 3 4

__BEGIN_DECLS

#if 0 /* expanded by -frewrite-includes */
#include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 30 "/usr/include/sys/types.h" 3 4
# 31 "/usr/include/sys/types.h" 3 4

#ifdef	__USE_BSD
# ifndef __u_char_defined
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
#  define __u_char_defined
# endif
# 43 "/usr/include/sys/types.h" 3 4
#endif
# 44 "/usr/include/sys/types.h" 3 4

typedef __loff_t loff_t;

#ifndef __ino_t_defined
# ifndef __USE_FILE_OFFSET64
typedef __ino_t ino_t;
# else
# 51 "/usr/include/sys/types.h" 3 4
typedef __ino64_t ino_t;
# endif
# 53 "/usr/include/sys/types.h" 3 4
# define __ino_t_defined
#endif
# 55 "/usr/include/sys/types.h" 3 4
#if defined __USE_LARGEFILE64 && !defined __ino64_t_defined
typedef __ino64_t ino64_t;
# define __ino64_t_defined
#endif
# 59 "/usr/include/sys/types.h" 3 4

#ifndef __dev_t_defined
typedef __dev_t dev_t;
# define __dev_t_defined
#endif
# 64 "/usr/include/sys/types.h" 3 4

#ifndef __gid_t_defined
typedef __gid_t gid_t;
# define __gid_t_defined
#endif
# 69 "/usr/include/sys/types.h" 3 4

#ifndef __mode_t_defined
typedef __mode_t mode_t;
# define __mode_t_defined
#endif
# 74 "/usr/include/sys/types.h" 3 4

#ifndef __nlink_t_defined
typedef __nlink_t nlink_t;
# define __nlink_t_defined
#endif
# 79 "/usr/include/sys/types.h" 3 4

#ifndef __uid_t_defined
typedef __uid_t uid_t;
# define __uid_t_defined
#endif
# 84 "/usr/include/sys/types.h" 3 4

#ifndef __off_t_defined
# ifndef __USE_FILE_OFFSET64
typedef __off_t off_t;
# else
# 89 "/usr/include/sys/types.h" 3 4
typedef __off64_t off_t;
# endif
# 91 "/usr/include/sys/types.h" 3 4
# define __off_t_defined
#endif
# 93 "/usr/include/sys/types.h" 3 4
#if defined __USE_LARGEFILE64 && !defined __off64_t_defined
typedef __off64_t off64_t;
# define __off64_t_defined
#endif
# 97 "/usr/include/sys/types.h" 3 4

#ifndef __pid_t_defined
typedef __pid_t pid_t;
# define __pid_t_defined
#endif
# 102 "/usr/include/sys/types.h" 3 4

#if (defined __USE_SVID || defined __USE_XOPEN || defined __USE_XOPEN2K8) \
    && !defined __id_t_defined
typedef __id_t id_t;
# define __id_t_defined
#endif
# 108 "/usr/include/sys/types.h" 3 4

#ifndef __ssize_t_defined
typedef __ssize_t ssize_t;
# define __ssize_t_defined
#endif
# 113 "/usr/include/sys/types.h" 3 4

#ifdef	__USE_BSD
# ifndef __daddr_t_defined
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
#  define __daddr_t_defined
# endif
# 120 "/usr/include/sys/types.h" 3 4
#endif
# 121 "/usr/include/sys/types.h" 3 4

#if (defined __USE_SVID || defined __USE_XOPEN) && !defined __key_t_defined
typedef __key_t key_t;
# define __key_t_defined
#endif
# 126 "/usr/include/sys/types.h" 3 4

#if defined __USE_XOPEN || defined __USE_XOPEN2K8
# define __need_clock_t
#endif
# 130 "/usr/include/sys/types.h" 3 4
#define	__need_time_t
#define __need_timer_t
#define __need_clockid_t
#if 0 /* expanded by -frewrite-includes */
#include <time.h>
#endif /* expanded by -frewrite-includes */
# 133 "/usr/include/sys/types.h" 3 4
# 134 "/usr/include/sys/types.h" 3 4

#ifdef __USE_XOPEN
# ifndef __useconds_t_defined
typedef __useconds_t useconds_t;
#  define __useconds_t_defined
# endif
# 140 "/usr/include/sys/types.h" 3 4
# ifndef __suseconds_t_defined
typedef __suseconds_t suseconds_t;
#  define __suseconds_t_defined
# endif
# 144 "/usr/include/sys/types.h" 3 4
#endif
# 145 "/usr/include/sys/types.h" 3 4

#define	__need_size_t
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 147 "/usr/include/sys/types.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 148 "/usr/include/sys/types.h" 2 3 4

#ifdef __USE_MISC
/* Old compatibility names for C types.  */
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
#endif
# 155 "/usr/include/sys/types.h" 3 4

/* These size-specific names are used by some of the inet code.  */

#if !__GNUC_PREREQ (2, 7)

/* These types are defined by the ISO C99 header <inttypes.h>. */
# ifndef __int8_t_defined
#  define __int8_t_defined
typedef	char int8_t;
typedef	short int int16_t;
typedef	int int32_t;
#  if __WORDSIZE == 64
typedef long int int64_t;
#  elif __GLIBC_HAVE_LONG_LONG
# 169 "/usr/include/sys/types.h" 3 4
__extension__ typedef long long int int64_t;
#  endif
# 171 "/usr/include/sys/types.h" 3 4
# endif
# 172 "/usr/include/sys/types.h" 3 4

/* But these were defined by ISO C without the first `_'.  */
typedef	unsigned char u_int8_t;
typedef	unsigned short int u_int16_t;
typedef	unsigned int u_int32_t;
# if __WORDSIZE == 64
typedef unsigned long int u_int64_t;
# elif __GLIBC_HAVE_LONG_LONG
# 180 "/usr/include/sys/types.h" 3 4
__extension__ typedef unsigned long long int u_int64_t;
# endif
# 182 "/usr/include/sys/types.h" 3 4

typedef int register_t;

#else
# 186 "/usr/include/sys/types.h" 3 4

/* For GCC 2.7 and later, we can use specific type-size attributes.  */
# define __intN_t(N, MODE) \
  typedef int int##N##_t __attribute__ ((__mode__ (MODE)))
# define __u_intN_t(N, MODE) \
  typedef unsigned int u_int##N##_t __attribute__ ((__mode__ (MODE)))

# ifndef __int8_t_defined
#  define __int8_t_defined
__intN_t (8, __QI__);
__intN_t (16, __HI__);
__intN_t (32, __SI__);
__intN_t (64, __DI__);
# endif
# 200 "/usr/include/sys/types.h" 3 4

__u_intN_t (8, __QI__);
__u_intN_t (16, __HI__);
__u_intN_t (32, __SI__);
__u_intN_t (64, __DI__);

typedef int register_t __attribute__ ((__mode__ (__word__)));


/* Some code from BIND tests this macro to see if the types above are
   defined.  */
#endif
# 212 "/usr/include/sys/types.h" 3 4
#define __BIT_TYPES_DEFINED__	1


#ifdef	__USE_BSD
/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
#if 0 /* expanded by -frewrite-includes */
# include <endian.h>
#endif /* expanded by -frewrite-includes */
# 217 "/usr/include/sys/types.h" 3 4
# 218 "/usr/include/sys/types.h" 3 4

/* It also defines `fd_set' and the FD_* macros for `select'.  */
#if 0 /* expanded by -frewrite-includes */
# include <sys/select.h>
#endif /* expanded by -frewrite-includes */
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2003, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */

#ifndef _SYS_SELECT_H
#define _SYS_SELECT_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 25 "/usr/include/sys/select.h" 3 4
# 26 "/usr/include/sys/select.h" 3 4

/* Get definition of needed basic types.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/sys/select.h" 3 4
# 29 "/usr/include/sys/select.h" 3 4

/* Get __FD_* definitions.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/select.h>
#endif /* expanded by -frewrite-includes */
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
/* Copyright (C) 1997,1998,1999,2001,2008,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _SYS_SELECT_H
# error "Never use <bits/select.h> directly; include <sys/select.h> instead."
#endif
# 22 "/usr/include/bits/select.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */

#if defined __x86_64__
# define __WORDSIZE	64
# define __WORDSIZE_COMPAT32	1
#else
# 7 "/usr/include/bits/wordsize.h" 3 4
# define __WORDSIZE	32
#endif
# 9 "/usr/include/bits/wordsize.h" 3 4
# 24 "/usr/include/bits/select.h" 2 3 4


#if defined __GNUC__ && __GNUC__ >= 2

# if __WORDSIZE == 64
#  define __FD_ZERO_STOS "stosq"
# else
# 31 "/usr/include/bits/select.h" 3 4
#  define __FD_ZERO_STOS "stosl"
# endif
# 33 "/usr/include/bits/select.h" 3 4

# define __FD_ZERO(fdsp) \
  do {									      \
    int __d0, __d1;							      \
    __asm__ __volatile__ ("cld; rep; " __FD_ZERO_STOS			      \
			  : "=c" (__d0), "=D" (__d1)			      \
			  : "a" (0), "0" (sizeof (fd_set)		      \
					  / sizeof (__fd_mask)),	      \
			    "1" (&__FDS_BITS (fdsp)[0])			      \
			  : "memory");					      \
  } while (0)

#else	/* ! GNU CC */
# 46 "/usr/include/bits/select.h" 3 4

/* We don't use `memset' because this would require a prototype and
   the array isn't too big.  */
# define __FD_ZERO(set)  \
  do {									      \
    unsigned int __i;							      \
    fd_set *__arr = (set);						      \
    for (__i = 0; __i < sizeof (fd_set) / sizeof (__fd_mask); ++__i)	      \
      __FDS_BITS (__arr)[__i] = 0;					      \
  } while (0)

#endif	/* GNU CC */
# 58 "/usr/include/bits/select.h" 3 4

#define __FD_SET(d, set)    (__FDS_BITS (set)[__FDELT (d)] |= __FDMASK (d))
#define __FD_CLR(d, set)    (__FDS_BITS (set)[__FDELT (d)] &= ~__FDMASK (d))
#define __FD_ISSET(d, set) \
  ((__FDS_BITS (set)[__FDELT (d)] & __FDMASK (d)) != 0)
# 32 "/usr/include/sys/select.h" 2 3 4

/* Get __sigset_t.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/sigset.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/sigset.h" 1 3 4
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef	_SIGSET_H_types
# define _SIGSET_H_types	1

typedef int __sig_atomic_t;

/* A `sigset_t' has a bit for each signal.  */

# define _SIGSET_NWORDS	(1024 / (8 * sizeof (unsigned long int)))
typedef struct
  {
    unsigned long int __val[_SIGSET_NWORDS];
  } __sigset_t;

#endif
# 35 "/usr/include/bits/sigset.h" 3 4


/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */

#if !defined _SIGSET_H_fns && defined _SIGNAL_H
# define _SIGSET_H_fns 1

# ifndef _EXTERN_INLINE
#  define _EXTERN_INLINE __extern_inline
# endif
# 49 "/usr/include/bits/sigset.h" 3 4

/* Return a mask that includes the bit for SIG only.  */
# define __sigmask(sig) \
  (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))

/* Return the word index for SIG.  */
# define __sigword(sig)	(((sig) - 1) / (8 * sizeof (unsigned long int)))

# if defined __GNUC__ && __GNUC__ >= 2
#  define __sigemptyset(set) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
		    sigset_t *__set = (set);				      \
		    while (--__cnt >= 0) __set->__val[__cnt] = 0;	      \
		    0; }))
#  define __sigfillset(set) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
		    sigset_t *__set = (set);				      \
		    while (--__cnt >= 0) __set->__val[__cnt] = ~0UL;	      \
		    0; }))

#  ifdef __USE_GNU
/* The POSIX does not specify for handling the whole signal set in one
   command.  This is often wanted and so we define three more functions
   here.  */
#   define __sigisemptyset(set) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
		    const sigset_t *__set = (set);			      \
		    int __ret = __set->__val[--__cnt];			      \
		    while (!__ret && --__cnt >= 0)			      \
			__ret = __set->__val[__cnt];			      \
		    __ret == 0; }))
#   define __sigandset(dest, left, right) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
		    sigset_t *__dest = (dest);				      \
		    const sigset_t *__left = (left);			      \
		    const sigset_t *__right = (right);			      \
		    while (--__cnt >= 0)				      \
		      __dest->__val[__cnt] = (__left->__val[__cnt]	      \
					      & __right->__val[__cnt]);	      \
		    0; }))
#   define __sigorset(dest, left, right) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
		    sigset_t *__dest = (dest);				      \
		    const sigset_t *__left = (left);			      \
		    const sigset_t *__right = (right);			      \
		    while (--__cnt >= 0)				      \
		      __dest->__val[__cnt] = (__left->__val[__cnt]	      \
					      | __right->__val[__cnt]);	      \
		    0; }))
#  endif
# 99 "/usr/include/bits/sigset.h" 3 4
# endif
# 100 "/usr/include/bits/sigset.h" 3 4

/* These functions needn't check for a bogus signal number -- error
   checking is done in the non __ versions.  */

extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);

# ifdef __USE_EXTERN_INLINES
#  define __SIGSETFN(NAME, BODY, CONST)					      \
  _EXTERN_INLINE int							      \
  NAME (CONST __sigset_t *__set, int __sig)				      \
  {									      \
    unsigned long int __mask = __sigmask (__sig);			      \
    unsigned long int __word = __sigword (__sig);			      \
    return BODY;							      \
  }

__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
__SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )

#  undef __SIGSETFN
# endif
# 124 "/usr/include/bits/sigset.h" 3 4


#endif /* ! _SIGSET_H_fns.  */
# 127 "/usr/include/bits/sigset.h" 3 4
# 35 "/usr/include/sys/select.h" 2 3 4

#ifndef __sigset_t_defined
# define __sigset_t_defined
typedef __sigset_t sigset_t;
#endif
# 40 "/usr/include/sys/select.h" 3 4

/* Get definition of timer specification structures.  */
#define __need_time_t
#define __need_timespec
#if 0 /* expanded by -frewrite-includes */
#include <time.h>
#endif /* expanded by -frewrite-includes */
# 44 "/usr/include/sys/select.h" 3 4
# 45 "/usr/include/sys/select.h" 3 4
#define __need_timeval
#if 0 /* expanded by -frewrite-includes */
#include <bits/time.h>
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Generic version.
   Copyright (C) 1996,1997,1999-2002,2003,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <time.h> instead.
 */

#ifndef __need_timeval
# ifndef _BITS_TIME_H
#  define _BITS_TIME_H	1

/* ISO/IEC 9899:1990 7.12.1: <time.h>
   The macro `CLOCKS_PER_SEC' is the number per second of the value
   returned by the `clock' function. */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
#  define CLOCKS_PER_SEC  1000000l

#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
   presents the real value for clock ticks per second for the system.  */
#if 0 /* expanded by -frewrite-includes */
#   include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/bits/time.h" 3 4
# 40 "/usr/include/bits/time.h" 3 4
extern long int __sysconf (int);
#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
#  endif
# 43 "/usr/include/bits/time.h" 3 4

#  ifdef __USE_POSIX199309
/* Identifier for system-wide realtime clock.  */
#   define CLOCK_REALTIME		0
/* Monotonic system-wide clock.  */
#   define CLOCK_MONOTONIC		1
/* High-resolution timer from the CPU.  */
#   define CLOCK_PROCESS_CPUTIME_ID	2
/* Thread-specific CPU-time clock.  */
#   define CLOCK_THREAD_CPUTIME_ID	3
/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
#   define CLOCK_MONOTONIC_RAW		4
/* Identifier for system-wide realtime clock, updated only on ticks.  */
#   define CLOCK_REALTIME_COARSE	5
/* Monotonic system-wide clock, updated only on ticks.  */
#   define CLOCK_MONOTONIC_COARSE	6

/* Flag to indicate time is absolute.  */
#   define TIMER_ABSTIME		1
#  endif
# 63 "/usr/include/bits/time.h" 3 4

# endif	/* bits/time.h */
# 65 "/usr/include/bits/time.h" 3 4
#endif
# 66 "/usr/include/bits/time.h" 3 4

#ifdef __need_timeval
# undef __need_timeval
# ifndef _STRUCT_TIMEVAL
#  define _STRUCT_TIMEVAL	1
#if 0 /* expanded by -frewrite-includes */
#  include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 71 "/usr/include/bits/time.h" 3 4
# 72 "/usr/include/bits/time.h" 3 4

/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec;		/* Seconds.  */
    __suseconds_t tv_usec;	/* Microseconds.  */
  };
# endif	/* struct timeval */
# 81 "/usr/include/bits/time.h" 3 4
#endif	/* need timeval */
# 82 "/usr/include/bits/time.h" 3 4
# 47 "/usr/include/sys/select.h" 2 3 4

#ifndef __suseconds_t_defined
typedef __suseconds_t suseconds_t;
# define __suseconds_t_defined
#endif
# 52 "/usr/include/sys/select.h" 3 4


/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;

/* Some versions of <linux/posix_types.h> define these macros.  */
#undef	__NFDBITS
#undef	__FDELT
#undef	__FDMASK
/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
#define __NFDBITS	(8 * (int) sizeof (__fd_mask))
#define	__FDELT(d)	((d) / __NFDBITS)
#define	__FDMASK(d)	((__fd_mask) 1 << ((d) % __NFDBITS))

/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */
#ifdef __USE_XOPEN
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->fds_bits)
#else
# 75 "/usr/include/sys/select.h" 3 4
    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->__fds_bits)
#endif
# 78 "/usr/include/sys/select.h" 3 4
  } fd_set;

/* Maximum number of file descriptors in `fd_set'.  */
#define	FD_SETSIZE		__FD_SETSIZE

#ifdef __USE_MISC
/* Sometimes the fd_set member is assumed to have this type.  */
typedef __fd_mask fd_mask;

/* Number of bits per word of `fd_set' (some code assumes this is 32).  */
# define NFDBITS		__NFDBITS
#endif
# 90 "/usr/include/sys/select.h" 3 4


/* Access macros for `fd_set'.  */
#define	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)
#define	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)
#define	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)
#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)


__BEGIN_DECLS

/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
		   fd_set *__restrict __writefds,
		   fd_set *__restrict __exceptfds,
		   struct timeval *__restrict __timeout);

#ifdef __USE_XOPEN2K
/* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pselect (int __nfds, fd_set *__restrict __readfds,
		    fd_set *__restrict __writefds,
		    fd_set *__restrict __exceptfds,
		    const struct timespec *__restrict __timeout,
		    const __sigset_t *__restrict __sigmask);
#endif
# 127 "/usr/include/sys/select.h" 3 4

__END_DECLS

#endif /* sys/select.h */
# 131 "/usr/include/sys/select.h" 3 4
# 221 "/usr/include/sys/types.h" 2 3 4

/* BSD defines these symbols, so we follow.  */
#if 0 /* expanded by -frewrite-includes */
# include <sys/sysmacros.h>
#endif /* expanded by -frewrite-includes */
# 223 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/sysmacros.h" 1 3 4
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996, 1997, 1999, 2003, 2004, 2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _SYS_SYSMACROS_H
#define _SYS_SYSMACROS_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 24 "/usr/include/sys/sysmacros.h" 3 4
# 25 "/usr/include/sys/sysmacros.h" 3 4

/* If the compiler does not know long long it is out of luck.  We are
   not going to hack weird hacks to support the dev_t representation
   they need.  */
#ifdef __GLIBC_HAVE_LONG_LONG
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __THROW;
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __THROW;
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
					       unsigned int __minor)
     __THROW;

# if defined __GNUC__ && __GNUC__ >= 2 && defined __USE_EXTERN_INLINES
__extension__ __extern_inline unsigned int
__NTH (gnu_dev_major (unsigned long long int __dev))
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ __extern_inline unsigned int
__NTH (gnu_dev_minor (unsigned long long int __dev))
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ __extern_inline unsigned long long int
__NTH (gnu_dev_makedev (unsigned int __major, unsigned int __minor))
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
	  | (((unsigned long long int) (__minor & ~0xff)) << 12)
	  | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# endif
# 62 "/usr/include/sys/sysmacros.h" 3 4


/* Access the functions with their traditional names.  */
# define major(dev) gnu_dev_major (dev)
# define minor(dev) gnu_dev_minor (dev)
# define makedev(maj, min) gnu_dev_makedev (maj, min)
#endif
# 69 "/usr/include/sys/sysmacros.h" 3 4

#endif /* sys/sysmacros.h */
# 71 "/usr/include/sys/sysmacros.h" 3 4
# 224 "/usr/include/sys/types.h" 2 3 4
#endif /* Use BSD.  */
# 225 "/usr/include/sys/types.h" 3 4


#if (defined __USE_UNIX98 || defined __USE_XOPEN2K8) \
    && !defined __blksize_t_defined
typedef __blksize_t blksize_t;
# define __blksize_t_defined
#endif
# 232 "/usr/include/sys/types.h" 3 4

/* Types from the Large File Support interface.  */
#ifndef __USE_FILE_OFFSET64
# ifndef __blkcnt_t_defined
typedef __blkcnt_t blkcnt_t;	 /* Type to count number of disk blocks.  */
#  define __blkcnt_t_defined
# endif
# 239 "/usr/include/sys/types.h" 3 4
# ifndef __fsblkcnt_t_defined
typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */
#  define __fsblkcnt_t_defined
# endif
# 243 "/usr/include/sys/types.h" 3 4
# ifndef __fsfilcnt_t_defined
typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
#  define __fsfilcnt_t_defined
# endif
# 247 "/usr/include/sys/types.h" 3 4
#else
# 248 "/usr/include/sys/types.h" 3 4
# ifndef __blkcnt_t_defined
typedef __blkcnt64_t blkcnt_t;	   /* Type to count number of disk blocks.  */
#  define __blkcnt_t_defined
# endif
# 252 "/usr/include/sys/types.h" 3 4
# ifndef __fsblkcnt_t_defined
typedef __fsblkcnt64_t fsblkcnt_t; /* Type to count file system blocks.  */
#  define __fsblkcnt_t_defined
# endif
# 256 "/usr/include/sys/types.h" 3 4
# ifndef __fsfilcnt_t_defined
typedef __fsfilcnt64_t fsfilcnt_t; /* Type to count file system inodes.  */
#  define __fsfilcnt_t_defined
# endif
# 260 "/usr/include/sys/types.h" 3 4
#endif
# 261 "/usr/include/sys/types.h" 3 4

#ifdef __USE_LARGEFILE64
typedef __blkcnt64_t blkcnt64_t;     /* Type to count number of disk blocks. */
typedef __fsblkcnt64_t fsblkcnt64_t; /* Type to count file system blocks.  */
typedef __fsfilcnt64_t fsfilcnt64_t; /* Type to count file system inodes.  */
#endif
# 267 "/usr/include/sys/types.h" 3 4


/* Now add the thread types.  */
#if defined __USE_POSIX199506 || defined __USE_UNIX98
#if 0 /* expanded by -frewrite-includes */
# include <bits/pthreadtypes.h>
#endif /* expanded by -frewrite-includes */
# 271 "/usr/include/sys/types.h" 3 4
# 272 "/usr/include/sys/types.h" 3 4
#endif
# 273 "/usr/include/sys/types.h" 3 4

__END_DECLS

#endif /* sys/types.h */
# 277 "/usr/include/sys/types.h" 3 4
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include <strings.h>
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 1 "/usr/include/strings.h" 1 3 4
/* Copyright (C) 1991,1992,1996,1997,1999,2000,2001,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef	_STRINGS_H
#define	_STRINGS_H	1

/* We don't need and should not read this file if <string.h> was already
   read. The one exception being that if __USE_BSD isn't defined, then
   these aren't defined in string.h, so we need to define them here.  */
#if !defined _STRING_H || !defined __USE_BSD

#if 0 /* expanded by -frewrite-includes */
# include <features.h>
#endif /* expanded by -frewrite-includes */
# 28 "/usr/include/strings.h" 3 4
# 29 "/usr/include/strings.h" 3 4
# define __need_size_t
#if 0 /* expanded by -frewrite-includes */
# include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 30 "/usr/include/strings.h" 3 4
# 31 "/usr/include/strings.h" 3 4

/* Tell the caller that we provide correct C++ prototypes.  */
# if defined __cplusplus && __GNUC_PREREQ (4, 4)
#  define __CORRECT_ISO_CPP_STRINGS_H_PROTO
# endif
# 36 "/usr/include/strings.h" 3 4

__BEGIN_DECLS

# if defined __USE_MISC || !defined __USE_XOPEN2K8
/* Compare N bytes of S1 and S2 (same as memcmp).  */
extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __THROW __attribute_pure__;

/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
extern void bcopy (__const void *__src, void *__dest, size_t __n) __THROW;

/* Set N bytes of S to 0.  */
extern void bzero (void *__s, size_t __n) __THROW;

/* Find the first occurrence of C in S (same as strchr).  */
#  ifdef __CORRECT_ISO_CPP_STRINGS_H_PROTO
extern "C++"
{
extern char *index (char *__s, int __c)
     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));
extern __const char *index (__const char *__s, int __c)
     __THROW __asm ("index") __attribute_pure__ __nonnull ((1));

#   if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRING_H_PROTO
__extern_always_inline char *
index (char *__s, int __c) __THROW
{
  return __builtin_index (__s, __c);
}

__extern_always_inline __const char *
index (__const char *__s, int __c) __THROW
{
  return __builtin_index (__s, __c);
}
#   endif
# 72 "/usr/include/strings.h" 3 4
}
#  else
# 74 "/usr/include/strings.h" 3 4
extern char *index (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#  endif
# 77 "/usr/include/strings.h" 3 4

/* Find the last occurrence of C in S (same as strrchr).  */
#  ifdef __CORRECT_ISO_CPP_STRINGS_H_PROTO
extern "C++"
{
extern char *rindex (char *__s, int __c)
     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));
extern __const char *rindex (__const char *__s, int __c)
     __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));

#   if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRING_H_PROTO
__extern_always_inline char *
rindex (char *__s, int __c) __THROW
{
  return __builtin_rindex (__s, __c);
}

__extern_always_inline __const char *
rindex (__const char *__s, int __c) __THROW
{
  return __builtin_rindex (__s, __c);
}
#   endif
# 100 "/usr/include/strings.h" 3 4
}
#  else
# 102 "/usr/include/strings.h" 3 4
extern char *rindex (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#  endif
# 105 "/usr/include/strings.h" 3 4
# endif
# 106 "/usr/include/strings.h" 3 4

#if defined __USE_MISC || !defined __USE_XOPEN2K8 || defined __USE_XOPEN2K8XSI
/* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  */
extern int ffs (int __i) __THROW __attribute__ ((const));
#endif
# 112 "/usr/include/strings.h" 3 4

/* Compare S1 and S2, ignoring case.  */
extern int strcasecmp (__const char *__s1, __const char *__s2)
     __THROW __attribute_pure__;

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __THROW __attribute_pure__;

#ifdef	__USE_XOPEN2K8
/* The following functions are equivalent to the both above but they
   take the locale they use for the collation as an extra argument.
   This is not standardsized but something like will come.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 125 "/usr/include/strings.h" 3 4
# 126 "/usr/include/strings.h" 3 4

/* Again versions of a few functions which use the given locale instead
   of the global one.  */
extern int strcasecmp_l (__const char *__s1, __const char *__s2,
			 __locale_t __loc)
     __THROW __attribute_pure__ __nonnull ((1, 2, 3));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
			  size_t __n, __locale_t __loc)
     __THROW __attribute_pure__ __nonnull ((1, 2, 4));
#endif
# 137 "/usr/include/strings.h" 3 4

__END_DECLS

#endif	/* string.h  */
# 141 "/usr/include/strings.h" 3 4

#endif	/* strings.h  */
# 143 "/usr/include/strings.h" 3 4
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh" 2

#if 0 /* expanded by -frewrite-includes */
#include "../../../../system/typedef64.h"
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h" 1
/***********************************************************************
 * Copyright (c) 2001 Synopsys Inc.
 *  ALL RIGHTS RESERVED
 *  This is unpublished proprietary source code belonging to
 *  Synopsys Inc.
 *
 * This file has typedef's for 64bit port.
 * This file should contain one line typedefs only!
 *
 * $Id$ $Author$ $DateTime$
 **********************************************************************/

#ifndef TYPEDEF64_H
#define TYPEDEF64_H

#if 0 /* expanded by -frewrite-includes */
#include "platform.h"
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"
# 1 "/remote/vgrnd13/bpham/VCS/system/platform.h" 1
/*
//=====================================================================
// Copyright (C) 1997-2000 Synopsys Inc. All Rights Reserved.
//=====================================================================
#ident "$Id$ $Author$ $DateTime$"
*/

#ifndef PLATFORM_H
#define PLATFORM_H

#if 0 /* expanded by -frewrite-includes */
#include "cc64mode.h"
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/system/platform.h"
# 1 "/remote/vgrnd13/bpham/VCS/system/cc64mode.h" 1
/* Note: this file should only contain the definition of VCS_64CCMODE
 *
 * $Id$ $Author$ $DateTime$
 */

#ifndef CC64MODE_H
#  define CC64MODE_H

/* Predefined macros for 64-bit compilation
 * ----------------------------------------
 *
 * __sparcv9 :: predefined in Solaris for 64bit (-xarch=v9 enables it.)
 *          (this also defines _LP64 )
 * __LP64__  :: predefined in HP for 64Bit. (+DA2.0W ... enables it.)
 * _LP64     :: DecAlpha doesnt have any predefines. so, we pass this in
 *          as a -D_LP64 as a c/c++ compiler argument.
 * __ia64    :: Intel 64-bit architecture.
 * __x86_64  :: AMD x86-64 architecture.
 */

/* VCS_64CCMODE expands to:
 *   1 if the C/C++ compiler is working in 64-bit mode
 *   0 otherwise
 */
#if defined(__sparcv9) || defined(__LP64__) || defined(_LP64) || defined(__ia64) || defined(__x86_64)
#  define VCS_64CCMODE 1
#else
# 28 "/remote/vgrnd13/bpham/VCS/system/cc64mode.h"
#  define VCS_64CCMODE 0
#endif
# 30 "/remote/vgrnd13/bpham/VCS/system/cc64mode.h"

#endif /* ifndef CC64MODE_H */
# 32 "/remote/vgrnd13/bpham/VCS/system/cc64mode.h"
# 12 "/remote/vgrnd13/bpham/VCS/system/platform.h" 2

#if defined(VCS64_FLAG)
#    define VCS_64COMPILER 1
#    define VCS_64RUNTIME 1
#else
# 17 "/remote/vgrnd13/bpham/VCS/system/platform.h"
#    define VCS_64COMPILER 0
#    define VCS_64RUNTIME 0
#endif
# 20 "/remote/vgrnd13/bpham/VCS/system/platform.h"

#endif /* ifndef PLATFORM_H */
# 22 "/remote/vgrnd13/bpham/VCS/system/platform.h"

# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h" 2

/* Set _LP64 whenever VCS_64CCMODE is set -- for backward compatibility */
#if VCS_64CCMODE
#  if !defined(__sparcv9) && !defined(_LP64)
#    define _LP64 1
#  endif
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"
#endif
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"

/* vhdl also defines UP and SP */
#ifndef VHDL_TYPEDEF64_H

/* definitions of integer types long enough to store pointers */
/* UP - unsigned, SP - signed */
/* please note that they are equivalents of ANSI C uintptr_t and intptr_t */

#if VCS_64CCMODE
typedef unsigned long UP;
typedef long SP;
#else
# 36 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"
typedef unsigned int UP;
typedef int SP;
#endif
# 39 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"

#endif /* VHDL_TYPEDEF64_H */
# 41 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"

/*----------------------------------------------------------------------------
 * This isn't necessarily the best place, but it's convenient to have a single
 * file describing when to build various optional components.
 *----------------------------------------------------------------------------*/

/* NTB is currently working with:
 * - 32-32 bit builds (except Alpha)
 * - 64-64 bit builds (Solaris and Opteron only)
 */
#if !defined(__alpha) && !defined(__ia64)
#  if !VCS_64CCMODE || defined(sparc) || defined(__x86_64)
#    define VCSBUILD_NTB 1
#  endif
# 55 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"
#endif
# 56 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"

/* System wide constants (to be used in front-end, back-end and RT library) */

/* 2GB - 1 */
#define VCS_MAX_MEMORY_SIZE  0x7fffffff
#define MAX_IP_SIZE (0x7fffffff)

#endif /* TYPEDEF64_H */
# 64 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../../../system/typedef64.h"
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh" 2

//--------------------------------------------------------------------
// First we define some macros of the form __SUPPORTS_xyz__ based
// on the platform/compiler.
//--------------------------------------------------------------------

#ifndef __SUPPORTS_UINT__
#   if defined(__sun) && defined(__SVR4) // Solaris 2.x
#   define __SUPPORTS_UINT__
#   endif
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 26 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_UNCHAR__
#   if defined(__sun) && defined(__SVR4) // Solaris 2.x
#   define __SUPPORTS_UNCHAR__
#   endif
# 31 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 32 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_BOOL__
#   if (defined(__GNUC__)) || \
       (defined(WIN32)) || \
       (defined(__alpha) && defined(__DECCXX_VER) && \
    ((__DECCXX_VER >= 60000000) || defined(_BOOL_EXISTS))) || \
       (defined(_BOOL)) || \
       (defined(_AIX43) && (__IBMCPP__ >= 500))
#   define __SUPPORTS_BOOL__
#   endif
# 42 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 43 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

//--------------------------------------------------------------------
// Now we define stuff based on the __SUPPORTS_xyz__'s defined earlier
//--------------------------------------------------------------------

#ifndef __SUPPORTS_UINT__
typedef unsigned int uint;
#endif
# 51 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_UNCHAR__
typedef unsigned char unchar;
#endif
# 55 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_BOOL__
typedef unsigned char bool;
const bool true = 1;
const bool false = 0;
#   if (defined(__alpha) && defined(__DECCXX_VER) && !defined(_BOOL_EXISTS))
#    define _BOOL_EXISTS
#   endif
# 63 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   if (defined(__sgi) && !defined(_BOOL))
#    define _BOOL
#   endif
# 66 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 67 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"


// Here we define the prototypes of some functions that are
// missing from the standard header files on some platforms.
// Since basictypes.hh is included almost everywhere, it seemed
// the right place to define these (I didn't want to create
// another header file for this stupid stuff).

#if defined(__sun) && !defined(__SVR4) // SunOS 4.1.x
extern "C" void* sbrk(int incr);
extern "C" int strcasecmp(const char* s1, const char* s2);
extern "C" int strncasecmp(const char* s1, const char* s2, int n);
extern "C" int gettimeofday(struct timeval* tp, void*);
#endif // __sun && !__SVR4
# 81 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#if defined(WIN32)
extern "C" void* sbrk(int incr);
extern "C" int gethostid();
#   define strcasecmp stricmp
#   define strncasecmp strnicmp
/*mkdir(<path, accessmode> is not available on NT, so its usage generates compilation error*/
#if 0 /* expanded by -frewrite-includes */
#   include <direct.h>
#endif /* expanded by -frewrite-includes */
# 88 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 89 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   define mkdir(x, y) _mkdir(x)
#   pragma warning(disable:4291)
#   define YY_NEVER_INTERACTIVE 1 /* Needed for .ll files */
#   define MSDOS /* Needed for .yy files */
#   define ftruncate _chsize
#   ifndef PATH_MAX
#   define PATH_MAX 1024
#   endif
# 97 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   define S_IRWXU  (S_IREAD | S_IWRITE | S_IEXEC)
#   ifdef _INC_MATH /* when math.h is included */
/* asinh, acosh, atanh are not defined in NT headers */
#   define asinh(x) log((x) + sqrt((x)*(x) + 1))
#   define acosh(x) log((x) - sqrt((x)*(x) - 1))
#   define atanh(x) log((1 + (x)) / (1 - (x))) / 2
#   endif /* _INC_MATH */
# 104 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif // WIN32
# 105 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef VCS_EXIT
extern "C" {
    extern void VCS_EXIT(int);
}
#endif
# 111 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#endif // _BASICTYPES_HH_
# 113 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

// We always include this part on the spot, even if it causes multiple
// inclusions.  This is because some other include files define NULL
// to be (void*) 0.  g++ wants it to be plain 0.

#ifdef  __GNUC__
#   ifdef NULL
#   undef NULL
#   define NULL 0
#   endif
# 123 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif // __GNUC__
# 124 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "exception.hh"
#endif /* expanded by -frewrite-includes */
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh" 1
//=====================================================================
// Copyright (C) 1997-1998 Synopsys Inc. All Rights Reserved.
//
// $RCSfile: exception.hh,v $
//=====================================================================
// #ident "$Id$ $Author$ $DateTime$"

#ifndef _EXCEPTION_HH_
#define _EXCEPTION_HH_

#if (defined(__GNUC__))             // GNU g++
#if 0 /* expanded by -frewrite-includes */
#   include <exception>
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#elif (defined(__alpha) && defined(__DECCXX))   // DEC cxx
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#if 0 /* expanded by -frewrite-includes */
#   include <exception>
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#elif (defined(__sun) && defined(__SUNPRO_CC))  // SUNWspro CC
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#if (__SUNPRO_CC >= 0x500) && (__cplusplus !=1)
#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#else
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#if 0 /* expanded by -frewrite-includes */
#   include <exception.h>
#endif /* expanded by -frewrite-includes */
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 20 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#endif
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#elif (defined(__mips))             // MIPSpro CC
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#if 0 /* expanded by -frewrite-includes */
#   include <exception.h>
#endif /* expanded by -frewrite-includes */
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#elif (defined(__hppa) && defined(__STDCPP__))  // HP-UX aCC
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#if 0 /* expanded by -frewrite-includes */
#   include <exception.h>
#endif /* expanded by -frewrite-includes */
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#elif (defined(_AIX) && defined(__xlC__))   // AIX xlC
# 26 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#if 0 /* expanded by -frewrite-includes */
#   include <terminate.h>
#endif /* expanded by -frewrite-includes */
# 26 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 27 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#if 0 /* expanded by -frewrite-includes */
#   include <unexpected.h>
#endif /* expanded by -frewrite-includes */
# 27 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 28 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
#endif
# 29 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"

// All exceptions are derived from this abstract base class.
class Exception
{
public:
    Exception()         { inException = true; }
    virtual ~Exception();

    /* coverity[+kill] */
    static bool     beingHandled() {
#ifdef __COVERITY__
        // The "+kill" function annotation doesn't work, so model it
        // explicitly.
        extern void __coverity_panic__();
        __coverity_panic__();
#endif
# 45 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
        return inException;
    }

private:
    static bool inException;
};

// The lowest non-abstract exception. Do not define
// any other type of exception in this file.
class GeneralException : public Exception
{
public:
    GeneralException() {}
    ~GeneralException() {}
};

class VcsVirException : public GeneralException
{
    bool bLoc;
public:
    VcsVirException(bool loc = false) : bLoc(loc) {}
    ~VcsVirException() {}
    bool hasLocation() { return bLoc; }
};

#endif // _EXCEPTION_HH_
# 71 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/exception.hh"
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "cntr_log.h"
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/cntr_log.h" 1
#ifndef _CNTR_LOG_H_
#define _CNTR_LOG_H_

/** @file
* This file defines the 'print_log' interface used throughout
* the VCS code.  These functions are not to be used for error or
* warning messages presented to users, but are still widely used
* for printing to log files, or printing internal messages.
*
* See comerror.h for the proper interface for user messages.
*
*/

/* Typedef for the mPrintStdoutRedirect function. */
typedef void        (*pfvc)(char*);

/* Optional set of mprint log file (defaults to no log file) */
void    setMPrintLogFile(FILE* fp);
FILE*   setMPrintLogFile(const char* fileName, const char* mode = "w");
FILE*   getMPrintLogFile();
void    closeMPrintLogFile();

/* Optional redirect and reset of mprint stdout (defaults to stdout)
 * "pause" and "resume" allow for error messages to go to screen, not file.
 */
void    setMPrintStdoutRedirect(FILE* fp);
FILE*   setMPrintStdoutRedirect(const char* fileName);
void    setMPrintStdoutRedirect(char* buf, int maxLength);
void    setMPrintStdoutRedirect(pfvc fn);
pfvc    getMPrintStdoutRedirectFn();
FILE*   getMPrintStdoutRedirect();
void    closeMPrintStdoutRedirect();
void    pauseMPrintStdoutRedirect();
void    resumeMPrintStdoutRedirect();
void    resetMPrintStdoutRedirect();

// Note:  Radiant Design Tools convention is to not use stderr at all.
// Do not use stderr for *any* messages (even fatals, etc).

#ifndef _AIX
#ifndef VCSELAB
#define printf  USE_MPRINTF_INSTEAD_OF_PRINTF
#define fprintf USE_MFPRINTF_INSTEAD_OF_FPRINTF
#endif
# 45 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/cntr_log.h"
#endif
# 46 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/cntr_log.h"

// Always use these "m" versions to get output buffered to the mprint log file
// The "FILE*" versions (mputc, mfprintf, mvfprintf) behave like the non-FILE*
// versions when FILE*==stdout, that is, they buffer to both stdout and logfile.
// The "FILE*" versions behave normally (non-"m") when FILE* != stdout, that
// is, they write to the specified file without buffering to the logfile.

int mputchar(char);
int mputc(char, FILE*);
int mprintf(const char* fmt, ...);
int mprintf_flush(const char* fmt, ...); // surround mprintf by mflush() calls
int mfprintf(FILE*, const char* fmt, ...);
int     mflush();

// xprintf must be used for printing debug messages. It is
// stripped out from a non-ENGINEER build so that `strings' cannot
// extract the messages from a binary that is shipped to the customer.
#ifdef ENGINEER
#define xprintf(...)     mprintf(__VA_ARGS__)
#else
# 66 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/cntr_log.h"
#define xprintf(...)
#endif
# 68 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/cntr_log.h"

#endif /* _CNTR_LOG_H_ */
# 70 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/cntr_log.h"
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "conutil.h"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/conutil.h" 1
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

#ifndef CONUTIL_H
#define CONUTIL_H

#ifdef __cplusplus
extern "C" {
#endif
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/conutil.h"

typedef void        (*StackTracerFuncC)(void);

/// This function registers a C function to be called on fassert() or
/// fatal() errors. Calling routines would normally bind these to the
/// dumpStackTrace() routine defined in crash_context.h
void registerStackTracerC(StackTracerFuncC stackTracer);

#ifdef __cplusplus
} // extern "C"
#endif
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/conutil.h"

#endif /* CONUTIL_H */
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/conutil.h"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "../../errorinf/include/crash_context.hh"
#endif /* expanded by -frewrite-includes */
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.hh" 1
/***************************************************************************
   SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work of
   Synopsys, Inc., and is fully protected under copyright and trade secret
   laws. You may not view, use, disclose, copy, or distribute this file or
   any information contained herein except pursuant to a valid written
   license from Synopsys.
 ***************************************************************************/

#ifndef _CRASH_CONTEXT_HH
#define _CRASH_CONTEXT_HH

extern "C" {
#if 0 /* expanded by -frewrite-includes */
#include "crash_context.h"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h" 1
/***************************************************************************
   SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work of
   Synopsys, Inc., and is fully protected under copyright and trade secret
   laws. You may not view, use, disclose, copy, or distribute this file or
   any information contained herein except pursuant to a valid written
   license from Synopsys.
 ***************************************************************************/

#ifndef _CRASH_CONTEXT_H
#define _CRASH_CONTEXT_H

#ifdef __cplusplus
extern "C" {
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"

#if 0 /* expanded by -frewrite-includes */
#include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"

/**
 * This file defines the C interface to the crash context library.
 * See crash_context.hh for the motivation for the library.
 */

#ifndef CTASSERT
/**
 * Poor man's compile-time assertions. Can be used wherever declarations are
 * permitted, don't incur any run-time penalties. Use model:
 *     CTASSERT(sizeof(myStruct_t) == sizeof(void*));
 */
# define __CTASSERT(x, y)    typedef char __ctassert_ ## y [(x) ? 1 : -1]
# define _CTASSERT(x, y)     __CTASSERT(x, y)
# define CTASSERT(x)         _CTASSERT(x, __LINE__)
#endif
# 33 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"

/********************************************************************/
/** @defgroup ccodecontext C-code context types and #defines
 * These definitions are for use with context tracking in C code.
 * For C++ code see crash_context.hh
 * @{
 */

/**
 * This struct must be included as the first field in any defined
 * context struct that uses a callback description function.
 *
 * Use wherever a context struct is declared.  Use model:
 *
 * @code
  typedef struct {
    CcodeContextHeader_t hdr;
    kindOfModule* m;
  } MyContext;

  extern void describeMyContext(MyContext*);

  void myCFunction(kindOfModule* mod) {
    SET_UP_CONTEXT(MyContext, contextVar, describeMyContext);
    contextVar.m = mod;
    ...
    REMOVE_CONTEXT(contextVar);
  }
 * @endcode
 *
 * You can also use it for struct objects whose allocation and deallocation
 * you manage yourself.  For example:
 * @code
 * MyContext* thing = ...
 * INIT_CONTEXT_PTR(thing, describeMyContext);
 * @endcode
 */
typedef struct {
    void* reserved1;
    void* reserved2;
    void* reserved3;
    void* reserved4;
} CcodeContextHeader_t;

/**
 * The description function takes void*; it will be passed a
 * CcodeContext pointer that it must cast to its own struct type.
 * Use with structs that contain CcodeContextHeader_t.
 */
typedef void (*DescriptionFunction)(void*);

/**
 * Use to initialize the context tracking for an already-allocated
 * or declared C struct object whose first member is a CcodeContextHeader_t
 * field.
 */
#define INIT_CONTEXT_PTR(type, pctxtvar, function) \
    CTASSERT(sizeof(*pctxtvar) >= sizeof(CcodeContextHeader_t)); \
    pctxtvar = (type*)trackerInitializeContextHeader(pctxtvar, function, 0);

/**
 * Use to remove a ctxt variable pointer from the stack.  To be used
 * with INIT_CONTEXT.
 */
#define REMOVE_CONTEXT_PTR(pctxtvar) \
    trackerRemoveContext(pctxtvar);

/**
 * These flags are used to control the behavior of various virtual functions
 * in the AbstractContext class when we are creating context objects through
 * the C interface (i.e., SET_UP_CONTEXT_FLAGS).
 * See the AbstractContext class declaration in crash_context.hh for how
 * these are interpreted.
 */
typedef enum {
    CTXT_FLAGS_UNKNOWN = 0,
    /** @defgroup exitflags These flags are mutually exclusive. */
    /** @{ */
    CTXT_FLAGS_DUMP_ON_EXIT = (1 << 1),
    CTXT_FLAGS_DO_NOT_DUMP_ON_EXIT = (1 << 2)
    /** @} */
} CTXT_FLAGS;

/**
 * The SET_UP_CONTEXT and SET_UP_CONTEXT_FLAGS macros are used to
 * declare a context object.  Using this macro puts the context object
 * onto the context stack so it can be found if a crash occurs.  Use
 * with context structs that contains CcodeContextHeader_t.  Use
 * REMOVE_CONTEXT when the context no longer applies.  The funny
 * business with the void* is there so coverity will detect when
 * someone has a SET_UP_CONTEXT without a corresponding
 * REMOVE_CONTEXT.  The flags argument is an or'd-together set of
 * CTXT_FLAGS values (above).
 */
#define SET_UP_CONTEXT_FLAGS(type, ctxtvar, function, flags) \
    type ctxtvar; \
    void* p##ctxtvar; \
    CTASSERT(sizeof(ctxtvar) >= sizeof(CcodeContextHeader_t)); \
    p##ctxtvar = trackerInitializeContextHeader(&ctxtvar, function, flags);

#define SET_UP_CONTEXT(type, ctxtvar, function) \
    SET_UP_CONTEXT_FLAGS(type, ctxtvar, function, 0)

/**
 * For context variables created with SET_UP_CONTEXT, use REMOVE_CONTEXT
 * to pop them off the context stack.
 */
#define REMOVE_CONTEXT(ctxtvar) \
    trackerRemoveContext((void*)p##ctxtvar);

/**@}  end of C-code context definitions **************************/

/**
 * When a crash or assertion failure occurs, this function is called
 * to dump the collected context out for debugging.
 */
extern void trackerDumpContextStack(void);

/**
 * This routine verifies that the context stack contains useful
 * context info.  If not, it reports the file, line and function
 * location of the macro to help track down where context is needed.
 * You can also set VG_ENG_SWITCH="vtg.context.dump.stack" to display
 * a full program stack dump of the failing location.
 */
extern void trackerCheckContext(const char* file, const char* func, int line);

/**
 * This routine allows a program to enable context checking.
 * For example, most programs run an initialization phase prior to
 * processing customer files.  During initialization the context stack
 * will normally be empty. Assertion checking should not report errors
 * before it is explicitly enabled with this call.
 */
extern void trackerEnableContextChecking(void);

/** @defgroup emitfns Context dumping functions
 * These functions are used to dump context from context object
 * "describeContext" functions.
 *
 * An example use model is shown below.  Note that the dumpModule function
 * is defined for the fictitious "kindOfModule" type, and would be used in all
 * description functions that involved "kindOfModule".
 *
 * Every describeContext function should call either trackerEmitFrameType
 * or trackerEmitContextPhase as its first output.  trackerEmitContextPhase
 * should be used when the context type is directly tied to a given phase
 * of execution (e.g., coverage instrumentation or parsing).
 *
 * trackerEmitFrameType should be used when the context type is not tied
 * to any particular phase or flow.
 *
 * @code
  static void dumpModule(kindOfModule* m) {
    if (m) {
      trackerEmitScope("Module", getModuleName(m));
      trackerEmitLocation("declared at", getModuleFile(m), getModuleLine(m));
    }
  }
  void describeMyContext(MyContext* myc) {
    trackerEmitContextPhase("My Pass");
    if (myc) {
      dumpModule(myc->m);
    }
  }
 * @endcode
 */
/*@{*/
void trackerEmitContextPhase(const char* phasename);
void trackerEmitScope(const char* scopetype, const char* scopename);
void trackerEmitLocation(const char* intro, const char* filename,
                         const int lineno);
void trackerEmitContextString(const char* key, const char* value);
void trackerEmitContextInt(const char* key, const int value);
void trackerEmitContextFrame(const char* name);
/*@}*/

/**
 * Use this function to insert a context check site in the code.  This
 * has no effect unless the code is compiled under ENGINEER, and
 * VG_ENG_SWITCH contains the string 'vtg.force.crash=NNN', where the argument
 * to CONTEXT_CHECK is a subset of NNN.
 */
#ifdef ENGINEER
#define CONTEXT_CHECK(checkname) forceCrashForContextTesting(checkname)
#else
# 219 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
#define CONTEXT_CHECK(checkname)
#endif
# 221 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"

/**
 * Used internally by the SET_UP_CONTEXT macro.  Do not use directly.
 */
extern void* trackerInitializeContextHeader(void* ctxt,
                                            DescriptionFunction fn,
                                            unsigned flags);

typedef enum {
    CTXT_REASON_UNKNOWN = 0,
    CTXT_REASON_SIGNAL,            /**< caught fatal signal (e.g., SEGV).
                                    * If signal number is known, use
                                    * dumpStackTraceWithSig() */
    CTXT_REASON_ASSERTION,         /**< assertion failure (e.g., fassert) */
    CTXT_REASON_INTERNAL_ERROR,    /**< internal error in the tool */
    CTXT_REASON_UNCONTROLLED_EXIT, /**< process called 'exit' unexpectedly */
    CTXT_REASON_ONEXIT_DIAG,       /**< exit called an -xdiag onexit given */
    CTXT_REASON_CONTROLLED,        /**< diagnostic stack dump, not an error */
    CTXT_REASON_STACK_OVERFLOW,    /**< stack overflow detected */
    CTXT_REASON_OUT_OF_MEMORY,     /**< out of memory detected */
    CTXT_REASON_CONTEXT_DIAG,      /**< requested by -context_on_error */
    CTXT_REASON_MAX
} vcsMsgDumpReason;

/** Display process stack trace. */
extern void dumpStackTrace(void);

/** Display process stack trace after an assertion failure */
extern void dumpStackTraceForAssert(void);

/** Display process stack trace with reason */
extern void dumpStackTraceWithReason(vcsMsgDumpReason);

/** Display process stack trace due to signal */
extern void dumpStackTraceWithSig(int signo);

/**
 * Set stack trace tool to be used by dumpStackTrace.
 * This is normally called at program startup.
 */
extern void setStackTraceTool(const char* argv0);

/**
 * Returns the name of the tool selected by setStackTraceTool.
 */
extern char* getStackTraceTool(void);

/**
 * Sets dumpStackTrace() as the handler for the following set of
 * signals: SIGILL, SIGABRT, SIGBUS, SIGFPE, SIGSEGV and SIGSYS.
 * The argv0 parameter is passed to setStackTraceTool().
 * This routine is normally called at program startup.
 * If a fault occurs, the handler will call dumpStackTrace(),
 * then exit(1).
 */
extern void trackerSetExceptionHandler(const char* argv0);

/**
 * Define CONTEXT_TEST to force vcs_assert.h assertion's to check the
 * status of the context stack.
 */
#if defined(CONTEXT_TEST)
#  if defined(linux)
#    define UUFUNCUU  __func__
#  else
# 286 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
#    define UUFUNCUU  "unknown"
#  endif
# 288 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
#  define AFFIRM(ex) (trackerCheckContext(__FILE__, UUFUNCUU, __LINE__),(ex))
#else
# 290 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
#  define AFFIRM(ex) (ex)
#endif
# 292 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"

/**
 * The vcsAssertHandler routine will normally call exit(-1) after
 * displaying the context/process stacks.  You can specify a different
 * routine (eg, VCS_EXIT) if you need to clean up before exiting.
 */
extern void trackerSetAssertExitRoutine(void (*func)(int));

/**
 * This routine registers an 'on_exit' handler that checks for
 * abnormal program exits.  All binaries which ship to customers must
 * call trackerRegisterOnExit from their main() routine to enable the
 * exit check routine.
 */
extern void trackerRegisterOnExit(void);
#ifdef linux
    typedef void (*onExitCallbackFn)(int, void*);
#else
# 310 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
    typedef void (*onExitCallbackFn)(void);
#endif
# 312 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"

void trackerRegisterOnExitFunction(onExitCallbackFn fn);

/**
 * Processes and removes the assertion ON/OFF cmdline flags.
 * All binaries which ship to customers must call this routine.
 */
extern char** trackerParseCmdLine(int argc, char** argv, int* pargc);

/**
 * CAUTION: These routines are called by vcs generated code.  You must
 * update cg/geninit.c and vhdl-src/sim/sckernel/make.c if you modify
 * the function interface.
 */
char** trackerParseArgs(int argc, char** argv);
int trackerCountArgs(char** argv);

/**
 * Use trackerAssertModeT to modify the assertion report.
 */
typedef enum {
    trackerAssertIOFF,          /* initially OFF (can be enabled) */
    trackerAssertION,           /* initially ON (can be disabled) */
    trackerAssertEXIT           /* always exits (cannot be disabled) */
} trackerAssertModeT;

extern void vcsAssertHandler(trackerAssertModeT mode,
                             const char *psAssertion,
                             unsigned uLine,
                             const char *psFile,
                             const char* msg);

/**
 * Guaranteed to exit ... used where we need to suppress compiler
 * errors about code paths not being reached.
 */
extern void vcsAssertNoReturn(const char *psAssertion,
                              unsigned uLine,
                              const char *psFile,
                              const char* msg)
#if defined(__GNUC__) && defined(__linux__)
__attribute__ ((__noreturn__))
#endif
# 355 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
;

extern int vcsAssertIoffEnabled; /* true if ioff asserts have been enabled. */
extern int vcsAssertIonDisabled; /* true if ion asserts have been disabled. */

/**
 * Used by the CONTEXT_CHECK macro - see above
 */
extern void forceCrashForContextTesting(const char* checkname);

/**
 * Use cmsg to format a string to be passed to vcsAssertHandler.
 * Caution: cmsg returns a pointer to a static buffer.
 */
extern char* cmsg(const char* format, ...)
#if defined(__GNUC__) && defined(__linux__)
__attribute__ ((format (__printf__, 1, 2)))
#endif
# 373 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
;

/**
 * Used internally by the SET_UP_PHASE macro.  Do not use directly.
 */
extern void trackerInitializePhaseContext(void* ctxt, const char* phase);

/**
 * Used internally by the REMOVE_CONTEXT macro.  Do not use directly.
 */
extern void trackerRemoveContext(void* ctxt);

/**
 * Do not use this routine.
 */
extern void AssFail(const char *psAssertion, unsigned uLine, const char *psFile);

/**
 * Routines to register for callback on assertion or signal fault.
 */
typedef void (*vcsSystemFaultCB)();
extern void vcsAddSystemFaultCB(vcsSystemFaultCB func, const char*option);
extern void vcsClearSystemFaultCB();

#ifdef __cplusplus
}
#endif
# 400 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
#endif /* _CRASH_CONTEXT_H */
# 401 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.h"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.hh" 2
}

namespace tracker {

class contextState;

/**
 * Base class for context data.
 * In C++ code, all context data types should be derived from this.
 *
 * For example, for a fictitious class VhdlArch, you could derive
 * a context class like this:
 * @code
  class VhdlArchContext : public AbstractContext {
    VhdlArch* arch_;
  public:
    VhdlArchContext(VhdlArch*) : arch_(NULL) { }
    VhdlArchContext(VhdlArch* a) : arch_(a) { }
    virtual void describe();
    virtual void updateArch(VhdlArch* a) { arch_ = a; }
  };
 * @endcode
 *
 * Then when code is traversing through architectures, you could
 * use VhdlArchContext like as shown below, where the architecture is
 * updated as each loop iteration begins:
 * @code
  void myAnalysisFunction(...) {
    VhdlArchContext myContext;
    ...
    for(VhdlArch* a = architer.begin(); a; a = architer++) {
      myContext.updateArch(a);
      ...
    }
  }
 * @endcode
 */
class AbstractContext {
    int index_;      //!< This frame's position in the context stack.

    void pushOnStack();

    static void invokeTerminationCallback(contextState* ctxtSt,
                                          vcsMsgDumpReason reas,
                                          int signo,
                                          const char* callback);
public:
    AbstractContext(const AbstractContext&);
    AbstractContext& operator=(const AbstractContext&);

    /// Function to describe the context object.  This will call the
    /// emit* functions defined in crash_context.h.  The code that is
    /// deriving from AbstractContext should redefine this method.
    virtual void describeContext() {
        trackerEmitContextFrame("Incomplete context frame");
    }

    /// The context tracking library generally intercepts calls to
    /// exit(). The rules are:
    /// - At compile time, if the exit status is nonzero and no error message
    /// has been emitted, we will dump context & the stack.  This check can
    /// only be done on linux because only on linux can we get the value
    /// of the argument passed to exit().
    /// - At runtime, we generally will not dump context on any exit.  However,
    /// when exit is called we do traverse the context stack and check if
    /// any of the context frames tells us we should, using by returning
    /// CTXT_FLAGS_DUMP_ON_EXIT from getContextFlags.
    /// - If we find a context frame that has CTXT_FLAGS_DO_NOT_DUMP_ON_EXIT set,
    /// however, we stop looking and do not dump context even if an older
    /// frame has CTXT_FLAGS_DUMP_ON_EXIT set.
    /// - Finally, if the -xdiags exits flag is given on the command line, we
    /// will dump context and the stack on ANY call to exit, regardless of
    /// the exit status or context frame flags.
    virtual int getContextFlags();

    /// Pushes the new context to the top of the stack.
    AbstractContext();

    /// Returns the top of the context stack.
    static AbstractContext* getContextStack();

    /// Gets the next context stack frame after this one
    AbstractContext* getNext();

    /// Pop 'this' from the top of the stack
    /// and remove any contexts that were above it on the stack.
    virtual ~AbstractContext();

    enum dumpFromT { DUMPING_UNKNOWN,
                     DUMPING_CONTEXT_ONLY,
                     DUMPING_CONTEXT_AND_STACK,
                     DUMPING_MAX };

    /// Dump all available context.
    /// This symbol is not visible outside of this library - use
    /// trackerDumpContextStack instead.
    static void dumpContextStack(dumpFromT df=DUMPING_UNKNOWN,
                                 vcsMsgDumpReason reas=CTXT_REASON_UNKNOWN,
                                 int signo=0);

#ifdef CONTEXT_TEST
    static void checkContext(const char* file, const char* func, int line);
#endif // CONTEXT_TEST
# 117 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.hh"

    static void enableContextChecking();
    static void disableContextChecking();

    /// Pop the stack from the given context upwards
    static void removeContext(AbstractContext* ctxt);

    friend class contextState;
};

/**
 * This class can be used by anyone who wants to just record a
 * phase name, such as "design resolution" or "coverage instrumentation".
 * It has no HDL context itself - the HDL context will be provided by
 * lower-level context objects.
 *
 * Code that wants to provide more context data than just a phase
 * name should derive their own class from AbstractContext
 */
class PhaseContext : public AbstractContext {
    const char* name_;
public:
    PhaseContext(const char* name) : name_(name) { }
    virtual void describeContext();
};
contextState* getGlobalCrashContext();
void setGlobalCrashContext(contextState*);

}

#endif /* _CRASH_CONTEXT_HH */
# 148 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/crash_context.hh"
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "../../errorinf/include/vcs_util.h"
#endif /* expanded by -frewrite-includes */
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/vcs_util.h" 1
/***************************************************************************
   SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work of
   Synopsys, Inc., and is fully protected under copyright and trade secret
   laws. You may not view, use, disclose, copy, or distribute this file or
   any information contained herein except pursuant to a valid written
   license from Synopsys.
 ***************************************************************************/

#ifndef _VCS_UTIL_H_
#define _VCS_UTIL_H_

#ifdef __cplusplus
extern "C" {
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/vcs_util.h"

#ifndef SNPS_MARKUSED
#   define SNPS_MARKUSED(X)  ((void)(sizeof(X)))
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/vcs_util.h"

#ifdef __cplusplus
}
#endif
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/vcs_util.h"

#endif /* _VCS_UTIL_H_ */
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/../../errorinf/include/vcs_util.h"
# 20 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh" 2

/// Typedef for registerOutOfMemoryFunction
typedef void        (*OOMFunc)();

/// Typedef for stackTracer function.
typedef void        (*StackTracerFunc)(void);

/// Standard min and max.
#if !defined(min)
inline int min(int a, int b)    { return a < b ? a : b; }
inline int max(int a, int b)    { return a > b ? a : b; }
#endif
# 32 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

// Poor man's compile-time assertions. Can be used wherever declarations are
// permitted; do not incur any run-time penalties. Use model:
//     CTASSERT(sizeof(myStruct_t) == sizeof(void*));
#ifndef CTASSERT
#    define __CTASSERT(x, y)    typedef char __ctassert_ ## y [(x) ? 1 : -1]
#    define _CTASSERT(x, y)     __CTASSERT(x, y)
#    define CTASSERT(x)         _CTASSERT(x, __LINE__)
#endif
# 41 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

/// Macro for determining sizes of static arrays
#ifndef asizeof
#  define asizeof(a) ((sizeof(a) / sizeof((a)[0])))
#endif
# 46 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

// Fatal errors:  invoke as follows:
//  fassert(condition, msg("text %d <%s>...", arg1, <arg2>...));
//  fatal(msg(<same as above>));

// Warnings:  invoke as follows:
//  wassert(<same as fassert above>);
//  warning(<same as fatal above>);

// Don't define this type - only the forward declaration is needed
struct MsgWasAlreadyCalled;

/// This function prints the arg and interpret any varargs as
/// printf. Always use msg() (or NULL, or a string literal) as an
/// argument to fassert, fatal, wassert, warning.
MsgWasAlreadyCalled& msg(const char* s, ...);

/// This function prints the arg and interpret any varargs as
/// vprintf. Always use msg() (or NULL, or a string literal) as an
/// argument to fassert, fatal, wassert, warning.
MsgWasAlreadyCalled& vmsg(const char* s, va_list ap);

// These two wrapper functions are intended to allow msg(), string literals and
// NULL as fassert() and fatal() arguments. Note that the first version uses a
// reference on purpose - otherwise 'NULL' would result in an ambiguity.
inline bool makeSureMessageWasPrinted(MsgWasAlreadyCalled&) {
    // No need to do anything - msg() was called when the argument was
    // evaluated
    return false;
}
inline bool makeSureMessageWasPrinted(const char* txt) {
    if (txt) {
        msg(txt);
    }
    return false;
}

/// What should internalError() do ?
enum IEWhatNext {
    /// Unconditionally throw GeneralException().
    IEHardExitC,

    /// Throw GeneralException() if VCS_DISABLE_EXIT_ON_FASSERT is not set.
    IESoftExitC,

    /// Call UtilGlobal::outOfMemoryFunction(), then unconditionally throw
    /// GeneralException().
    IEOutOfMemC
};

int     internalError_wrap(const char* expression, const char* file, int line, IEWhatNext whatNext);
/// This macro should be used anytime you allocate memory with
/// malloc or any allocator that could return NULL on failure.
/// It will print some useful information before exiting. This must
/// be left even in NO_DEBUG mode.
/// @note This is not needed for the LifeGuard.
/// @todo FIX--make better message (query operating system
/// information, etc.)
#define memcheck(EX) (void)(AFFIRM(EX) || \
                            makeSureMessageWasPrinted("Out of Memory") || \
                            internalError_wrap(#EX,__FILE__, __LINE__, IEOutOfMemC))

/// The fatal macro always causes an exception to be thrown,
/// independently of ENGINEER mode. This is a macro in order to allow
/// the compiler to fill in the file (__FILE__) and line number
/// (__LINE__) at the point the macro shows up in the source. The
/// stmt should be an invocation of the msg function, or a literal
/// string.
#define fatal(stmt)  (void)(Exception::beingHandled() || \
                            makeSureMessageWasPrinted(stmt) || \
                            internalError_wrap(0, __FILE__, __LINE__, IEHardExitC))
#define fatal2(EX,stmt) (void)((EX) || (Exception::beingHandled() || \
                                        makeSureMessageWasPrinted(stmt) || \
                                        internalError_wrap(#EX,__FILE__, __LINE__, IESoftExitC)))
#define fatal3(EX) (void)((EX) || (Exception::beingHandled() || \
                                   internalError_wrap(#EX,__FILE__, __LINE__, IESoftExitC)))
#define fatal_davinci(EX) (void)((EX) || (Exception::beingHandled() || davinci_context() || \
                                          internalError_wrap(#EX,__FILE__, __LINE__, IESoftExitC)))

/// The passert (production assert) macro always causes an exception
/// to be thrown, independently of ENGINEER mode. This is a macro in
/// order to allow the compiler to fill in the file (__FILE__) and
/// line number (__LINE__) at the point the macro shows up in the
/// source. The stmt should be an invocation of the msg function, or a
/// literal string.
#define passert(EX,stmt)(void) (AFFIRM(EX) || \
                                makeSureMessageWasPrinted(stmt) || \
                                internalError_wrap(#EX,__FILE__, __LINE__, IEHardExitC))

#define FASSERT_INNER(EX,stmt)  AFFIRM(EX) || \
                                Exception::beingHandled() || \
                                makeSureMessageWasPrinted(stmt) || \
                                internalError_wrap(#EX,__FILE__, __LINE__, IESoftExitC)

#define WASSERT_INNER(EX,stmt)  (EX) || \
                                internalWarning(#EX,__FILE__, __LINE__) || \
                                makeSureMessageWasPrinted(stmt)

#define WARNING_INTERNAL(stmt)  internalWarning(0,__FILE__, __LINE__) || \
                                makeSureMessageWasPrinted(stmt)

#if !defined(ENGINEER) && !defined(Synopsys_Debug) // non-engr builds with checks stripped out:

#if defined(sparc) || defined(_AIX)
#define fassert(EX,stmt) ((void)0)
#define wassert(EX,stmt) ((void)0)
#define nullcheck(EX) ((void)0)
#define warning(stmt)    ((void)0)
#define ifdebug(stmt)    ((void)0)
#else
# 156 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
bool shouldBeOptimizedOut(void);
#define fassert(EX,stmt) while (false) \
                                (void)(shouldBeOptimizedOut() || \
                                FASSERT_INNER(EX,stmt))
#define wassert(EX,stmt) while (false) \
                                (void)(shouldBeOptimizedOut() || \
                                WASSERT_INNER(EX,stmt))
#define warning(stmt)    while (false) \
                                (void)(shouldBeOptimizedOut() || \
                                WARNING_INTERNAL(stmt))
#define ifdebug(stmt)    while (false) \
                                (stmt)
#endif
# 169 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

#else           // default debug mode:
# 171 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

/// The fassert macro will cause an exception to be thrown if EX is false
/// if the build was compiled with ENGINEER set. This is a macro in
/// order to allow the compiler to fill in the file (__FILE__) and
/// line number (__LINE__) at the point the macro shows up in the
/// source. The stmt should be an invocation of the msg function, or a
/// literal string.
/// @note Prefer fatal(stmt) over fassert(0, stmt).
#define fassert(EX,stmt) (void)(FASSERT_INNER(EX,stmt))

// Warnings
#define wassert(EX,stmt) (void)(WASSERT_INNER(EX,stmt))
#define warning(stmt)    (void)(WARNING_INTERNAL(stmt))

// Conditional execution of a statement
#define ifdebug(stmt) (stmt)

#endif  // NO_DEBUG
# 189 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

#if (((defined(sparc) || defined(_AIX)) && defined(ENGINEER)) || \
     (!defined(sparc) && !defined(_AIX)))

/// The nullcheck macro will cause an exception to be thrown if EX is
/// false if the build was compiled with ENGINEER set. This is a macro
/// in order to allow the compiler to fill in the file (__FILE__) and
/// line number (__LINE__) at the point the macro shows up in the
/// source. It is equivalent to fassert(EX, "Illegal NULL in pointer").
#define nullcheck(EX) fassert(EX, msg("Illegal NULL in pointer"))

#endif
# 201 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

// Do not use these routines directly!  (Internal use only)
int virExit();
int     internalError(const char* expression, const char* file, int line,
                      IEWhatNext whatNext);
int internalWarning(const char* expression, const char* file, int line);
int mvprintf(const char* fmt, va_list ap);
int callOutOfMemoryFunction();

// Miscellaneous
char* getRadTimeAndDate();

bool isEscaped(const char*);
#ifdef __cplusplus
extern "C" {
#endif
# 217 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
bool isEscapedByLength(const char*, int len);
#ifdef __cplusplus
}
#endif
# 221 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"

// true if the name prints as an escaped identifier e.g. "\foo[10] ;"
bool makeUnescapedFromEscaped(char* to, const char* from, const char repl);
// makes an unescaped string from an escaped one by replacing the
// escaped char by "repl".
bool hasHighOrderChars(const char* n);
// true if name has '.'+80, '['+0x80 or ']'+0x80
bool isVhdlExtendedId(const char*);
// true if the name has an '\' to start with e.g. "\foo[10]\ ;"
void convertToUpper(char* s);
void convertToLower(char* s);
bool isupperstr(const char* s);
char* vcsStrUpcaseCpy(char* dest, const char * src);
// char* vcsStrLowercaseCpy (const char* s);
char * convertToVhdlToken(char * ret, const char * str, int* isSpaceInExtendedId=NULL, bool processSpaceInExtendedId=false);

/// Converts all special characters into underscores.
void convertSpecialCharsToUnderscores(char* s);

/// Converts all special characters by clearing top bit.
void clearSpecialChars(char* s);
unsigned char ClearTopBit(unsigned char byte);
bool IsSpecialChar(const char n);
bool isWSCharacter(char const c);
bool isEWSCharacter(char const c);
bool isIDCharacter(char const c, bool start = false);
const char* lookForCharacter(const char* p, char const lookFor);

int mstrcmp(const char *s1, const char *s2,
            bool isCaseInsensitive);
int mstrncmp(const char *s1, const char *s2, size_t n,
             bool isCaseInsensitive);

int convertToDecimal(const char* s, bool& isOk);

int getIntProduct(int a, int b, bool& overOrUnderFlow);
// returns a * b with overOrUnderFlow indicating any overflow or
// underflow.

/// This function registers a function to be called when we run out of
/// memory.
/// @return old function
OOMFunc registerOutOfMemoryFunction(OOMFunc newFn);

/// This function calls the function registered by registerStackTracerC().
void callStackTracer();

// utility functions for Generate name handling
void    EscapeNameForGenerate(char** );
void    FixName(char* objName);

// This controls the verbosity of the whole program.
class PrintMode
{
public:
    PrintMode() :
        verbose(1) {}
    enum {      MaxVerbose = 9 };
    /** Sets new verbosity level and returns old level. */
    int     setVerbose(int i) {
        fassert((i >= 0) && (i <= MaxVerbose),
                msg("PrintMode.setVerbose level '%u' too high", i));
        int ret = verbose;
        verbose = i;
        return ret;
    }
    int         getVerbose() const  { return verbose; }
    bool        isQuiet()    const  { return verbose == 0; }
    bool        isVerbose1() const  { return verbose >= 1; }
#ifdef ENGINEER
    bool        isVerbose2() const  { return verbose >= 2; }
    bool        isVerbose3() const  { return verbose >= 3; }
    bool        isVerbose4() const  { return verbose >= 4; }
    bool        isVerbose5() const  { return verbose >= 5; }
    bool        isVerbose6() const  { return verbose >= 6; }
    bool        isVerbose7() const  { return verbose >= 7; }
    bool        isVerbose8() const  { return verbose >= 8; }
    bool        isVerbose9() const  { return verbose >= 9; }
#else
# 300 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
    // Since the following always return false, a good optimizing
    // C++ compiler should eliminate (almost) all of the the debug code.
    bool        isVerbose2() const  { return false; }
    bool        isVerbose3() const  { return false; }
    bool        isVerbose4() const  { return false; }
    bool        isVerbose5() const  { return false; }
    bool        isVerbose6() const  { return false; }
    bool        isVerbose7() const  { return false; }
    bool        isVerbose8() const  { return false; }
    bool        isVerbose9() const  { return false; }
#endif
# 311 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
private:
    int     verbose;
};

extern PrintMode printMode;

// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : AutoDetachItems<ListT>
//
//  When an object of this class goes out of scope, it detaches the list items.
//  Use this class for automatic lists (i.e., allocated on the stack) that do
//  not own the list items.
// ----------------------------------------------------------------------------

template <class ListT>
class AutoDetachItems
{
public:

    AutoDetachItems() : mList() {}

    ListT& operator() () { return mList; }  // to access the list

    ~AutoDetachItems() {
#ifdef ENGINEER
        mList.detachItems();
#endif // ENGINEER
# 338 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
    }

private:

    // disabled
    AutoDetachItems(const AutoDetachItems<ListT>&);
    AutoDetachItems<ListT>& operator = (const AutoDetachItems<ListT>&);

private:

    ListT mList;    // the list
};

// ----------------------------------------------------------------------------
//  FUNCTION TEMPLATE : deleteListItems<ListT>
//
//  Deletes all the items in the list.
//  Use this function only for lists that own the list items.
// ----------------------------------------------------------------------------

template <class ListT>
inline void deleteListItems(ListT& list)
{
    while (!list.isEmpty()) {
        delete list.detachFirst();
    }
}

#define VCS_UNIT_NAME           "$unit"
#define VCS_UNIT_LENGTH         5
#define VCS_UNIT_INT_NAME       "_vcs_unit__"
#define VCS_UNIT_INT_LENGTH     11
#define VCS_UNIT_PKG_SUFFIX     "as_pkg__"

/// Returns true for names starting with VCS_UNIT_INT_NAME.
inline bool isInternalDollarUnitName(const char* name)
{
    return !strncmp(name, VCS_UNIT_INT_NAME, VCS_UNIT_INT_LENGTH);
}

/// If name contains VCS_UNIT_INT_NAME (eg. "LIB._vcs_unit__1"), returns a
/// non-NULL pointer to the first character of VCS_UNIT_INT_NAME. Otherwise
/// returns NULL.
inline const char* isInternalDollarUnitNameWithPrefix(const char* name)
{
    if (const char* p = strstr(name, VCS_UNIT_INT_NAME)) {
        // Return NULL if the seemingly unit is being treated as a package.
        // This is possible in GPU_SV_DECOMPILE mode for ZEBU/FGP US1 flow.
        return strstr(name, VCS_UNIT_PKG_SUFFIX) ? NULL : p;
    }
    return NULL;
}

inline bool isDollarUnitName(const char* name)
{
    return !strcmp(name, VCS_UNIT_NAME);
}

// Also cover the name such as $unit::<filename>
inline bool isExtendedDollarUnitName(const char* name)
{
    return !strncmp(name, VCS_UNIT_NAME, VCS_UNIT_LENGTH);
}

void removeEsc(char *escapedName);

#endif // _UTIL_HH_
# 405 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/util.hh"
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh" 2
#endif
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh"
#ifndef _POOL_HH_
#if 0 /* expanded by -frewrite-includes */
#    include "pool.hh"
#endif /* expanded by -frewrite-includes */
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

// Copyright (C) 1995-1997 Radiant Design Tools.  All Rights Reserved.
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

#ifndef _POOL_HH_
#define _POOL_HH_

#if 0 /* expanded by -frewrite-includes */
#include <stdlib.h>
#endif /* expanded by -frewrite-includes */
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"
# 1 "/usr/include/stdlib.h" 1 3 4
/* Copyright (C) 1991-2007, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */

#ifndef	_STDLIB_H

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 25 "/usr/include/stdlib.h" 3 4
# 26 "/usr/include/stdlib.h" 3 4

/* Get size_t, wchar_t and NULL from <stddef.h>.  */
#define		__need_size_t
#ifndef __need_malloc_and_calloc
# define	__need_wchar_t
# define	__need_NULL
#endif
# 33 "/usr/include/stdlib.h" 3 4
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

__BEGIN_DECLS

#ifndef __need_malloc_and_calloc
#define	_STDLIB_H	1

#if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H
/* XPG requires a few symbols from <sys/wait.h> being defined.  */
#if 0 /* expanded by -frewrite-includes */
# include <bits/waitflags.h>
#endif /* expanded by -frewrite-includes */
# 42 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/waitflags.h" 1 3 4
/* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992,1996,1997,2000,2004,2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#if !defined _SYS_WAIT_H && !defined _STDLIB_H
# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
#endif
# 23 "/usr/include/bits/waitflags.h" 3 4


/* Bits in the third argument to `waitpid'.  */
#define	WNOHANG		1	/* Don't block waiting.  */
#define	WUNTRACED	2	/* Report status of stopped children.  */

/* Bits in the fourth argument to `waitid'.  */
#define WSTOPPED	2	/* Report stopped child (same as WUNTRACED). */
#define WEXITED		4	/* Report dead child.  */
#define WCONTINUED	8	/* Report continued child.  */
#define WNOWAIT		0x01000000 /* Don't reap, just poll status.  */

#define __WNOTHREAD     0x20000000 /* Don't wait on children of other threads
				      in this group */
#define __WALL		0x40000000 /* Wait for any child.  */
#define __WCLONE	0x80000000 /* Wait for cloned process.  */
# 43 "/usr/include/stdlib.h" 2 3 4
#if 0 /* expanded by -frewrite-includes */
# include <bits/waitstatus.h>
#endif /* expanded by -frewrite-includes */
# 43 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
/* Definitions of status bits for `wait' et al.
   Copyright (C) 1992,1994,1996,1997,2000,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#if !defined _SYS_WAIT_H && !defined _STDLIB_H
# error "Never include <bits/waitstatus.h> directly; use <sys/wait.h> instead."
#endif
# 23 "/usr/include/bits/waitstatus.h" 3 4


/* Everything extant so far uses these same bits.  */


/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
#define	__WEXITSTATUS(status)	(((status) & 0xff00) >> 8)

/* If WIFSIGNALED(STATUS), the terminating signal.  */
#define	__WTERMSIG(status)	((status) & 0x7f)

/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
#define	__WSTOPSIG(status)	__WEXITSTATUS(status)

/* Nonzero if STATUS indicates normal termination.  */
#define	__WIFEXITED(status)	(__WTERMSIG(status) == 0)

/* Nonzero if STATUS indicates termination by a signal.  */
#define __WIFSIGNALED(status) \
  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)

/* Nonzero if STATUS indicates the child is stopped.  */
#define	__WIFSTOPPED(status)	(((status) & 0xff) == 0x7f)

/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */
#ifdef WCONTINUED
# define __WIFCONTINUED(status)	((status) == __W_CONTINUED)
#endif
# 52 "/usr/include/bits/waitstatus.h" 3 4

/* Nonzero if STATUS indicates the child dumped core.  */
#define	__WCOREDUMP(status)	((status) & __WCOREFLAG)

/* Macros for constructing status values.  */
#define	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
#define	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
#define __W_CONTINUED		0xffff
#define	__WCOREFLAG		0x80


#ifdef	__USE_BSD

#if 0 /* expanded by -frewrite-includes */
# include <endian.h>
#endif /* expanded by -frewrite-includes */
# 65 "/usr/include/bits/waitstatus.h" 3 4
# 66 "/usr/include/bits/waitstatus.h" 3 4

union wait
  {
    int w_status;
    struct
      {
# if	__BYTE_ORDER == __LITTLE_ENDIAN
	unsigned int __w_termsig:7; /* Terminating signal.  */
	unsigned int __w_coredump:1; /* Set if dumped core.  */
	unsigned int __w_retcode:8; /* Return code if exited normally.  */
	unsigned int:16;
# endif				/* Little endian.  */
# 78 "/usr/include/bits/waitstatus.h" 3 4
# if	__BYTE_ORDER == __BIG_ENDIAN
	unsigned int:16;
	unsigned int __w_retcode:8;
	unsigned int __w_coredump:1;
	unsigned int __w_termsig:7;
# endif				/* Big endian.  */
# 84 "/usr/include/bits/waitstatus.h" 3 4
      } __wait_terminated;
    struct
      {
# if	__BYTE_ORDER == __LITTLE_ENDIAN
	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
	unsigned int __w_stopsig:8; /* Stopping signal.  */
	unsigned int:16;
# endif				/* Little endian.  */
# 92 "/usr/include/bits/waitstatus.h" 3 4
# if	__BYTE_ORDER == __BIG_ENDIAN
	unsigned int:16;
	unsigned int __w_stopsig:8; /* Stopping signal.  */
	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
# endif				/* Big endian.  */
# 97 "/usr/include/bits/waitstatus.h" 3 4
      } __wait_stopped;
  };

# define w_termsig	__wait_terminated.__w_termsig
# define w_coredump	__wait_terminated.__w_coredump
# define w_retcode	__wait_terminated.__w_retcode
# define w_stopsig	__wait_stopped.__w_stopsig
# define w_stopval	__wait_stopped.__w_stopval

#endif	/* Use BSD.  */
# 107 "/usr/include/bits/waitstatus.h" 3 4
# 44 "/usr/include/stdlib.h" 2 3 4

# ifdef __USE_BSD

/* Lots of hair to allow traditional BSD use of `union wait'
   as well as POSIX.1 use of `int' for the status word.  */

#  if defined __GNUC__ && !defined __cplusplus
#   define __WAIT_INT(status) \
  (__extension__ (((union { __typeof(status) __in; int __i; }) \
		   { .__in = (status) }).__i))
#  else
# 55 "/usr/include/stdlib.h" 3 4
#   define __WAIT_INT(status)	(*(int *) &(status))
#  endif
# 57 "/usr/include/stdlib.h" 3 4

/* This is the type of the argument to `wait'.  The funky union
   causes redeclarations with either `int *' or `union wait *' to be
   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
   the actual function definitions.  */

#  if !defined __GNUC__ || __GNUC__ < 2 || defined __cplusplus
#   define __WAIT_STATUS	void *
#   define __WAIT_STATUS_DEFN	void *
#  else
# 67 "/usr/include/stdlib.h" 3 4
/* This works in GCC 2.6.1 and later.  */
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
#   define __WAIT_STATUS_DEFN	int *
#  endif
# 75 "/usr/include/stdlib.h" 3 4

# else /* Don't use BSD.  */
# 77 "/usr/include/stdlib.h" 3 4

#  define __WAIT_INT(status)	(status)
#  define __WAIT_STATUS		int *
#  define __WAIT_STATUS_DEFN	int *

# endif /* Use BSD.  */
# 83 "/usr/include/stdlib.h" 3 4

/* Define the macros <sys/wait.h> also would define this way.  */
# define WEXITSTATUS(status)	__WEXITSTATUS (__WAIT_INT (status))
# define WTERMSIG(status)	__WTERMSIG (__WAIT_INT (status))
# define WSTOPSIG(status)	__WSTOPSIG (__WAIT_INT (status))
# define WIFEXITED(status)	__WIFEXITED (__WAIT_INT (status))
# define WIFSIGNALED(status)	__WIFSIGNALED (__WAIT_INT (status))
# define WIFSTOPPED(status)	__WIFSTOPPED (__WAIT_INT (status))
# ifdef __WIFCONTINUED
#  define WIFCONTINUED(status)	__WIFCONTINUED (__WAIT_INT (status))
# endif
# 94 "/usr/include/stdlib.h" 3 4
#endif	/* X/Open or XPG7 and <sys/wait.h> not included.  */
# 95 "/usr/include/stdlib.h" 3 4

__BEGIN_NAMESPACE_STD
/* Returned by `div'.  */
typedef struct
  {
    int quot;			/* Quotient.  */
    int rem;			/* Remainder.  */
  } div_t;

/* Returned by `ldiv'.  */
#ifndef __ldiv_t_defined
typedef struct
  {
    long int quot;		/* Quotient.  */
    long int rem;		/* Remainder.  */
  } ldiv_t;
# define __ldiv_t_defined	1
#endif
# 113 "/usr/include/stdlib.h" 3 4
__END_NAMESPACE_STD

#if defined __USE_ISOC99 && !defined __lldiv_t_defined
__BEGIN_NAMESPACE_C99
/* Returned by `lldiv'.  */
__extension__ typedef struct
  {
    long long int quot;		/* Quotient.  */
    long long int rem;		/* Remainder.  */
  } lldiv_t;
# define __lldiv_t_defined	1
__END_NAMESPACE_C99
#endif
# 126 "/usr/include/stdlib.h" 3 4


/* The largest number rand will return (same as INT_MAX).  */
#define	RAND_MAX	2147483647


/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */
#define	EXIT_FAILURE	1	/* Failing exit status.  */
#define	EXIT_SUCCESS	0	/* Successful exit status.  */


/* Maximum length of a multibyte character in the current locale.  */
#define	MB_CUR_MAX	(__ctype_get_mb_cur_max ())
extern size_t __ctype_get_mb_cur_max (void) __THROW __wur;


__BEGIN_NAMESPACE_STD
/* Convert a string to a floating-point number.  */
extern double atof (__const char *__nptr)
     __THROW __attribute_pure__ __nonnull ((1)) __wur;
/* Convert a string to an integer.  */
extern int atoi (__const char *__nptr)
     __THROW __attribute_pure__ __nonnull ((1)) __wur;
/* Convert a string to a long integer.  */
extern long int atol (__const char *__nptr)
     __THROW __attribute_pure__ __nonnull ((1)) __wur;
__END_NAMESPACE_STD

#if defined __USE_ISOC99 || (defined __GLIBC_HAVE_LONG_LONG && defined __USE_MISC)
__BEGIN_NAMESPACE_C99
/* Convert a string to a long long integer.  */
__extension__ extern long long int atoll (__const char *__nptr)
     __THROW __attribute_pure__ __nonnull ((1)) __wur;
__END_NAMESPACE_C99
#endif
# 162 "/usr/include/stdlib.h" 3 4

__BEGIN_NAMESPACE_STD
/* Convert a string to a floating-point number.  */
extern double strtod (__const char *__restrict __nptr,
		      char **__restrict __endptr)
     __THROW __nonnull ((1)) __wur;
__END_NAMESPACE_STD

#ifdef	__USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float strtof (__const char *__restrict __nptr,
		     char **__restrict __endptr) __THROW __nonnull ((1)) __wur;

extern long double strtold (__const char *__restrict __nptr,
			    char **__restrict __endptr)
     __THROW __nonnull ((1)) __wur;
__END_NAMESPACE_C99
#endif
# 181 "/usr/include/stdlib.h" 3 4

__BEGIN_NAMESPACE_STD
/* Convert a string to a long integer.  */
extern long int strtol (__const char *__restrict __nptr,
			char **__restrict __endptr, int __base)
     __THROW __nonnull ((1)) __wur;
/* Convert a string to an unsigned long integer.  */
extern unsigned long int strtoul (__const char *__restrict __nptr,
				  char **__restrict __endptr, int __base)
     __THROW __nonnull ((1)) __wur;
__END_NAMESPACE_STD

#if defined __GLIBC_HAVE_LONG_LONG && defined __USE_BSD
/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoq (__const char *__restrict __nptr,
			     char **__restrict __endptr, int __base)
     __THROW __nonnull ((1)) __wur;
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
				       char **__restrict __endptr, int __base)
     __THROW __nonnull ((1)) __wur;
#endif /* GCC and use BSD.  */
# 205 "/usr/include/stdlib.h" 3 4

#if defined __USE_ISOC99 || (defined __GLIBC_HAVE_LONG_LONG && defined __USE_MISC)
__BEGIN_NAMESPACE_C99
/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoll (__const char *__restrict __nptr,
			      char **__restrict __endptr, int __base)
     __THROW __nonnull ((1)) __wur;
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
					char **__restrict __endptr, int __base)
     __THROW __nonnull ((1)) __wur;
__END_NAMESPACE_C99
#endif /* ISO C99 or GCC and use MISC.  */
# 220 "/usr/include/stdlib.h" 3 4


#ifdef __USE_GNU
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another problem is
   the implementation of the internationalization handling in the
   ISO C++ standard library.  To support this another set of
   the functions using locale data exist which take an additional
   argument.

   Attention: even though several *_l interfaces are part of POSIX:2008,
   these are not.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */
# 236 "/usr/include/stdlib.h" 3 4
# 237 "/usr/include/stdlib.h" 3 4

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
extern long int strtol_l (__const char *__restrict __nptr,
			  char **__restrict __endptr, int __base,
			  __locale_t __loc) __THROW __nonnull ((1, 4)) __wur;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
				    char **__restrict __endptr,
				    int __base, __locale_t __loc)
     __THROW __nonnull ((1, 4)) __wur;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
				char **__restrict __endptr, int __base,
				__locale_t __loc)
     __THROW __nonnull ((1, 4)) __wur;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
					  char **__restrict __endptr,
					  int __base, __locale_t __loc)
     __THROW __nonnull ((1, 4)) __wur;

extern double strtod_l (__const char *__restrict __nptr,
			char **__restrict __endptr, __locale_t __loc)
     __THROW __nonnull ((1, 3)) __wur;

extern float strtof_l (__const char *__restrict __nptr,
		       char **__restrict __endptr, __locale_t __loc)
     __THROW __nonnull ((1, 3)) __wur;

extern long double strtold_l (__const char *__restrict __nptr,
			      char **__restrict __endptr,
			      __locale_t __loc)
     __THROW __nonnull ((1, 3)) __wur;
#endif /* GNU */
# 274 "/usr/include/stdlib.h" 3 4


#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline double
__NTH (atof (__const char *__nptr))
{
  return strtod (__nptr, (char **) NULL);
}
__extern_inline int
__NTH (atoi (__const char *__nptr))
{
  return (int) strtol (__nptr, (char **) NULL, 10);
}
__extern_inline long int
__NTH (atol (__const char *__nptr))
{
  return strtol (__nptr, (char **) NULL, 10);
}
__END_NAMESPACE_STD

# if defined __USE_MISC || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
__extension__ __extern_inline long long int
__NTH (atoll (__const char *__nptr))
{
  return strtoll (__nptr, (char **) NULL, 10);
}
__END_NAMESPACE_C99
# endif
# 304 "/usr/include/stdlib.h" 3 4
#endif /* Optimizing and Inlining.  */
# 305 "/usr/include/stdlib.h" 3 4


#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED
/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  */
extern char *l64a (long int __n) __THROW __wur;

/* Read a number from a string S in base 64 as above.  */
extern long int a64l (__const char *__s)
     __THROW __attribute_pure__ __nonnull ((1)) __wur;

#endif	/* Use SVID || extended X/Open.  */
# 318 "/usr/include/stdlib.h" 3 4

#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED || defined __USE_BSD
#if 0 /* expanded by -frewrite-includes */
# include <sys/types.h>	/* we need int32_t... */
#endif /* expanded by -frewrite-includes */
# 320 "/usr/include/stdlib.h" 3 4
# 321 "/usr/include/stdlib.h" 3 4

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void) __THROW;

/* Seed the random number generator with the given number.  */
extern void srandom (unsigned int __seed) __THROW;

/* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  */
extern char *initstate (unsigned int __seed, char *__statebuf,
			size_t __statelen) __THROW __nonnull ((2));

/* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  */
extern char *setstate (char *__statebuf) __THROW __nonnull ((1));


# ifdef __USE_MISC
/* Reentrant versions of the `random' family of functions.
   These functions all use the following data structure to contain
   state, rather than global state variables.  */

struct random_data
  {
    int32_t *fptr;		/* Front pointer.  */
    int32_t *rptr;		/* Rear pointer.  */
    int32_t *state;		/* Array of state values.  */
    int rand_type;		/* Type of random number generator.  */
    int rand_deg;		/* Degree of random number generator.  */
    int rand_sep;		/* Distance between front and rear.  */
    int32_t *end_ptr;		/* Pointer behind state table.  */
  };

extern int random_r (struct random_data *__restrict __buf,
		     int32_t *__restrict __result) __THROW __nonnull ((1, 2));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __THROW __nonnull ((2));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
			size_t __statelen,
			struct random_data *__restrict __buf)
     __THROW __nonnull ((2, 4));

extern int setstate_r (char *__restrict __statebuf,
		       struct random_data *__restrict __buf)
     __THROW __nonnull ((1, 2));
# endif	/* Use misc.  */
# 375 "/usr/include/stdlib.h" 3 4
#endif	/* Use SVID || extended X/Open || BSD. */
# 376 "/usr/include/stdlib.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void) __THROW;
/* Seed the random number generator with the given number.  */
extern void srand (unsigned int __seed) __THROW;
__END_NAMESPACE_STD

#ifdef __USE_POSIX
/* Reentrant interface according to POSIX.1.  */
extern int rand_r (unsigned int *__seed) __THROW;
#endif
# 389 "/usr/include/stdlib.h" 3 4


#if defined __USE_SVID || defined __USE_XOPEN
/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern double drand48 (void) __THROW;
extern double erand48 (unsigned short int __xsubi[3]) __THROW __nonnull ((1));

/* Return non-negative, long integer in [0,2^31).  */
extern long int lrand48 (void) __THROW;
extern long int nrand48 (unsigned short int __xsubi[3])
     __THROW __nonnull ((1));

/* Return signed, long integers in [-2^31,2^31).  */
extern long int mrand48 (void) __THROW;
extern long int jrand48 (unsigned short int __xsubi[3])
     __THROW __nonnull ((1));

/* Seed random number generator.  */
extern void srand48 (long int __seedval) __THROW;
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __THROW __nonnull ((1));
extern void lcong48 (unsigned short int __param[7]) __THROW __nonnull ((1));

# ifdef __USE_MISC
/* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users
   have to allocate objects of this type.  */
struct drand48_data
  {
    unsigned short int __x[3];	/* Current state.  */
    unsigned short int __old_x[3]; /* Old state.  */
    unsigned short int __c;	/* Additive const. in congruential formula.  */
    unsigned short int __init;	/* Flag for initializing.  */
    unsigned long long int __a;	/* Factor in congruential formula.  */
  };

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern int drand48_r (struct drand48_data *__restrict __buffer,
		      double *__restrict __result) __THROW __nonnull ((1, 2));
extern int erand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      double *__restrict __result) __THROW __nonnull ((1, 2));

/* Return non-negative, long integer in [0,2^31).  */
extern int lrand48_r (struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __THROW __nonnull ((1, 2));
extern int nrand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __THROW __nonnull ((1, 2));

/* Return signed, long integers in [-2^31,2^31).  */
extern int mrand48_r (struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __THROW __nonnull ((1, 2));
extern int jrand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __THROW __nonnull ((1, 2));

/* Seed random number generator.  */
extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __THROW __nonnull ((2));

extern int seed48_r (unsigned short int __seed16v[3],
		     struct drand48_data *__buffer) __THROW __nonnull ((1, 2));

extern int lcong48_r (unsigned short int __param[7],
		      struct drand48_data *__buffer)
     __THROW __nonnull ((1, 2));
# endif	/* Use misc.  */
# 463 "/usr/include/stdlib.h" 3 4
#endif	/* Use SVID or X/Open.  */
# 464 "/usr/include/stdlib.h" 3 4

#endif /* don't just need malloc and calloc */
# 466 "/usr/include/stdlib.h" 3 4

#ifndef __malloc_and_calloc_defined
# define __malloc_and_calloc_defined
__BEGIN_NAMESPACE_STD
/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;
/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
     __THROW __attribute_malloc__ __wur;
__END_NAMESPACE_STD
#endif
# 477 "/usr/include/stdlib.h" 3 4

#ifndef __need_malloc_and_calloc
__BEGIN_NAMESPACE_STD
/* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
     __THROW __attribute_warn_unused_result__;
/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) __THROW;
__END_NAMESPACE_STD

#ifdef	__USE_MISC
/* Free a block.  An alias for `free'.	(Sun Unices).  */
extern void cfree (void *__ptr) __THROW;
#endif /* Use misc.  */
# 495 "/usr/include/stdlib.h" 3 4

#if defined __USE_GNU || defined __USE_BSD || defined __USE_MISC
#if 0 /* expanded by -frewrite-includes */
# include <alloca.h>
#endif /* expanded by -frewrite-includes */
# 497 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/alloca.h" 1 3 4
/* Copyright (C) 1992, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef	_ALLOCA_H
#define	_ALLOCA_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 22 "/usr/include/alloca.h" 3 4
# 23 "/usr/include/alloca.h" 3 4

#define	__need_size_t
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
# 25 "/usr/include/alloca.h" 3 4
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 1 3 4
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif
# 44 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
# 51 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
# 53 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */
# 55 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
# 62 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ size_t;
#endif
# 64 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_size_t
#endif /*defined(__need_size_t) */
# 66 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
# 76 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __SIZE_TYPE__ rsize_t;
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif /* defined(__need_STDDEF_H_misc) */
# 79 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
# 89 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 90 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WCHAR_TYPE__ wchar_t;
#endif
# 92 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 93 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */
# 95 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#    define NULL 0
#  endif
# 104 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#else
# 105 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#  define NULL ((void*)0)
#endif
# 107 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
# 112 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 113 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_NULL
#endif /* defined(__need_NULL) */
# 115 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
# 118 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#endif
# 120 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */
# 123 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
# 132 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
typedef __WINT_TYPE__ wint_t;
#endif
# 134 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
#undef __need_wint_t
#endif /* __need_wint_t */
# 136 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4

#endif
# 138 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/stddef.h" 3 4
# 26 "/usr/include/alloca.h" 2 3 4

__BEGIN_DECLS

/* Remove any previous definitions.  */
#undef	alloca

/* Allocate a block that will be freed when the calling function exits.  */
extern void *alloca (size_t __size) __THROW;

#ifdef	__GNUC__
# define alloca(size)	__builtin_alloca (size)
#endif /* GCC.  */
# 38 "/usr/include/alloca.h" 3 4

__END_DECLS

#endif /* alloca.h */
# 42 "/usr/include/alloca.h" 3 4
# 498 "/usr/include/stdlib.h" 2 3 4
#endif /* Use GNU, BSD, or misc.  */
# 499 "/usr/include/stdlib.h" 3 4

#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \
    || defined __USE_BSD
/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
extern void *valloc (size_t __size) __THROW __attribute_malloc__ __wur;
#endif
# 505 "/usr/include/stdlib.h" 3 4

#ifdef __USE_XOPEN2K
/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __THROW __nonnull ((1)) __wur;
#endif
# 511 "/usr/include/stdlib.h" 3 4

__BEGIN_NAMESPACE_STD
/* Abort execution and generate a core-dump.  */
extern void abort (void) __THROW __attribute__ ((__noreturn__));


/* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void)) __THROW __nonnull ((1));

#ifdef __USE_GNU
// XXX There should be a macro to signal with C++ revision is used.
// XXX This function is in the C++1x revision.
/* Register a function to be called when `quick_exit' is called.  */
# ifdef __cplusplus
extern "C++" int at_quick_exit (void (*__func) (void))
     __THROW __asm ("at_quick_exit") __nonnull ((1));
# else
# 528 "/usr/include/stdlib.h" 3 4
extern int at_quick_exit (void (*__func) (void)) __THROW __nonnull ((1));
# endif
# 530 "/usr/include/stdlib.h" 3 4
#endif
# 531 "/usr/include/stdlib.h" 3 4
__END_NAMESPACE_STD

#ifdef	__USE_MISC
/* Register a function to be called with the status
   given to `exit' and the given argument.  */
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __THROW __nonnull ((1));
#endif
# 539 "/usr/include/stdlib.h" 3 4

__BEGIN_NAMESPACE_STD
/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
extern void exit (int __status) __THROW __attribute__ ((__noreturn__));

#ifdef __USE_GNU
// XXX There should be a macro to signal with C++ revision is used.
// XXX This function is in the C++1x revision.
/* Call all functions registered with `at_quick_exit' in the reverse
   of the order in which they were registered and terminate program
   execution with STATUS.  */
extern void quick_exit (int __status) __THROW __attribute__ ((__noreturn__));
#endif
# 554 "/usr/include/stdlib.h" 3 4
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  */
extern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));
__END_NAMESPACE_C99
#endif
# 563 "/usr/include/stdlib.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char *getenv (__const char *__name) __THROW __nonnull ((1)) __wur;
__END_NAMESPACE_STD

/* This function is similar to the above but returns NULL if the
   programs is running with SUID or SGID enabled.  */
extern char *__secure_getenv (__const char *__name)
     __THROW __nonnull ((1)) __wur;

#if defined __USE_SVID || defined __USE_XOPEN
/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
/* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  */
extern int putenv (char *__string) __THROW __nonnull ((1));
#endif
# 581 "/usr/include/stdlib.h" 3 4

#if defined __USE_BSD || defined __USE_XOPEN2K
/* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  */
extern int setenv (__const char *__name, __const char *__value, int __replace)
     __THROW __nonnull ((2));

/* Remove the variable NAME from the environment.  */
extern int unsetenv (__const char *__name) __THROW __nonnull ((1));
#endif
# 591 "/usr/include/stdlib.h" 3 4

#ifdef	__USE_MISC
/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
extern int clearenv (void) __THROW;
#endif
# 598 "/usr/include/stdlib.h" 3 4


#if defined __USE_MISC \
    || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K)
/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique file name.  */
extern char *mktemp (char *__template) __THROW __nonnull ((1)) __wur;
#endif
# 608 "/usr/include/stdlib.h" 3 4

#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED \
    || defined __USE_XOPEN2K8
/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
# ifndef __USE_FILE_OFFSET64
extern int mkstemp (char *__template) __nonnull ((1)) __wur;
# else
# 622 "/usr/include/stdlib.h" 3 4
#  ifdef __REDIRECT
extern int __REDIRECT (mkstemp, (char *__template), mkstemp64)
     __nonnull ((1)) __wur;
#  else
# 626 "/usr/include/stdlib.h" 3 4
#   define mkstemp mkstemp64
#  endif
# 628 "/usr/include/stdlib.h" 3 4
# endif
# 629 "/usr/include/stdlib.h" 3 4
# ifdef __USE_LARGEFILE64
extern int mkstemp64 (char *__template) __nonnull ((1)) __wur;
# endif
# 632 "/usr/include/stdlib.h" 3 4
#endif
# 633 "/usr/include/stdlib.h" 3 4

#ifdef __USE_MISC
/* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
# ifndef __USE_FILE_OFFSET64
extern int mkstemps (char *__template, int __suffixlen) __nonnull ((1)) __wur;
# else
# 644 "/usr/include/stdlib.h" 3 4
#  ifdef __REDIRECT
extern int __REDIRECT (mkstemps, (char *__template, int __suffixlen),
		       mkstemps64) __nonnull ((1)) __wur;
#  else
# 648 "/usr/include/stdlib.h" 3 4
#   define mkstemps mkstemps64
#  endif
# 650 "/usr/include/stdlib.h" 3 4
# endif
# 651 "/usr/include/stdlib.h" 3 4
# ifdef __USE_LARGEFILE64
extern int mkstemps64 (char *__template, int __suffixlen)
     __nonnull ((1)) __wur;
# endif
# 655 "/usr/include/stdlib.h" 3 4
#endif
# 656 "/usr/include/stdlib.h" 3 4

#if defined __USE_BSD || defined __USE_XOPEN2K8
/* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  */
extern char *mkdtemp (char *__template) __THROW __nonnull ((1)) __wur;
#endif
# 665 "/usr/include/stdlib.h" 3 4

#ifdef __USE_GNU
/* Generate a unique temporary file name from TEMPLATE similar to
   mkstemp.  But allow the caller to pass additional flags which are
   used in the open call to create the file..

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
# ifndef __USE_FILE_OFFSET64
extern int mkostemp (char *__template, int __flags) __nonnull ((1)) __wur;
# else
# 676 "/usr/include/stdlib.h" 3 4
#  ifdef __REDIRECT
extern int __REDIRECT (mkostemp, (char *__template, int __flags), mkostemp64)
     __nonnull ((1)) __wur;
#  else
# 680 "/usr/include/stdlib.h" 3 4
#   define mkostemp mkostemp64
#  endif
# 682 "/usr/include/stdlib.h" 3 4
# endif
# 683 "/usr/include/stdlib.h" 3 4
# ifdef __USE_LARGEFILE64
extern int mkostemp64 (char *__template, int __flags) __nonnull ((1)) __wur;
# endif
# 686 "/usr/include/stdlib.h" 3 4

/* Similar to mkostemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
# ifndef __USE_FILE_OFFSET64
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __nonnull ((1)) __wur;
# else
# 697 "/usr/include/stdlib.h" 3 4
#  ifdef __REDIRECT
extern int __REDIRECT (mkostemps, (char *__template, int __suffixlen,
				   int __flags), mkostemps64)
     __nonnull ((1)) __wur;
#  else
# 702 "/usr/include/stdlib.h" 3 4
#   define mkostemps mkostemps64
#  endif
# 704 "/usr/include/stdlib.h" 3 4
# endif
# 705 "/usr/include/stdlib.h" 3 4
# ifdef __USE_LARGEFILE64
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __nonnull ((1)) __wur;
# endif
# 709 "/usr/include/stdlib.h" 3 4
#endif
# 710 "/usr/include/stdlib.h" 3 4


__BEGIN_NAMESPACE_STD
/* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int system (__const char *__command) __wur;
__END_NAMESPACE_STD


#ifdef	__USE_GNU
/* Return a malloc'd string containing the canonical absolute name of the
   existing named file.  */
extern char *canonicalize_file_name (__const char *__name)
     __THROW __nonnull ((1)) __wur;
#endif
# 727 "/usr/include/stdlib.h" 3 4

#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
extern char *realpath (__const char *__restrict __name,
		       char *__restrict __resolved) __THROW __wur;
#endif
# 737 "/usr/include/stdlib.h" 3 4


/* Shorthand for type of comparison functions.  */
#ifndef __COMPAR_FN_T
# define __COMPAR_FN_T
typedef int (*__compar_fn_t) (__const void *, __const void *);

# ifdef	__USE_GNU
typedef __compar_fn_t comparison_fn_t;
# endif
# 747 "/usr/include/stdlib.h" 3 4
#endif
# 748 "/usr/include/stdlib.h" 3 4
#ifdef __USE_GNU
typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);
#endif
# 751 "/usr/include/stdlib.h" 3 4

__BEGIN_NAMESPACE_STD
/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
extern void *bsearch (__const void *__key, __const void *__base,
		      size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __nonnull ((1, 2, 5)) __wur;

/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
extern void qsort (void *__base, size_t __nmemb, size_t __size,
		   __compar_fn_t __compar) __nonnull ((1, 4));
#ifdef __USE_GNU
extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
		     __compar_d_fn_t __compar, void *__arg)
  __nonnull ((1, 4));
#endif
# 768 "/usr/include/stdlib.h" 3 4


/* Return the absolute value of X.  */
extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;
extern long int labs (long int __x) __THROW __attribute__ ((__const__)) __wur;
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__extension__ extern long long int llabs (long long int __x)
     __THROW __attribute__ ((__const__)) __wur;
#endif
# 779 "/usr/include/stdlib.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom)
     __THROW __attribute__ ((__const__)) __wur;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __THROW __attribute__ ((__const__)) __wur;
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
__extension__ extern lldiv_t lldiv (long long int __numer,
				    long long int __denom)
     __THROW __attribute__ ((__const__)) __wur;
__END_NAMESPACE_C99
#endif
# 798 "/usr/include/stdlib.h" 3 4


#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \
    || defined __USE_SVID
/* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  */

/* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  */
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;

/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  */
extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;

/* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  */
extern char *gcvt (double __value, int __ndigit, char *__buf)
     __THROW __nonnull ((3)) __wur;


# ifdef __USE_MISC
/* Long double versions of above functions.  */
extern char *qecvt (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign)
     __THROW __nonnull ((3, 4)) __wur;
extern char *qfcvt (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign)
     __THROW __nonnull ((3, 4)) __wur;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __THROW __nonnull ((3)) __wur;


/* Reentrant version of the functions above which provide their own
   buffers.  */
extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign, char *__restrict __buf,
		   size_t __len) __THROW __nonnull ((3, 4, 5));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign, char *__restrict __buf,
		   size_t __len) __THROW __nonnull ((3, 4, 5));

extern int qecvt_r (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign,
		    char *__restrict __buf, size_t __len)
     __THROW __nonnull ((3, 4, 5));
extern int qfcvt_r (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign,
		    char *__restrict __buf, size_t __len)
     __THROW __nonnull ((3, 4, 5));
# endif	/* misc */
# 854 "/usr/include/stdlib.h" 3 4
#endif	/* use MISC || use X/Open Unix */
# 855 "/usr/include/stdlib.h" 3 4


__BEGIN_NAMESPACE_STD
/* Return the length of the multibyte character
   in S, which is no longer than N.  */
extern int mblen (__const char *__s, size_t __n) __THROW __wur;
/* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  */
extern int mbtowc (wchar_t *__restrict __pwc,
		   __const char *__restrict __s, size_t __n) __THROW __wur;
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
extern int wctomb (char *__s, wchar_t __wchar) __THROW __wur;


/* Convert a multibyte string to a wide char string.  */
extern size_t mbstowcs (wchar_t *__restrict  __pwcs,
			__const char *__restrict __s, size_t __n) __THROW;
/* Convert a wide char string to multibyte string.  */
extern size_t wcstombs (char *__restrict __s,
			__const wchar_t *__restrict __pwcs, size_t __n)
     __THROW;
__END_NAMESPACE_STD


#ifdef __USE_SVID
/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  */
extern int rpmatch (__const char *__response) __THROW __nonnull ((1)) __wur;
#endif
# 887 "/usr/include/stdlib.h" 3 4


#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
/* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  */
extern int getsubopt (char **__restrict __optionp,
		      char *__const *__restrict __tokens,
		      char **__restrict __valuep)
     __THROW __nonnull ((1, 2, 3)) __wur;
#endif
# 901 "/usr/include/stdlib.h" 3 4


#ifdef __USE_XOPEN
/* Setup DES tables according KEY.  */
extern void setkey (__const char *__key) __THROW __nonnull ((1));
#endif
# 907 "/usr/include/stdlib.h" 3 4


/* X/Open pseudo terminal handling.  */

#ifdef __USE_XOPEN2KXSI
/* Return a master pseudo-terminal handle.  */
extern int posix_openpt (int __oflag) __wur;
#endif
# 915 "/usr/include/stdlib.h" 3 4

#ifdef __USE_XOPEN
/* The next four functions all take a master pseudo-tty fd and
   perform an operation on the associated slave:  */

/* Chown the slave to the calling user.  */
extern int grantpt (int __fd) __THROW;

/* Release an internal lock so the slave can be opened.
   Call after grantpt().  */
extern int unlockpt (int __fd) __THROW;

/* Return the pathname of the pseudo terminal slave assoicated with
   the master FD is open on, or NULL on errors.
   The returned storage is good until the next call to this function.  */
extern char *ptsname (int __fd) __THROW __wur;
#endif
# 932 "/usr/include/stdlib.h" 3 4

#ifdef __USE_GNU
/* Store at most BUFLEN characters of the pathname of the slave pseudo
   terminal associated with the master FD is open on in BUF.
   Return 0 on success, otherwise an error number.  */
extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __THROW __nonnull ((2));

/* Open a master pseudo terminal and return its file descriptor.  */
extern int getpt (void);
#endif
# 943 "/usr/include/stdlib.h" 3 4

#ifdef __USE_BSD
/* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  */
extern int getloadavg (double __loadavg[], int __nelem)
     __THROW __nonnull ((1));
#endif
# 951 "/usr/include/stdlib.h" 3 4


/* Define some macros helping to catch buffer overflows.  */
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdlib.h>
#endif /* expanded by -frewrite-includes */
# 955 "/usr/include/stdlib.h" 3 4
# 956 "/usr/include/stdlib.h" 3 4
#endif
# 957 "/usr/include/stdlib.h" 3 4
#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdlib-ldbl.h>
#endif /* expanded by -frewrite-includes */
# 958 "/usr/include/stdlib.h" 3 4
# 959 "/usr/include/stdlib.h" 3 4
#endif
# 960 "/usr/include/stdlib.h" 3 4

#endif /* don't just need malloc and calloc */
# 962 "/usr/include/stdlib.h" 3 4
#undef __need_malloc_and_calloc

__END_DECLS

#endif /* stdlib.h  */
# 967 "/usr/include/stdlib.h" 3 4
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "basictypes.hh"
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh" 1
//=====================================================================
// Copyright (C) 1997-1998 Synopsys Inc. All Rights Reserved.
//
// $RCSfile: basictypes.hh,v $
//=====================================================================
#ifndef _BASICTYPES_HH_
#define _BASICTYPES_HH_

// #ident "$Id$ $Author$ $DateTime$"

#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#if 0 /* expanded by -frewrite-includes */
#include <strings.h>
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#if 0 /* expanded by -frewrite-includes */
#include "../../../../system/typedef64.h"
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

//--------------------------------------------------------------------
// First we define some macros of the form __SUPPORTS_xyz__ based
// on the platform/compiler.
//--------------------------------------------------------------------

#ifndef __SUPPORTS_UINT__
#   if defined(__sun) && defined(__SVR4) // Solaris 2.x
#   define __SUPPORTS_UINT__
#   endif
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 26 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_UNCHAR__
#   if defined(__sun) && defined(__SVR4) // Solaris 2.x
#   define __SUPPORTS_UNCHAR__
#   endif
# 31 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 32 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_BOOL__
#   if (defined(__GNUC__)) || \
       (defined(WIN32)) || \
       (defined(__alpha) && defined(__DECCXX_VER) && \
    ((__DECCXX_VER >= 60000000) || defined(_BOOL_EXISTS))) || \
       (defined(_BOOL)) || \
       (defined(_AIX43) && (__IBMCPP__ >= 500))
#   define __SUPPORTS_BOOL__
#   endif
# 42 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 43 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

//--------------------------------------------------------------------
// Now we define stuff based on the __SUPPORTS_xyz__'s defined earlier
//--------------------------------------------------------------------

#ifndef __SUPPORTS_UINT__
typedef unsigned int uint;
#endif
# 51 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_UNCHAR__
typedef unsigned char unchar;
#endif
# 55 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_BOOL__
typedef unsigned char bool;
const bool true = 1;
const bool false = 0;
#   if (defined(__alpha) && defined(__DECCXX_VER) && !defined(_BOOL_EXISTS))
#    define _BOOL_EXISTS
#   endif
# 63 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   if (defined(__sgi) && !defined(_BOOL))
#    define _BOOL
#   endif
# 66 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 67 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"


// Here we define the prototypes of some functions that are
// missing from the standard header files on some platforms.
// Since basictypes.hh is included almost everywhere, it seemed
// the right place to define these (I didn't want to create
// another header file for this stupid stuff).

#if defined(__sun) && !defined(__SVR4) // SunOS 4.1.x
extern "C" void* sbrk(int incr);
extern "C" int strcasecmp(const char* s1, const char* s2);
extern "C" int strncasecmp(const char* s1, const char* s2, int n);
extern "C" int gettimeofday(struct timeval* tp, void*);
#endif // __sun && !__SVR4
# 81 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#if defined(WIN32)
extern "C" void* sbrk(int incr);
extern "C" int gethostid();
#   define strcasecmp stricmp
#   define strncasecmp strnicmp
/*mkdir(<path, accessmode> is not available on NT, so its usage generates compilation error*/
#if 0 /* expanded by -frewrite-includes */
#   include <direct.h>
#endif /* expanded by -frewrite-includes */
# 88 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 89 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   define mkdir(x, y) _mkdir(x)
#   pragma warning(disable:4291)
#   define YY_NEVER_INTERACTIVE 1 /* Needed for .ll files */
#   define MSDOS /* Needed for .yy files */
#   define ftruncate _chsize
#   ifndef PATH_MAX
#   define PATH_MAX 1024
#   endif
# 97 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   define S_IRWXU  (S_IREAD | S_IWRITE | S_IEXEC)
#   ifdef _INC_MATH /* when math.h is included */
/* asinh, acosh, atanh are not defined in NT headers */
#   define asinh(x) log((x) + sqrt((x)*(x) + 1))
#   define acosh(x) log((x) - sqrt((x)*(x) - 1))
#   define atanh(x) log((1 + (x)) / (1 - (x))) / 2
#   endif /* _INC_MATH */
# 104 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif // WIN32
# 105 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef VCS_EXIT
extern "C" {
    extern void VCS_EXIT(int);
}
#endif
# 111 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#endif // _BASICTYPES_HH_
# 113 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

// We always include this part on the spot, even if it causes multiple
// inclusions.  This is because some other include files define NULL
// to be (void*) 0.  g++ wants it to be plain 0.

#ifdef  __GNUC__
#   ifdef NULL
#   undef NULL
#   define NULL 0
#   endif
# 123 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif // __GNUC__
# 124 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "util.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"

#if defined(linux) && defined(ENGINEER)
#define ENABLE_TRACE
#endif
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"

/// This is the radify memory manager. This memory manager will manage
/// both a collection of specialized allocators for fixed size
/// objects, and an allocator for strings. The allocator for sized
/// objects is a collection of Pools, one for each size up to a
/// certain maximum. It relies on both the create and destroy calls to
/// pass the size, since it uses that to send the request to the right
/// Pool.
///
/// The easiest way to use it is by overriding the operators new and
/// delete in a class. There are two macros for this purpose, the
/// common one being lifeGuardNewAndDeleteMacro, and the other is
/// lifeGuardNewAndDeleteMacroWith(LifeGuard*).
///
/// The lifeguard used at any time is determined by
/// getCurrentLifeGuard(void). In order to change it there is a class
/// LifeGuard::Override whose constructor and destructor make sure a
/// new lifeguard is used and the old one is replaced when the object
/// goes out of scope.
///
/// A typical use would be as
///
/// \code
///     ...
///     {
///         LifeGuard::Override lifeGuardOverride(getCurrentXLifeGuard());
///         XNode* xn = new XNode(...);
///         ...
///     }
/// \endcode
///
/// In addition, the current lifeguard must be initialized using
/// initCurrentLifeGuard.
///
/// In order to facilitate the diagnostics of out of memory conditions
/// a user of the lifeguard can register a function to be called using
/// registerOutOfMemoryFunction.
///
/// @note If the size of the item is larger than the maximum that this
/// allocator can handle natively, the request will be passed to the
/// underlying ::new.
/// @note This allocator will attempt to return any unused memory back
/// to the system when it runs out of memory, to try once again.
class LifeGuard
{
public:
    /// The virtual destructor.
    virtual         ~LifeGuard() = 0;

    /// This function returns a pointer to memory allocated for an
    /// item of size @p p_sz.
    virtual void*   create(size_t p_sz) = 0;

    /// This function deletes an item @p p_item of size @p p_sz.
    virtual void    destroy(void* p_item, size_t p_sz) = 0;

    /// This function returns a pointer to memory allocated for an
    /// array of @p count items, each of size @p p_sz.
    virtual void*   createArray(size_t p_sz, unsigned count) = 0;

    virtual void*   create(size_t p_sz, const char*) {
        return create(p_sz);
    }

    virtual void    destroy(void* p_item, size_t p_sz, const char*) {
        destroy(p_item, p_sz);
    }

    virtual void*   createArray(size_t p_sz, unsigned count, const char*) {
        return createArray(p_sz, count);
    }

    /// This function deletes an array of @p count items, each of
    /// size @p p_sz, at pointer @p p_item.
    virtual void    destroyArray(void* p_item, size_t p_sz, unsigned count) = 0;

    /// This function allocates memory for a string of size p_sz.
    /// @note The size must include the terminating null character.
    virtual char*   createStr(size_t p_sz) = 0;

    /// This function deletes a string @p p_item of size @p p_sz
    /// (including the terminating null).
    virtual void    destroyStr(void* p_item, size_t p_sz) = 0;

    /// This function allocates memory for a string of size p_sz,
    /// but bypasses this memory manager.
    /// @note The size must include the terminating null
    /// character.
    virtual char*   createVolatileStr(size_t p_sz) = 0;

    /// This function creates a copy of string s using createVolatileStr().
    /// Returns NULL if s was NULL.
    virtual char*   strdupVolatileStr(const char* s);

    /// This function deletes a string @p p_item of size @p p_sz
    /// (including the terminating null) bypassing this memory
    /// manager.
    virtual void    destroyVolatileStr(void* p_item) = 0;

    /// This function enabled free page recycle mechanism. It is only
    /// available with CLifeGuard.
    virtual void    activatePageRecycle() = 0;
    virtual void    setPoolDisable(bool b) = 0;

    /// This function will attempt to find any chunks of memory
    /// that can be returned to the system, particularly useful to
    /// be able to retry after memory runs out (outOfMemory == true
    /// indicates that the function was called in this scenario).
    virtual int     doCompaction(bool const outOfMemory = false) = 0;

    virtual int     memAllocated() const = 0;
    virtual void    setBrk() = 0;

    /// To guide whether to use malloc/new or mmap, now only 
    /// implemented in BLifeGuard.
    virtual void    preferMMapInFixedSizePool(bool v = false) {  }

    /// Determines the amount of memory allocated by the LifeGuard and the
    /// amount of memory that is not in use.
    /// @note Both kbAllocated and kbFree are in kilobytes (rounded up).
    /// @note kbAllocated is always >= kbFree.
    virtual void    getMemoryUsage(unsigned& kbAllocated,
                                   unsigned& kbFree) = 0;

    /// Determines the amount of memory allocated by the LifeGuard.
    /// @note return result is in kilobytes (rounded up).
    virtual unsigned getMemoryAllocated() = 0;

    /// This function will show the current status of the memory
    /// manager.
    virtual void    show() = 0;

    /// This class is used to override the current lifeguard when
    /// an object is instantiated, and restore the previous
    /// lifeguard when this object goes out of scope.
    /// \note Do not create this object in free store, only on the
    /// stack.
    class Override
    {
    public:
        /// The constructor saves the current lifeguard and
        /// activates the given one.
        Override(LifeGuard* pushThis);

        /// The destructor restores the saved lifeguard.
        ~Override();
    private:

        /// The LifeGuard saved.
        LifeGuard*      savedOne;
    };
#ifdef ENGINEER
    /// Pointer to a routine to be called from BLifeGuard::create(). Its
    /// initial value is NULL.
    static void (*memoryAllocationCallback)(void*, size_t);
#endif
# 178 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"
};

/// This function creates and returns a pointer to a LifeGuard.
extern LifeGuard*   makeLifeGuard(const char* name=NULL);

/// This function creates and returns a pointer to a CLifeGuard.
extern LifeGuard*       makeCLifeGuard();

/// This function gets the current lifeguard.
LifeGuard*              getCurrentLifeGuard();

/// This function initializes the current lifeguard.
void                    initCurrentLifeGuard(LifeGuard*);

/// This function destroys the given lifeGuard.
extern void             destroyLifeGuard(LifeGuard* lifeGuard);

/// This is the handler for an out-of-memory condition.
extern void             outOfMemory();

typedef LifeGuard* (*lifeGuardOverrideFunc)();
void setLifeGuardOverrideFunc(lifeGuardOverrideFunc func);

/// Macro for lifeguard new and delete.  These are macroes for uniformity.
/// Perhaps we should derive from memory-conscious class.
/// The placement new versions are same with and without ENABLE_TRACE as
/// they do not allocate any memory, but just return the pointer
#ifdef ENABLE_TRACE
#define lifeGuardCreateArray(lg, size, count) \
    (lg)->createArray(size, count, __PRETTY_FUNCTION__)
#define lifeGuardNewAndDeleteMacro \
    void*                   operator new(size_t p_sz) { \
        return getCurrentLifeGuard()->create(p_sz, __PRETTY_FUNCTION__); \
    } \
    void*                   operator new(size_t , void* ptr) { \
        return ptr; \
    } \
    void                    operator delete(void* p_item, size_t p_sz) { \
        getCurrentLifeGuard()->destroy(p_item, p_sz, __PRETTY_FUNCTION__); \
    }
#else
# 219 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"
#define lifeGuardCreateArray(lg, size, count) \
    (lg)->createArray(size, count)
#define lifeGuardNewAndDeleteMacro \
    void*                   operator new(size_t p_sz) { \
        return getCurrentLifeGuard()->create(p_sz); \
    } \
    void*                   operator new(size_t , void* ptr) { \
        return ptr; \
    } \
    void                    operator delete(void* p_item, size_t p_sz) { \
        getCurrentLifeGuard()->destroy(p_item, p_sz); \
    }
#endif
# 232 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"

/// Macro for lifeguard new and delete using an explicit lifeguard.
#ifdef ENABLE_TRACE
#define lifeGuardNewAndDeleteMacroWith(lg)                   \
    void*                   operator new(size_t p_sz) {  \
        return lg->create(p_sz, __PRETTY_FUNCTION__); \
    } \
    void*                   operator new(size_t , void* ptr) { \
        return ptr; \
    } \
    void                    operator delete(void* p_item, size_t p_sz) { \
        lg->destroy(p_item, p_sz, __PRETTY_FUNCTION__); \
    }
#else
# 246 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"
#define lifeGuardNewAndDeleteMacroWith(lg)                   \
    void*                   operator new(size_t p_sz) {  \
        return lg->create(p_sz); \
    } \
    void*                   operator new(size_t , void* ptr) { \
        return ptr; \
    } \
    void                    operator delete(void* p_item, size_t p_sz) { \
        lg->destroy(p_item, p_sz); \
    }
#endif
# 257 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"

/// This class is thrown when we run out of memory.
class MemoryException : public GeneralException
{
public:
    MemoryException(LifeGuard* lg) :
        lifeGuard(lg)
    {}
    ~MemoryException();
private:
    LifeGuard*      lifeGuard;
};

void doMemoryPoolChecks();
void disableMemoryPoolChecks();

extern  "C" {
    extern  LifeGuard*  makeMLifeGuard(const char* name);

};

#ifdef ENABLE_TRACE
extern const bool EnableMemTraceC;
extern void logClassAllocMem(size_t sz, const char* funcName);
extern void logArrayAllocMem(size_t sz, const char* funcName);
extern void logClassFreeMem(size_t sz, const char* funcName);
extern void logArrayFreeMem(size_t sz, const char* funcName);
extern "C" void printMemTraceFile(FILE* f);
#endif
# 286 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"

#ifdef ENGINEER
extern bool memTraceInitialized;
extern "C" void initMemTrace();
extern "C" void resetMemTrace();
#endif
# 292 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"

#endif // _POOL_HH_
# 294 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pool.hh"
# 20 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh" 2
#endif
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh"

/// @file list.hh
/// This file defines the interface for linked lists, linked items,
/// and list iterators. The linked lists are template classes, all
/// based on non-template base classes for lists, links, and iterators.
/// We have singly and doubly linked lists as follows:
///
/// Non-intrusive singly linked list: suitable for lists that will be
/// modified in random order but that are not too large (in that case
/// use doubly linked lists, that can be modified in constant time)
/// - SlistL: non-intrusive singly linked list
/// - SlistLI: the corresponding iterator
/// - SlistLEI: a "heavier weight" iterator that has more editing capabilities
///
/// Intrusive singly linked list: we tend to use them for the most commonly used form of traversal of
/// - SlistM: intrusive singly linked list
/// - SlistMI: the corresponding iterator
///
/// The singly linked lists are based on the following non-template
/// classes:
/// - SlinkB: the basic link holding a single next pointer
/// - SlistB: an intrusive singly-linked list of SlinkBs
/// - SlistBI: the corresponging iterator
/// - SlistBEI: a "heavier weight" iterator that has more editing capabilities
///
/// Non-intrusive doubly linked list
/// - DlistL: non-intrusive doubly linked list
/// - DlistLI: the corresponding iterator
///
/// Intrusive doubly linked list
/// - DlistM: intrusive doubly linked list
/// - DlistMI: the corresponding iterator
///
/// The doubly linked lists are based on the following non-template
/// classes:
/// - DlinkB: the basic link holding next and previous pointers
/// - DlistB: an intrusive doubly-linked list of DlinkBs
/// - DlistBI: the corresponging iterator
///
/// @attention All these lists are circular, and the list holds a
/// pointer to the last item. This makes it constant time to access
/// the first and last item, and constant time to append an item to
/// the end of the list, or detach the first item.

// Forward declarations.
// Base class for link, list, and iterator for singly linked lists.
class           SlinkB;
class           SlistB;
class           SlistBI;
class           SlistBEI;

// Template classes for non intrusive singly linked lists and iterator.
template<class T>       class           SlistL;
template<class T>       class           SlistLI;

// Template classes for intrusive singly linked lists and iterator.
template<class T>       class           SlistM;
template<class T>       class           SlistMI;

// Base class for link, list, and iterator for doubly linked lists.
class           DlinkB;
class           DlistB;
class           DlistBI;

// Template classes for intrusive doubly linked lists and iterator.
template<class T>       class           DlistM;
template<class T>       class           DlistMI;

// Template classes for non intrusive doubly linked lists and iterator.
template<class T>       class           DlistL;
template<class T>       class           DlistLI;

/// This is the base class for a link in a singly linked list.
/// It holds a single next pointer. All items in singly-linked lists
/// derive from this.
class SlinkB
{
public:
    /// This function returns the next pointer.
    SlinkB*         getNext() const         { return next; }

    /// This function sets next to point to the given link.
    void            linkTo(SlinkB* l)       { next = l; }

    /// This function unlinks the link.
    void            unlink()                { next = 0; }

    /// This constructor initializes the link to NULL.
    SlinkB() : next(NULL)                   {}

    /// The destructor does nothing.
    ~SlinkB()       {}
    /// The operator new generates a fatal exception, so ensure we
    /// don't instantiate these directly.
    void*           operator new(size_t)
    {
        fatal(msg("new SlinkB should not happen"));
        throw MemoryException(getCurrentLifeGuard());
    }
    /// The operator delete generates a fatal exception.
    void            operator delete(void*, size_t)
    {
        fatal(msg("delete SlinkB should not happen"));
    }
private:
    /// The next pointer.
    SlinkB*         next;
};

/// This is the base class for singly-linked, circular lists. Since
/// this list is circular it just holds a single pointer to the last
/// link. This makes it constant time to access the first and last
/// link, and constant time to append an link to the end of the list,
/// or detach the first link.
class SlistB
{
public:
    /// This constructor makes an empty list.
    SlistB() :                      last(NULL) {}

    /// This constructor makes a list with a single link @p l.
    SlistB(SlinkB* l) : last(l)             { l->linkTo(l); }

    /// The destructor does nothing. The derived lists will
    /// generate a fatal assertion if the list is not empty.
    ~SlistB() {}
    lifeGuardNewAndDeleteMacro

    /// This function returns true if the list is empty.
    bool            isEmpty() const         { return (last == NULL); }

    /// This function returns true if the list has a single link.
    bool            hasOneItem() const {
        return last ? (last->getNext() == last) : false;
    }

    /// Counts items in the list.
    /// @note This method takes O(N) time, where N is the number of items.
    unsigned        countItems() const;

    /// This function inserts a link as the first link in the list.
    void            insert(SlinkB* l);

    /// This function appends a link to the end of the list.
    void            append(SlinkB* l);

    /// This function appends a link after the given link @p a.
    void            appendAfter(SlinkB* a, SlinkB* l);

    /// This function just wipes out the list. Used to steal the
    /// list contents.
    /// @attention Careless use of this function can lead to
    /// memory leaks, so make sure to use it only when stealing a
    /// list.
    void            flush()                 { last = NULL; }

    /// This function detaches the first link in the list.
    SlinkB*         detachFirst();

    /// This function just returns the last link, but does not
    /// modify the list.
    /// @return The last link or NULL if the list is empty.
    SlinkB*         getLast() const         { return last; }

    /// This function just returns the first link, but does not
    /// modify the list.
    /// @return The first link or NULL if the list is empty.
    SlinkB*         getFirst() const {
        return last ? last->getNext() : NULL;
    }

    /// Strict equality operator: traverses a and this, and returns true
    /// if all elements are same (and in same order)
    bool operator==(const SlistB& a) const;
    bool operator==(const SlistB* a) const;

protected:
    friend class    SlistBI;
    friend class    SlistBEI;

public:
    /// This function detaches the link after the given one.
    SlinkB*         detachNext(SlinkB*& link);

protected:
    // Needed protected because of steal().  Otherwise could be private.
    SlinkB*         last;

private:
    /// The copy constructor is fatal.
    SlistB(const SlistB&) {
        fatal(msg("SlistB copy constructor"));
    }
};

/// This is the base class for an intrusive singly-linked circular
/// list iterator.
class SlistBI
{
public:
    /// This creates an iterator to an effectively empty list.
    SlistBI() :
        currentList(NULL),
        currentLink(NULL) {}

    /// This creates an iterator for the given list, and points
    /// the iterator to the first link.
    SlistBI(const SlistB* list) :
        currentList(list && list->last ? list : NULL),
        currentLink(list && list->last ? list->last->getNext() : NULL) {}

    explicit SlistBI(const SlistB& list) :
        currentList(list.last ? &list : NULL),
        currentLink(list.last ? list.last->getNext() : NULL) {}

    /// Copy constructor.
    SlistBI(const SlistBI& iter)
        : currentList(iter.currentList)
        , currentLink(iter.currentLink) {}

    /// This is the pre increment operator.
    SlinkB*         operator++();

    /// This is the post increment operator.
    SlinkB*         operator++(int);

    /// This returns the current link.
    SlinkB*         operator()() const      { return currentLink; }

    /// This function returns the next link.
    /// @attention If the list has a single link peek will return
    /// the current link.
    SlinkB*         peek() const {
        return currentLink ? currentLink->getNext() : NULL;
    }

    /// This function returns the last link in the list.
    SlinkB*         getLast() const {
        return currentList ? currentList->last : NULL; }

    /// This function appends the given link at current position.
    void            append(SlinkB* pItem, SlistB* pList);

    /// This function removes the next link from given list.
    SlinkB*         detachNext(SlistB* pList);

    /// This function replaces the next link relative to the
    /// iterator's current item from given list.
    SlinkB*         replaceNext(SlinkB* pItem, SlistB* pList);

    /// This function replaces the current link from given list.
    SlinkB*         replaceCurrent(SlinkB* pItem, SlistB* pList);

    /// This function returns true if the iterator is at the last
    /// link.
    bool            atLast() const {
        return currentList ?
               currentLink == currentList->last : true;
    }

    /// This function returns true if the iterator is at the first
    /// link.
    bool            atFirst() const {
        return currentList ?
               currentLink == currentList->last->getNext() : true;
    }

    /// This function resets the iterator so it points to the
    /// first link.
    void            toFirst() {
        currentLink = currentList ? currentList->getFirst() : NULL;
    }

    /// This function resets the iterator so it points to the
    /// last link.
    void            toLast()                { currentLink = getLast(); }

    /// This function appends a link after the current one.
    /// @param pItem The link to be appended.
    /// @attention The list can be modified if the iterator was at
    /// the last link, since the last pointer must be moved.
    void            appendAfter(SlinkB* pItem) {
        const_cast<SlistB*>(currentList)->appendAfter(
            currentLink, pItem);
    }

    /// This function resets the iterator so it points to the first
    /// link.
    void            reset() {
        currentLink = (currentList && currentList->last) ?
                      currentList->last->getNext() : NULL;
    }

    const SlistB* getCurrentList(void){return currentList;}
private:
    /// The list to be traversed.
    /// @note It is a const list.
    const SlistB*   currentList;

    /// The link currently pointed to.
    SlinkB*         currentLink;
};

/// This is the base class for an intrusive singly-linked circular
/// list iterator, that is more easily Editable.  By employing a
/// "prev" pointer, this iterator facillitates delete and insertBefore
/// member functions at the current iterator position. Do not use if
/// the extra memory required for the "prev" pointer would be an issue.
/// I only supported the member functions that I currently require, so
/// feel free to add for your requirements
class SlistBEI
{
public:
    /// This creates an iterator to an effectively empty list.
    SlistBEI() :
        currentList(NULL),
        currentLink(NULL),
        prevLink(NULL)     {}

    /// This creates an iterator for the given list, and points
    /// the iterator to the first link, prev to NULL
    explicit SlistBEI(SlistB* list) :
        currentList(list && list->last ? list : NULL),
        currentLink(list && list->last ? list->last->getNext() : NULL),
        prevLink(NULL) {}

    /// Copy constructor.
    SlistBEI(SlistBEI& iter)
        : currentList(iter.currentList)
        , currentLink(iter.currentLink)
        , prevLink(iter.prevLink) {}

    /// This is the post increment operator.
    SlinkB*         operator++(int);

    /// This returns the current link.
    SlinkB*         operator()() const      { return currentLink; }

    /// This function returns the next link.
    /// @attention If the list has a single link peek will return
    /// the current link.
    SlinkB*         peek() const {
        return currentLink ? currentLink->getNext() : NULL;
    }

    /// This function returns the last link in the list.
    SlinkB*         getLast() const {
        return currentList ? currentList->last : NULL; }

    /// This function inserts the given link before the current position.
    void            insertBefore(SlinkB* pItem);

    /// This function inserts the given link after the current position.
    void            insertAfter(SlinkB* pItem);

    /// This function removes the current link from given list.
    SlinkB*         detachCurrent();

    /// This function removes the next link from given list.
    SlinkB*         detachNext();

    /// This function replaces the current link from given list.
    SlinkB*         replaceCurrent(SlinkB* pItem);

    /// This function replaces the next link relative to the
    /// iterator's current item from given list.
    SlinkB*         replaceNext(SlinkB* pItem);

    /// Returns previous link item.
    SlinkB*         getPrevious() const { return prevLink; }

    /// This function returns true if the iterator is at the last
    /// link.
    bool            atLast() const {
        return currentList ?
               currentLink == currentList->last : true;
    }

private:
    /// The list to be traversed.
    /// @note It is a const list.
    SlistB*   currentList;

    /// The link currently pointed to.
    SlinkB*   currentLink;
    /// The link to the previous item in the list.
    SlinkB*   prevLink;
};

// Base objects for doubly linked lists.
class DlinkB
{
public:
    /// This function returns the next pointer.
    DlinkB*         getNext() const         { return next; }

    /// This function returns the previous pointer.
    DlinkB*         getPrev() const         { return prev; }

    /// This function sets next to point to the given link and its
    /// prev to point to this.
    void            linkTo(DlinkB* l) {
        next = l;
        l->prev = this;
    }

    /// This function unlinks the link.
    void            unlink() {
        next = NULL;
        prev = NULL;
    }

    /// This constructor initializes the link to NULL.
    DlinkB() : prev(NULL), next(NULL)       {}

    /// The destructor does nothing.
    ~DlinkB()       {}
    /// The operator new generates a fatal exception, so ensure we
    /// don't instantiate these directly.
    void*           operator new(size_t)
    {
        fatal(msg("new DlinkB should not happen"));
        throw MemoryException(getCurrentLifeGuard());
    }
    /// The operator delete generates a fatal exception.
    void            operator delete(void*, size_t)
    {
        fatal(msg("delete DlinkB should not happen"));
    }
private:
    /// The next pointer.
    DlinkB*         prev;

    /// The previous pointer.
    DlinkB*         next;
};

/// This is the base class for doubly-linked, circular lists. Since
/// this list is circular it just holds a single pointer to the last
/// link. This makes it constant time to access the first and last
/// link, and constant time to append an link to the end of the list,
/// or detach the first link. It also makes detaching any item a
/// constant time operation, which is the main difference to
/// singly-linked lists.
class DlistB
{
public:
    /// This function returns true if the list is empty.
    bool            isEmpty() const         { return (last == NULL); }

    /// This function returns true if the list has a single link.
    bool            hasOneItem() const {
        return last ? (last->getNext() == last) : false;
    }

    /// Counts items in the list.
    /// @note This method takes O(N) time, where N is the number of items.
    unsigned        countItems() const;

    /// This function inserts a link as the first link in the list.
    void            insert(DlinkB* l);

    /// This function appends a link to the end of the list.
    void            append(DlinkB* l);

    /// This function inserts a link before the given link @p a.
    void            insertBefore(DlinkB* a, DlinkB* l);

    /// This function appends a link after the given link @p a.
    void            appendAfter(DlinkB* a, DlinkB* l);

    /// This function just wipes out the list. Used to steal the
    /// list contents.
    /// @attention Careless use of this function can lead to
    /// memory leaks, so make sure to use it only when stealing a
    /// list.
    void            flush()                 { last = NULL; }

    /// This function detaches the first link in the list.
    DlinkB*         detachFirst();

    /// This function just returns the last link, but does not
    /// modify the list.
    /// @return The last link or NULL if the list is empty.
    DlinkB*         getLast() const         { return last; }

    /// This function just returns the first link, but does not
    /// modify the list.
    /// @return The first link or NULL if the list is empty.
    DlinkB*         getFirst() const {
        return last ? last->getNext() : NULL;
    }

    /// This constructor makes an empty list.
    DlistB() :      last(NULL)              {}

    /// This constructor makes a list with a single link @p l.
    DlistB(DlinkB* l) {
        l->linkTo(l);
        last = l;
    }
    /// The destructor does nothing. The derived lists will
    /// generate a fatal assertion if the list is not empty.
    ~DlistB() {}

protected:
    friend class    DlistBI;

    /// This function detaches the given link.
    DlinkB*         detach(DlinkB* link);

public:
    /// This function detaches the link after the given one.
    DlinkB*         detachNext(DlinkB*& link);

protected:
    // Needed protected because of steal().  Otherwise could be private.
    DlinkB*         last;
private:
    /// The copy constructor is fatal.
    DlistB(const DlistB&) {
        fatal(msg("DlistB copy constructor"));
    }
};

/// This is the base class for an intrusive doubly-linked circular
/// list iterator.
class DlistBI
{
public:
    /// This creates an iterator to an empty list.
    DlistBI() :
        currentList(NULL),
        currentLink(NULL) {}

    /// This creates an iterator for the given list, and points
    /// the iterator to the first link.
    DlistBI(const DlistB* list) :
        currentList(list && list->last ? list : NULL),
        currentLink(list && list->last ? list->last->getNext() : NULL) {}

    /// This creates an iterator for the given list, and points
    /// the iterator to the given link.
    DlistBI(const DlistB* list, DlinkB* link) :
        currentList(list),
        currentLink(link) {}

    /// Copy constructor.
    DlistBI(const DlistBI& iter)
        : currentList(iter.currentList)
        , currentLink(iter.currentLink) {}

    /// This is the pre-increment operator.
    DlinkB*         operator++();

    /// This is the post-increment operator.
    DlinkB*         operator++(int);

    /// This is the pre-decrement operator.
    DlinkB*         operator--();

    /// This is the post-decrement operator.
    DlinkB*         operator--(int);

    /// This returns the current link.
    DlinkB*         operator()() const      { return currentLink; }

    /// This function returns the next link.
    /// @attention If the list has a single link peek will return
    /// the current link.
    DlinkB*         peek() const {
        return currentLink ? currentLink->getNext() : NULL;
    }

    /// This function returns the previous link.
    /// @attention If the list has a single link peek will return
    /// the current link.
    DlinkB*         prev() const {
        return currentLink ? currentLink->getPrev() : NULL;
    }

    /// This function returns the last element in the list.
    DlinkB*         getLast() const {
        return currentList ? currentList->last : NULL;
    }

    // This function appends the given link at current position.
    void            append(DlinkB* pItem, DlistB* pList);

    /// This function removes the next link from given list.
    DlinkB*         detachNext(DlistB* pList);

    /// This function replaces the next link relative to the
    /// iterator's current item from given list.
    DlinkB*         replaceNext(DlinkB* pItem, DlistB* pList);

    /// This function replaces the current link from given list.
    /// @note This works in constant time.
    DlinkB*         replaceCurrent(DlinkB* pItem, DlistB* pList);

    /// This function returns true if the iterator is at the last
    /// link.
    bool            atLast() const {
        return currentList ?
               currentLink == currentList->last : true;
    }

    /// This function returns true if the iterator is at the first
    /// link.
    bool            atFirst() const {
        return currentList ?
               currentLink == currentList->last->getNext() : true;
    }

    /// This function resets the iterator so it points to the
    /// first link.
    void            toFirst() {
        currentLink = currentList ? currentList->getFirst() : NULL;
    }

    /// This function resets the iterator so it points to the
    /// last link.
    void            toLast()                { currentLink = getLast(); }
    
    /// This function resets the iterator so it points to the first
    /// link.
    void            reset() {
        currentLink = (currentList && currentList->last) ?
                      currentList->last->getNext() : NULL;
    }
private:
    const DlistB*   currentList;
    DlinkB*         currentLink;
};

// These templates are for non-intrusive singly linked lists.  These
// are suitable for lists that are not performance critical and not
// really large.  Intensively used lists are better implemented
// intrusively, i.e. with the next pointer in the data items.

/// This is the container for the next pointer and a pointer
/// to the item. Essentially a CONS cell.
template<class T> class SlinkL : public SlinkB
{
public:
    /// This returns a pointer to the item.
    T*              getItem() const         { return item; }

    /// This constructor makes a link pointing to the given item
    /// and otherwise detached.
    SlinkL(T* pItem) :
        SlinkB(),
        item(pItem) {
        nullcheck(pItem);
    }
    lifeGuardNewAndDeleteMacro
    /// The destructor does nothing.
    ~SlinkL() {}
    void            replaceItem(T* nItem)   { item = nItem; }
private:
    /// The pointer to the item.
    T*              item;
};

// Notice there is some explicit casting in this code.  We can trust
// this since it always casts up towards the template object, never
// down to SlistB or SlinkB (which could strip information).
template<class T> class SlistL : public SlistB
{
public:
    typedef SlistLI<T> iterator;
    typedef T Item;

public:
    SlistL() :
        SlistB() {}

    SlistL(const SlistL<T>&) :SlistB() {
        fatal(msg("Copy constructor for SlistL"));
    }

    // Insert and append.  The SlistB append and insert test
    // that the new returned a non-NULL pointer.
    void            insert(T* pItem) {
        SlistB::insert(new SlinkL<T>(pItem));
    }
    void            append(T* pItem) {
        SlistB::append(new SlinkL<T>(pItem));
    }

    // These versions remove the const-ness of an object.
    void            insert(const T* pItem) {
        SlistB::insert(new SlinkL<T>(const_cast<T*>(pItem)));
    }
    void            append(const T* pItem) {
        SlistB::append(new SlinkL<T>(const_cast<T*>(pItem)));
    }
    T*              detachFirst();
    T*              getLast() const {
        SlinkL<T>* lst = (SlinkL<T>*)SlistB::getLast();
        return lst ? lst->getItem() : NULL;
    }

    // tbasu 11/16/00

    SlinkL<T>*              getLastLink() const {
        SlinkL<T>* lst = (SlinkL<T>*)SlistB::getLast();
        return lst ;
    }

    T*              getFirst() const {
        SlinkL<T>* fst = (SlinkL<T>*)SlistB::getFirst();
        return fst ? fst->getItem() : NULL;
    }

    void            steal(SlistL<T>& list);
    void            merge(SlistL<T>& list);
    void            detach(const T* pItem);
    SlinkL<T>*      detachFast(const T* pItem, SlinkL<T>* startLink);
    void            detachItems()   { while (detachFirst()) ; }
    void deleteItems()
    {
        while (T *item = detachFirst()) {
            delete item;
        }
    }
    bool            hasItem(const T* item) const;
    bool            split(
        void*   holder,
        int     count,
        void    (*fun)(void*, SlistL<T>&));

    ~SlistL() {
        fassert(isEmpty(), msg("SlistL destructor on non-empty list"));
    }
    T*              detachNth(int n);
    size_t          getMemSizeOf() const;
    friend class    SlistLI<T>;
};

template<class T> class SlistLI : protected SlistBI
{
public:
    SlistLI() :
        SlistBI()
    {}
    SlistLI(const SlistL<T>* list) :
        SlistBI(list)
    {}
    SlistLI(const SlistL<T>& list) :
        SlistBI(list)
    {}
    SlistLI(const SlistLI<T>& iter)
        : SlistBI(iter) {}

    /// The pre-increment operator.
    /// @return The item current after incrementing.
    T*              operator++() {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::operator++();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    /// The post-increment operator.
    /// @return The item current before incrementing.
    T*              operator++(int) {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::operator++(0);
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    /// The current item operator.
    /// @return The current item.
    T*              operator()() const {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::operator()();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              peek() const {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::peek();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              getLast() const {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::getLast();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    // tbasu 11/16/00

    SlinkL<T>*              getLastLink() const {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::getLast();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ;
    }

    void            reset() { SlistBI::reset(); }
    void            append(T* pItem, SlistL<T>* pList) {
        nullcheck(pItem);
        SlistBI::append(new SlinkL<T>(pItem), pList);
    }
    void            appendAfter(T* pItem) {
        nullcheck(pItem);
        SlistBI::appendAfter(new SlinkL<T>(pItem));
    }
    T*              detachNext(SlistL<T>* pList) {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::detachNext(pList);
        T* ret = link->getItem();
        delete link;
        return ret;
    }
    T*              detachNext(SlistL<T>& pList) {
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::detachNext(&pList);
        T* ret = link->getItem();
        delete link;
        return ret;
    }
    T*              replaceNext(T* pItem, SlistL<T>* pList) {
        nullcheck(pItem);
        SlinkL<T>* nlink = new SlinkL<T>(pItem);
        SlinkL<T>* olink =
            (SlinkL<T>*)SlistBI::replaceNext(nlink, pList);
        fassert(olink, msg("replaceNext returns NULL SlinkL"));
        T* ret = olink->getItem();
        delete olink;
        return ret;
    }
    T*              replaceCurrent(T* pItem, SlistL<T>* pList) {
        nullcheck(pItem);
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::operator()();
        T* ret = link->getItem();
        link->replaceItem(pItem);
        return ret;
    }
    T*              replaceCurrent(T* pItem) {
        nullcheck(pItem);
        SlinkL<T>* link = (SlinkL<T>*)SlistBI::operator()();
        T* ret = link->getItem();
        link->replaceItem(pItem);
        return ret;
    }
    T*              giveNextItem(const T* item);
    T*              giveNextItem(const T* item, uint& itemNo);
    bool            atLast() const          { return SlistBI::atLast(); }
    bool            atFirst() const         { return SlistBI::atFirst(); }
    void            toLast()                { SlistBI::toLast(); }
    void            toFirst()               { SlistBI::toFirst(); }
};

template<class T> class SlistLEI : protected SlistBEI
{
public:
    SlistLEI() :
        SlistBEI()
    {}
    explicit SlistLEI(SlistL<T>* list) :
        SlistBEI(list)
    {}
    explicit SlistLEI(SlistL<T>& list) :
        SlistBEI(&list)
    {}
    SlistLEI(SlistLEI<T>& iter)
        : SlistBEI(iter) {}

    /// The post-increment operator.
    /// @return The item current before incrementing.
    T*              operator++(int) {
        SlinkL<T>* link = (SlinkL<T>*)SlistBEI::operator++(0);
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    /// The current item operator.
    /// @return The current item.
    T*              operator()() const {
        SlinkL<T>* link = (SlinkL<T>*)SlistBEI::operator()();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              peek() const {
        SlinkL<T>* link = (SlinkL<T>*)SlistBEI::peek();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              getLast() const {
        SlinkL<T>* link = (SlinkL<T>*)SlistBEI::getLast();
        fassert(!link || link->getItem(), msg("Corrupt SlistL"));
        return link ? link->getItem() : NULL;
    }
    void            insertBefore(T* pItem) {
        nullcheck(pItem);
        SlistBEI::insertBefore(new SlinkL<T>(pItem));
    }
    void            insertAfter(T* pItem) {
        nullcheck(pItem);
        SlistBEI::insertAfter(new SlinkL<T>(pItem));
    }

    // Given list { 1, 2, 3 }, and if iterator @ 2, then after detach
    // current, list = { 1, 3 }, and iterator @ 3
    T*              detachCurrent() {
        SlinkL<T>* link = (SlinkL<T>*)SlistBEI::detachCurrent();
        T* ret = link->getItem();
        delete link;
        return ret;
    }
    T*              detachNext() {
        SlinkL<T>* link = (SlinkL<T>*)SlistBEI::detachNext();
        T* ret = link->getItem();
        delete link;
        return ret;
    }
    T*              replacePrevious(T* pItem) {
        nullcheck(pItem);
        SlinkL<T>* prevlink = (SlinkL<T>*)SlistBEI::getPrevious();
        fassert(prevlink, msg("Previous link not established"));
        T* ret = prevlink->getItem();
        prevlink->replaceItem(pItem);
        return ret;
    }
    T*              replaceCurrent(T* pItem) {
        nullcheck(pItem);
        SlinkL<T>* link = (SlinkL<T>*)SlistBEI::operator()();
        T* ret = link->getItem();
        link->replaceItem(pItem);
        return ret;
    }
    T*              replaceNext(T* pItem) {
        nullcheck(pItem);
        SlinkL<T>* nlink = new SlinkL<T>(pItem);
        SlinkL<T>* olink = (SlinkL<T>*)SlistBEI::replaceNext(nlink);
        fassert(olink, msg("replaceNext returns NULL SlinkL"));
        T* ret = olink->getItem();
        delete olink;
        return ret;
    }
    bool            atLast() const          { return SlistBEI::atLast(); }
};

// These templates are for non-intrusive doubly linked lists.  These
// are suitable for lists that are not performance critical and not
// really large.  Intensively used lists are better implemented
// intrusively, i.e. with the next pointer in the data items.

// This is the container for the next and prev pointers and a pointer
// to the item.  Essentially a double CONS cell.
template<class T> class DlinkL : public DlinkB
{
public:
    /// This function returns the link's item.
    T*              getItem() const         { return item; }
    DlinkL(T* pItem) :
        DlinkB(),
        item(pItem) {
        nullcheck(pItem);
    }
    lifeGuardNewAndDeleteMacro
    ~DlinkL() {}
private:
    /// The item itself.
    T*              item;
};

// Notice there is some explicit casting in this code.  We can trust
// this since it always casts up towards the template object, never
// down to DlistB or DlinkB (which could strip information).
template<class T> class DlistL : public DlistB
{
public:
    DlistL() :
        DlistB() {}

    DlistL(const DlistL<T>&) {
        fatal(msg("Copy constructor for DlistL"));
    }

    // Insert and append.  The DlistB append and insert test
    // that the new returned a non-NULL pointer.
    void            insert(T* pItem) {
        DlistB::insert(new DlinkL<T>(pItem));
    }
    void            append(T* pItem) {
        DlistB::append(new DlinkL<T>(pItem));
    }

    // These versions remove the const-ness of an object.
    void            insert(const T* pItem) {
        DlistB::insert(new DlinkL<T>(const_cast<T*>(pItem)));
    }
    void            append(const T* pItem) {
        DlistB::append(new DlinkL<T>(const_cast<T*>(pItem)));
    }
    T*              detachFirst();
    T*              getLast() const {
        DlinkL<T>* lst = (DlinkL<T>*)DlistB::getLast();
        return lst ? lst->getItem() : NULL;
    }
    // tbasu  11/16/00
    DlinkL<T>*              getLastLink() const {
        DlinkL<T>* lst = (DlinkL<T>*)DlistB::getLast();
        return lst ;
    }

    T*              getFirst() const {
        DlinkL<T>* fst = (DlinkL<T>*)DlistB::getFirst();
        return fst ? fst->getItem() : NULL;
    }

    void            steal(DlistL<T>& list);
    void            merge(DlistL<T>& list);
    void            detach(const T* pItem);
    void            detachItems()   { while (detachFirst()) ; }
    T*              detachNth(int n) { //on the same ground as SlistL<T>::detachNth
        if (n == 0) return detachFirst();
        DlistLI<T> ti(*this);
        for (int i = 0; i < (n - 1); i++) {
            ti++;
        }    
        nullcheck(ti.peek());
        return ti.detachNext(*this);
    }
    bool            hasItem(const T* item) const;
    bool            split(
        void*   holder,
        int     count,
        void    (*fun)(void*, DlistL<T>&));

    ~DlistL() {
        fassert(isEmpty(), msg("DlistL destructor on non-empty list"));
    }
    size_t          getMemSizeOf() const;
    friend class    DlistLI<T>;
};

template<class T> class DlistLI : protected DlistBI
{
public:
    DlistLI() :
        DlistBI() {}
    DlistLI(const DlistL<T>* list) :
        DlistBI(list) {}
    DlistLI(const DlistL<T>& list) :
        DlistBI(&list) {}
    DlistLI(const DlistLI<T>& iter)
        : DlistBI(iter) {}
    /// The pre-increment operator.
    /// @return The item current after incrementing.
    T*              operator++() {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::operator++();
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    /// The post-increment accesses.
    /// @return The item current before incrementing.
    T*              operator++(int) {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::operator++(0);
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              operator--() {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::operator--();
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              operator--(int) {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::operator--(0);
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    /// The current item operator.
    /// @return The current item.
    T*              operator()() const {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::operator()();
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              peek() const {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::peek();
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              prev() const {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::prev();
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    T*              getLast() const {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::getLast();
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ? link->getItem() : NULL;
    }
    DlinkL<T>*      getLastLink() const {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::getLast();
        fassert(!link || link->getItem(), msg("Corrupt DlistL"));
        return link ;
    }
    void            append(T* pItem, DlistL<T>* pList) {
        nullcheck(pItem);
        DlistBI::append(new DlinkL<T>(pItem), pList);
    }
    T*              detachNext(DlistL<T>* pList) {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::detachNext(pList);
        T* ret = link->getItem();
        delete link;
        return ret;
    }
    T*              detachNext(DlistL<T>& pList) {
        DlinkL<T>* link = (DlinkL<T>*)DlistBI::detachNext(&pList);
        T* ret = link->getItem();
        delete link;
        return ret;
    }
    T*              replaceNext(T* pItem, DlistL<T>* pList) {
        nullcheck(pItem);
        DlinkL<T>* nlink = new DlinkL<T>(pItem);
        DlinkL<T>* olink =
            (DlinkL<T>*)DlistBI::replaceNext(nlink, pList);
        fassert(olink, msg("replaceNext returns NULL DlinkL"));
        T* ret = olink->getItem();
        delete olink;
        return ret;
    }
    T*              replaceCurrent(T* pItem, DlistL<T>* pList) {
        nullcheck(pItem);
        DlinkL<T>* nlink = new DlinkL<T>(pItem);
        DlinkL<T>* olink =
            (DlinkL<T>*)DlistBI::replaceCurrent(nlink, pList);
        fassert(olink, msg("replaceCurrent returns NULL DlinkL"));
        T* ret = olink->getItem();
        delete olink;
        return ret;
    }
    bool            atLast() const          { return DlistBI::atLast(); }
    bool            atFirst() const         { return DlistBI::atFirst(); }
    void            toLast()                { DlistBI::toLast(); }
    void            toFirst()               { DlistBI::toFirst(); }
    void            reset() { DlistBI::reset(); }
};

// These classes define an intrusive singly linked list.
template<class T> class SlistM : public SlistB
{
    friend class    SlistMI<T>;
public:
    typedef SlistMI<T> iterator;
    typedef T Item;
public:
    SlistM() :
        SlistB()
    {}

    SlistM(const SlistM<T>&) : SlistB() {
        fatal(msg("Copy constructor for SlistM"));
    }
    void            insert(const T* pItem) {
        SlistB::insert(const_cast<T*>(pItem));
    }
    void            append(const T* pItem) {
        SlistB::append(const_cast<T*>(pItem));
    }

    T*              detachFirst() {
        return static_cast<T*>(SlistB::detachFirst());
    }
    T*              getLast() const {
        return static_cast<T*>(SlistB::getLast());
    }
    T*              getFirst() const {
        return static_cast<T*>(SlistB::getFirst());
    }
    void            steal(SlistM<T>& list);
    void            merge(SlistM<T>& list);
    void            detach(const T* pItem);
    void            detachItems()   { while (detachFirst()) ; }
    bool            hasItem(const T* item) const;
    bool            split(
        void*   holder,
        int     count,
        void    (*fun)(void*, SlistM<T>&));

    ~SlistM() {
        fassert(isEmpty(), msg("SlistM destructor on non-empty list"));
    }
};

template<class T> class SlistMI : protected SlistBI
{
public:
    // Provide both pointer and reference constructors for convenience.
    SlistMI() :
        SlistBI()
    {}
    SlistMI(const SlistM<T>* list) :
        SlistBI((SlistB*) list)
    {}
    SlistMI(const SlistM<T>& list) :
        SlistBI((SlistB*) &list)
    {}
    SlistMI(const SlistMI<T>& iter)
        : SlistBI(iter) {}

    /// The pre-increment operator.
    /// @return The item current after incrementing.
    T*              operator++() {
        return static_cast<T*>(SlistBI::operator++());
    }
    /// The post-increment operator.
    /// @return The item current before incrementing.
    T*              operator++(int) {
        return static_cast<T*>(SlistBI::operator++(0));
    }
    /// The current item operator.
    /// @return The current item.
    T*              operator()() const {
        return static_cast<T*>(SlistBI::operator()());
    }
    T*              peek() const {
        return static_cast<T*>(SlistBI::peek());
    }
    T*              getLast() const {
        return static_cast<T*>(SlistBI::getLast());
    }
    void            append(T* pItem, SlistM<T>* pList) {
        nullcheck(pItem);
        SlistBI::append(pItem, pList);
    }
    T*              detachNext(SlistM<T>* pList) {
        T* ret = static_cast<T*>(SlistBI::detachNext(pList));
        return ret;
    }
    T*              detachNext(SlistM<T>& pList) {
        T* ret = static_cast<T*>(SlistBI::detachNext(&pList));
        return ret;
    }
    T*              replaceNext(T* pItem, SlistM<T>* pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(SlistBI::replaceNext(pItem, pList));
        ret->unlink();
        return ret;
    }
    T*              replaceNext(T* pItem, SlistM<T>& pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(SlistBI::replaceNext(pItem, &pList));
        ret->unlink();
        return ret;
    }
    T*              replaceCurrent(T* pItem, SlistM<T>* pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(
                     SlistBI::replaceCurrent(pItem, pList));
        ret->unlink();
        return ret;
    }
    T*              replaceCurrent(T* pItem, SlistM<T>& pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(
                     SlistBI::replaceCurrent(pItem, &pList));
        ret->unlink();
        return ret;
    }
    T*              giveNextItem(const T* item);
    T*              giveNextItem(const T* item, uint& itemNo);
    bool            atLast() const          { return SlistBI::atLast(); }
    bool            atFirst() const         { return SlistBI::atFirst(); }
    void            toLast()                { SlistBI::toLast(); }
    void            toFirst()               { SlistBI::toFirst(); }
};

// These classes define an intrusive doubly linked list.
template<class T> class DlistM : public DlistB
{
    friend class    DlistMI<T>;
public:
    DlistM() :
        DlistB()
    {}
    void            insert(T* pItem)        { DlistB::insert(pItem); }
    void            append(T* pItem)        { DlistB::append(pItem); }

    // These versions remove the const-ness of an object.
    void            insert(const T* pItem) {
        DlistB::insert(const_cast<T*>(pItem));
    }
    void            append(const T* pItem) {
        DlistB::append(const_cast<T*>(pItem));
    }

    T*              detachFirst() {
        return static_cast<T*>(DlistB::detachFirst());
    }
    T*              getLast() const {
        return static_cast<T*>(DlistB::getLast());
    }
    T*              getFirst() const {
        return static_cast<T*>(DlistB::getFirst());
    }
    void            steal(DlistM<T>& list);
    void            merge(DlistM<T>& list);
    void            detach(const T* pItem) {
        DlistB::detach(const_cast<T*>(pItem));
    }
    void            detachItems()   { while (detachFirst()) ; }
    bool            hasItem(const T* item) const;
    bool            split(
        void*   holder,
        int     count,
        void    (*fun)(void*, DlistM<T>&));

    ~DlistM() {
        fassert(isEmpty(), msg("DlistM destructor on non-empty list"));
    }
};

template<class T> class DlistMI : protected DlistBI
{
public:
    // Provide both pointer and reference constructors for convenience.
    DlistMI() :
        DlistBI()
    {}
    DlistMI(const DlistM<T>* list) :
        DlistBI((DlistB*) list)
    {}
    DlistMI(const DlistM<T>& list) :
        DlistBI((DlistB*) &list)
    {}
    DlistMI(const DlistM<T>& list, DlinkB *link) :
        DlistBI((DlistB*) &list, link) {}
    DlistMI(const DlistMI<T>& iter)
        : DlistBI(iter) {}

    /// The post-increment operator.
    /// @return The item current before incrementing.
    T*              operator++(int) {
        return static_cast<T*>(DlistBI::operator++(0));
    }
    /// The pre-increment operator.
    /// @return The item current after incrementing.
    T*              operator++() {
        return static_cast<T*>(DlistBI::operator++());
    }
    T*              operator--(int) {
        return static_cast<T*>(DlistBI::operator--(0));
    }
    T*              operator--() {
        return static_cast<T*>(DlistBI::operator--());
    }
    /// The current item operator.
    /// @return The current item.
    T*              operator()() const {
        return static_cast<T*>(DlistBI::operator()());
    }
    T*              peek() const {
        return static_cast<T*>(DlistBI::peek());
    }
    T*              prev() const {
        return static_cast<T*>(DlistBI::prev());
    }
    T*              getLast() const {
        return static_cast<T*>(DlistBI::getLast());
    }
    void            append(T* pItem, DlistM<T>* pList) {
        nullcheck(pItem);
        DlistBI::append(pItem, pList);
    }
    T*              detachNext(DlistM<T>* pList) {
        T* ret = static_cast<T*>(DlistBI::detachNext(pList));
        return ret;
    }
    T*              detachNext(DlistM<T>& pList) {
        T* ret = static_cast<T*>(DlistBI::detachNext(&pList));
        return ret;
    }
    T*              replaceNext(T* pItem, DlistM<T>* pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(DlistBI::replaceNext(pItem, pList));
        ret->unlink();
        return ret;
    }
    T*              replaceNext(T* pItem, DlistM<T>& pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(DlistBI::replaceNext(pItem, &pList));
        ret->unlink();
        return ret;
    }
    T*              replaceCurrent(T* pItem, DlistM<T>* pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(
                     DlistBI::replaceCurrent(pItem, pList));
        ret->unlink();
        return ret;
    }
    T*              replaceCurrent(T* pItem, DlistM<T>& pList) {
        nullcheck(pItem);
        T* ret = static_cast<T*>(
                     DlistBI::replaceCurrent(pItem, &pList));
        ret->unlink();
        return ret;
    }
    T*              giveNextItem(const T* item);
    T*              giveNextItem(const T* item, uint& itemNo);
    bool            atLast() const          { return DlistBI::atLast(); }
    bool            atFirst() const         { return DlistBI::atFirst(); }
    void            toLast()                { DlistBI::toLast(); }
    void            toFirst()               { DlistBI::toFirst(); }
};

typedef SlistL<char>            CharL;
typedef SlistLI<char>           CharLI;

typedef SlistL<int>             IntL;
typedef SlistLI<int>            IntLI;


////////////////////////////////CallOnReturn/////////////////////////
template<class TYPE> class CallOnReturnT
{
    typedef SlistL<TYPE> TypeL;
public:
    CallOnReturnT(TypeL& tL) : tempL(tL) {}
    ~CallOnReturnT() { tempL.detachItems(); }
    TypeL& tempL;
};

#ifdef INLINE_TMPL
#if 0 /* expanded by -frewrite-includes */
#include "list.ii"
#endif /* expanded by -frewrite-includes */
# 1443 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.ii" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

// $Id$ $Author$ $DateTime$

// This file holds the part of the list code (in list.hh) that could
// be placed on a regular compile file if the compiler supports
// non-inlined templates, otherwise this file is included from the
// list.hh file and all is exposed.

#ifdef INLINE_TMPL
#define TMPL_INLINE inline
#else
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.ii"
#define TMPL_INLINE
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.ii"

//------------------------------------------------------------------------------
// SlistB member functions

/// This function inserts a link as the first link in the list.
/// @param l The link to insert
/// @pre If the link is NULL a fatal assertion is thrown
TMPL_INLINE void SlistB::insert(SlinkB* l)
{
    memcheck(l);
    if (last) {
        l->linkTo(last->getNext());
    }
    else {
        last = l;
    }
    last->linkTo(l);
}

/// This function appends a link to the end of the list.
/// @param l The link to append
/// @pre If the link is NULL or its next pointer is NOT NULL a
/// fatal assertion is thrown
TMPL_INLINE void SlistB::append(SlinkB* l)
{
    memcheck(l);
    fassert(l->getNext() == NULL,
            msg("Trying to attach SlinkB already attached"));
    if (last) {
        l->linkTo(last->getNext());
        last->linkTo(l);
    }
    else {
        l->linkTo(l);
    }
    last = l;
}

/// This function appends a link after the given link @p a.
/// @param a The link after which @p l should be inserted.
/// @param l The link to append.
/// @pre If the link is NULL or its next pointer is NOT NULL a
/// fatal assertion is thrown.
/// @note We could check that the link @p a belongs to the
/// list and throw a fatal assertion if it does not.
TMPL_INLINE void SlistB::appendAfter(SlinkB* a, SlinkB* l)
{
    memcheck(a && l && last);
    fassert(l->getNext() == NULL,
            msg("Trying to attach SlinkB already attached"));
    l->linkTo(a->getNext());
    a->linkTo(l);
    if (last == a) {
        last = l;
    }
    else {
        // Check that a belongs to the list.
        ;
    }
}

/// This function detaches the first link in the list.
/// @return The first link or NULL if the list is empty.
TMPL_INLINE SlinkB* SlistB::detachFirst()
{
    if (!last) {
        // Empty list--allow it but return benign value.
        return NULL;
    }
    SlinkB* l = last->getNext();
    if (l == last) {
        // This was the only item, now list is empty.
        last = NULL;
    }
    else {
        last->linkTo(l->getNext());
    }
    l->unlink();
    return l;
}

/// This function detaches the link after the given one.
/// @param link The link whose next link should be detached.
/// @attention The list can become empty after calling this,
/// and in this case detachNext will detach the given link,
/// since in a list with a single link @c next points to
/// itself.
TMPL_INLINE SlinkB* SlistB::detachNext(SlinkB*& link)
{
    SlinkB* ret = link->getNext();
    fassert(ret, msg("SlistB::detachNext returns null"));

    link->linkTo(ret->getNext());
    ret->unlink();

    // Now adjust the last pointer.
    if (last == ret) {
        if (ret == link) {
            // Last is being detached leaving
            // the list empty.
            last = NULL;
            link = NULL;
        }
        else {
            // Last walks back one.
            last = link;
        }
    }
    return ret;
}

TMPL_INLINE bool SlistB::operator==(const SlistB& a) const {
    SlistBI aI(&a);
    SlistBI thisI(this);
    while (SlinkB* l = aI++) {
        if (l != thisI++) {
            return false;
        }
    }
    return true;
}

TMPL_INLINE bool SlistB::operator==(const SlistB* a) const {
    return this->operator==(*a);
}

//------------------------------------------------------------------------------
// SlistBI member functions

/// This is the pre increment operator.
/// @return The link after moving forward, or NULL if it was
/// already at the last link.
TMPL_INLINE SlinkB* SlistBI::operator++()
{
    if (currentLink) {
        fassert(currentList, msg("SlistBI has link but no list"));
        if (currentLink == currentList->last) {
            currentLink = NULL;
        }
        else {
            currentLink = currentLink->getNext();
        }
    }
    return currentLink;
}

/// This is the post increment operator.
/// @return The current link, or NULL if the iterator had
/// reached the last link.
TMPL_INLINE SlinkB* SlistBI::operator++(int)
{
    if (currentLink) {
        fassert(currentList, msg("SlistBI has link but no list"));
        SlinkB* ret = currentLink;
        if (currentLink == currentList->last) {
            currentLink = NULL;
        }
        else {
            currentLink = currentLink->getNext();
        }
        return ret;
    }
    else {
        return NULL;
    }
}

/// This function appends the given link at current position.
/// @param pItem The link to append.
/// @param pList The list to be used to append. Since this
/// modifies the list we need to pass a non-const pointer to
/// the list.
/// @attention If the given list does not equal the list held
/// by the iterator this triggers a fatal assertion.
TMPL_INLINE void SlistBI::append(SlinkB* pItem, SlistB* pList)
{
    nullcheck(pList && currentList);
    fassert(pList == currentList, msg("SlistBI::append gets bad list"));
    if (!currentLink) {
        pList->append(pItem);
    }
    else {
        pList->appendAfter(currentLink, pItem);
    }
}

/// This function removes the next link from given list.
/// @param pList The list to be modified. Since this modifies
/// the list we need to pass a non-const pointer to the list.
/// @return The link detached.
/// @attention If the given list does not equal the list held
/// by the iterator this triggers a fatal assertion.
/// @note This is a constant time operation.
/// @pre The list can not be empty.
TMPL_INLINE SlinkB* SlistBI::detachNext(SlistB* pList)
{
    fassert(currentLink, msg("detachNext from empty list"));
    fassert(currentList && currentList->last,
            msg("detachNext from empty list"));
    fassert(currentList == pList, msg("detachNext gets bad list"));
    return pList->detachNext(currentLink);
}

/// This function replaces the next link relative to the
/// iterator's current item from given list.
/// @param pItem The new link to be appended.
/// @param pList The list to be modified. Since this modifies
/// the list we need to pass a non-const pointer to the list.
/// @return The replaced link.
/// @attention If the given list does not equal the list held
/// by the iterator this triggers a fatal assertion.
/// @attention If the list has a single item the iterator's
/// current item is modified.
/// @note This is a constant time operation.
/// @pre The list can not be empty.
TMPL_INLINE SlinkB* SlistBI::replaceNext(SlinkB* pItem, SlistB* pList)
{
    fassert(currentLink, msg("replaceNext with bad iterator"));
    fassert(currentList && currentList->last,
            msg("replaceNext from empty list"));
    fassert(currentList == pList, msg("replaceNext gets bad list"));

    SlinkB* ret = currentLink->getNext();
    // Corner case: list of one element needs currentLink
    // to point to the new item.
    if (ret == currentLink) {
        currentLink = pItem;
        pItem->linkTo(pItem);
    }
    else {
        currentLink->linkTo(pItem);
        pItem->linkTo(ret->getNext());
    }

    // Now adjust the last pointer.
    if (currentList->last == ret) {
        pList->last = pItem;
    }
    return ret;
}

/// This function replaces the current link from given list.
/// @param pItem The new link to be appended.
/// @param pList The list to be modified. Since this modifies
/// the list we need to pass a non-const pointer to the list.
/// @return The replaced link.
/// @attention If the given list does not equal the list held
/// by the iterator this triggers a fatal assertion.
/// @attention The current link the iterator is pointing to
/// becomes the new link.
/// @note This operation takes time proportional to the
/// position of the current item, since it needs to traverse
/// the list.
/// @pre The list can not be empty.
TMPL_INLINE SlinkB* SlistBI::replaceCurrent(SlinkB* pItem, SlistB* pList)
{
    fassert(currentLink, msg("replaceCurrent from empty list"));
    fassert(currentList->last, msg("replaceCurrent from empty list"));

    SlinkB* ret;
    // Special case.  This may not be all uncommon.
    if (currentList->last->getNext() == currentLink) {
        currentLink = currentList->last;
        ret = replaceNext(pItem, pList);
    }
    else {
        SlinkB* curr = currentLink;
        reset();

        while (peek() != curr)
            this->operator++();
        ret = replaceNext(pItem, pList);
    }
    // This is essential, in order to leave the iterator pointing
    // at the replaced item.  Use the next pointer instead of
    // operator++, since the former clears currentLink at the
    // end of the list.
    currentLink = currentLink->getNext();
    return ret;
}


//------------------------------------------------------------------------------
// SlistBEI member functions

/// This is the post increment operator.
/// @return The current link, or NULL if the iterator had
/// reached the last link.
TMPL_INLINE SlinkB* SlistBEI::operator++(int)
{
    if (currentLink) {
        fassert(currentList, msg("SlistBI has link but no list"));
        SlinkB* ret = currentLink;
        if (currentLink == currentList->last) {
            currentLink = NULL;
            prevLink = NULL;
        }
        else {
            prevLink = currentLink;
            currentLink = currentLink->getNext();
        }
        return ret;
    }
    else {
        return NULL;
    }
}

/// This function inserts the given link before current position.
/// @param pItem The link to insert.
TMPL_INLINE void SlistBEI::insertBefore(SlinkB* pItem)
{
    nullcheck(currentList);
    fassert(currentLink, msg("insertBefore from empty list"));
    if (!prevLink) {
        currentList->insert(pItem);
        prevLink = pItem;
    }
    else {
        currentList->appendAfter(prevLink, pItem);
    }
}

/// This function inserts the given link after current position.
/// @param pItem The link to insert.
TMPL_INLINE void SlistBEI::insertAfter(SlinkB* pItem)
{
    nullcheck(currentList);
    if (!currentLink) {
        currentList->append(pItem);
    }
    else {
        currentList->appendAfter(currentLink, pItem);
    }
}

/// This function removes the current link from given list.
TMPL_INLINE SlinkB* SlistBEI::detachCurrent()
{
    fassert(currentLink, msg("detachCurrent from empty list"));
    fassert(currentList && currentList->last,
            msg("detachCurrent from empty list"));

    SlinkB* ret;
    if (currentLink == currentList->getFirst()) {
        fassert(!prevLink, msg("Inconsistent iterator state"));
        if (currentLink == currentList->getLast()) {
            /// Only one item, make iterator null
            currentLink = NULL;
            ret = currentList->detachFirst();
        }
        else {
            ret = currentList->detachFirst();
            currentLink = currentList->getFirst();
        }
    }
    else {
        /// Can only detach one item @ current.  Must ++ to
        /// re-establish prevLink
        fassert(prevLink, msg("Cannot detachCurrent twice"));
        ret = currentList->detachNext(prevLink);
        currentLink = prevLink->getNext();
        if (currentList->hasOneItem()) {
            prevLink = NULL;
        }
    }
    return ret;
}

/// This function removes the next link from given list.
TMPL_INLINE SlinkB* SlistBEI::detachNext()
{
    fassert(currentLink, msg("detachNext from empty list"));
    fassert(currentList && currentList->last,
            msg("detachNext from empty list"));
    return currentList->detachNext(currentLink);
}

/// This function replaces the next link relative to the
/// iterator's current item from given list.
/// @attention If the list has a single item the iterator's
/// current item is modified.
/// @note This is a constant time operation.
/// @pre The list can not be empty.
TMPL_INLINE SlinkB* SlistBEI::replaceNext(SlinkB* pItem)
{
    fassert(currentLink, msg("replaceNext with bad iterator"));
    fassert(currentList && currentList->last,
            msg("replaceNext from empty list"));

    SlinkB* ret = currentLink->getNext();
    // Corner case: list of one element needs currentLink
    // to point to the new item.
    if (ret == currentLink) {
        currentLink = pItem;
        pItem->linkTo(pItem);
    }
    else {
        currentLink->linkTo(pItem);
        pItem->linkTo(ret->getNext());
    }

    // Now adjust the last pointer.
    if (currentList->last == ret) {
        currentList->last = pItem;
    }
    return ret;
}

/// This function replaces the current link from given list.
/// @param pItem The new link to be appended.
/// @attention The current link the iterator is pointing to
/// becomes the new link.
/// @note This operation takes time proportional to the
/// position of the current item, since it needs to traverse
/// the list.
/// @pre The list can not be empty.
TMPL_INLINE SlinkB* SlistBEI::replaceCurrent(SlinkB* pItem)
{
    fassert(currentLink, msg("replaceCurrent from empty list"));
    fassert(currentList->last, msg("replaceCurrent from empty list"));

    SlinkB* ret;
    if (currentLink == currentList->getFirst()) {
        fassert(!prevLink, msg("Inconsistent iterator state"));
        currentLink = currentList->last;
        ret = replaceNext(pItem);
    }
    else {
        fassert(prevLink, msg("prevLink not set"));
        prevLink->linkTo(pItem);
        pItem->linkTo(currentLink->getNext());
        ret = currentLink;
    }
    // This is essential, in order to leave the iterator pointing
    // at the replaced item.  Use the next pointer instead of
    // operator++, since the former clears currentLink at the
    // end of the list.
    currentLink = currentLink->getNext();
    return ret;
}

//------------------------------------------------------------------------------
// DlistB member functions

// Add link to the head of the list.
TMPL_INLINE void DlistB::insert(DlinkB* l)
{
    memcheck(l);
    fassert((l->getNext() == NULL) && (l->getPrev() == NULL),
            msg("Trying to insert DlinkB already attached"));
    if (last) {
        l->linkTo(last->getNext());
    }
    else {
        last = l;
    }
    last->linkTo(l);
}

// Add to the tail of the list.
TMPL_INLINE void DlistB::append(DlinkB* l)
{
    memcheck(l);
    fassert((l->getNext() == NULL) && (l->getPrev() == NULL),
            msg("Trying to attach DlinkB already attached"));
    if (last) {
        l->linkTo(last->getNext());
        last->linkTo(l);
    }
    else {
        l->linkTo(l);
    }
    last = l;
}

/// This function inserts a link before the given link @p a.
/// @param a the link before which the new link is inserted
/// @param l the link to be inserted
/// @note inserting before the first link causes the new link to
/// become first.
TMPL_INLINE void DlistB::insertBefore(DlinkB* a, DlinkB* l)
{
    memcheck(a && l && last);
    fassert((l->getNext() == NULL) && (l->getPrev() == NULL),
            msg("Trying to attach DlinkB already attached"));
    a->getPrev()->linkTo(l);
    l->linkTo(a);
}

// Add after the given item.
TMPL_INLINE void DlistB::appendAfter(DlinkB* a, DlinkB* l)
{
    memcheck(a && l && last);
    fassert((l->getNext() == NULL) && (l->getPrev() == NULL),
            msg("Trying to attach DlinkB already attached"));
    if (last == a) {
        last = l;
    }
    l->linkTo(a->getNext());
    a->linkTo(l);
}

// Detach and return head of the list.
TMPL_INLINE DlinkB* DlistB::detachFirst()
{
    if (!last) {
        // Empty list--allow it but return benign value.
        return NULL;
    }
    DlinkB* l = last->getNext();
    if (l == last) {
        // This was the only item, now list is empty.
        last = NULL;
    }
    else {
        last->linkTo(l->getNext());
    }
    l->unlink();
    return l;
}

TMPL_INLINE DlinkB* DlistB::detachNext(DlinkB*& link)
{
    DlinkB* ret = link->getNext();
    fassert(ret, msg("DlistB::detachNext returns null"));
    if (last == ret) {
        if (ret == link) {
            // Last is being detached leaving
            // the list empty.
            link = NULL;
            last = NULL;
        }
        else {
            // Last walks back one.
            last = link;
            link->linkTo(ret->getNext());
        }
    }
    else {
        link->linkTo(ret->getNext());

    }
    ret->unlink();
    return ret;
}

TMPL_INLINE DlinkB* DlistB::detach(DlinkB* link)
{
    if (last == link) {
        if (link->getNext() == link) {
            // Last item.
            last = NULL;
        }
        else {
            // There were other items.
            last = link->getPrev();
            last->linkTo(link->getNext());
        }
    }
    else {
        link->getPrev()->linkTo(link->getNext());
    }
    link->unlink();
    return link;
}

//------------------------------------------------------------------------------
// DlistBI member functions

// Pre-increment operator: return NULL at the end of the list.
TMPL_INLINE DlinkB* DlistBI::operator++()
{
    if (currentLink) {
        fassert(currentList, msg("DlistBI has link but no list"));
        if (currentLink == currentList->last) {
            currentLink = NULL;
        }
        else {
            currentLink = currentLink->getNext();
        }
    }
    return currentLink;
}

// Post-increment operator: return NULL at the end of the list.
TMPL_INLINE DlinkB* DlistBI::operator++(int)
{
    if (currentLink) {
        fassert(currentList, msg("DlistBI has link but no list"));
        DlinkB* ret = currentLink;
        if (currentLink == currentList->last) {
            currentLink = NULL;
        }
        else {
            currentLink = currentLink->getNext();
        }
        return ret;
    }
    else {
        return NULL;
    }
}

// Pre-decrement operator: return NULL at the beginning of the list.
TMPL_INLINE DlinkB* DlistBI::operator--()
{
    if (currentLink) {
        fassert(currentList, msg("DlistBI has link but no list"));
        if (currentLink == currentList->last->getNext()) {
            currentLink = NULL;
        }
        else {
            currentLink = currentLink->getPrev();
        }
    }
    return currentLink;
}

// Post-decrement operator: return NULL at the beginning of the list.
TMPL_INLINE DlinkB* DlistBI::operator--(int)
{
    if (currentLink) {
        fassert(currentList, msg("DlistBI has link but no list"));
        DlinkB* ret = currentLink;
        if (currentLink == currentList->last->getNext()) {
            currentLink = NULL;
        }
        else {
            currentLink = currentLink->getPrev();
        }
        return ret;
    }
    else {
        return NULL;
    }
}

TMPL_INLINE void DlistBI::append(DlinkB* pItem, DlistB* pList)
{
    nullcheck(pList && currentList);
    fassert(pList == currentList, msg("DlistBI::append gets bad list"));
    if (!currentLink) {
        pList->append(pItem);
    }
    else {
        pList->appendAfter(currentLink, pItem);
    }
}

// Remove the next from given link.  It gets passed the
// list so it can be used as const for all other effects.
TMPL_INLINE DlinkB* DlistBI::detachNext(DlistB* pList)
{
    fassert(currentLink, msg("detachNext from empty list"));
    fassert(currentList && currentList->last,
            msg("detachNext from empty list"));
    fassert(currentList == pList, msg("detachNext gets bad list"));
    return pList->detachNext(currentLink);
}

// Replace the next from current link by given item.  It gets
// passed the list so it can be used as const for all other effects.
// It returns the old link.
TMPL_INLINE DlinkB* DlistBI::replaceNext(DlinkB* pItem, DlistB* pList)
{
    fassert(currentLink, msg("replaceNext with bad iterator"));
    fassert(currentList && currentList->last,
            msg("replaceNext from empty list"));
    fassert(currentList == pList, msg("replaceNext gets bad list"));

    DlinkB* ret = currentLink->getNext();
    // Corner case: list of one element needs currentLink
    // to point to the new item.
    if (ret == currentLink) {
        currentLink = pItem;
        pItem->linkTo(pItem);
    }
    else {
        currentLink->linkTo(pItem);
        pItem->linkTo(ret->getNext());
    }

    // Now adjust the last pointer.
    if (currentList->last == ret) {
        pList->last = pItem;
    }
    return ret;
}

// Replace the current link by given item.  It gets passed the list
// so it can be used as const for all other effects.  It is careful
// to leave the iterator pointing at the item replaced.
// It returns the old link.
TMPL_INLINE DlinkB* DlistBI::replaceCurrent(DlinkB* pItem, DlistB* pList)
{
    fassert(currentLink, msg("replaceCurrent from empty list"));
    fassert(currentList->last, msg("replaceCurrent from empty list"));

    DlinkB* ret = currentLink;
    if (ret->getNext() == ret) {
        // Only item in the list.
        pItem->linkTo(pItem);
        pList->last = pItem;
    }
    else {
        pItem->linkTo(ret->getNext());
        ret->getPrev()->linkTo(pItem);
        if (pList->last == ret) {
            pList->last = pItem;
        }
    }
    currentLink = pItem;
    ret->unlink();
    return ret;
}

//------------------------------------------------------------------------------
// SlistL<T> member functions

template<class T> TMPL_INLINE bool SlistL<T>::split(
    void* holder, int count, void (*appendFun)(void*, SlistL<T>&))
{
    if (!last) {
        return false;
    }
    bool didSplit = false;
    int numItems = 0;
    SlinkB* link = last->getNext();
    SlinkB* currentFirst = link;
    while (link != last) {
        SlinkB* nextLink = link->getNext();
        numItems++;
        if (numItems == count) {
            didSplit = true;
            numItems = 0;
            link->linkTo(currentFirst);
            currentFirst = nextLink;
            last->linkTo(currentFirst);
            SlistL<T> newL;
            newL.last = link;
            appendFun(holder, newL);
        }
        link = nextLink;
    }
    if (didSplit) {
        if (!isEmpty()) {
            appendFun(holder, *this);
        }
    }
    return didSplit;
}

template<class T> TMPL_INLINE void SlistL<T>::steal(SlistL<T>& list)
{
    // Snatch the list pointed to by the argument: copy the last
    // pointer and set it to NULL on argument.  Notice we don't
    // use getLast() because we need the CONS cell.
    fassert(!last, msg("stealing into non-empty list; use merge"));
    last = list.last;
    list.flush();
}

// NOTE: merge() is expected to append the contents of 'list' to the end of
//       *this list
template<class T> TMPL_INLINE void SlistL<T>::merge(SlistL<T>& list)
{
    // Merge the list pointed to by the argument into self and
    // and flush the argument.

    if (list.last) {
        if (last) {
            SlinkB* next = last->getNext();
            last->linkTo(list.last->getNext());
            list.last->linkTo(next);
        }
        last = list.last;
        list.flush();
    }
}

template<class T> TMPL_INLINE void SlistL<T>::detach(const T* pItem)
{
    SlinkB* link = last;
    while (link) {
        if (((SlinkL<T>*)link->getNext())->getItem() == pItem) {
            SlinkL<T>* lnk = (SlinkL<T>*)detachNext(link);
            fassert(lnk->getItem() == pItem,
                    msg("detach inconsistent"));
            delete lnk;
            return;
        }
        link = link->getNext();
        if (link == last) {
            break;
        }
    }
    fatal(msg("Item not found in list"));
}

template<class T> TMPL_INLINE SlinkL<T>* SlistL<T>::detachFast(const T* pItem,
        SlinkL<T>* startLink)
{
    SlinkB* link = startLink ? startLink : last;
    while (link) {
        if (((SlinkL<T>*)link->getNext())->getItem() == pItem) {
            SlinkL<T>* lnk = static_cast<SlinkL<T>*>(
                                 detachNext(link));
            fassert(lnk->getItem() == pItem,
                    msg("detach inconsistent"));
            delete lnk;
            return (SlinkL<T>*) link;
        }
        link = link->getNext();
        if (link == startLink) {
            break;
        }
    }
    fatal(msg("Item not found in list"));
    return (SlinkL<T>*) link;
}

template<class T> TMPL_INLINE bool SlistL<T>::hasItem(const T* item) const
{
    SlistLI<T> ii(this);
    while (T* i = ii++) {
        if (i == item) {
            return true;
        }
    }
    return false;
}

template<class T> TMPL_INLINE T* SlistL<T>::detachFirst()
{
    SlinkL<T>* lnk = (SlinkL<T>*) SlistB::detachFirst();
    if (lnk) {
        T* item = lnk->getItem();
        delete lnk;
        return item;
    }
    else {
        // List was already empty.  Allow it.
        return NULL;
    }
}

//------------------------------------------------------------------------------
// DlistL<T> member functions
template<class T> TMPL_INLINE bool DlistL<T>::split(
    void* holder, int count, void (*appendFun)(void*, DlistL<T>&))
{
    if (!last) {
        return false;
    }
    bool didSplit = false;
    int numItems = 0;
    DlinkB* link = last->getNext();
    DlinkB* currentFirst = link;
    while (link != last) {
        DlinkB* nextLink = link->getNext();
        numItems++;
        if (numItems == count) {
            didSplit = true;
            numItems = 0;
            link->linkTo(currentFirst);
            currentFirst = nextLink;
            last->linkTo(currentFirst);
            DlistL<T> newL;
            newL.last = link;
            appendFun(holder, newL);
        }
        link = nextLink;
    }
    if (didSplit) {
        if (!isEmpty()) {
            appendFun(holder, *this);
        }
    }
    return didSplit;
}

template<class T> TMPL_INLINE void DlistL<T>::steal(DlistL<T>& list)
{
    // Snatch the list pointed to by the argument: copy the last
    // pointer and set it to NULL on argument.  Notice we don't
    // use getLast() because we need the CONS cell.
    fassert(!last, msg("stealing into non-empty list; use merge"));
    last = list.last;
    list.flush();
}

template<class T> TMPL_INLINE void DlistL<T>::merge(DlistL<T>& list)
{
    // Merge the list pointed to by the argument into self
    // and flush the argument.
    if (list.last) {
        if (last) {
            DlinkB* next = last->getNext();
            last->linkTo(list.last->getNext());
            list.last->linkTo(next);
        }
        last = list.last;
        list.flush();
    }
}

template<class T> TMPL_INLINE void DlistL<T>::detach(const T* pItem)
{
    DlinkB* link = last;
    while (link) {
        if (((DlinkL<T>*)link->getNext())->getItem() == pItem) {
            DlinkL<T>* lnk = (DlinkL<T>*)detachNext(link);
            fassert(lnk->getItem() == pItem,
                    msg("detach inconsistent"));
            delete lnk;
            return;
        }
        link = link->getNext();
        if (link == last) {
            break;
        }
    }
    fatal(msg("Item not found in list"));
}

template<class T> TMPL_INLINE bool DlistL<T>::hasItem(const T* item) const
{
    DlistLI<T> ii(this);
    while (T* i = ii++) {
        if (i == item) {
            return true;
        }
    }
    return false;
}

template<class T> TMPL_INLINE T* DlistL<T>::detachFirst()
{
    DlinkL<T>* lnk = (DlinkL<T>*) DlistB::detachFirst();
    if (lnk) {
        T* item = lnk->getItem();
        delete lnk;
        return item;
    }
    else {
        // List was already empty.  Allow it.
        return NULL;
    }
}

//------------------------------------------------------------------------------
// SlistM<T> member functions

template<class T> TMPL_INLINE bool SlistM<T>::split(
    void* holder, int count, void (*appendFun)(void*, SlistM<T>&))
{
    if (!last) {
        return false;
    }
    bool didSplit = false;
    int numItems = 0;
    SlinkB* link = last->getNext();
    SlinkB* currentFirst = link;
    while (link != last) {
        SlinkB* nextLink = link->getNext();
        numItems++;
        if (numItems == count) {
            didSplit = true;
            numItems = 0;
            link->linkTo(currentFirst);
            currentFirst = nextLink;
            last->linkTo(currentFirst);
            SlistM<T> newL;
            newL.last = link;
            appendFun(holder, newL);
        }
        link = nextLink;
    }
    if (didSplit) {
        if (!isEmpty()) {
            appendFun(holder, *this);
        }
    }
    return didSplit;
}

template<class T> TMPL_INLINE void SlistM<T>::steal(SlistM<T>& list)
{
    // Snatch the list pointed to by the argument:
    // copy the last pointer and set it to NULL on
    // argument.
    fassert(!last, msg("stealing into non-empty list; use merge"));
    last = list.getLast();
    list.flush();
}

template<class T> TMPL_INLINE void SlistM<T>::merge(SlistM<T>& list)
{
    // Merge the list pointed to by the argument into self
    // and flush the argument.
    if (list.last) {
        if (last) {
            SlinkB* next = last->getNext();
            last->linkTo(list.last->getNext());
            list.last->linkTo(next);
        }
        last = list.last;
        list.flush();
    }
}

template<class T> TMPL_INLINE void SlistM<T>::detach(const T* pItem)
{
    SlinkB* link = last;
    while (link) {
        if (((T*)link->getNext()) == pItem) {
            SlinkB* lnk = NULL;
            lnk = detachNext(link);
            fassert((T*)lnk == pItem,
                    msg("detach inconsistent"));
            return;
        }
        link = link->getNext();
        if (link == last) {
            break;
        }
    }
    fatal(msg("Item not found in list"));
}

template<class T> TMPL_INLINE bool SlistM<T>::hasItem(const T* item) const
{
    SlistMI<T> ii(this);
    while (T* i = ii++) {
        if (i == item) {
            return true;
        }
    }
    return false;
}

//------------------------------------------------------------------------------
// DlistM<T> member functions

template<class T> TMPL_INLINE bool DlistM<T>::split(
    void* holder, int count, void (*appendFun)(void*, DlistM<T>&))
{
    if (!last) {
        return false;
    }
    bool didSplit = false;
    int numItems = 0;
    DlinkB* link = last->getNext();
    DlinkB* currentFirst = link;
    while (link != last) {
        DlinkB* nextLink = link->getNext();
        numItems++;
        if (numItems == count) {
            didSplit = true;
            numItems = 0;
            link->linkTo(currentFirst);
            currentFirst = nextLink;
            last->linkTo(currentFirst);
            DlistM<T> newL;
            newL.last = link;
            appendFun(holder, newL);
        }
        link = nextLink;
    }
    if (didSplit) {
        if (!isEmpty()) {
            appendFun(holder, *this);
        }
    }
    return didSplit;
}

template<class T> TMPL_INLINE void DlistM<T>::steal(DlistM<T>& list)
{
    // Snatch the list pointed to by the argument:
    // copy the last pointer and set it to NULL on
    // argument.
    fassert(!last, msg("stealing into non-empty list; use merge"));
    last = list.getLast();
    list.flush();
}

template<class T> TMPL_INLINE void DlistM<T>::merge(DlistM<T>& list)
{
    // Merge the list pointed to by the argument into self
    // and flush the argument.
    if (list.last) {
        if (last) {
            DlinkB* next = last->getNext();
            last->linkTo(list.last->getNext());
            list.last->linkTo(next);
        }
        last = list.last;
        list.flush();
    }
}

template<class T> TMPL_INLINE bool DlistM<T>::hasItem(const T* item) const
{
    DlistMI<T> ii(this);
    while (T* i = ii++) {
        if (i == item) {
            return true;
        }
    }
    return false;
}

template<class T> TMPL_INLINE T*  SlistLI<T>::giveNextItem(const T* item)
{
    T* t;
    SlistLI<T>& listI = *this;

    while (item && (listI.peek() == (const T*)item)) { // Avoid duplicates
        listI++;
    }
    if (!item) {
        t = listI();
    } else {
        while ((t = listI++)) {
            if (t == (const T*)item) break;
        }

        if (t) {
            t = listI(); // Next item
        }
    }
    return(t);
}

template<class T> TMPL_INLINE T*  SlistLI<T>::giveNextItem(
    const T* item, uint& itemNo)
{
    T* t;
    SlistLI<T>& listI = *this;

    itemNo = 1;
    if (!item) {
        return(listI());
    }
    while ((t = listI++)) {
        if (t == item) {
            break;
        }
        itemNo++;
    }

    if (t) {
        t = listI(); // Next item
        itemNo++;
    }
    return(t);
}

template<class T> TMPL_INLINE T*  SlistMI<T>::giveNextItem(const T* item)
{
    T* t;
    SlistMI<T>& listI = *this;

    if (!item) {
        return(listI());
    }
    while ((t = listI++)) {
        if (t == item) {
            break;
        }
    }

    if (t) {
        t = listI(); // Next item
    }
    return(t);
}

template<class T> TMPL_INLINE T*  SlistMI<T>::giveNextItem(
    const T* item, uint& itemNo)
{
    T* t;
    SlistMI<T>& listI = *this;

    itemNo = 1;
    if (!item) {
        return(listI());
    }
    while ((t = listI++)) {
        if (t == item) {
            break;
        }
        itemNo++;
    }
    if (t) {
        t = listI(); // Next item
        itemNo++;
    }
    return(t);
}

template<class T> TMPL_INLINE T*  DlistMI<T>::giveNextItem(const T* item)
{
    T* t;
    DlistMI<T>& listI = *this;

    while (item && (listI.peek() == (const T*)item)) { // Avoid duplicates
        listI++;
    }
    if (!item) {
        t = listI();
    } else {
        while ((t = listI++)) {
            if (t == item) {
                break;
            }
        }

        if (t) {
            t = listI(); // Next item
        }
    }
    return(t);
}

template<class T> TMPL_INLINE T*  DlistMI<T>::giveNextItem(
    const T* item, uint& itemNo)
{
    T* t;
    DlistMI<T>& listI = *this;

    itemNo = 1;
    if (!item) {
        return(listI());
    }
    while ((t = listI++)) {
        if (t == item) {
            break;
        }
        itemNo++;
    }
    if (t) {
        t = listI(); // Next item
        itemNo++;
    }
    return(t);
}

/// This function detaches the item at position n in this list.
/// \todo What happens if the list has less than n items?
template<class T> TMPL_INLINE T* SlistL<T>::detachNth(int n)
{
    if (n == 0) {
        return detachFirst();
    }
    SlistLI<T> ti(*this);
    for (int i = 0; i < (n - 1); i++) {
        ti++;
    }
    nullcheck(ti.peek());
    return ti.detachNext(*this);
}


template<class T> TMPL_INLINE size_t SlistL<T>::getMemSizeOf() const
{
    return countItems() * sizeof(SlinkL<T>);
}

template<class T> TMPL_INLINE size_t DlistL<T>::getMemSizeOf() const
{
    return countItems() * sizeof(DlinkL<T>);
}

# 1444 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh" 2
#endif  // INLINE_TMPL
# 1445 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh"

#endif // _LIST_HH_
# 1447 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/list.hh"
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "pair.hh"
#endif /* expanded by -frewrite-includes */
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pair.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

#ifndef _PAIR_HH_
#define _PAIR_HH_

template <class K, class V> class Pair1
{
public:
    Pair1(K* k, V* v) {
        Key = k;
        Value = v;
    }
    Pair1() {
        Key = NULL;
        Value = NULL;
    }
    ~Pair1() {}
    K* getKey() const { return Key; }
    V* getValue() const { return Value; }
    void setKey(K* k) { Key = k; }
    void setValue(V* v) { Value = v; }
    lifeGuardNewAndDeleteMacro
private:
    K* Key;
    V* Value;
};

template <typename K, typename V> class ValuePair
{
public:
    ValuePair(K k, V v) : Key( k ), Value( v ) {}
    ~ValuePair() {}
    K getKey() const { return Key; }
    V getValue() const { return Value; }
    void setKey(K k) { Key = k; }
    void setValue(V v) { Value = v; }
    void incrementValue() { Value++; }
private:
    K Key;
    V Value;
};


template <class K, class V> class Pair2
{
public:
    Pair2(K k, V v) {
        Key = k;
        Value = v;
    }
    Pair2() {
        Key = NULL;
        Value = NULL;
    }
    ~Pair2() {}
    K getKey() const { return Key; }
    V getValue() const { return Value; }
    void setKey(K k) { Key = k; }
    void setValue(V v) { Value = v; }
    lifeGuardNewAndDeleteMacro
private:
    K Key;
    V Value;
};
#endif //_PAIR_HH_
# 70 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/pair.hh"
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "hash.hh"
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

// Copyright (C) 1995-1997 Radiant Design Tools.  All Rights Reserved.
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

#ifndef _HASH_HH_
#define _HASH_HH_

/// @file hash.hh
/// This file defines the interface for hash tables. The hash tables
/// are template classes for tables with chaining, where a key is used
/// to hash to a list, and perform a linear search therein.  We have
/// the following kinds:
///
/// - HashTableL: non-intrusive lists with fixed hash function,
/// - HashTableM: intrusive lists with fixed hash function,
/// - HashTableP: non-intrusive lists with variable hash function.
/// - HashTableQ: intrusive lists with variable hash function.
/// - HashTableKeyL: non-intrusive lists with key and variable hash function,
/// - HashTableKeyM: intrusive lists with key and variable hash function.
///
/// All these tables are derived from a common HashTableBase that
/// provide the common attributes and functionality for all the above.
///
/// The main operations are lookup, append, and detach. There are
/// variants of append and detach that can be given the computed hash
/// index returned by a prior lookup, in order to avoid recomputing it.
///
/// Iterator classes.  Each hash table class has two iterators:
/// - HashTableXLI iterates over the list array, so it returns a list,
/// - HashTableXI iterates over all items.

#if 0 /* expanded by -frewrite-includes */
#include <stdlib.h>
#endif /* expanded by -frewrite-includes */
# 39 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 40 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
#if 0 /* expanded by -frewrite-includes */
#include <string.h>
#endif /* expanded by -frewrite-includes */
# 40 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 41 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
#if 0 /* expanded by -frewrite-includes */
#include "basictypes.hh"
#endif /* expanded by -frewrite-includes */
# 41 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh" 1
//=====================================================================
// Copyright (C) 1997-1998 Synopsys Inc. All Rights Reserved.
//
// $RCSfile: basictypes.hh,v $
//=====================================================================
#ifndef _BASICTYPES_HH_
#define _BASICTYPES_HH_

// #ident "$Id$ $Author$ $DateTime$"

#if 0 /* expanded by -frewrite-includes */
#include <sys/types.h>
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#if 0 /* expanded by -frewrite-includes */
#include <strings.h>
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#if 0 /* expanded by -frewrite-includes */
#include "../../../../system/typedef64.h"
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

//--------------------------------------------------------------------
// First we define some macros of the form __SUPPORTS_xyz__ based
// on the platform/compiler.
//--------------------------------------------------------------------

#ifndef __SUPPORTS_UINT__
#   if defined(__sun) && defined(__SVR4) // Solaris 2.x
#   define __SUPPORTS_UINT__
#   endif
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 26 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_UNCHAR__
#   if defined(__sun) && defined(__SVR4) // Solaris 2.x
#   define __SUPPORTS_UNCHAR__
#   endif
# 31 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 32 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_BOOL__
#   if (defined(__GNUC__)) || \
       (defined(WIN32)) || \
       (defined(__alpha) && defined(__DECCXX_VER) && \
    ((__DECCXX_VER >= 60000000) || defined(_BOOL_EXISTS))) || \
       (defined(_BOOL)) || \
       (defined(_AIX43) && (__IBMCPP__ >= 500))
#   define __SUPPORTS_BOOL__
#   endif
# 42 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 43 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

//--------------------------------------------------------------------
// Now we define stuff based on the __SUPPORTS_xyz__'s defined earlier
//--------------------------------------------------------------------

#ifndef __SUPPORTS_UINT__
typedef unsigned int uint;
#endif
# 51 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_UNCHAR__
typedef unsigned char unchar;
#endif
# 55 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef __SUPPORTS_BOOL__
typedef unsigned char bool;
const bool true = 1;
const bool false = 0;
#   if (defined(__alpha) && defined(__DECCXX_VER) && !defined(_BOOL_EXISTS))
#    define _BOOL_EXISTS
#   endif
# 63 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   if (defined(__sgi) && !defined(_BOOL))
#    define _BOOL
#   endif
# 66 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif
# 67 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"


// Here we define the prototypes of some functions that are
// missing from the standard header files on some platforms.
// Since basictypes.hh is included almost everywhere, it seemed
// the right place to define these (I didn't want to create
// another header file for this stupid stuff).

#if defined(__sun) && !defined(__SVR4) // SunOS 4.1.x
extern "C" void* sbrk(int incr);
extern "C" int strcasecmp(const char* s1, const char* s2);
extern "C" int strncasecmp(const char* s1, const char* s2, int n);
extern "C" int gettimeofday(struct timeval* tp, void*);
#endif // __sun && !__SVR4
# 81 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#if defined(WIN32)
extern "C" void* sbrk(int incr);
extern "C" int gethostid();
#   define strcasecmp stricmp
#   define strncasecmp strnicmp
/*mkdir(<path, accessmode> is not available on NT, so its usage generates compilation error*/
#if 0 /* expanded by -frewrite-includes */
#   include <direct.h>
#endif /* expanded by -frewrite-includes */
# 88 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 89 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   define mkdir(x, y) _mkdir(x)
#   pragma warning(disable:4291)
#   define YY_NEVER_INTERACTIVE 1 /* Needed for .ll files */
#   define MSDOS /* Needed for .yy files */
#   define ftruncate _chsize
#   ifndef PATH_MAX
#   define PATH_MAX 1024
#   endif
# 97 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#   define S_IRWXU  (S_IREAD | S_IWRITE | S_IEXEC)
#   ifdef _INC_MATH /* when math.h is included */
/* asinh, acosh, atanh are not defined in NT headers */
#   define asinh(x) log((x) + sqrt((x)*(x) + 1))
#   define acosh(x) log((x) - sqrt((x)*(x) - 1))
#   define atanh(x) log((1 + (x)) / (1 - (x))) / 2
#   endif /* _INC_MATH */
# 104 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif // WIN32
# 105 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#ifndef VCS_EXIT
extern "C" {
    extern void VCS_EXIT(int);
}
#endif
# 111 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

#endif // _BASICTYPES_HH_
# 113 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"

// We always include this part on the spot, even if it causes multiple
// inclusions.  This is because some other include files define NULL
// to be (void*) 0.  g++ wants it to be plain 0.

#ifdef  __GNUC__
#   ifdef NULL
#   undef NULL
#   define NULL 0
#   endif
# 123 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
#endif // __GNUC__
# 124 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/basictypes.hh"
# 42 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "list.hh"
#endif /* expanded by -frewrite-includes */
# 42 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 43 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
#if 0 /* expanded by -frewrite-includes */
#include "pool.hh"
#endif /* expanded by -frewrite-includes */
# 43 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 44 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
#if 0 /* expanded by -frewrite-includes */
#include "hashbase.hh"
#endif /* expanded by -frewrite-includes */
# 44 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hashbase.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

#ifndef HASHBASE_HH_
#define HASHBASE_HH_

/// @file
/// This file defines the HashTableBase class, which is used by all
/// template hash tables. It deals with the table sizes, not with the
/// specific table details. This is extracted out of the template
/// tables to reduce code bloat.

///
/// This is the base class for hash tables with chaining.
///
/// The hash tables are implemented as an array of linked lists. This
/// class contains the attributes common to all tables that are
/// independent ot the array and lists. It is a class with protected
/// constructor, so it can not be directly instantiated. We are careful
/// not to have virtual functions, to avoid adding a virtual table to
/// the derived classes.
class HashTableBase
{
public:
    /// This function is used to choose a well behaved size that
    /// is at least as large as the given one.
    static int  getBetterSize(int sz);

    /// This is a hash function suitable for a null terminated
    /// string.
    static uint hash(const char* s, uint seed = 0);

    /// This is a hash function suitable for hashing unsigned ints.
    static uint hash(uint n, uint seed = 0);

    /// This is a hash function suitable for hashing pointers
    static uint     hash(const void* n, uint seed = 0);

    /// This function returns true if the table is empty.
    bool        isEmpty() const     { return entries == 0; }

    /// This function returns true if the table has a single item.
    bool        hasOneItem() const  { return entries == 1; }

    /// This function returns the number of entries in the table in
    /// constant time (no counting).
    int     getNumEntries() const   { return entries; }

    /// This gets the size of the table.
    /// @note This is not the same as the number of entries, but
    /// the number of buckets.
    int     getSize() const     { return size; }

    //--------------------------------------------------------------
    //  Some default hash/eq functions.

    template<typename T>
    static bool defaultPtrEq(const T *p1, const T *p2)
    {
        return (p1 == p2);
    }

    template<typename T>
    static uint defaultPtrHash(const T *p)
    {
        return hash((const void *)p);
    }

private:
    enum {
        DefaultSizeIndex    = 0,
        NumSizes        = 32,
        LargestSizeIndex        = VCS_64CCMODE ? 31:24
    };

    /// This is an array of prime numbers close to powers of two
    /// used to size tables due to their behavior viz a viz integer
    /// division.
    static int  sizes[NumSizes];

protected:
    /// This is used when a new item is added to the table.
    void        incrEntries()       { entries++; }

    /// This is used when an item is detached from the table.
    void        decrEntries()       { entries--; }

    /// This returns true if the table should be grown, based on
    /// its size and number of entries.
    bool        mustGrow() const;

    /// This function sets the size to the next larger size,
    /// roughly doubling the table size.
    void        growSize();

    /// This function converts a hash number to an index into the
    /// array.
    int     hashToIndex(uint hashVal) const {
        return hashVal % getSize();
    }

    /// This is used to copy the size and entries from another
    /// table, used when such table is stolen.
    /// @param ht the table to be stolen
    void        copyBaseAttributes(const HashTableBase& ht) {
        size = ht.size;
        entries = ht.entries;
    }

    /// This is called to finish stealing a table, in order to
    /// completely clear it.
    void        flush() {
        size = 0;
        entries = 0;
    }

    /// This is called to complete removing all entries in the table.
    void        flushEntries()      { entries = 0; }

    /// Auxiliary class holding data for stats.
    class StatsInfo
    {
    public:
        StatsInfo(const char* name)
            : name_(name)
            , maxCount_(0)
            , maxIndex_(0)
            , totalCompares_(0)
            , memSize_(0)
        {
            for (int bin = 0; bin <= LastEntry_; bin++) {
                entryBin_[bin] = 0;
            }
        }
        void            incrMemSize(int incr) {
            memSize_ += incr;
        }
        void            update(int index, int count)
        {
            if (count > maxCount_) {
                maxCount_ = count;
                maxIndex_ = index;
            }
            entryBin_[(count < LastEntry_)? count : LastEntry_]++;
            totalCompares_ += (count * (count + 1)) / 2;
        }
        const char*     getName() const         { return name_; }
        int             getMaxCount() const     { return maxCount_; }
        int             getMaxIndex() const     { return maxIndex_; }
        int             getLastEntry() const    { return LastEntry_; }
        int             getCompareCount() const {
            return totalCompares_;
        }
        int             getMemSize() const      { return memSize_; }
        int             getBinCount(int i) const {
            fassert((i >= 0) && (i <= LastEntry_),
                    msg("StatsInfo::getBinCount index out of "
                        "bounds %d", i));
            return entryBin_[i];
        }
    private:
        const char*     name_;
        int             maxCount_;
        int             maxIndex_;
        int             totalCompares_;
        int             memSize_;
        enum {          LastEntry_ = 20 };
        int     entryBin_[LastEntry_ + 1];
    };

    /// This is called to print the statistics for an empty table.
    void            showEmptyStats(const char* name) const;

    /// This is called to print the statistics for a non-empty table.
    void            showTableStats(const StatsInfo& info) const;

    /// This constructor sets the initial size of the table to be
    /// at least as large as the given one.
    /// @param sz the initial size
    HashTableBase(int sz) :
        entries(0),
        size(getBetterSize(sz))
    {}

    /// This constructor initializes the size of the table to one.
    HashTableBase() :
        entries(0),
        size(sizes[DefaultSizeIndex])
    {}

    /// The destructor has nothing to do.
    ~HashTableBase() {}

private:
    /// This internal function returns the largest possible table
    /// size.
    static int  getLargestSize() {
        return sizes[LargestSizeIndex];
    }

    /// The number of items in the table. It is updated on each
    /// append or detach.
    int     entries;

    /// The size of the array of linked lists.
    int     size;
};

#endif // HASHBASE_HH_
# 213 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hashbase.hh"
# 45 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh" 2

/*
 * internal::unlinked::HashTableX and ::HashTableX
 * have the same leaf name 'HashTableX', which confuses AIX c++ compiler xlC.
 
typedef IVector <int> IntV;
typedef ValuePair<int, IntV*> PairIntVint;
typedef HashTableP<PairIntVint> IntVintHash;
typedef ValuePair<const void*, IntVintHash*> PairVoidL2Hash;
typedef HashTableP<PairVoidL2Hash> VoidInt2LevHash;

 * Without following workaround, xlC complains
 * "Too many template arguments have been specified"
 * "class internal::unlinked::HashTableP<ValuePair<const void *,HashTableP<ValuePair<int,IVector<int> *>,0,1> *> >"
 *
 * Obviously, xlC interprets the second 'HashTableP' as 'internal::unlinked::HashTableP'.
 *
 * Actually, the second 'HashTable" shall be '::HashTableP', i.e.,
 * xlC shall deduce the following when seeing 'typedef HashTableP<PairVoidL2Hash> VoidInt2LevHash'
 * "class internal::unlinked::HashTableP<ValuePair<const void *,::HashTableP<ValuePair<int,IVector<int> *>,0,1> *> >"
 *
 * Although it's AIX specific issue, I'd like to rename internal names on LINUX/SOLARIS as well.
 */

// Assume HashTableX was not defined. Otherwise, compile error is a hint that the work around doesn't work.
#define HashTableL HashTableL_
#define HashTableM HashTableM_
#define HashTableP HashTableP_
#define HashTableQ HashTableQ_
#define HashTableKeyL HashTableKeyL_
#define HashTableKeyM HashTableKeyM_
#define HashTableLI HashTableLI_
#define HashTableMI HashTableMI_
#define HashTablePI HashTablePI_
#define HashTableQI HashTableQI_
#define HashTableKeyLI HashTableKeyLI_
#define HashTableKeyMI HashTableKeyMI_

namespace internal
{
namespace unlinked
{
template<class T> class HashTableL;
template<class T> class HashTableM;
template<class T> class HashTableP;
template<class T> class HashTableQ;
template<typename K, class T> class HashTableKeyL;
template<typename K, class T> class HashTableKeyM;
template<class T> class HashTableLI;
template<class T> class HashTableMI;
template<class T> class HashTablePI;
template<class T> class HashTableQI;
template<typename K, class T> class HashTableKeyLI;
template<typename K, class T> class HashTableKeyMI;
template<class T> class HashTableLLI;
template<class T> class HashTableMLI;
template<class T> class HashTablePLI;
template<class T> class HashTableQLI;
template<typename K, class T> class HashTableKeyLLI;
template<typename K, class T> class HashTableKeyMLI;

template <typename T, class Impl>
class LocalIterator
{
private:
    Impl impl_;
public:
    T *operator++(int) // post-increment
    {
        return impl_++;
    }
    T *operator++() // pre-increment
    {
        return ++impl_;
    }
    T *operator()() const // dereference
    {
        return impl_();
    }
public:
    LocalIterator() { }
    // Since implementation may change in futrue,
    // hash table clients should not directly use this constructor.
    // Instead, use HashTableX::lookupI to get local iterator.
    explicit LocalIterator(const Impl &impl) : impl_(impl)
    {
    }
};

//------------------------------------------------------------------------------

/// This is a Template Hash Table with non-intrusive lists and fixed
/// hash function.  The classes are required to have a const char*
/// getName() member function.
template<class T> class HashTableL : public HashTableBase
{
public:
    typedef LocalIterator<T, SlistLI<T> > local_iterator;

public:
    /// This constructor sets the initial size of the table to be
    /// at least as large as the given one.
    /// @param pSize the initial size
    HashTableL(int pSize);

    /// This constructor initializes the size of the table to one.
    HashTableL();

    /// The destructor needs to delete the table.
    /// @attention It will be a fatal assertion if the table is
    /// not empty.
    ~HashTableL();
    lifeGuardNewAndDeleteMacro

    /// This lookup function will return any item whose name is the
    /// given one, or NULL if none is found, and it also returns the
    /// @p index into the table.
    T*      lookup(const char* pName, int& index) const;

    /// This lookup function will return any item whose name is the
    /// given one, or NULL if none is found. It is like the one
    /// above but does not deal with the index. Use it if not
    /// interested in a subsequent append.
    /// @param[in] pName the name to lookup
    /// @return the item if found or NULL
    T*      lookup(const char* pName) const {
        int index;
        return lookup(pName, index);
    }

    /// This lookup function returns an iterator pointing at the
    /// list that would contain an item with the given @p pName.
    local_iterator lookupI(const char* pName, int& index) const;

    /// This lookup function is like the one above except it does
    /// not return the index.
    /// @param[in] pName the name to search for
    /// @return a list iterator to the list that may contain the item
    /// @see local_iterator lookupI(const char*, int&) const
    local_iterator lookupI(const char* pName) const {
        int index;
        return lookupI(pName, index);
    }

    /// This function appends an @p item given the @p index.
    void        append(T* item, int index);

    /// This function appends an @p item with no index given. The
    /// list is picked by computing the hash value.
    /// @param item the item to append
    void        append(T* item) {
        append(item, hashToIndex(hash(item->getName())));
    }

    /// This function detaches @p item from hash table given the
    /// @p index.
    T*      detach(T* item, int index);

    /// This function detaches @p item from hash table.
    /// @param[in] item the item to detach
    /// @pre The item must be found or a fatal assertion is triggered.
    T*      detach(T* item) {
        return detach(item, hashToIndex(hash(item->getName())));
    }

    /// This function detaches the item pointed by @p iter and
    /// advances @p iter to the item immediately following
    /// the one being detached. If no such item exists, the target of
    /// @p iter is NULL after the function returns.
    /// It returns the item being detached.
    T *detachAt(HashTableLI<T> &iter);

    /// This function detaches all items in the hash table.
    void        detachItems();

    /// This function deletes all items in the hash table.
    void        deleteItems();

    /// This function steals the complete array of lists of
    /// another hash table @p ht.
    void        steal(HashTableL<T>& ht);

    /// This function shows all items in the table.
    void        show() const;

    /// This function shows interesting metrics in the table.
    /// @param[in] name the name to be used for this table in the
    /// report
    void        showStats(const char* name) const;

    // This function returns the memory used by table not 
    // inlcuding the size of the entries. This does not 
    // include the size of the HashTableL<T> class itself.
    size_t      getMemSizeOf() const;

private:
    /// This function blindly empties the table. To be used on a
    /// table that has been previously stolen.
    /// @attention Beware the array and all lists are not deleted,
    /// since they were stolen.
    void        flush() {
        array = NULL;
        HashTableBase::flush();
    }

    friend class    HashTableLLI<T>;

    /// This function is called internally when the table is found
    /// to be getting too populated.
    void        growTable();

    /// The array of SlistL<T>s.
    SlistL<T>*  array;
};

/// This is a Template Hash Table with intrusive lists and fixed
/// hash function.  The class T of the items is required to have a
/// const char* getName() member function, and to derive from SlinkB.
/// @see template<class T> class HashTableL as most of the behavior is
/// the same, except for the intrusive pointer in the individual
/// items.
template<class T> class HashTableM : public HashTableBase
{
public:
    typedef LocalIterator<T, SlistMI<T> > local_iterator;

public:
    /// This constructor sets the initial size of the table to be
    /// at least as large as the given one.
    /// @param pSize the initial size
    HashTableM(int pSize);

    /// This constructor initializes the size of the table to one.
    HashTableM();

    /// The destructor needs to delete the table.
    /// @attention It will be a fatal assertion if the table is
    /// not empty.
    ~HashTableM();
    lifeGuardNewAndDeleteMacro

    /// This lookup function will return any item whose name is the
    /// given one, or NULL if none is found, and it also returns the
    /// @p index into the table.
    T*      lookup(const char* pName, int& index) const;

    /// This lookup function will return any item whose name is the
    /// given one, or NULL if none is found. It is like the one
    /// above but does not deal with the index. Use it if not
    /// interested in a subsequent append.
    /// @param[in] pName the name to lookup
    /// @return the item if found or NULL
    T*      lookup(const char* pName) const {
        int index;
        return lookup(pName, index);
    }
    /// This lookup function returns an iterator pointing at the
    /// list that would contain an item with the given @p pName.
    local_iterator lookupI(const char* pName, int& index) const;

    /// This lookup function is like the one above except it does
    /// not return the index.
    /// @param[in] pName the name to search for
    /// @return a list iterator to the list that may contain the item
    /// @see local_iterator lookupI(const char*, int&) const
    local_iterator lookupI(const char* pName) const {
        int index;
        return lookupI(pName, index);
    }

    /// This function appends an @p item given the @p index.
    void        append(T* item, int index);

    /// This function appends an @p item with no index given. The
    /// list is picked by computing the hash value.
    /// @param item the item to append
    void        append(T* item) {
        append(item, hashToIndex(hash(item->getName())));
    }

    /// This function detaches @p item from hash table given the
    /// @p index.
    T*      detach(T* item, int index);

    /// This function detaches @p item from hash table.
    /// @param item the item to detach
    /// @pre The item must be found or a fatal assertion is triggered.
    T*      detach(T* item) {
        return detach(item, hashToIndex(hash(item->getName())));
    }

    /// This function detaches the item pointed by @p iter and
    /// advances @p iter to the item immediately following
    /// the one being detached. If no such item exists, the target of
    /// @p iter is NULL after the function returns.
    /// It returns the item being detached.
    T *detachAt(HashTableMI<T> &iter);

    /// This function detaches all items in the hash table.
    void        detachItems();

    /// This function deletes all items in the hash table.
    void        deleteItems();

    /// This function steals the complete array of lists of
    /// another hash table @p ht.
    void        steal(HashTableM<T>& ht);

    /// This function shows all items in the table.
    void        show() const;

    /// This function shows interesting metrics in the table.
    /// @param[in] name the name to be used for this table in the
    /// report
    void        showStats(const char* name) const;

private:
    /// This function blindly empties the table. To be used on a
    /// table that has been previously stolen.
    /// @attention Beware the array and all lists are not deleted,
    /// since they were stolen.
    void        flush() {
        array = NULL;
        HashTableBase::flush();
    }

    friend class    HashTableMLI<T>;

    /// This function is called internally when the table is found
    /// to be getting too populated.
    void        growTable();

    /// The array of SlistL<T>s.
    SlistM<T>*  array;
};

/// This is a Template Hash Table with non-intrusive lists.  There are
/// no requirements on the class of the items, since the function to
/// compute a hash index and to compare items as the list is traversed
/// is supplied in the constructor.
/// @see template<class T> class HashTableL as most of the behavior is
/// the same, except for using the user supplied hash and compare
/// functions when accessing the table.
template<class T> class HashTableP : public HashTableBase
{
public:
    typedef LocalIterator<T, SlistLI<T> > local_iterator;

public:
    /// This constructor sets the initial size of the table to be
    /// at least as large as the given one.
    HashTableP(
        uint        (*pHashFun)(const T*),
        bool        (*pEqFun)(const T*, const T*),
        int     pSize);
    /// This constructor sets the initial size of the table to one.
    HashTableP(
        uint        (*pHashFun)(const T*),
        bool        (*pEqFun)(const T*, const T*));
    /// This constructor is needed for serialization.
    HashTableP();

    /// The destructor needs to delete the table.
    /// @attention It will be a fatal assertion if the table is
    /// not empty.
    ~HashTableP();
    lifeGuardNewAndDeleteMacro

    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found, and it also returns the
    /// @p index into the table.
    T*      lookup(const T* item, int& index) const;
    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found. It is like the one
    /// above but does not deal with the index. Use it if not
    /// interested in a subsequent append.
    /// @param[in] item the item to lookup (the key is in the item)
    /// @return the item if found or NULL
    T*      lookup(const T* item) const {
        int index;
        return lookup(item, index);
    }
    /// This lookup function returns an iterator pointing at the
    /// list that would contain the given @p item.
    local_iterator lookupI(const T* item, int& index) const;

    /// This lookup function is like the one above except it does
    /// not return the index.
    /// @param[in] item the item to search for
    /// @return a list iterator to the list that may contain the item
    /// @see local_iterator lookupI(const char*, int&) const
    local_iterator lookupI(const T* item) const {
        int index;
        return lookupI(item, index);
    }

    /// This function appends an @p item given the @p index.
    void        append(T* item, int index);

    /// This function appends an @p item with no index given. The
    /// list is picked by computing the hash value.
    /// @param item the item to append
    void        append(T* item) {
        append(item, hashToIndex((*hashFun)(item)));
    }

    /// This function detaches @p item from hash table given the
    /// @p index.
    T*      detach(T* item, int index);

    /// This function detaches @p item from hash table.
    /// @param[in] item the item to detach
    /// @pre The item must be found or a fatal assertion is triggered.
    T*      detach(T* item) {
        return detach(item, hashToIndex((*hashFun)(item)));
    }

    /// This function detaches the item pointed by @p iter and
    /// advances @p iter to the item immediately following
    /// the one being detached. If no such item exists, the target of
    /// @p iter is NULL after the function returns.
    /// It returns the item being detached.
    T *detachAt(HashTablePI<T> &iter);

    /// @attention Each invocation needs to find the first non-empty bucket.
    T *detachFirst();

    /// This function detaches all items in the hash table.
    void        detachItems();

    /// This function deletes all items in the hash table.
    void        deleteItems();

    /// This function steals the complete array of lists of
    /// another hash table @p ht.
    void        steal(HashTableP<T>& ht);

    /// This function shows all items in the table.
    void        show() const;

    /// This function shows interesting metrics in the table.
    /// @param[in] name the name to be used for this table in the
    /// report
    void        showStats(const char* name) const;

    // This function returns the memory used by table not
    // inlcuding the size of the entries. This does not
    // include the size of the HashTableP<T> class itself.
    size_t      getMemSizeOf() const;

private:
    /// This function blindly empties the table. To be used on a
    /// table that has been previously stolen.
    /// @attention Beware the array and all lists are not deleted,
    /// since they were stolen.
    void        flush() {
        array = NULL;
        HashTableBase::flush();
    }

    friend class    HashTablePLI<T>;

    /// This function is called internally when the table is found
    /// to be getting too populated.
    void        growTable();

    /// The array of SlistL<T>s.
    SlistL<T>*  array;

    /// The function used for hashing.
    uint        (*hashFun)(const T*);

    /// The function used for comparing.
    bool        (*eqFun)(const T*, const T*);
};

/// This is a Template Hash Table with intrusive lists.  The items
/// must be derived from SlinkB, but otherwise there are no
/// requirements on them, since the function to compute a hash index
/// and to compare items as the list is traversed is supplied in the
/// constructor.
/// @see template<class T> class HashTableL as most of the behavior is
/// the same, except for using the user supplied hash and compare
/// functions when accessing the table.
template<class T> class HashTableQ : public HashTableBase
{
public:
    typedef LocalIterator<T, SlistMI<T> > local_iterator;

public:
    HashTableQ(
        uint        (*pHashFun)(const T*),
        bool        (*pEqFun)(const T*, const T*),
        int     pSize);
    HashTableQ(
        uint        (*pHashFun)(const T*),
        bool        (*pEqFun)(const T*, const T*));
    /// This constructor is needed for serialization.
    HashTableQ();

    ~HashTableQ();
    lifeGuardNewAndDeleteMacro

    // Lookup returns the item or NULL if it is not found.
    // It also returns the index into the table, to avoid
    // hashing again for the insertion.
    T*      lookup(const T* item, int& index) const;
    T*      lookup(const T* item) const {
        int index;
        return lookup(item, index);
    }
    // This is for lookups: returns an iterator pointing at the
    // list that would contain the item.  This is to handle hash
    // tables where we can append multiple items with the same
    // key.
    local_iterator lookupI(const T* item, int& index) const;
    local_iterator lookupI(const T* item) const {
        int index;
        return lookupI(item, index);
    }

    /// This function appends an @p item given the @p index.
    void        append(T* item, int index);
    // Append item with no index given.  Must be hashed.
    void        append(T* item) {
        append(item, hashToIndex((*hashFun)(item)));
    }
    /// This function detaches @p item from hash table given the
    /// @p index.
    T*      detach(T* item, int index);

    /// This function detaches @p item from hash table.
    /// @param[in] item the item to detach
    /// @pre The item must be found or a fatal assertion is triggered.
    T*      detach(T* item) {
        return detach(item, hashToIndex((*hashFun)(item)));
    }

    /// This function detaches the item pointed by @p iter and
    /// advances @p iter to the item immediately following
    /// the one being detached. If no such item exists, the target of
    /// @p iter is NULL after the function returns.
    /// It returns the item being detached.
    T *detachAt(HashTableQI<T> &iter);

    /// This function detaches all items in the hash table.
    void        detachItems();

    /// This function deletes all items in the hash table.
    void        deleteItems();

    /// This function steals the complete array of lists of
    /// another hash table @p ht.
    void        steal(HashTableQ<T>& ht);

    /// This function shows all items in the table.
    void        show() const;

    /// This function shows interesting metrics in the table.
    /// @param[in] name the name to be used for this table in the
    /// report
    void        showStats(const char* name) const;

private:
    /// This function blindly empties the table. To be used on a
    /// table that has been previously stolen.
    /// @attention Beware the array and all lists are not deleted,
    /// since they were stolen.
    void        flush() {
        array = NULL;
        HashTableBase::flush();
    }

    friend class    HashTableQLI<T>;

    /// This function is called internally when the table is found
    /// to be getting too populated.
    void        growTable();

    /// The array of SlistM<T>s.
    SlistM<T>*  array;

    /// The function used for hashing.
    uint        (*hashFun)(const T*);

    /// The function used for comparing.
    bool        (*eqFun)(const T*, const T*);
};

/// This is a Template Hash Table with non-intrusive lists, separate
/// key, and variable hash function.  There are no requirements on the
/// class of the items, since the function to compute a hash index and
/// to compare items as the list is traversed is supplied in the
/// constructor. Three functions need to be supplied in the constructor:
/// - hashFunKey_ is used to compute the hash value from a key
///   object, and is used for lookups,
/// - hashFunItem_ is used to compute the hash value from an item, and is
///   used for inserting and detaching items,
/// - eqFun_ is used to compare a key and an item on a lookup.
///
/// @note the hash on key and hash on item functions must be compatible:
/// typically the item will contain the information in the key
/// embedded in them, so the resulting hash index must be identical.
///
/// @see template<class T> class HashTableL as most of
/// the behavior is the same, except for using the user supplied hash
/// and compare functions when accessing the table.
template<typename K, class T> class HashTableKeyL : public HashTableBase
{
public:
    typedef LocalIterator<T, SlistLI<T> > local_iterator;

public:
    /// This constructor sets the initial size of the table to be
    /// at least as large as the given one.
    HashTableKeyL(
        uint        (*pHashFunKey)(K),
        uint        (*pHashFunItem)(const T*),
        bool        (*pEqFun)(K, const T*),
        int     pSize);
    /// This constructor sets the initial size of the table to one.
    HashTableKeyL(
        uint        (*pHashFunKey)(K),
        uint        (*pHashFunItem)(const T*),
        bool        (*pEqFun)(K, const T*));
    /// This constructor is needed for serialization.
    HashTableKeyL();

    /// The destructor needs to delete the table.
    /// @attention It will be a fatal assertion if the table is
    /// not empty.
    ~HashTableKeyL();
    lifeGuardNewAndDeleteMacro

    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found, and it also returns the
    /// @p index into the table.
    T*              lookup(K key, int& index) const;

    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found. It is like the one
    /// above but does not deal with the index. Use it if not
    /// interested in a subsequent append.
    /// @param[in] key the key to lookup
    /// @return the item if found or NULL
    T*              lookup(K key) const {
        int index;
        return lookup(key, index);
    }
    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found, and it also returns the
    /// @p index into the table.
    T*              lookup(const T* item, int& index) const;
    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found. It is like the one
    /// above but does not deal with the index. Use it if not
    /// interested in a subsequent append.
    /// @param[in] item the item to lookup (the key is in the item)
    /// @return the item if found or NULL
    T*              lookup(const T* item) const {
        int index;
        return lookup(item, index);
    }
    /// This lookup function returns an iterator pointing at the
    /// list that would contain the given @p item.
    local_iterator lookupI(const T* item, int& index) const;

    /// This lookup function returns an iterator pointing at the
    /// list corresponding to the given @p key.
    local_iterator lookupI(K key, int& index) const;
    /// This lookup function is like the one above except it does
    /// not return the index.
    /// @param[in] key the key to search for
    /// @return a list iterator to the list that may contain the item
    /// @see local_iterator lookupI(const char*, int&) const
    local_iterator lookupI(K key) const {
        int index;
        return lookupI(key, index);
    }

    /// This function appends an @p item given the @p index.
    void        append(T* item, int index);

    /// This function appends an @p item with no index given. The
    /// list is picked by computing the hash value.
    /// @param item the item to append
    void        append(T* item) {
        append(item, hashToIndex((*hashFunItem_)(item)));
    }

    /// This function detaches @p item from hash table given the
    /// @p index.
    T*              detach(T* item, int index);

    /// This function detaches @p item from hash table.
    /// @param[in] item the item to detach
    /// @pre The item must be found or a fatal assertion is triggered.
    T*          detach(T* item) {
        return detach(item, hashToIndex((*hashFunItem_)(item)));
    }

    /// This function detaches the item pointed by @p iter and
    /// advances @p iter to the item immediately following
    /// the one being detached. If no such item exists, the target of
    /// @p iter is NULL after the function returns.
    /// It returns the item being detached.
    T *detachAt(HashTableKeyLI<K, T> &iter);

    /// This function detaches all items in the hash table.
    void        detachItems();

    /// This function deletes all items in the hash table.
    void        deleteItems();

    /// This function steals the complete array of lists of
    /// another hash table @p ht.
    void        steal(HashTableKeyL<K,T>& ht);

    /// This function shows all items in the table.
    void        show() const;

    /// This function shows interesting metrics in the table.
    /// @param[in] name the name to be used for this table in the
    /// report
    void        showStats(const char* name) const;

private:
    /// This function blindly empties the table. To be used on a
    /// table that has been previously stolen.
    /// @attention Beware the array and all lists are not deleted,
    /// since they were stolen.
    void        flush() {
        array_ = NULL;
        HashTableBase::flush();
    }

    friend class    HashTableKeyLLI<K,T>;

    /// This function is called internally when the table is found
    /// to be getting too populated.
    void        growTable();

    /// These functions are disabled.
    HashTableKeyL(const HashTableKeyL<K,T>&);
    HashTableKeyL<K,T>& operator = (const HashTableKeyL<K,T>&);

    /// The array of SlistL<T>s.
    SlistL<T>*          array_;

    /// The function used for hashing on Key, used for lookups.
    uint        (*hashFunKey_)(K);

    /// The function used for hashing on Item, used for inserting and
    /// detaching items.
    uint        (*hashFunItem_)(const T*);

    /// The function used for comparing.
    bool        (*eqFun_)(K, const T*);
};

/// This is a Template Hash Table with intrusive lists, separate key,
/// and variable hash function.  The items must be derived from
/// SlinkB, but otherwise there are no requirements on them, since the
/// functions to compute a hash index and to compare items as the list
/// is traversed is supplied in the constructor. Three functions need
/// to be supplied in the constructor:
///
/// - hashFunKey_ is used to compute the hash value from a key
///   object, and is used for lookups,
/// - hashFunItem_ is used to compute the hash value from an item, and is
///   used for inserting and detaching items,
/// - eqFun_ is used to compare a key and an item on a lookup.
///
/// @note the hash on key and hash on item functions must be compatible:
/// typically the item will contain the information in the key
/// embedded in them, so the resulting hash index must be identical.
///
/// @see template<class T> class HashTableL and
/// template<typename K, class T> class HashTableKeyL as most of
/// the behavior is the same, except for using SlistM instead of SlistL
/// for the buckets, which requires the objects to be derived from SlinkB.
template<typename K, class T> class HashTableKeyM : public HashTableBase
{
public:
    typedef LocalIterator<T, SlistMI<T> > local_iterator;

public:
    /// This constructor sets the initial size of the table to be
    /// at least as large as the given one.
    HashTableKeyM(
        uint        (*pHashFunKey)(const K&),
        uint        (*pHashFunItem)(const T*),
        bool        (*pEqFun)(const K&, const T*),
        int     pSize);
    /// This constructor sets the initial size of the table to one.
    HashTableKeyM(
        uint        (*pHashFunKey)(const K&),
        uint        (*pHashFunItem)(const T*),
        bool        (*pEqFun)(const K&, const T*));
    /// This constructor is needed for serialization.
    HashTableKeyM();

    /// The destructor needs to delete the table.
    /// @attention It will be a fatal assertion if the table is
    /// not empty.
    ~HashTableKeyM();
    lifeGuardNewAndDeleteMacro

    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found, and it also returns the
    /// @p index into the table.
    T*          lookup(const K& key, int& index) const;

    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found. It is like the one
    /// above but does not deal with the index. Use it if not
    /// interested in a subsequent append.
    /// @param[in] key the key to lookup
    /// @return the item if found or NULL
    T*              lookup(const K& key) const {
        int index;
        return lookup(key, index);
    }
    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found, and it also returns the
    /// @p index into the table.
    T*              lookup(const T* item, int& index) const;
    /// This lookup function will return any item matching the
    /// given one, or NULL if none is found. It is like the one
    /// above but does not deal with the index. Use it if not
    /// interested in a subsequent append.
    /// @param[in] item the item to lookup (the key is in the item)
    /// @return the item if found or NULL
    T*              lookup(const T* item) const {
        int index;
        return lookup(item, index);
    }
    /// This lookup function returns an iterator pointing at the
    /// list that would contain the given @p item.
    local_iterator lookupI(const K& key, int& index) const;
    /// This lookup function is like the one above except it does
    /// not return the index.
    /// @param[in] key the key to search for
    /// @return a list iterator to the list that may contain the item
    /// @see local_iterator lookupI(const char*, int&) const
    local_iterator lookupI(const K& key) const {
        int index;
        return lookupI(key, index);
    }

    /// This function appends an @p item given the @p index.
    void        append(T* item, int index);

    /// This function appends an @p item with no index given. The
    /// list is picked by computing the hash value.
    /// @param item the item to append
    void        append(T* item) {
        append(item, hashToIndex((*hashFunItem_)(item)));
    }

    /// This function detaches @p item from hash table given the
    /// @p index.
    T*              detach(T* item, int index);

    /// This function detaches @p item from hash table.
    /// @param[in] item the item to detach
    /// @pre The item must be found or a fatal assertion is triggered.
    T*              detach(T* item) {
        return detach(item, hashToIndex((*hashFunItem_)(item)));
    }

    /// This function detaches the item pointed by @p iter and
    /// advances @p iter to the item immediately following
    /// the one being detached. If no such item exists, the target of
    /// @p iter is NULL after the function returns.
    /// It returns the item being detached.
    T *detachAt(HashTableKeyMI<K, T> &iter);

    /// This function detaches all items in the hash table.
    void        detachItems();

    /// This function deletes all items in the hash table.
    void        deleteItems();

    /// This function steals the complete array of lists of
    /// another hash table @p ht.
    void        steal(HashTableKeyM<K,T>& ht);

    /// This function shows all items in the table.
    void        show() const;

    /// This function shows interesting metrics in the table.
    /// @param[in] name the name to be used for this table in the
    /// report
    void        showStats(const char* name) const;

private:
    /// This function blindly empties the table. To be used on a
    /// table that has been previously stolen.
    /// @attention Beware the array and all lists are not deleted,
    /// since they were stolen.
    void        flush() {
        array_ = NULL;
        HashTableBase::flush();
    }

    friend class    HashTableKeyMLI<K,T>;

    /// This function is called internally when the table is found
    /// to be getting too populated.
    void        growTable();

    /// These functions are disabled.
    HashTableKeyM(const HashTableKeyM<K,T>&);
    HashTableKeyM<K,T>& operator = (const HashTableKeyM<K,T>&);

    /// The array of SlistL<T>s.
    SlistM<T>*      array_;

    /// The function used for hashing on Key.
    uint        (*hashFunKey_)(const K&);

    /// The function used for hashing on Item.
    uint        (*hashFunItem_)(const T*);

    /// The function used for comparing.
    bool        (*eqFun_)(const K&, const T*);
};


// Iterator classes.  Each hash table class has two iterators:
// - HashTableXLI iterates over the list array, so it returns a list,
// - HashTableXI iterates over all items.

/// Iterator class for HashTableL giving successive lists.
template<class T> class HashTableLLI
{
    friend class HashTableLI<T>;
private:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableLLI(const HashTableL<T>* tab) :
        table(tab),
        index(0) {
        nullcheck(tab);
    }

    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableLLI(const HashTableL<T>& tab) :
        table(&tab),
        index(0) {}

public:
    /// This is the post-increment operator.
    /// @return a pointer to the list prior to incrementing
    SlistL<T>*  operator++(int) {
        SlistL<T>* list = operator()();
        index++;
        return list;
    }
    /// This returns the current list, or NULL if done iterating.

    SlistL<T>*  operator()() const {
        return index < table->getSize() ?
               &(table->array[index]) :
               NULL;
    }

    /// The destructor has nothing to do.
    ~HashTableLLI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// The table to iterate on.
    const HashTableL<T>*    table;

    /// The index to the current list in the array.
    int         index;
};

/// Iterator class for HashTableL giving successive items. This is
/// implemented as a hash table iterator giving successive lists and
/// an iterator on the current list of that iterator.
template<class T> class HashTableLI
{
    friend class HashTableL<T>;
public:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableLI(const HashTableL<T>* tab) :
        li(tab) {
        nextNonEmptyList();
    }

    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableLI(const HashTableL<T>& tab) :
        li(&tab) {
        nextNonEmptyList();
    }

    /// This is the post-increment operator.
    /// @return a pointer to the item prior to incrementing
    T*      operator++(int) {
        T* ret = ii();
        ii++;
        if (!ii()) {
            li++;
            nextNonEmptyList();
        }
        return ret;
    }

    /// This returns the current item, or NULL if done iterating.
    T*      operator()() const {
        return ii();
    }

private:
    int index() const { return li.index; }

public:
    /// The destructor has nothing to do.
    ~HashTableLI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// This private function is used to skip empty lists.
    void        nextNonEmptyList() {
        SlistL<T>* l;
        while ((l = li())) {
            if (!l->isEmpty()) {
                ii = SlistLI<T>(l);
                return;
            }
            li++;
        }
        // Didn't find a non empty list.  Leave ii in empty list.
        ii = SlistLI<T>();
    }

    /// A list iterator.
    /// @see template<class T> class HashTableLLI
    HashTableLLI<T> li;

    /// An iterator within a list.
    SlistLI<T>  ii;
};

/// Iterator class for HashTableM giving successive lists.
/// @see template<class T> class HashTableLLI
template<class T> class HashTableMLI
{
    friend class HashTableMI<T>;
private:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableMLI(const HashTableM<T>* tab) :
        table(tab),
        index(0) {
        nullcheck(tab);
    }
    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableMLI(const HashTableM<T>& tab) :
        table(&tab),
        index(0) {}
public:
    /// This is the post-increment operator.
    /// @return a pointer to the list prior to incrementing
    SlistM<T>*  operator++(int) {
        SlistM<T>* list = operator()();
        index++;
        return list;
    }
    /// This returns the current list, or NULL if done iterating.
    SlistM<T>*  operator()() const {
        return index < table->getSize() ?
               &(table->array[index]) :
               NULL;
    }
    /// The destructor has nothing to do.
    ~HashTableMLI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// The table to iterate on.
    const HashTableM<T>*    table;
    /// The index to the current list in the array.
    int         index;
};

/// Iterator class for HashTableM giving successive items. This is
/// implemented as a hash table iterator giving successive lists and
/// an iterator on the current list of that iterator.
/// @see template<class T> class HashTableLI
template<class T> class HashTableMI
{
    friend class HashTableM<T>;
public:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableMI(const HashTableM<T>* tab) :
        li(tab) {
        nextNonEmptyList();
    }
    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableMI(const HashTableM<T>& tab) :
        li(&tab) {
        nextNonEmptyList();
    }
    /// This is the post-increment operator.
    /// @return a pointer to the item prior to incrementing
    T*      operator++(int) {
        T* ret = ii();
        ii++;
        if (!ii()) {
            li++;
            nextNonEmptyList();
        }
        return ret;
    }
    /// This returns the current item, or NULL if done iterating.
    T*      operator()() const {
        return ii();
    }

private:
    int index() const { return li.index; }

public:
    /// The destructor has nothing to do.
    ~HashTableMI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// This private function is used to skip empty lists.
    void        nextNonEmptyList() {
        SlistM<T>* l;
        while ((l = li())) {
            if (!l->isEmpty()) {
                ii = SlistMI<T>(l);
                return;
            }
            li++;
        }
        // Didn't find a non empty list.  Leave ii in empty list.
        ii = SlistMI<T>();
    }
    /// A list iterator.
    /// @see template<class T> class HashTableLLI
    HashTableMLI<T> li;
    /// An iterator within a list.
    SlistMI<T>  ii;
};

// Iterator classes for HashTableP giving successive lists.
template<class T> class HashTablePLI
{
    friend class HashTablePI<T>;
// the following is used in mmc/...
// This constructor has been made private in TD: before upmerge
// we need to investigate more
public:
    HashTablePLI(const HashTableP<T>* tab) :
        table(tab),
        index(0) {
        nullcheck(tab);
    }
private:
    HashTablePLI(const HashTableP<T>& tab) :
        table(&tab),
        index(0) {}
public:
    SlistL<T>*  operator++(int) {
        SlistL<T>* list = operator()();
        index++;
        return list;
    }
    HashTablePLI()
    {
        table = 0;
        index = 0;
    }
    SlistL<T>*  operator()() const {
        if (!table) {
            return 0;
        }
        return index < table->getSize() ?
               &(table->array[index]) :
               NULL;
    }
    ~HashTablePLI() {}
    lifeGuardNewAndDeleteMacro

private:
    const HashTableP<T>*    table;
    int         index;
};

// Iterator classes for HashTableP giving successive items.
template<class T> class HashTablePI
{
    friend class HashTableP<T>;
public:
    HashTablePI(const HashTableP<T>* tab) :
        li(tab) {
        nextNonEmptyList();
    }
    HashTablePI(const HashTableP<T>& tab) :
        li(&tab) {
        nextNonEmptyList();
    }
    HashTablePI() { }

    T*      operator++() {
        ii++;
        if (!ii()) {
            li++;
            nextNonEmptyList();
        }
        return ii();
    }
    T*      operator++(int) {
        T* ret = ii();
        ii++;
        if (ret && !ii()) {
            li++;
            nextNonEmptyList();
        }
        return ret;
    }
    T*      operator()() const {
        return ii();
    }

private:
    int index() const { return li.index; }

public:
    ~HashTablePI() {}
    lifeGuardNewAndDeleteMacro

private:
    void        nextNonEmptyList() {
        SlistL<T>* l;
        while ((l = li())) {
            if (!l->isEmpty()) {
                ii = SlistLI<T>(l);
                return;
            }
            li++;
        }
        // Didn't find a non empty list.  Leave ii in empty list.
        ii = SlistLI<T>();
    }
    HashTablePLI<T> li;
    SlistLI<T>  ii;
};

// Iterator classes for HashTableM giving successive lists.
template<class T> class HashTableQLI
{
    friend class HashTableQI<T>;
private:
    HashTableQLI(const HashTableQ<T>* tab) :
        table(tab),
        index(0) {
        nullcheck(tab);
    }
    HashTableQLI(const HashTableQ<T>& tab) :
        table(&tab),
        index(0) {}
    HashTableQLI()
    {
        table = 0;
        index = 0;
    }
public:
    SlistM<T>*  operator++(int) {
        SlistM<T>* list = operator()();
        index++;
        return list;
    }
    SlistM<T>*  operator()() const {
        if (!table) {
            return 0;
        }
        return index < table->getSize() ?
               &(table->array[index]) :
               NULL;
    }
    ~HashTableQLI() {}
    lifeGuardNewAndDeleteMacro

private:
    const HashTableQ<T>*    table;
    int         index;
};

// Iterator classes for HashTableQ giving successive items.
template<class T> class HashTableQI
{
    friend class HashTableQ<T>;
public:
    HashTableQI(const HashTableQ<T>* tab) :
        li(tab) {
        nextNonEmptyList();
    }
    HashTableQI(const HashTableQ<T>& tab) :
        li(&tab) {
        nextNonEmptyList();
    }
    HashTableQI() { }

    T*      operator++(int) {
        T* ret = ii();
        ii++;
        if (!ii()) {
            li++;
            nextNonEmptyList();
        }
        return ret;
    }
    T*      operator()() const {
        return ii();
    }

private:
    int index() const { return li.index; }

public:
    ~HashTableQI() {}
    lifeGuardNewAndDeleteMacro

private:
    void        nextNonEmptyList() {
        SlistM<T>* l;
        while ((l = li())) {
            if (!l->isEmpty()) {
                ii = SlistMI<T>(l);
                return;
            }
            li++;
        }
        // Didn't find a non empty list.  Leave ii in empty list.
        ii = SlistMI<T>();
    }
    HashTableQLI<T> li;
    SlistMI<T>  ii;
};

/// Iterator class for HashTableKeyL giving successive lists.
template<typename K, class T> class HashTableKeyLLI
{
    friend class HashTableKeyLI<K, T>;
private:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableKeyLLI(const HashTableKeyL<K,T>* tab)
        : table(tab)
        , index(0) {
        nullcheck(tab);
    }
    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableKeyLLI(const HashTableKeyL<K,T>& tab)
        : table(&tab)
        , index(0) {}
    HashTableKeyLLI()
    {
        table = 0;
        index = 0;
    }
public:
    /// This is the post-increment operator.
    /// @return a pointer to the list prior to incrementing
    SlistL<T>*  operator++(int) {
        SlistL<T>* list = operator()();
        index++;
        return list;
    }
    /// This returns the current list, or NULL if done iterating.
    SlistL<T>*  operator()() const {
        if (!table) {
            return 0;
        }
        return index < table->getSize() ?
               &(table->array_[index]) :
               NULL;
    }
    /// The destructor has nothing to do.
    ~HashTableKeyLLI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// The table to iterate on.
    const HashTableKeyL<K,T>*   table;
    /// The index to the current list in the array.
    int                 index;
};

/// Iterator class for HashTableKeyL giving successive items. This is
/// implemented as a hash table iterator giving successive lists and
/// an iterator on the current list of that iterator.
template<typename K, class T> class HashTableKeyLI
{
    friend class HashTableKeyL<K, T>;
public:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableKeyLI(const HashTableKeyL<K,T>* tab)
        : li(tab) {
        nextNonEmptyList();
    }
    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableKeyLI(const HashTableKeyL<K,T>& tab)
        : li(&tab) {
        nextNonEmptyList();
    }
    HashTableKeyLI() { }
    /// This is the post-increment operator.
    /// @return a pointer to the item prior to incrementing
    T*      operator++(int) {
        T* ret = ii();
        ii++;
        if (!ii()) {
            li++;
            nextNonEmptyList();
        }
        return ret;
    }
    /// This returns the current item, or NULL if done iterating.
    T*      operator()() const {
        return ii();
    }

private:
    int index() const { return li.index; }

public:
    /// The destructor has nothing to do.
    ~HashTableKeyLI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// This private function is used to skip empty lists.
    void        nextNonEmptyList() {
        SlistL<T>* l;
        while ((l = li())) {
            if (!l->isEmpty()) {
                ii = SlistLI<T>(l);
                return;
            }
            li++;
        }
        // Didn't find a non empty list.  Leave ii in empty list.
        ii = SlistLI<T>();
    }
    /// A list iterator.
    /// @see template<class T> class HashTableLLI
    HashTableKeyLLI<K,T>    li;
    /// An iterator within a list.
    SlistLI<T>                  ii;
};

/// Iterator class for HashTableKeyM giving successive lists.
/// @see template<class T> class HashTableLLI
template<typename K, class T> class HashTableKeyMLI
{
    friend class HashTableKeyMI<K, T>;
private:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableKeyMLI(const HashTableKeyM<K,T>* tab)
        : table(tab)
        , index(0) {
        nullcheck(tab);
    }
    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableKeyMLI(const HashTableKeyM<K,T>& tab)
        : table(&tab)
        , index(0) {}
    HashTableKeyMLI()
    {
        table = 0;
        index = 0;
    }
public:
    /// This is the post-increment operator.
    /// @return a pointer to the list prior to incrementing
    SlistM<T>*  operator++(int) {
        SlistM<T>* list = operator()();
        index++;
        return list;
    }
    /// This returns the current list, or NULL if done iterating.
    SlistM<T>*  operator()() const {
        if (!table) {
            return 0;
        }
        return index < table->getSize() ?
               &(table->array_[index]) :
               NULL;
    }
    /// The destructor has nothing to do.
    ~HashTableKeyMLI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// The table to iterate on.
    const HashTableKeyM<K,T>*   table;
    /// The index to the current list in the array.
    int             index;
};

/// Iterator class for HashTableKeyM giving successive items. This is
/// implemented as a hash table iterator giving successive lists and
/// an iterator on the current list of that iterator.
/// @see template<class T> class HashTableLI
template<typename K, class T> class HashTableKeyMI
{
    friend class HashTableKeyM<K, T>;
public:
    /// This constructor initializes the iterator for the given table.
    /// @param tab pointer to the table to iterate on
    HashTableKeyMI(const HashTableKeyM<K,T>* tab)
        : li(tab) {
        nextNonEmptyList();
    }
    /// This constructor initializes the iterator for the given table.
    /// @param tab reference to the table to iterate on
    HashTableKeyMI(const HashTableKeyM<K,T>& tab)
        : li(&tab) {
        nextNonEmptyList();
    }
    HashTableKeyMI() { }
    /// This is the post-increment operator.
    /// @return a pointer to the item prior to incrementing
    T*      operator++(int) {
        T* ret = ii();
        ii++;
        if (!ii()) {
            li++;
            nextNonEmptyList();
        }
        return ret;
    }
    /// This returns the current item, or NULL if done iterating.
    T*      operator()() const {
        return ii();
    }

private:
    int index() const { return li.index; }

public:
    /// The destructor has nothing to do.
    ~HashTableKeyMI() {}
    lifeGuardNewAndDeleteMacro

private:
    /// This private function is used to skip empty lists.
    void        nextNonEmptyList() {
        while (SlistM<T>* l = li()) {
            if (!l->isEmpty()) {
                ii = SlistMI<T>(l);
                return;
            }
            li++;
        }
        // Didn't find a non empty list.  Leave ii in empty list.
        ii = SlistMI<T>();
    }
    /// A list iterator.
    /// @see template<class T> class HashTableLLI
    HashTableKeyMLI<K,T>    li;
    /// An iterator within a list.
    SlistMI<T>                  ii;
};
} // namespace unlinked
} // namespace internal


#ifdef INLINE_TMPL
#if 0 /* expanded by -frewrite-includes */
#include "hash.ii"
#endif /* expanded by -frewrite-includes */
# 1634 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

// This file holds the part of the hash code (in hash.hh) that could
// be placed on a regular compile file if the compiler supports
// non-inlined templates, otherwise this file is included from the
// hash.hh file and all is exposed.

#ifdef INLINE_TMPL
#define TMPL_INLINE inline
#else
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
#define TMPL_INLINE
#endif
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"

/// This returns true if the table should be grown, based on its size
/// and number of entries. The idea is that if the number of entries
/// is twice the size of the array then on average each lookup will
/// need to perform 1.5 compares (assumming a well distributed table).
TMPL_INLINE bool HashTableBase::mustGrow() const
{
    return (getNumEntries() > 2 * getSize()) &&
           (getSize() < getLargestSize());
}

namespace internal
{
namespace unlinked
{
template<class T> TMPL_INLINE HashTableL<T>::HashTableL(int pSize) :
    HashTableBase(pSize)
{
    array = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistL<T>), getSize());
    memcheck(array);
}

template<class T> TMPL_INLINE HashTableL<T>::HashTableL() :
    HashTableBase()
{
    array = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistL<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
//  memset(array, 0, sizeof(SlistL<T>) * getSize());
}

template<class T> TMPL_INLINE HashTableL<T>::~HashTableL()
{
    if (array) {
#ifdef ENGINEER
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array[i];
            fassert(l.isEmpty(),
                    msg("HashTableL destroying non-empty list"));
        }
#endif
# 60 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
        getCurrentLifeGuard()->destroyArray(
            array, sizeof(SlistL<T>), getSize());
    }
}

/// This lookup function will return any item whose name is the given
/// one, or NULL if none is found, and it also returns the @p index into
/// the table. This is useful if the lookup may followed by appending
/// an item since the index makes the hashing for appending
/// unnecessary.
///
/// @param[in] name the name to search for
/// @param[out] index the index computed by hashing upon return
/// @return the item if found or NULL
/// @attention Beware not to append any other item between the
/// lookup and the append, since any append can resize the
/// table, thus invalidating the index.
template<class T> TMPL_INLINE T* HashTableL<T>::lookup(
    const char* name, int& index) const
{
    index = hashToIndex(hash(name));

    SlistLI<T> iter(array[index]);
    while (T* item = iter++) {
        if (!strcmp(name, item->getName())) {
            return item;
        }
    }
    return NULL;
}

/// This lookup function returns an iterator pointing at the
/// list that would contain an item with the given @p pName.  This is
/// to handle hash tables where we can append multiple items with the
/// same key. Notice a non-empty iterator does not guarantee the item
/// will be found in the list. It also returns the @p index into the
/// table.
///
/// @param[in] name the name to search for
/// @param[out] index the index computed by hashing upon return
/// @return a list iterator to the list that may contain the item
/// @see T* lookup(const char* pName, int& index) const for
/// issues related to the index
template<class T> TMPL_INLINE typename HashTableL<T>::local_iterator HashTableL<T>::lookupI(
    const char* name, int& index) const
{
    index = hashToIndex(hash(name));

    SlistLI<T> iter(array[index]);
    return local_iterator(iter);
}

/// This function appends an @p item given the @p index. The index
/// must be the value returned by a previous lookup.  This avoids
/// having to hash again.  The item is appended to the end of the
/// list.  This means if possible the first items inserted should be
/// the most commonly occurring.
///
/// @param[in] item the item to append
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index, or a
/// fatal assertion is triggered
template<class T> TMPL_INLINE void HashTableL<T>::append(T* item, int index)
{
    fassert(index == hashToIndex(hash(item->getName())),
            msg("Index bad for HashTableL::append"));
    array[index].append(item);
    incrEntries();
    if (mustGrow()) {
        growTable();
    }
}

/// This function detaches @p item from hash table given the @p index.
///
/// @param[in] item the item to detach
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index and
/// the item must be found or a fatal assertion is triggered
template<class T> TMPL_INLINE T* HashTableL<T>::detach(T* item, int index)
{
    fassert(index == hashToIndex(hash(item->getName())),
            msg("Index bad for HashTableL::detach"));

    // Look for item in list and detach it.
    SlistLI<T> ti(&array[index]);
    if (ti() == item) {
        array[index].detachFirst();
        decrEntries();
        return item;
    }
    else {
        for (; ti(); ti++) {
            if (ti.peek() == item) {
                ti.detachNext(&array[index]);
                decrEntries();
                return item;
            }
        }
    }
    fatal(msg("HashTableL::detach can't find item %s",  item->getName()));
    return NULL;
}

template <class T> TMPL_INLINE
T *HashTableL<T>::detachAt(HashTableLI<T> &iter) {
    int index = iter.index();
    T *item = iter++;
    if (item) {
        detach(item, index);
    }
    return item;
}

/// This function detaches all items in the hash table.
/// @attention Beware the items are not deleted, just detached.
template<class T> TMPL_INLINE void HashTableL<T>::detachItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array[i];
            l.detachItems();
        }
        flushEntries();
    }
}

/// This function deletes all items in the hash table.
template<class T> TMPL_INLINE void HashTableL<T>::deleteItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array[i];
            while (T* item = l.detachFirst()) {
                delete item;
            }
        }
        flushEntries();
    }
}

/// This function steals the complete array of lists of another hash
/// table @p ht.
///
/// @param ht the table to be stolen
/// @pre this table must be empty before stealing a table
template<class T> TMPL_INLINE void HashTableL<T>::steal(HashTableL<T>& ht)
{
    fassert(!getNumEntries(), msg("stealing into non-empty table"));
    getCurrentLifeGuard()->destroyArray(
        array, sizeof(SlistL<T>), getSize());
    array = ht.array;
    copyBaseAttributes(ht);
    ht.flush();
}

template<class T> TMPL_INLINE void HashTableL<T>::show() const
{
    for (int index = 0; index < getSize(); index++) {
        SlistLI<T>  iter(&array[index]);
        while (T* entry = iter++) {
            mprintf("%s\n", entry->getName());
        }
    }
}

/// This function shows interesting metrics in the table. The main
/// objective of this function is getting an indication of the
/// dispersion of the hash function and the collision rate. The
/// distribution of number of items per list should cluster around 1.
///
/// @param name this will be the name given the table in the report
template<class T>
TMPL_INLINE void HashTableL<T>::showStats(const char* name) const
{
    if (isEmpty()) {
        showEmptyStats(name);
        return;
    }
    StatsInfo info(name);
    info.incrMemSize(sizeof(array));
    for (int index = 0; index < getSize(); index++) {
        SlistLI<T> iter(&array[index]);
        int count = 0;
        while (iter++) {
            count++;
        }
        info.update(index, count);
        info.incrMemSize(count * 2 * sizeof(void*));
    }
    showTableStats(info);
}

template<class T>
TMPL_INLINE size_t HashTableL<T>::getMemSizeOf() const
{
    size_t total = getSize() * sizeof(SlistL<T>);
    for (int index = 0; index < getSize(); index++) {
        total += array[index].getMemSizeOf();
    }
    return total;
}

/// This function is called internally when the table is found
/// to be getting too populated.
template<class T> TMPL_INLINE void HashTableL<T>::growTable()
{
    int oldSize = getSize();
    growSize();
    if (oldSize == getSize()) {
        warning(msg("HashTableL::growTable doesn't grow"));
        return;
    }
    SlistL<T>* newArray = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                                           sizeof(SlistL<T>), getSize());
    memcheck(newArray);

    // Make sure the lists are empty.  The constructor is
    // not necessarily called (depends on the compiler?),
    // so we better clear it all explicitly.
    // RFE--the compiler should be able to do this soon?
    int clearSize = getSize() * sizeof(SlistL<T>);
    memset(newArray, 0, clearSize);

    for (int index = 0; index < oldSize; index++) {
        while (T* t = array[index].detachFirst()) {
            int i = hashToIndex(hash(t->getName()));
            newArray[i].append(t);
        }
    }
#ifdef ENGINEER
    // This code is left here just so that the showStats function
    // gets compiled, even if it really does not end up getting
    // used here. It allows the function to be called from the
    // debugger.
    if (0) {
        showStats("Some table");
    }
#endif
# 299 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
    getCurrentLifeGuard()->destroyArray(
        array, sizeof(SlistL<T>), oldSize);
    array = newArray;
}

template<class T> TMPL_INLINE HashTableM<T>::HashTableM(int pSize) :
    HashTableBase(pSize)
{
    array = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistM<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistM<T>) * getSize());
}

template<class T> TMPL_INLINE HashTableM<T>::HashTableM() :
    HashTableBase()
{
    array = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistM<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistM<T>) * getSize());
}

template<class T> TMPL_INLINE HashTableM<T>::~HashTableM()
{
    if (array) {
#ifdef ENGINEER
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array[i];
            fassert(l.isEmpty(),
                    msg("HashTableM destroying non-empty list"));
        }
#endif
# 334 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
        getCurrentLifeGuard()->destroyArray(
            array, sizeof(SlistM<T>), getSize());
    }
}

/// This lookup function will return any item whose name is the
/// given one, or NULL if none is found, and it also returns the
/// @p index into the table. This index can be used for a subsequent
/// append.
/// @param[in] name the name to lookup
/// @param[out] index the index into the table
/// @return the item if found or NULL
template<class T> TMPL_INLINE T* HashTableM<T>::lookup(
    const char* name, int& index) const
{
    index = hashToIndex(hash(name));

    SlistMI<T> iter(array[index]);
    while (iter()) {
        if (!strcmp(name, iter()->getName())) {
            break;
        }
        iter++;
    }
    return iter();
}

/// This lookup function returns an iterator pointing at the
/// list that would contain an item with the given @p pName.  This is
/// to handle hash tables where we can append multiple items with the
/// same key. Notice a non-empty iterator does not guarantee the item
/// will be found in the list. It also returns the @p index into the
/// table.
///
/// @param[in] name the name to search for
/// @param[out] index the index computed by hashing upon return
/// @return a list iterator to the list that may contain the item
/// @see T* lookup(const char* pName, int& index) const for
/// issues related to the index
template<class T> TMPL_INLINE typename HashTableM<T>::local_iterator HashTableM<T>::lookupI(
    const char* name, int& index) const
{
    index = hashToIndex(hash(name));

    SlistMI<T> iter(array[index]);
    return local_iterator(iter);
}

/// This function appends an @p item given the @p index. The index
/// must be the value returned by a previous lookup.  This avoids
/// having to hash again.  The item is appended to the end of the
/// list.  This means if possible the first items inserted should be
/// the most commonly occurring.
///
/// @param[in] item the item to append
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index, or a
/// fatal assertion is triggered
template<class T> TMPL_INLINE void HashTableM<T>::append(T* item, int index)
{
    fassert(index == hashToIndex(hash(item->getName())),
            msg("Index bad for HashTableM::append"));
    array[index].append(item);
    incrEntries();
    if (mustGrow()) {
        growTable();
    }
}

/// This function detaches @p item from hash table given the @p index.
/// @param[in] item the item to be detached
/// @param[in] index the index into the table
/// @pre The item must be found or a fatal assertion is triggered.
template<class T> TMPL_INLINE T* HashTableM<T>::detach(T* item, int index)
{
    fassert(index == hashToIndex(hash(item->getName())),
            msg("Index bad for HashTableM::detach"));

    SlistMI<T> ti(array[index]);
    // Look for item and perform detachNext.
    if (ti() == item) {
        array[index].detachFirst();
        decrEntries();
        return item;
    }
    else {
        for (; ti(); ti++) {
            if (ti.peek() == item) {
                ti.detachNext(&array[index]);
                decrEntries();
                return item;
            }
        }
    }
    fatal(msg("HashTableM::detach can't find item %s", item->getName()));
    return NULL;
}

template <class T> TMPL_INLINE
T *HashTableM<T>::detachAt(HashTableMI<T> &iter) {
    int index = iter.index();
    T *item = iter++;
    if (item) {
        detach(item, index);
    }
    return item;
}

/// This function detaches all items in the hash table.
/// @attention Beware the items are not deleted, just detached.
template<class T> TMPL_INLINE void HashTableM<T>::detachItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array[i];
            l.detachItems();
        }
        flushEntries();
    }
}

/// This function deletes all items in the hash table.
template<class T> TMPL_INLINE void HashTableM<T>::deleteItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array[i];
            while (T* item = l.detachFirst()) {
                delete item;
            }
        }
        flushEntries();
    }
}

/// This function steals the complete array of lists of
/// another hash table @p ht.
/// @param[in] ht the hash table that will be stolen
template<class T> TMPL_INLINE void HashTableM<T>::steal(HashTableM<T>& ht)
{
    fassert(!getNumEntries(), msg("stealing into non-empty table"));
    getCurrentLifeGuard()->destroyArray(
        array, sizeof(SlistM<T>), getSize());
    array = ht.array;
    copyBaseAttributes(ht);
    ht.flush();
}

template<class T> TMPL_INLINE void HashTableM<T>::show() const
{
    for (int index = 0; index < getSize(); index++) {
        SlistMI<T>  iter(&array[index]);
        T*      entry;
        while ((entry = iter++)) {
            mprintf("%s\n", entry->getName());
        }
    }
}

template<class T>
TMPL_INLINE void HashTableM<T>::showStats(const char* name) const
{
    if (isEmpty()) {
        showEmptyStats(name);
        return;
    }
    StatsInfo info(name);
    info.incrMemSize(sizeof(array));
    for (int index = 0; index < getSize(); index++) {
        SlistMI<T> iter(&array[index]);
        int count = 0;
        while (iter++) {
            count++;
        }
        info.update(index, count);
        info.incrMemSize(count * sizeof(void*));
    }
    showTableStats(info);
}

template<class T> TMPL_INLINE void HashTableM<T>::growTable()
{
    int oldSize = getSize();
    growSize();
    if (oldSize == getSize()) {
        warning(msg("HashTableM::growTable doesn't grow"));
        return;
    }
    SlistM<T>* newArray = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                                           sizeof(SlistM<T>), getSize());
    memcheck(newArray);

    // Make sure the lists are empty.  The constructor is
    // not necessarily called (depends on the compiler?),
    // so we better clear it all explicitly.
    // RFE--the compiler should be able to do this soon?
    memset(newArray, 0, getSize() * sizeof(SlistM<T>));

    for (int index = 0; index < oldSize; index++) {
        T* t;
        while ((t = array[index].detachFirst())) {
            newArray[hashToIndex(hash(t->getName()))].append(t);
        }
    }
    getCurrentLifeGuard()->destroyArray(array, sizeof(SlistM<T>), oldSize);
    array = newArray;
}

/// This constructor sets the initial size of the table to be
/// at least as large as the given one.
/// @param[in] pHashFun the hash function for an element
/// @param[in] pEqFun the comparison function
/// @param[in] pSize the initial size
template<class T> TMPL_INLINE HashTableP<T>::HashTableP(
    uint        (*pHashFun)(const T*),
    bool        (*pEqFun)(const T*, const T*),
    int     pSize) :
    HashTableBase(pSize),
    hashFun(pHashFun),
    eqFun(pEqFun)
{
    nullcheck(pHashFun);
    nullcheck(pEqFun);
    array = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistL<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistL<T>) * getSize());
}

/// This constructor sets the initial size of the table to one.
/// @param[in] pHashFun the hash function for an element
/// @param[in] pEqFun the comparison function
template<class T> TMPL_INLINE HashTableP<T>::HashTableP(
    uint        (*pHashFun)(const T*),
    bool        (*pEqFun)(const T*, const T*)) :
    HashTableBase(),
    hashFun(pHashFun),
    eqFun(pEqFun)
{
    nullcheck(pHashFun);
    nullcheck(pEqFun);
    array = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistL<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistL<T>) * getSize());
}

/// This default constructor is needed for serialization.
template<class T> TMPL_INLINE HashTableP<T>::HashTableP() :
    HashTableBase(),
    hashFun(0),
    eqFun(0)
{
    // nullcheck(pHashFun); // intentionally null
    // nullcheck(pEqFun);
    array = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistL<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistL<T>) * getSize());
}

template<class T> TMPL_INLINE HashTableP<T>::~HashTableP()
{
    if (array) {
#ifdef ENGINEER
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array[i];
            fassert(l.isEmpty(),
                    msg("HashTableP destroying non-empty list"));
        }
#endif
# 608 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
        getCurrentLifeGuard()->destroyArray(
            array, sizeof(SlistL<T>), getSize());
    }
}

/// This lookup function will return any item matching the
/// given one, or NULL if none is found, and it also returns the
/// @p index into the table. This is useful if the lookup may
/// followed by appending an item since the index makes the hashing
/// for appending unnecessary.
///
/// @param[in] item the item to search for
/// @param[out] index the index computed by hashing upon return
/// @return the item if found or NULL
/// @attention Beware not to append any other item between the
/// lookup and the append, since any append can resize the
/// table, thus invalidating the index.
template<class T> TMPL_INLINE T* HashTableP<T>::lookup(
    const T* item, int& index) const
{
    index = hashToIndex((*hashFun)(item));

    SlistLI<T> iter(array[index]);
    while (iter()) {
        if ((*eqFun)(item, iter())) {
            break;
        }
        iter++;
    }
    return iter();
}

/// This lookup function returns an iterator pointing at the
/// list that would contain the given @p item.  This is to
/// handle hash tables where we can append multiple items with the
/// same key. Notice a non-empty iterator does not guarantee the item
/// will be found in the list. It also returns the @p index into the
/// table.
///
/// @param[in] item the item to search for (the key is in the item)
/// @param[out] index the index computed by hashing upon return
/// @return a list iterator to the list that may contain the item
/// @see T* lookup(const char* pName, int& index) const for
/// issues related to the index
template<class T> TMPL_INLINE typename HashTableP<T>::local_iterator HashTableP<T>::lookupI(
    const T* item, int& index) const
{
    index = hashToIndex((*hashFun)(item));

    SlistLI<T> iter(array[index]);
    return local_iterator(iter);
}

/// This function appends an @p item given the @p index. The index
/// must be the value returned by a previous lookup.  This avoids
/// having to hash again.  The item is appended to the end of the
/// list.  This means if possible the first items inserted should be
/// the most commonly occurring.
///
/// @param[in] item the item to append
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index, or a
/// fatal assertion is triggered
template<class T> TMPL_INLINE void HashTableP<T>::append(T* item, int index)
{
    fassert(index == hashToIndex((*hashFun)(item)),
            msg("Index bad for HashTableP::append"));
    array[index].append(item);
    incrEntries();
    if (mustGrow()) {
        growTable();
    }
}

/// This function detaches @p item from hash table given the @p index.
/// @param[in] item the item to be detached
/// @param[in] index the index into the table
/// @pre The item must be found or a fatal assertion is triggered.
template<class T> TMPL_INLINE T* HashTableP<T>::detach(T* item, int index)
{
    fassert(index == hashToIndex((*hashFun)(item)),
            msg("Index bad for HashTableP::detach"));

    // Look for item in list and detach it.
    SlistLI<T> ti(&array[index]);
    if (ti() == item) {
        array[index].detachFirst();
        decrEntries();
        return item;
    }
    else {
        for (; ti(); ti++) {
            if (ti.peek() == item) {
                ti.detachNext(&array[index]);
                decrEntries();
                return item;
            }
        }
    }
    fatal(msg("HashTableP::detach can't find item"));
    return NULL;
}

template <class T> TMPL_INLINE
T *HashTableP<T>::detachAt(HashTablePI<T> &iter) {
    int index = iter.index();
    T *item = iter++;
    if (item) {
        detach(item, index);
    }
    return item;
}

template <class T> TMPL_INLINE
T *HashTableP<T>::detachFirst()
{
    if (isEmpty()) {
        return 0;
    }
    unsigned size = getSize();
    for (unsigned index = 0; index < size; ++index) {
        if (!this->array[index].isEmpty()) {
            return this->array[index].detachFirst();
        }
    }
    return 0;
}

/// This function detaches all items in the hash table.
/// @attention Beware the items are not deleted, just detached.
template<class T> TMPL_INLINE void HashTableP<T>::detachItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array[i];
            l.detachItems();
        }
        flushEntries();
    }
}

/// This function deletes all items in the hash table.
template<class T> TMPL_INLINE void HashTableP<T>::deleteItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array[i];
            while (T* item = l.detachFirst()) {
                delete item;
            }
        }
        flushEntries();
    }
}

template<class T> TMPL_INLINE void HashTableP<T>::steal(HashTableP<T>& ht)
{
    fassert(!getNumEntries(), msg("stealing into non-empty table"));
    getCurrentLifeGuard()->destroyArray(
        array, sizeof(SlistL<T>), getSize());
    array = ht.array;
    copyBaseAttributes(ht);
    ht.flush();
}

template<class T> TMPL_INLINE void HashTableP<T>::show() const
{
    for (int index = 0; index < getSize(); index++) {
        SlistLI<T>  iter(array[index]);
        while (iter()) {
            (iter++)->print();
        }
    }
}

template<class T>
TMPL_INLINE void HashTableP<T>::showStats(const char* name) const
{
    if (isEmpty()) {
        showEmptyStats(name);
        return;
    }
    StatsInfo info(name);
    info.incrMemSize(sizeof(array));
    for (int index = 0; index < getSize(); index++) {
        SlistLI<T> iter(&array[index]);
        int count = 0;
        while (iter++) {
            count++;
        }
        info.update(index, count);
        info.incrMemSize(count * 2 * sizeof(void*));
    }
    showTableStats(info);
}

template<class T>
TMPL_INLINE size_t HashTableP<T>::getMemSizeOf() const
{
    size_t total = getSize() * sizeof(SlistL<T>);
    for (int index = 0; index < getSize(); index++) {
        total += array[index].getMemSizeOf();
    }
    return total;
}

template<class T> TMPL_INLINE void HashTableP<T>::growTable()
{
    int oldSize = getSize();
    growSize();
    if (oldSize == getSize()) {
        warning(msg("HashTableP::growTable doesn't grow"));
        return;
    }
    SlistL<T>* newArray = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                                           sizeof(SlistL<T>), getSize());
    memcheck(newArray);

    // Make sure the lists are empty.  The constructor is
    // not necessarily called (depends on the compiler?),
    // so we better clear it all explicitly.
    // RFE--the compiler should be able to do this soon?
    memset(newArray, 0, getSize() * sizeof(SlistL<T>));

    for (int index = 0; index < oldSize; index++) {
        T* item;
        while ((item = array[index].detachFirst())) {
            newArray[hashToIndex((*hashFun)(item))].append(item);
        }
    }
    getCurrentLifeGuard()->destroyArray(
        array, sizeof(SlistL<T>), oldSize);
    array = newArray;
}

template<class T> TMPL_INLINE HashTableQ<T>::HashTableQ(
    uint        (*pHashFun)(const T*),
    bool        (*pEqFun)(const T*, const T*),
    int     pSize)
    : HashTableBase(pSize)
    , hashFun(pHashFun)
    , eqFun(pEqFun)
{
    nullcheck(pHashFun);
    nullcheck(pEqFun);
    array = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistM<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistM<T>) * getSize());
}

template<class T> TMPL_INLINE HashTableQ<T>::HashTableQ(
    uint        (*pHashFun)(const T*),
    bool        (*pEqFun)(const T*, const T*)) :
    HashTableBase(),
    hashFun(pHashFun),
    eqFun(pEqFun)
{
    nullcheck(pHashFun);
    nullcheck(pEqFun);
    array = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistM<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistM<T>) * getSize());
}

/// This default constructor is needed for serialization.
template<class T> TMPL_INLINE HashTableQ<T>::HashTableQ() :
    HashTableBase(),
    hashFun(0),
    eqFun(0)
{
    // nullcheck(pHashFun); // intentionally null
    // nullcheck(pEqFun);
    array = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                             sizeof(SlistM<T>), getSize());
    memcheck(array);
    // Since we don't use operator new we need this.
    memset(array, 0, sizeof(SlistM<T>) * getSize());
}

template<class T> TMPL_INLINE HashTableQ<T>::~HashTableQ()
{
    if (array) {
#ifdef ENGINEER
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array[i];
            fassert(l.isEmpty(),
                    msg("HashTableQ destroying non-empty list"));
        }
#endif
# 901 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
        getCurrentLifeGuard()->destroyArray(
            array, sizeof(SlistM<T>), getSize());
    }
}

template<class T> TMPL_INLINE T* HashTableQ<T>::lookup(
    const T* item, int& index) const
{
    index = hashToIndex((*hashFun)(item));

    SlistMI<T> iter(array[index]);
    while (iter()) {
        if ((*eqFun)(item, iter())) {
            break;
        }
        iter++;
    }
    return iter();
}

/// This lookup function returns an iterator pointing at the
/// list that would contain the given @p item. This is to
/// handle hash tables where we can append multiple items with the
/// same key. Notice a non-empty iterator does not guarantee the item
/// will be found in the list. It also returns the @p index into the
/// table.
///
/// @param[in] item the item to search for
/// @param[out] index the index computed by hashing upon return
/// @return a list iterator to the list that may contain the item
/// @see T* lookup(const char* pName, int& index) const for
/// issues related to the index
template<class T> TMPL_INLINE typename HashTableQ<T>::local_iterator HashTableQ<T>::lookupI(
    const T* item, int& index) const
{
    index = hashToIndex((*hashFun)(item));

    SlistMI<T> iter(array[index]);
    return local_iterator(iter);
}

/// This function appends an @p item given the @p index. The index
/// must be the value returned by a previous lookup.  This avoids
/// having to hash again.  The item is appended to the end of the
/// list.  This means if possible the first items inserted should be
/// the most commonly occurring.
///
/// @param[in] item the item to append
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index, or a
/// fatal assertion is triggered
template<class T> TMPL_INLINE void HashTableQ<T>::append(T* item, int index)
{
    fassert(index == hashToIndex((*hashFun)(item)),
            msg("Index bad for HashTableQ::append"));
    array[index].append(item);
    incrEntries();
    if (mustGrow()) {
        growTable();
    }
}

/// This function detaches @p item from hash table given the @p index.
/// @param[in] item the item to be detached
/// @param[in] index the index into the table
/// @pre The item must be found or a fatal assertion is triggered.
template<class T> TMPL_INLINE T* HashTableQ<T>::detach(T* item, int index)
{
    fassert(index == hashToIndex((*hashFun)(item)),
            msg("Index bad for HashTableQ::detach"));

    // Look for item in list and detach it.
    SlistMI<T> ti(&array[index]);
    if (ti() == item) {
        array[index].detachFirst();
        decrEntries();
        return item;
    }
    else {
        for (; ti(); ti++) {
            if (ti.peek() == item) {
                ti.detachNext(&array[index]);
                decrEntries();
                return item;
            }
        }
    }
    fatal(msg("HashTableQ::detach can't find item"));
    return NULL;
}

template <class T> TMPL_INLINE
T *HashTableQ<T>::detachAt(HashTableQI<T> &iter) {
    int index = iter.index();
    T *item = iter++;
    if (item) {
        detach(item, index);
    }
    return item;
}

/// This function detaches all items in the hash table.
/// @attention Beware the items are not deleted, just detached.
template<class T> TMPL_INLINE void HashTableQ<T>::detachItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array[i];
            l.detachItems();
        }
        flushEntries();
    }
}

/// This function deletes all items in the hash table.
template<class T> TMPL_INLINE void HashTableQ<T>::deleteItems()
{
    if (getNumEntries() > 0) {
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array[i];
            while (T* item = l.detachFirst()) {
                delete item;
            }
        }
        flushEntries();
    }
}

template<class T> TMPL_INLINE void HashTableQ<T>::steal(HashTableQ<T>& ht)
{
    fassert(!getNumEntries(), msg("stealing into non-empty table"));
    getCurrentLifeGuard()->destroyArray(
        array, sizeof(SlistM<T>), getSize());
    array = ht.array;
    copyBaseAttributes(ht);
    ht.flush();
}

template<class T> TMPL_INLINE void HashTableQ<T>::show() const
{
    for (int index = 0; index < getSize(); index++) {
        SlistMI<T>  iter(array[index]);
        while (iter()) {
            (iter++)->print();
        }
    }
}

template<class T>
TMPL_INLINE void HashTableQ<T>::showStats(const char* name) const
{
    if (isEmpty()) {
        showEmptyStats(name);
        return;
    }
    StatsInfo info(name);
    info.incrMemSize(sizeof(array));
    for (int index = 0; index < getSize(); index++) {
        SlistMI<T> iter(&array[index]);
        int count = 0;
        while (iter++) {
            count++;
        }
        info.update(index, count);
        info.incrMemSize(count * sizeof(void*));
    }
    showTableStats(info);
}

/// This function is called internally when the table is found to be
/// getting too populated. The action is to essentially realloc the
/// array.
/// @attention Beware that the order of items in the table will change.
template<class T> TMPL_INLINE void HashTableQ<T>::growTable()
{
    int oldSize = getSize();
    growSize();
    if (oldSize == getSize()) {
        warning(msg("HashTableQ::growTable doesn't grow"));
        return;
    }
    SlistM<T>* newArray = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                                           sizeof(SlistM<T>), getSize());
    memcheck(newArray);

    // Make sure the lists are empty.  The constructor is
    // not necessarily called (depends on the compiler?),
    // so we better clear it all explicitly.
    // RFE--the compiler should be able to do this soon?
    memset(newArray, 0, getSize() * sizeof(SlistM<T>));

    for (int index = 0; index < oldSize; index++) {
        T* item;
        while ((item = array[index].detachFirst())) {
            newArray[hashToIndex((*hashFun)(item))].append(item);
        }
    }
    getCurrentLifeGuard()->destroyArray(array, sizeof(SlistM<T>), oldSize);
    array = newArray;
}

//------------------------------------------------------------------------------
// HashTableKeyL
//------------------------------------------------------------------------------

template<typename K, class T> TMPL_INLINE HashTableKeyL<K, T>::HashTableKeyL(
    uint    (*pHashFunKey)(K),
    uint    (*pHashFunItem)(const T*),
    bool    (*pEqFun)(K, const T*),
    int     pSize)
    : HashTableBase(pSize)
    , hashFunKey_(pHashFunKey)
    , hashFunItem_(pHashFunItem)
    , eqFun_(pEqFun)
{
    nullcheck(pHashFunKey);
    nullcheck(pHashFunItem);
    nullcheck(pEqFun);
    array_ = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                              sizeof(SlistL<T>), getSize());
    memcheck(array_);
}

template<typename K, class T> TMPL_INLINE HashTableKeyL<K, T>::HashTableKeyL(
    uint    (*pHashFunKey)(K),
    uint    (*pHashFunItem)(const T*),
    bool    (*pEqFun)(K, const T*))
    : HashTableBase()
    , hashFunKey_(pHashFunKey)
    , hashFunItem_(pHashFunItem)
    , eqFun_(pEqFun)
{
    nullcheck(pHashFunKey);
    nullcheck(pHashFunItem);
    nullcheck(pEqFun);
    array_ = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                              sizeof(SlistL<T>), getSize());
    memcheck(array_);
}

/// This default constructor is used for serialization.
template<typename K, class T> TMPL_INLINE HashTableKeyL<K, T>::HashTableKeyL()
    : HashTableBase()
    , hashFunKey_(0)
    , hashFunItem_(0)
    , eqFun_(0)
{
    array_ = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                              sizeof(SlistL<T>), getSize());
    memcheck(array_);
}

template<typename K, class T> TMPL_INLINE HashTableKeyL<K, T>::~HashTableKeyL()
{
    if (array_) {
#ifdef ENGINEER
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array_[i];
            fassert(l.isEmpty(),
                    msg("HashTableKeyL destroying non-empty list"));
        }
#endif
# 1163 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
        getCurrentLifeGuard()->destroyArray(
            array_, sizeof(SlistL<T>), getSize());
    }
}

/// This lookup function will return any item matching the given key,
/// or NULL if none is found, and it also returns the @p index into
/// the table. This is useful if the lookup may be followed by
/// appending an item since the index makes the hashing for appending
/// unnecessary.
///
/// @param[in] key the key to search for
/// @param[out] index the index computed by hashing upon return
/// @return the item if found or NULL
/// @attention Beware not to append any other item between the
/// lookup and the append, since any append can resize the
/// table, thus invalidating the index.
template<typename K, class T> TMPL_INLINE T* HashTableKeyL<K, T>::lookup(
    K key, int& index) const
{
    index = hashToIndex((*hashFunKey_)(key));

    SlistLI<T> iter(array_[index]);
    T* item = iter();
    while (item) {
        if ((*eqFun_)(key, item)) {
            break;
        }
        item = ++iter;
    }
    return item;
}

/// This lookup function will return any item matching the given one,
/// or NULL if none is found, and it also returns the @p index into
/// the table. This is useful if the lookup may be followed by
/// appending an item since the index makes the hashing for appending
/// unnecessary.
///
/// @param[in] item the item to search for (the key is in the item)
/// @param[out] index the index computed by hashing upon return
/// @return the item if found or NULL
/// @attention Beware not to append any other item between the
/// lookup and the append, since any append can resize the
/// table, thus invalidating the index.
template<typename K, class T> TMPL_INLINE T* HashTableKeyL<K, T>::lookup(
    const T* item, int& index) const
{
    index = hashToIndex((*hashFunItem_)(item));

    SlistLI<T> iter(array_[index]);
    T* iterItem = iter();
    while (iterItem) {
        if (item == iterItem) {
            break;
        }
        iterItem = ++iter;
    }
    return iterItem;
}

/// This lookup function returns an iterator pointing at the
/// list that would contain the given @p item. This is
/// to handle hash tables where we can append multiple items with the
/// same key. It is also used to find items that are equal but not
/// pointer equal. Notice a non-empty iterator does not guarantee the
/// item will be found in the list. It also returns the @p index into
/// the table.
///
/// @param[in] item The item to search for.
/// @param[out] index The index computed by hashing upon return.
/// @return A list iterator to the list that may contain the item
/// @see T* lookup(K key, int& index) const for
/// issues related to the index
template<typename K, class T> TMPL_INLINE typename HashTableKeyL<K, T>::local_iterator
HashTableKeyL<K, T>::lookupI(
    const T* item, int& index) const
{
    index = hashToIndex((*hashFunItem_)(item));

    SlistLI<T> iter(array_[index]);
    return local_iterator(iter);
}

/// This lookup function returns an iterator pointing at the
/// list corresponding to the given @p key. This is
/// to handle hash tables where we can append multiple items with the
/// same key. Notice a non-empty iterator does not guarantee the item
/// will be found in the list. It also returns the @p index into the
/// table.
///
/// @param[in] key the key to search for
/// @param[out] index the index computed by hashing upon return
/// @return a list iterator to the list that may contain the item
/// @see T* lookup(const char* pName, int& index) const for
/// issues related to the index
template<typename K, class T> TMPL_INLINE typename HashTableKeyL<K, T>::local_iterator
HashTableKeyL<K, T>::lookupI(
    K key, int& index) const
{
    index = hashToIndex((*hashFunKey_)(key));

    SlistLI<T> iter(array_[index]);
    return local_iterator(iter);
}

/// This function appends an @p item given the @p index. The index
/// must be the value returned by a previous lookup.  This avoids
/// having to hash again.  The item is appended to the end of the
/// list.  This means if possible the first items inserted should be
/// the most commonly occurring.
///
/// @param[in] item the item to append
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index, or a
/// fatal assertion is triggered
template<typename K, class T> TMPL_INLINE void
HashTableKeyL<K, T>::append(T* item, int index)
{
    fassert(index == hashToIndex((*hashFunItem_)(item)),
            msg("Index bad for HashTableKeyL::append"));
    array_[index].append(item);
    incrEntries();
    if (mustGrow()) {
        growTable();
    }
}

/// This function detaches @p item from hash table given the @p index.
///
/// @param[in] item the item to detach
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index and
/// the item must be found or a fatal assertion is triggered
template<typename K, class T> TMPL_INLINE T*
HashTableKeyL<K, T>::detach(T* item, int index)
{
    fassert(index == hashToIndex((*hashFunItem_)(item)),
            msg("Index bad for HashTableKeyL::detach"));

    // Look for item in list and detach it.
    SlistLI<T> ti(&array_[index]);
    if (ti() == item) {
        array_[index].detachFirst();
        decrEntries();
        return item;
    }
    else {
        for (; ti(); ++ti) {
            if (ti.peek() == item) {
                ti.detachNext(&array_[index]);
                decrEntries();
                return item;
            }
        }
    }
    /* purecov: begin inspected */
    fatal(msg("HashTableKeyL::detach can't find item"));
    return NULL;
    /* purecov: end */
}

template <typename K, class T> TMPL_INLINE
T *HashTableKeyL<K, T>::detachAt(HashTableKeyLI<K, T> &iter) {
    int index = iter.index();
    T *item = iter++;
    if (item) {
        detach(item, index);
    }
    return item;
}

/// This function detaches all items in the hash table.
/// @attention Beware the items are not deleted, just detached.
template<typename K, class T> TMPL_INLINE void
HashTableKeyL<K, T>::detachItems()
{
    for (int i = 0; i < getSize(); i++) {
        SlistL<T>& l = array_[i];
        l.detachItems();
    }
    flushEntries();
}

/// This function deletes all items in the hash table.
template<typename K, class T> TMPL_INLINE void
HashTableKeyL<K, T>::deleteItems()
{
    if (getNumEntries()) {
        for (int i = 0; i < getSize(); i++) {
            SlistL<T>& l = array_[i];
            while (T* item = l.detachFirst()) {
                delete item;
            }
        }
        flushEntries();
    }
}

/// This function steals the complete array of lists of another hash
/// table @p ht.
///
/// @param ht the table to be stolen
/// @pre this table must be empty before stealing a table
template<typename K, class T> TMPL_INLINE void
HashTableKeyL<K, T>::steal(HashTableKeyL<K, T>& ht)
{
    fassert(!getNumEntries(), msg("stealing into non-empty table"));
    getCurrentLifeGuard()->destroyArray(
        array_, sizeof(SlistL<T>), getSize());
    array_ = ht.array_;
    copyBaseAttributes(ht);
    ht.flush();
}

template<typename K, class T> TMPL_INLINE
void HashTableKeyL<K, T>::show() const
{
    for (int index = 0; index < getSize(); index++) {
        if (!array_[index].isEmpty()) {
            SlistLI<T>  iter(&array_[index]);
            mprintf("%d:", index);
            while (T* entry = iter++) {
                entry->print();
            }
            mprintf("\n");
        }
    }
}

/// This function shows interesting metrics in the table. The main
/// objective of this function is getting an indication of the
/// dispersion of the hash function and the collision rate. The
/// distribution of number of items per list should cluster around 1.
///
/// @param name this will be the name given the table in the report
template<typename K, class T>
TMPL_INLINE void HashTableKeyL<K, T>::showStats(const char* name) const
{
    if (isEmpty()) {
        showEmptyStats(name);
        return;
    }
    StatsInfo info(name);
    info.incrMemSize(sizeof(array_));
    for (int index = 0; index < getSize(); index++) {
        SlistLI<T> iter(&array_[index]);
        int count = 0;
        while (iter++) {
            count++;
        }
        info.update(index, count);
        info.incrMemSize(count * 2 * sizeof(void*));
    }
    showTableStats(info);
}

/// This function is called internally when the table is found
/// to be getting too populated.
template<typename K, class T> TMPL_INLINE void HashTableKeyL<K, T>::growTable()
{
    int oldSize = getSize();
    growSize();
    if (oldSize == getSize()) {
        warning(msg("HashTableKeyL::growTable doesn't grow"));
        return;
    }
    SlistL<T>* newArray = (SlistL<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                                           sizeof(SlistL<T>), getSize());
    memcheck(newArray);

    for (int index = 0; index < oldSize; index++) {
        while (T* t = array_[index].detachFirst()) {
            int i = hashToIndex((*hashFunItem_)(t));
            newArray[i].append(t);
        }
    }
    getCurrentLifeGuard()->destroyArray(
        array_, sizeof(SlistL<T>), oldSize);
    array_ = newArray;
}

//------------------------------------------------------------------------------
// HashTableKeyM
//------------------------------------------------------------------------------

template<typename K, class T> TMPL_INLINE HashTableKeyM<K, T>::HashTableKeyM(
    uint    (*pHashFunKey)(const K&),
    uint    (*pHashFunItem)(const T*),
    bool    (*pEqFun)(const K&, const T*),
    int     pSize)
    : HashTableBase(pSize)
    , hashFunKey_(pHashFunKey)
    , hashFunItem_(pHashFunItem)
    , eqFun_(pEqFun)
{
    nullcheck(pHashFunKey);
    nullcheck(pHashFunItem);
    nullcheck(pEqFun);
    array_ = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                              sizeof(SlistM<T>), getSize());
    memcheck(array_);
}

template<typename K, class T> TMPL_INLINE HashTableKeyM<K, T>::HashTableKeyM(
    uint    (*pHashFunKey)(const K&),
    uint    (*pHashFunItem)(const T*),
    bool    (*pEqFun)(const K&, const T*))
    : HashTableBase()
    , hashFunKey_(pHashFunKey)
    , hashFunItem_(pHashFunItem)
    , eqFun_(pEqFun)
{
    nullcheck(pHashFunKey);
    nullcheck(pHashFunItem);
    nullcheck(pEqFun);
    array_ = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                              sizeof(SlistM<T>), getSize());
    memcheck(array_);
}

/// This default constructor is used for serialization.
template<typename K, class T> TMPL_INLINE HashTableKeyM<K, T>::HashTableKeyM()
    : HashTableBase()
    , hashFunKey_(0)
    , hashFunItem_(0)
    , eqFun_(0)
{
    array_ = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                              sizeof(SlistM<T>), getSize());
    memcheck(array_);
}

template<typename K, class T> TMPL_INLINE HashTableKeyM<K, T>::~HashTableKeyM()
{
    if (array_) {
#ifdef ENGINEER
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array_[i];
            fassert(l.isEmpty(),
                    msg("HashTableKeyM destroying non-empty list"));
        }
#endif
# 1506 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.ii"
        getCurrentLifeGuard()->destroyArray(
            array_, sizeof(SlistM<T>), getSize());
    }
}

/// This lookup function will return any item matching the given key,
/// or NULL if none is found, and it also returns the @p index into
/// the table. This is useful if the lookup may be followed by
/// appending an item since the index makes the hashing for appending
/// unnecessary.
///
/// @param[in] key the key to search for
/// @param[out] index the index computed by hashing upon return
/// @return the item if found or NULL
/// @attention Beware not to append any other item between the
/// lookup and the append, since any append can resize the
/// table, thus invalidating the index.
template<typename K, class T> TMPL_INLINE T* HashTableKeyM<K, T>::lookup(
    const K& key, int& index) const
{
    index = hashToIndex((*hashFunKey_)(key));

    SlistMI<T> iter(array_[index]);
    T* item = iter();
    while (item) {
        if ((*eqFun_)(key, item)) {
            break;
        }
        item = ++iter;
    }
    return item;
}

/// This lookup function will return any item matching the given one,
/// or NULL if none is found, and it also returns the @p index into
/// the table. This is useful if the lookup may be followed by
/// appending an item since the index makes the hashing for appending
/// unnecessary.
///
/// @param[in] item the item to search for (the key is in the item)
/// @param[out] index the index computed by hashing upon return
/// @return the item if found or NULL
/// @attention Beware not to append any other item between the
/// lookup and the append, since any append can resize the
/// table, thus invalidating the index.
template<typename K, class T> TMPL_INLINE T* HashTableKeyM<K, T>::lookup(
    const T* item, int& index) const
{
    index = hashToIndex((*hashFunItem_)(item));

    SlistMI<T> iter(array_[index]);
    T* iterItem = iter();
    while (iterItem) {
        if (item == iterItem) {
            break;
        }
        iterItem = ++iter;
    }
    return iterItem;
}

/// This lookup function returns an iterator pointing at the
/// list that would contain an item with the given @p pName.  This is
/// to handle hash tables where we can append multiple items with the
/// same key. Notice a non-empty iterator does not guarantee the item
/// will be found in the list. It also returns the @p index into the
/// table.
///
/// @param[in] key the key to search for
/// @param[out] index the index computed by hashing upon return
/// @return a list iterator to the list that may contain the item
/// @see T* lookup(const char* pName, int& index) const for
/// issues related to the index
template<typename K, class T> TMPL_INLINE typename HashTableKeyM<K, T>::local_iterator
HashTableKeyM<K, T>::lookupI(
    const K& key, int& index) const
{
    index = hashToIndex((*hashFunKey_)(key));

    SlistMI<T> iter(array_[index]);
    return local_iterator(iter);
}

/// This function appends an @p item given the @p index. The index
/// must be the value returned by a previous lookup.  This avoids
/// having to hash again.  The item is appended to the end of the
/// list.  This means if possible the first items inserted should be
/// the most commonly occurring.
///
/// @param[in] item the item to append
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index, or a
/// fatal assertion is triggered
template<typename K, class T> TMPL_INLINE void
HashTableKeyM<K, T>::append(T* item, int index)
{
    fassert(index == hashToIndex((*hashFunItem_)(item)),
            msg("Index bad for HashTableKeyM::append"));
    array_[index].append(item);
    incrEntries();
    if (mustGrow()) {
        growTable();
    }
}

/// This function detaches @p item from hash table given the @p index.
///
/// @param[in] item the item to detach
/// @param[in] index the hash index for the item
/// @pre the index should match the computed hash index and
/// the item must be found or a fatal assertion is triggered
template<typename K, class T> TMPL_INLINE T*
HashTableKeyM<K, T>::detach(T* item, int index)
{
    fassert(index == hashToIndex((*hashFunItem_)(item)),
            msg("Index bad for HashTableKeyM::detach"));

    // Look for item in list and detach it.
    SlistMI<T> ti(&array_[index]);
    if (ti() == item) {
        array_[index].detachFirst();
        decrEntries();
        return item;
    }
    else {
        for (; ti(); ++ti) {
            if (ti.peek() == item) {
                ti.detachNext(&array_[index]);
                decrEntries();
                return item;
            }
        }
    }
    /* purecov: begin inspected */
    fatal(msg("HashTableKeyM::detach can't find item"));
    return NULL;
    /* purecov: end */
}

template <typename K, class T> TMPL_INLINE
T *HashTableKeyM<K, T>::detachAt(HashTableKeyMI<K, T> &iter) {
    int index = iter.index();
    T *item = iter++;
    if (item) {
        detach(item, index);
    }
    return item;
}

/// This function detaches all items in the hash table.
/// @attention Beware the items are not deleted, just detached.
template<typename K, class T> TMPL_INLINE void
HashTableKeyM<K, T>::detachItems()
{
    for (int i = 0; i < getSize(); i++) {
        SlistM<T>& l = array_[i];
        l.detachItems();
    }
    flushEntries();
}

/// This function deletes all items in the hash table.
template<typename K, class T> TMPL_INLINE void
HashTableKeyM<K, T>::deleteItems()
{
    if (getNumEntries()) {
        for (int i = 0; i < getSize(); i++) {
            SlistM<T>& l = array_[i];
            while (T* item = l.detachFirst()) {
                delete item;
            }
        }
        flushEntries();
    }
}

/// This function steals the complete array of lists of another hash
/// table @p ht.
///
/// @param ht the table to be stolen
/// @pre this table must be empty before stealing a table
template<typename K, class T> TMPL_INLINE void
HashTableKeyM<K, T>::steal(HashTableKeyM<K, T>& ht)
{
    fassert(!getNumEntries(), msg("stealing into non-empty table"));
    getCurrentLifeGuard()->destroyArray(
        array_, sizeof(SlistM<T>), getSize());
    array_ = ht.array_;
    copyBaseAttributes(ht);
    ht.flush();
}

template<typename K, class T> TMPL_INLINE
void HashTableKeyM<K, T>::show() const
{
    for (int index = 0; index < getSize(); index++) {
        SlistMI<T>  iter(&array_[index]);
        while (T* entry = iter++) {
            entry->print();
        }
    }
}

/// This function shows interesting metrics in the table. The main
/// objective of this function is getting an indication of the
/// dispersion of the hash function and the collision rate. The
/// distribution of number of items per list should cluster around 1.
///
/// @param name this will be the name given the table in the report
template<typename K, class T>
TMPL_INLINE void HashTableKeyM<K, T>::showStats(const char* name) const
{
    if (isEmpty()) {
        showEmptyStats(name);
        return;
    }
    StatsInfo info(name);
    info.incrMemSize(sizeof(array_));
    for (int index = 0; index < getSize(); index++) {
        SlistMI<T> iter(&array_[index]);
        int count = 0;
        while (iter++) {
            count++;
        }
        info.update(index, count);
        info.incrMemSize(count * sizeof(void*));
    }
    showTableStats(info);
}

/// This function is called internally when the table is found
/// to be getting too populated.
template<typename K, class T> TMPL_INLINE void HashTableKeyM<K, T>::growTable()
{
    int oldSize = getSize();
    growSize();
    if (oldSize == getSize()) {
        warning(msg("HashTableKeyM::growTable doesn't grow"));
        return;
    }
    SlistM<T>* newArray = (SlistM<T>*)lifeGuardCreateArray(getCurrentLifeGuard(),
                                                           sizeof(SlistM<T>), getSize());
    memcheck(newArray);

    for (int index = 0; index < oldSize; index++) {
        while (T* t = array_[index].detachFirst()) {
            int i = hashToIndex((*hashFunItem_)(t));
            newArray[i].append(t);
        }
    }
    getCurrentLifeGuard()->destroyArray(
        array_, sizeof(SlistM<T>), oldSize);
    array_ = newArray;
}
} // namespace unlinked
} // namespace internal

# 1635 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh" 2
#endif // INLINE_TMPL
# 1636 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"

#if 0 /* expanded by -frewrite-includes */
#include "linked_hash.hh"
#endif /* expanded by -frewrite-includes */
# 1637 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

// Copyright (C) 1995-1997 Radiant Design Tools.  All Rights Reserved.
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

/**
 * @file
 * @ brief Linked hash table maintains a well-defined entry order when
 * traversing the hash table, no matter what the hash function is.
 * 
 * Basically, linked hash table contains a list of all hash elements
 * and an array of bucket.
 * Each bucket consists of linked outer nodes.
 * The list consists of linked inner nodes.
 * Each hash element has an inner node and an outer node.
 * APIs can extract inner node from outer node and extract hash element from inner node.
 *
 * Non-intrusive hash table HashTable<T>:
 * 1. Each inner node maintains a prev and the next pointer in the 
 * list [T1, T2, T3, T4]. Each outer node maintains next pointer in bucket.
 * These pointers are not changed during rehash.
 * 2. Comparing with the unlinked hash table, 2 pointers overhead.
 * 3. Possible to have a version without single element detachment, which
 * has one pointer overhead.
 * 4. Implementation: SlistM<OuterNode> can implement bucket,
 * DlistM<InnerNode> can implement the list. Inner node is nested
 * inside outer node.
 *
 *                  +--------------+    +--------------+
 *                  +              +    +              +
 *  +----------+    +   +------+   +    +   +------+   +  
 *  +bucket 0  +--->+   +  T1  +   +--->+   +  T4  +   +
 *  +----------+    +   +------+   +    +   +------+   + 
 *  +bucket 1  +    +     |  |     +    +     |  |     +
 *  +----------+    +-----|--|-----+    +-----|--|-----+   
 *  +bucket 2  +          |  |                |  |
 *  +----------+    +-----|--|-----+    +-----|--|-----+
 *  +          +    +     |  |     +    +     |  |     +
 *  +----------+    +   +------+   +    +   +------+   +  
 *  +bucket n-1+--->+   +  T2  +   +--->+   +  T3  +   +
 *  +----------+    +   +------+   +    +   +------+   + 
 *                  +     |  |     +    +     |  |     +
 *                  +-----|--|-----+    +-----|--|-----+   
 *                        |  |________________|  |
 *                        |______________________|
 *
 *
 * Intrusive hash table HashTable<T>:
 *                  
 *                 
 *  +----------+    +----------+    +----------+
 *  +bucket 0  +--->+prev of T1+--->+prev of T4+
 *  +----------+    +----------+    +-----|----+
 *  +bucket 1  +                          |
 *  +----------+                          |_____________
 *  +bucket 2  +                                        |
 *  +----------+                                        |
 *  +          +                                        |
 *  +----------+    +----------+    +----------+        |
 *  +bucket n-1+--->+prev of T2+--->+prev of T3+        |
 *  +----------+    +----|-----+    +----|-----+        |
 *                       |               |              |
 *                  +----------+    +----------+    +----------+    +----------+
 *                  +   T1     +--->+   T2     +--->+   T3     +--->+   T4     +
 *                  +----------+    +----------+    +----------+    +----------+
 *
 * The type T shall derive from SlinkB, which itself can represent the InnerNode type.
 * Outer node, i.e., element of bucket, contains pointer to prev element, which can
 * help implement detachment in O(1).
 *
 * lookup(T *item)
 * 1. compute hash key and find the bucket
 * 2. find the outer node satisfying the condition: outer->prev->next == item
 *
 * append(T *item)
 * 1. compute hash key and find the bucket
 * 2. create a new outer node and initialize its 'prev' member to the tail of list.
 * 3. append the new outer node into bucket, and append its inner node 'item' into list.
 *
 * detach(T *item)
 * 1. compute hash key and find the bucket
 * 2. find the outer node satisfying the condition: outer->prev->next == item. Detach the outer
 * node from bucket in O(1) because we can remember its previous one when iterating the bucket. Now,
 * we know the previous element before 'item', i.e., outer->prev. Then we can detach 'item' from
 * list in O(1).
 * 3. For the next element after 'item', finds its corresponding outer node as 'lookup' does.
 * Let the 'prev' member of this outer node point to the previous element before 'item'.
 */
#ifndef LINKED_HASH_HH
#define LINKED_HASH_HH

#if 0 /* expanded by -frewrite-includes */
#include <new>
#endif /* expanded by -frewrite-includes */
# 98 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"
# 99 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"

void appendLinkedItemCallback(HashTableBase *ht, void *item);
void detachLinkedItemCallback(HashTableBase *ht, void *item);
void detachAllLinkedItemCallback(HashTableBase *ht, int num);

namespace internal
{
namespace linked 
{
struct VoidType; // no definition, only declaration is required.
template <typename K>
struct KeyTypeTraits
{
    typedef K KeyType;
};

template <> struct KeyTypeTraits<void>
{
    // Remedy for compile error "reference to void"
    // if user specified key type is 'void'.
    // See HashTable::lookup(const KeyType &);
    // See HashTableP/HashTableQ
    typedef VoidType KeyType;
};

template <typename K> struct KeyTypeTraits<K &>
{
    // Remedy for compile error "reference to reference"
    // if user specified key type is reference type.
    // See HashTable::lookup(const KeyType &);
    // See BuilderImpl::expr2Term_
    typedef K KeyType; 
};

// Map the intrusive attribute value to type and help dispath at compile time 
// by function overloading.
template <bool> struct IntrusiveType 
{
};

// Traits help to implement various hash table using only one template class.
// It defines the bucket, list, inner node (list node) and outer node (bucket node).
// Also, it defines how to extract the item from the inner node.
template <class T, bool intrusive, bool detachment> struct HashTableTraits;

template <class T>
struct HashTableTraits<T, true /* intrusive */, true /* single detachment */>
{
    typedef T InnerNode; // implicit requirement: T shall derive from SlinkB
    struct OuterNode;
    typedef SlistM<InnerNode> List;
    typedef SlistM<OuterNode> Bucket;
    typedef SlistMI<InnerNode> InnerNodeIterator;
    typedef SlistMI<OuterNode> OuterNodeIterator;
    // API SlistB::detachNext requires that the formal parameter shall be 'SlinkB *&'.
    // So, it is illegal to pass an inner/outer node (derived from SlinkB) reference to this API.
    // That's too bad.
    // Instead, the formal parameter shall be 'SlistB *'.
    // However, it's risky to change the API because its implementation does
    // reset the formal argument reference to NULL and legacy codes may depend on this side effect.
    // Workaround: trait class track the base class of inner/outernode
    // and HashTable::detach cast the inner/outer node reference to base reference.
    typedef SlinkB InnerNodeBase;
    typedef SlinkB OuterNodeBase;

    struct OuterNode : public SlinkB
    {
        InnerNode *m_prev;
        OuterNode(T *item, List &inners)
        {
            m_prev = inners.getLast();
            inners.append(item);
        }
        InnerNode *getCurrentInnerNode(const List &inners)
        {
            if (m_prev) {
                return static_cast<InnerNode *>(m_prev->getNext());
            }
            return inners.getFirst();
        }
        InnerNode *getPreviousInnerNode() // required by single detachment
        {
            return m_prev;
        }
        void setPreviousInnerNode(InnerNode *prev) // required by updatePreviousInnerNode
        {
            m_prev = prev;
        }
        InnerNode *getNextInnerNode(const List &inners) // required by updaePreviousInnerNode
        {
            InnerNode *current = getCurrentInnerNode(inners);
            InnerNode *next = static_cast<InnerNode *>(current->getNext());
            InnerNode *first = inners.getFirst();
            if (next == first) {
                // Inner node list (SlistM) is a circular list.
                // We break the circularity for simplicty.
                // If maintaing the circularity, we may have to set 
                // previous inner node of *FIRST* outer node to the new item
                // each time appending the new item into hash table.
                // It's a problem to maintain *FIRST* outer node.
                return 0;
            }
            return next;
        }
        lifeGuardNewAndDeleteMacro
    };

    static T *getItem(InnerNode *inner)
    {
        return inner;
    }
};

template <class T>
struct HashTableTraits<T, false /* non-intrusive */, false /* no single detachment */>
{
    struct InnerNode;
    struct OuterNode;
    typedef SlistM<InnerNode> List;
    typedef SlistM<OuterNode> Bucket;
    typedef SlistMI<InnerNode> InnerNodeIterator;
    typedef SlistMI<OuterNode> OuterNodeIterator;
    typedef SlinkB InnerNodeBase;
    typedef SlinkB OuterNodeBase;

    struct InnerNode : public SlinkB
    {
        T *m_item;
    };

    struct OuterNode : public SlinkB
    {
        InnerNode m_inner;
        OuterNode(T *item, List &inners)
        {
            m_inner.m_item = item;
            inners.append(&m_inner);
        }
        InnerNode *getCurrentInnerNode(const List &)
        {
            return &m_inner;
        }
        lifeGuardNewAndDeleteMacro
    };

    static T *getItem(InnerNode *inner)
    {
        return inner->m_item;
    }
};

template <class T>
struct HashTableTraits<T, false /* non-intrusive */, true /* single detachment */>
{
    struct InnerNode;
    struct OuterNode;
    typedef DlistM<InnerNode> List;
    typedef SlistM<OuterNode> Bucket;
    typedef DlistMI<InnerNode> InnerNodeIterator;
    typedef SlistMI<OuterNode> OuterNodeIterator;
    typedef DlinkB InnerNodeBase;
    typedef SlinkB OuterNodeBase;

    struct InnerNode : public DlinkB
    {
        T *m_item;
    };

    struct OuterNode : public SlinkB
    {
        InnerNode m_inner;
        OuterNode(T *item, List &inners)
        {
            m_inner.m_item = item;
            inners.append(&m_inner);
        }
        InnerNode *getCurrentInnerNode(const List &)
        {
            return &m_inner;
        }
        InnerNode *getPreviousInnerNode() // required by single detachment
        {
            return static_cast<InnerNode *>(m_inner.getPrev());
        }
        lifeGuardNewAndDeleteMacro
    };

    static T *getItem(InnerNode *inner)
    {
        return inner->m_item;
    }
};

///
/// @param K key type
/// @param T item type
/// @param intrusive intrusive hash table or not
/// @param detachment support single element detachment or not
///
// If 'HashPolicy' and 'EqualPolicy' have no data members, aggregating their instances in
// 'HashTable' may waste some memories.  Instead, inheritance may fix this issue.
template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
class HashTable : public HashTableBase,
    private HashPolicy, private EqualPolicy, private HashTableTraits<T, intrusive, detachment>
{
    typedef HashTableTraits<T, intrusive, detachment> Traits;
    typedef typename Traits::InnerNode InnerNode;
    typedef typename Traits::OuterNode OuterNode;
    typedef typename Traits::InnerNodeIterator InnerNodeIterator;
    typedef typename Traits::OuterNodeIterator OuterNodeIterator;
    typedef typename Traits::Bucket Bucket;
    typedef typename Traits::List List;
    typedef typename Traits::InnerNodeBase InnerNodeBase;
    typedef typename Traits::OuterNodeBase OuterNodeBase;
    typedef typename KeyTypeTraits<K>::KeyType KeyType;
    static T *getItem(InnerNode *inner) {
        return Traits::getItem(inner);
    }
private:
    Bucket *m_buckets; ///< array of bucket
    List m_inners; ///< list of all elements

public:
    struct iterator
    {
        const HashTable *m_ht;
        InnerNodeIterator m_impl;
        explicit iterator(const HashTable &ht) : m_ht(&ht), m_impl(ht.m_inners) { }
        explicit iterator(const HashTable *ht) : m_ht(ht), m_impl(ht->m_inners) { }
        iterator() { m_ht = 0; }
        T *operator++()
        {
            InnerNode *inner = ++m_impl;
            if (inner) {
                return m_ht->getItem(inner);
            }
            return 0;
        }
        T *operator++(int)
        {
            InnerNode *inner = m_impl++;
            if (inner) {
                return m_ht->getItem(inner);
            }
            return 0;
        }
        T *operator()() const
        {
            InnerNode *inner = m_impl();
            if (inner) {
                return m_ht->getItem(inner);
            }
            return 0;
        }
    };
    friend struct iterator;

    struct local_iterator
    {
        const HashTable *m_ht;
        OuterNodeIterator m_impl;
        local_iterator(const HashTable *ht, const Bucket &bucket) : m_ht(ht), m_impl(bucket) { }
        local_iterator() { m_ht = 0; }
        T *operator++()
        {
            OuterNode *outer = ++m_impl;
            if (outer) {
                InnerNode *inner = outer->getCurrentInnerNode(m_ht->m_inners);
                return m_ht->getItem(inner);
            }
            return 0;
        }
        T *operator++(int)
        {
            OuterNode *outer = m_impl++;
            if (outer) {
                InnerNode *inner = outer->getCurrentInnerNode(m_ht->m_inners);
                return m_ht->getItem(inner);
            }
            return 0;
        }
        T *operator()() const
        {
            OuterNode *outer = m_impl();
            if (outer) {
                InnerNode *inner = outer->getCurrentInnerNode(m_ht->m_inners);
                return m_ht->getItem(inner);
            }
            return 0;
        }
    };
    friend struct local_iterator;

private:
    static Bucket *createBuckets(int size);
    static void destroyBuckets(Bucket *first, int size);

private:
    void updatePreviousInnerNode(OuterNode *, IntrusiveType<false>) { }
    ///
    /// @param outer point to the outer node that will be removed from hash table.
    ///
    void updatePreviousInnerNode(OuterNode *outer, IntrusiveType<true>);

protected:
    HashTable(int size, const HashPolicy &hp, const EqualPolicy &ep)
        : HashTableBase(size), HashPolicy(hp), EqualPolicy(ep)
    {
        m_buckets = createBuckets(getSize());
    }
    HashTable(const HashPolicy &hp, const EqualPolicy &ep)
        : HashTableBase(), HashPolicy(hp), EqualPolicy(ep)
    {
        m_buckets = createBuckets(getSize());
    }
    ~HashTable()
    {
#ifdef ENGINEER
        // legacy requirement
        fassert(getNumEntries() == 0, "Destroy non-empty HashTable");
#endif
# 420 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"
        destroyBuckets(m_buckets, getSize());
    }

protected:
    lifeGuardNewAndDeleteMacro

public:
    T *lookup(const KeyType &key, int &index) const;
    T *lookup(const KeyType &key) const
    {
        int index;
        return lookup(key, index);
    }
    T *lookup(const T *item, int &index) const;
    T *lookup(const T * item) const
    {
        int index;
        return lookup(item, index);
    }

    local_iterator lookupI(const KeyType &key, int &index) const
    {
        index = hashToIndex(HashPolicy::getHash(key));
        return local_iterator(this, m_buckets[index]);
    }
    local_iterator lookupI(const KeyType &key) const
    {
        int index;
        return lookupI(key, index);
    }
    local_iterator lookupI(const T *item, int &index) const
    {
        index = hashToIndex(HashPolicy::getHash(item));
        return local_iterator(this, m_buckets[index]);
    }
    local_iterator lookupI(const T *item) const
    {
        int index;
        return lookupI(item, index);
    }

    void append(T *item, int index);
    void append(T *item)
    {
        append(item, hashToIndex(HashPolicy::getHash(item)));
    }

    T *detach(T *item, int index);
    T *detach(T *item)
    {
        return detach(item, hashToIndex(HashPolicy::getHash(item)));
    }
    T *detachAt(iterator &iter)
    {
        T *item = iter++;
        if (item) {
            detach(item);
        }
        return item;
    }
    void detachItems();
    T *detachFirst();

    void deleteItems();

    void steal(HashTable &ht);

    // TODO: debug utility
    void show() const
    {
        mprintf("not implemented");
    }
    void showStats(const char *) const
    {
        mprintf("not implemented");
    }

    size_t getMemSizeOf() const;

private:
    void flushAfterStolen()
    {
        m_buckets = 0;
        flush();
    }

    void growTable();
}; // class HashTable

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
typename HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::Bucket *
HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::createBuckets(int size)
{
    Bucket *first = reinterpret_cast<Bucket *>(lifeGuardCreateArray(getCurrentLifeGuard(),
                sizeof(Bucket), size));
    memcheck(first);
    Bucket *last = first + size;
    for (Bucket *bucket = first; bucket != last; ++bucket) {
        ::new (bucket) Bucket();
    }
    return first;
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
void HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::destroyBuckets(Bucket *first, int size)
{
    if (!first) {
        return;
    }
    Bucket *last = first + size;
    for (Bucket *bucket = first; bucket != last; ++bucket) {
        bucket->~Bucket();
    }
    getCurrentLifeGuard()->destroyArray(first, sizeof(Bucket), size);
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
void HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::updatePreviousInnerNode(OuterNode *outer, IntrusiveType<true>)
{
    InnerNode *next_inner = outer->getNextInnerNode(m_inners);
    if (!next_inner) {
        return;
    }
    // find the outer node corresponding to next inner node and update its previous inner node.
    T *next_item = getItem(next_inner);
    int index = hashToIndex(HashPolicy::getHash(next_item));
    OuterNodeIterator iter(m_buckets[index]);
    while (OuterNode *next_outer = iter++) {
        if (next_item == getItem(next_outer->getCurrentInnerNode(m_inners))) {
            next_outer->setPreviousInnerNode(outer->getPreviousInnerNode());
            return;
        }
    }
    fatal(msg("HashTable::updatePreviousInnerNode can't find the outer node"));
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
T *HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::lookup(const KeyType &key, int &index) const
{
    index = hashToIndex(HashPolicy::getHash(key));
    OuterNodeIterator iter(m_buckets[index]);
    while (OuterNode *outer = iter++) {
        InnerNode *inner = outer->getCurrentInnerNode(m_inners);
        if (EqualPolicy::testEquality(key, getItem(inner))) {
            return getItem(inner);
        }
    }
    return 0;
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
T *HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::lookup(const T *item, int &index) const
{
    index = hashToIndex(HashPolicy::getHash(item));
    OuterNodeIterator iter(m_buckets[index]);
    while (OuterNode *outer = iter++) {
        InnerNode *inner = outer->getCurrentInnerNode(m_inners);
        if (EqualPolicy::testEquality(item, getItem(inner))) {
            return getItem(inner);
        }
    }
    return 0;
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
void HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::append(T *item, int index)
{
    fassert(index == hashToIndex(HashPolicy::getHash(item)),
            msg("Bad index for HashTable::append"));
    // The corresponding inner node is automatically appended into the list
    // when constructing outer node.
    OuterNode *outer = new OuterNode(item, m_inners);
    // m_inners.append(inner);
    m_buckets[index].append(outer);
    incrEntries();
    if (mustGrow()) {
        growTable();
    }
#ifdef ENGINEER
    appendLinkedItemCallback(this, item);
#endif
# 601 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
T *HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::detach(T *item, int index)
{
    fassert(index == hashToIndex(HashPolicy::getHash(item)),
            msg("Bad index for HashTable::detach"));
    OuterNodeIterator iter(m_buckets[index]);
    OuterNode *outer = iter++;
    if (!outer) {
        fatal(msg("HashTable::detach can't find the given item"));
        return 0;
    }
    if (getItem(outer->getCurrentInnerNode(m_inners)) == item) {
        m_buckets[index].detachFirst();
    } else {
        OuterNodeBase *prev_outer = outer;
        outer = iter++;
        while (outer) {
            if (getItem(outer->getCurrentInnerNode(m_inners)) == item) {
                m_buckets[index].detachNext(prev_outer);
                break;
            }
            prev_outer = outer;
            outer = iter++;
        }
        if (!outer) {
            fatal(msg("HashTable::detach can't find the given item"));
            return 0;
        }
    }
    InnerNodeBase *prev_inner = outer->getPreviousInnerNode();
    // Only intrusive hash table needs to update previous inner node.
    // FIXME: how to dispatch at compile time more gracefully?
    updatePreviousInnerNode(outer, IntrusiveType<intrusive>());
    if (prev_inner) {
        m_inners.detachNext(prev_inner);
    } else {
        m_inners.detachFirst();
    }
    delete outer;
    decrEntries();
#ifdef ENGINEER
    detachLinkedItemCallback(this, item);
#endif
# 646 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"
    return item;
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
void HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::detachItems()
{
    if (getNumEntries() > 0) {
        while (m_inners.detachFirst()) { }
        Bucket *first = m_buckets;
        Bucket *last = first + getSize();
        for (Bucket *bucket = first; bucket < last; ++bucket) {
            while (OuterNode *outer = bucket->detachFirst()) {
                delete outer;
            }
        }
#ifdef ENGINEER
        detachAllLinkedItemCallback(this, getNumEntries());
#endif
# 664 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"
        flushEntries();
    }
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
T *HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::detachFirst()
{
    InnerNode *inner = m_inners.getFirst();
    if (inner) {
        T *item = getItem(inner);
        detach(item);
        return item;
    }
    return 0;
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
void HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::deleteItems()
{
    if (getNumEntries() > 0) {
        while (InnerNode *inner = m_inners.detachFirst()) {
            delete getItem(inner);
        }
        Bucket *first = m_buckets;
        Bucket *last = first + getSize();
        for (Bucket *bucket = first ; bucket < last; ++bucket) {
            while (OuterNode *outer = bucket->detachFirst()) {
                delete outer;
            }
        }
#ifdef ENGINEER
        detachAllLinkedItemCallback(this, getNumEntries());
#endif
# 697 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"
        flushEntries();
    }
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
void HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::steal(HashTable &ht)
{
    fassert(!getNumEntries(), msg("Steal into non-empty HashTable"));
    destroyBuckets(m_buckets, getSize());
    m_buckets = ht.m_buckets;
    m_inners.steal(ht.m_inners);
    copyBaseAttributes(ht);
    ht.flushAfterStolen();
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
void HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::growTable()
{
    int oldSize = getSize();
    growSize();
    if (oldSize == getSize()) {
        warning(msg("HashTable::growTable doesn't grow"));
        return;
    }
    Bucket *buckets = createBuckets(getSize());
    // remove from old buckets, and append into new buckets
    Bucket *first = m_buckets;
    Bucket *last = m_buckets + oldSize;
    for (Bucket *bucket = first; bucket < last; ++bucket) {
        while (OuterNode *outer = bucket->detachFirst()) {
            int i = hashToIndex(HashPolicy::getHash(getItem(outer->getCurrentInnerNode(m_inners))));
            buckets[i].append(outer);
        }
    }
    destroyBuckets(m_buckets, oldSize);
    m_buckets = buckets;
}

template <typename K, class T, class HashPolicy, class EqualPolicy, bool intrusive, bool detachment>
size_t HashTable<K, T, HashPolicy, EqualPolicy, intrusive, detachment>::getMemSizeOf() const
{
    size_t total = getSize() * sizeof(Bucket);
    Bucket *first = m_buckets;
    Bucket *last = m_buckets + getSize();
    for (Bucket *bucket = first; bucket < last; ++bucket) {
        total += (bucket->countItems() * sizeof(OuterNode));
    }
    return total;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct HashPolicyForHashTableL
{
    uint getHash(const char *key) const
    {
        return HashTableBase::hash(key);
    }
    uint getHash(const T *item) const
    {
        return HashTableBase::hash(item->getName());
    }
    // In rare cases, legacy codes doesn't declare T::getName() as const member function.
    // e.g., radify-src/covdbreader/srcinfo.hh: SrcInfo::getName
    // Instead of modifying these legacy codes, overloading hash method is a remedy.
    uint getHash(T *item) const
    {
        return HashTableBase::hash(item->getName());
    }
};

template <class T>
struct EqualPolicyForHashTableL
{
    bool testEquality(const char *key, const T *item) const
    {
        return ::strcmp(key, item->getName()) == 0;
    }
    bool testEquality(const char *key, T *item) const
    {
        return ::strcmp(key, item->getName()) == 0;
    }
};

template <class T, bool detachment = true>
class HashTableL : public HashTable<const char *, T,
    HashPolicyForHashTableL<T>, EqualPolicyForHashTableL<T>, false /* non-intrusive */, detachment>
{
    typedef HashTable<const char *, T, HashPolicyForHashTableL<T>, EqualPolicyForHashTableL<T>,
        false /* non-intrusive */, detachment> Base;
public:
    explicit HashTableL(int size) : Base(size, HashPolicyForHashTableL<T>(), EqualPolicyForHashTableL<T>()) { }
    HashTableL() : Base(HashPolicyForHashTableL<T>(), EqualPolicyForHashTableL<T>()) { }
    ~HashTableL() { }
public:
    lifeGuardNewAndDeleteMacro
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct HashPolicyForHashTableM
{
    uint getHash(const char *key) const
    {
        return HashTableBase::hash(key);
    }
    uint getHash(const T *item) const
    {
        return HashTableBase::hash(item->getName());
    }
    uint getHash(T *item) const
    {
        return HashTableBase::hash(item->getName());
    }
};

template <class T>
struct EqualPolicyForHashTableM
{
    bool testEquality(const char *key, const T *item) const
    {
        return ::strcmp(key, item->getName()) == 0;
    }
    bool testEquality(const char *key, T *item) const
    {
        return ::strcmp(key, item->getName()) == 0;
    }
};

template <class T, bool detachment = true>
class HashTableM : public HashTable<const char *, T,
    HashPolicyForHashTableM<T>, EqualPolicyForHashTableM<T>, true /* intrusive */, detachment>
{
    typedef HashTable<const char *, T, HashPolicyForHashTableM<T>, EqualPolicyForHashTableM<T>,
        true /* intrusive */, detachment> Base;
public:
    explicit HashTableM(int size) : Base(size, HashPolicyForHashTableM<T>(), EqualPolicyForHashTableM<T>()) { }
    HashTableM() : Base(HashPolicyForHashTableM<T>(), EqualPolicyForHashTableM<T>()) { }
    ~HashTableM() { }
public:
    lifeGuardNewAndDeleteMacro
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct HashPolicyForHashTableP
{
    uint (*m_hf)(const T *); // hash function
    explicit HashPolicyForHashTableP(uint (*hf)(const T *)) : m_hf(hf) { }
    HashPolicyForHashTableP() : m_hf() { }
    uint getHash(const T *item) const
    {
        return m_hf(item);
    }
};

template <class T>
struct EqualPolicyForHashTableP
{
    bool (*m_eq)(const T *, const T *); // equal function
    explicit EqualPolicyForHashTableP(bool (*eq)(const T *, const T *)) : m_eq(eq) { }
    EqualPolicyForHashTableP() : m_eq() { }
    bool testEquality(const T *lhs, const T *rhs) const
    {
        return m_eq(lhs, rhs);
    }
};

template <class T, bool detachment = true>
class HashTableP : public HashTable<void, T, HashPolicyForHashTableP<T>, EqualPolicyForHashTableP<T>,
    false /* non-intrusive */, detachment>
{
    typedef HashTable<void, T, HashPolicyForHashTableP<T>, EqualPolicyForHashTableP<T>,
        false /* non-intrusive */, detachment> Base;
public:
    HashTableP(uint (*hf)(const T *), bool (*eq)(const T *, const T *), int size)
        : Base(size, HashPolicyForHashTableP<T>(hf), EqualPolicyForHashTableP<T>(eq))
    {
        nullcheck(hf);
        nullcheck(eq);
    }
    HashTableP(uint (*hf)(const T *), bool (*eq)(const T *, const T *))
        : Base(HashPolicyForHashTableP<T>(hf), EqualPolicyForHashTableP<T>(eq))
    {
        nullcheck(hf);
        nullcheck(eq);
    }
    HashTableP() : Base(HashPolicyForHashTableP<T>(), EqualPolicyForHashTableP<T>()) { }
    ~HashTableP() { }
public:
    lifeGuardNewAndDeleteMacro
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct HashPolicyForHashTableQ
{
    uint (*m_hf)(const T *); // hash function
    explicit HashPolicyForHashTableQ(uint (*hf)(const T *)) : m_hf(hf) { }
    HashPolicyForHashTableQ() : m_hf() { }
    uint getHash(const T *item) const
    {
        return m_hf(item);
    }
};

template <class T>
struct EqualPolicyForHashTableQ
{
    bool (*m_eq)(const T *, const T *); // equal function
    explicit EqualPolicyForHashTableQ(bool (*eq)(const T *, const T *)) : m_eq(eq) { }
    EqualPolicyForHashTableQ() : m_eq() { }
    bool testEquality(const T *lhs, const T *rhs) const
    {
        return m_eq(lhs, rhs);
    }
};

template <class T, bool detachment = true>
class HashTableQ : public HashTable<void, T, HashPolicyForHashTableQ<T>, EqualPolicyForHashTableQ<T>,
    true /* intrusive */, detachment>
{
    typedef HashTable<void, T, HashPolicyForHashTableQ<T>, EqualPolicyForHashTableQ<T>,
        true /* intrusive */, detachment> Base;
public:
    HashTableQ(uint (*hf)(const T *), bool (*eq)(const T *, const T *), int size)
        : Base(size, HashPolicyForHashTableQ<T>(hf), EqualPolicyForHashTableQ<T>(eq))
    {
        nullcheck(hf);
        nullcheck(eq);
    }
    HashTableQ(uint (*hf)(const T *), bool (*eq)(const T *, const T *))
        : Base(HashPolicyForHashTableQ<T>(hf), EqualPolicyForHashTableQ<T>(eq))
    {
        nullcheck(hf);
        nullcheck(eq);
    }
    HashTableQ() : Base(HashPolicyForHashTableQ<T>(), EqualPolicyForHashTableQ<T>()) { }
    ~HashTableQ() { }
public:
    lifeGuardNewAndDeleteMacro
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T>
struct HashPolicyForHashTableKeyL
{
    uint (*m_key_hash)(K); // key hash function
    uint (*m_item_hash)(const T *); // item hash function
    HashPolicyForHashTableKeyL(uint (*key_hash)(K), uint (*item_hash)(const T *))
        : m_key_hash(key_hash), m_item_hash(item_hash) { }
    HashPolicyForHashTableKeyL() : m_key_hash(), m_item_hash() { }
    uint getHash(K key) const
    {
        return m_key_hash(key);
    }
    uint getHash(const T *item) const
    {
        return m_item_hash(item);
    }
};

template <typename K, class T>
struct EqualPolicyForHashTableKeyL
{
    bool (*m_eq)(K, const T *); // equal function
    explicit EqualPolicyForHashTableKeyL(bool (*eq)(K, const T *)) : m_eq(eq) { }
    EqualPolicyForHashTableKeyL() : m_eq() { }
    bool testEquality(K key, const T *item) const
    {
        return m_eq(key, item);
    }
    bool testEquality(const T *lhs, const T *rhs) const // used by lookup(const T *)
    {
        return lhs == rhs;
    }
};

template <typename K, class T, bool detachment = true>
class HashTableKeyL : public HashTable<K, T,
    HashPolicyForHashTableKeyL<K, T>, EqualPolicyForHashTableKeyL<K, T>,
    false /* non-intrusive */, detachment>
{
    typedef HashTable<K, T, HashPolicyForHashTableKeyL<K, T>, EqualPolicyForHashTableKeyL<K, T>,
        false /* non-intrusive */, detachment> Base;
public:
    HashTableKeyL(uint (*kh)(K), uint (*ih)(const T *), bool (*eq)(K, const T *), int size)
        : Base(size, HashPolicyForHashTableKeyL<K, T>(kh, ih), EqualPolicyForHashTableKeyL<K, T>(eq))
    {
        nullcheck(kh);
        nullcheck(ih);
        nullcheck(eq);
    }
    HashTableKeyL(uint (*kh)(K), uint (*ih)(const T *), bool (*eq)(K, const T *))
        : Base(HashPolicyForHashTableKeyL<K, T>(kh, ih), EqualPolicyForHashTableKeyL<K, T>(eq))
    {
        nullcheck(kh);
        nullcheck(ih);
        nullcheck(eq);
    }
    HashTableKeyL() : Base(HashPolicyForHashTableKeyL<K, T>(), EqualPolicyForHashTableKeyL<K, T>()) { }
    ~HashTableKeyL() { }
public:
    lifeGuardNewAndDeleteMacro
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T>
struct HashPolicyForHashTableKeyM
{
    uint (*m_key_hash)(const K &); // key hash function
    uint (*m_item_hash)(const T *); // item hash function
    HashPolicyForHashTableKeyM(uint (*key_hash)(const K &), uint (*item_hash)(const T *))
        : m_key_hash(key_hash), m_item_hash(item_hash) { }
    HashPolicyForHashTableKeyM() : m_key_hash(), m_item_hash() { }
    uint getHash(const K &key) const
    {
        return m_key_hash(key);
    }
    uint getHash(const T *item) const
    {
        return m_item_hash(item);
    }
};

template <typename K, class T>
struct EqualPolicyForHashTableKeyM
{
    bool (*m_eq)(const K &, const T *); // equal function
    explicit EqualPolicyForHashTableKeyM(bool (*eq)(const K &, const T *)) : m_eq(eq) { }
    EqualPolicyForHashTableKeyM() : m_eq() { }
    bool testEquality(const K &key, const T *item) const
    {
        return m_eq(key, item);
    }
    bool testEquality(const T *lhs, const T *rhs) const // used by lookup(const T *)
    {
        return lhs == rhs;
    }
};

template <typename K, class T, bool detachment = true>
class HashTableKeyM : public HashTable<K, T,
    HashPolicyForHashTableKeyM<K, T>, EqualPolicyForHashTableKeyM<K, T>,
    true /* intrusive */, detachment>
{
    typedef HashTable<K, T, HashPolicyForHashTableKeyM<K, T>, EqualPolicyForHashTableKeyM<K, T>,
        true /* intrusive */, detachment> Base;
public:
    HashTableKeyM(uint (*kh)(const K &), uint (*ih)(const T *), bool (*eq)(const K &, const T *), int size)
        : Base(size, HashPolicyForHashTableKeyM<K, T>(kh, ih), EqualPolicyForHashTableKeyM<K, T>(eq))
    {
        nullcheck(kh);
        nullcheck(ih);
        nullcheck(eq);
    }
    HashTableKeyM(uint (*kh)(const K &), uint (*ih)(const T *), bool (*eq)(const K &, const T *))
        : Base(HashPolicyForHashTableKeyM<K, T>(kh, ih), EqualPolicyForHashTableKeyM<K, T>(eq))
    {
        nullcheck(kh);
        nullcheck(ih);
        nullcheck(eq);
    }
    HashTableKeyM() : Base(HashPolicyForHashTableKeyM<K, T>(), EqualPolicyForHashTableKeyM<K, T>()) { }
    ~HashTableKeyM() { }
public:
    lifeGuardNewAndDeleteMacro
};
} // namespace linked 
} // namespace internal

#endif // LINKED_HASH_HH
# 1075 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/linked_hash.hh"

# 1638 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh" 2

namespace internal
{
//////////////////////////////////////////////////////////////////////////////////////////
template <class T, bool linked, bool detachment>
struct HashTableLTraits;

template <class T>
struct HashTableLTraits<T, false /* unlinked */, true /* single element detachment */>
{
    typedef internal::unlinked::HashTableL<T> HashTable;
    typedef internal::unlinked::HashTableLI<T> Iterator;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked, bool detachment>
struct HashTableMTraits;

template <class T>
struct HashTableMTraits<T, false /* unlinked */, true /* single element detachment */>
{
    typedef internal::unlinked::HashTableM<T> HashTable;
    typedef internal::unlinked::HashTableMI<T> Iterator;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked, bool detachment>
struct HashTablePTraits;

template <class T>
struct HashTablePTraits<T, false /* unlinked */, true /* single element detachment */>
{
    typedef internal::unlinked::HashTableP<T> HashTable;
    typedef internal::unlinked::HashTablePI<T> Iterator;
};

template <class T, bool detachment>
struct HashTablePTraits<T, true /* linked */, detachment>
{
    typedef internal::linked::HashTableP<T, detachment> HashTable;
    typedef typename HashTable::iterator Iterator;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked, bool detachment>
struct HashTableQTraits;

template <class T>
struct HashTableQTraits<T, false /* unlinked */, true /* single element detachment */>
{
    typedef internal::unlinked::HashTableQ<T> HashTable;
    typedef internal::unlinked::HashTableQI<T> Iterator;
};

template <class T, bool detachment>
struct HashTableQTraits<T, true /* linked */, detachment>
{
    typedef internal::linked::HashTableQ<T, detachment> HashTable;
    typedef typename HashTable::iterator Iterator;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T, bool linked, bool detachment>
struct HashTableKeyLTraits;

template <typename K, class T>
struct HashTableKeyLTraits<K, T, false /* unlinked */, true /* single element detachment */>
{
    typedef internal::unlinked::HashTableKeyL<K, T> HashTable;
    typedef internal::unlinked::HashTableKeyLI<K, T> Iterator;
};

template <typename K, class T, bool detachment>
struct HashTableKeyLTraits<K, T, true /* linked */, detachment>
{
    typedef internal::linked::HashTableKeyL<K, T, detachment> HashTable;
    typedef typename HashTable::iterator Iterator;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T, bool linked, bool detachment>
struct HashTableKeyMTraits;

template <typename K, class T>
struct HashTableKeyMTraits<K, T, false /* unlinked */, true /* single element detachment */>
{
    typedef internal::unlinked::HashTableKeyM<K, T> HashTable;
    typedef internal::unlinked::HashTableKeyMI<K, T> Iterator;
};

template <typename K, class T, bool detachment>
struct HashTableKeyMTraits<K, T, true /* linked */, detachment>
{
    typedef internal::linked::HashTableKeyM<K, T, detachment> HashTable;
    typedef typename HashTable::iterator Iterator;
};
} // namespace internal

#undef HashTableL
#undef HashTableM
#undef HashTableP
#undef HashTableQ
#undef HashTableKeyL
#undef HashTableKeyM
#undef HashTableLI
#undef HashTableMI
#undef HashTablePI
#undef HashTableQI
#undef HashTableKeyLI
#undef HashTableKeyMI

// Unlinked hash table always supports single element detachment.
// Compile error if template arguments 'linked' and 'detachment' violate this requirment.

// Attention: Currently, the template argument 'linked' shall be false.
// Next step: test linked hash table and enable it.

// Unlinked HashTableL and HashTableM can give a well-defined deterministic traversal order
// because they hash element's name. So, the template argument 'linked' shall be false.

// Life would be better if C++ compiler does support 'typedef template'.
/*
template <class T, bool linked = false, bool detachment = true>
using HashTableL = HashTableLTraits<T, linked, detachment>::HashTable;
*/

template <class T, bool linked = false, bool detachment = true>
class HashTableL : public internal::HashTableLTraits<T, linked, detachment>::HashTable
{
    typedef typename internal::HashTableLTraits<T, linked, detachment>::HashTable Base;
public:
    explicit HashTableL(int pSize) : Base(pSize) { }
    HashTableL() { }
private:
    HashTableL(const HashTableL &); // = deleted; // not implemented
    HashTableL &operator=(const HashTableL &); // = deleted; // not implemented
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked = false, bool detachment = true>
class HashTableM : public internal::HashTableMTraits<T, linked, detachment>::HashTable
{
    typedef typename internal::HashTableMTraits<T, linked, detachment>::HashTable Base;
public:
    explicit HashTableM(int pSize) : Base(pSize) { }
    HashTableM() { }
private:
    HashTableM(const HashTableM &); // = deleted; // not implemented
    HashTableM &operator=(const HashTableM &); // = deleted; // not implemented
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

// Legacy hash table implementation doesn't have the nested type definition HashTableX::iterator.
// So, legacy user codes have widely used HashTableXI instead.
// We don't want to modify lots of legacy user codes.
// So, we reimplement HashTableXI at library level.
template <class T, bool linked = false, bool detachment = true>
class HashTableLI : public internal::HashTableLTraits<T, linked, detachment>::Iterator
{
    typedef typename internal::HashTableLTraits<T, linked, detachment>::Iterator Base;
    typedef HashTableL<T, linked, detachment> HashTable; // The corresponding hash table container
public:
    HashTableLI(const HashTable &ht) : Base(ht) { }
    HashTableLI(const HashTable *ht) : Base(ht) { }
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked = false, bool detachment = true>
class HashTableMI : public internal::HashTableMTraits<T, linked, detachment>::Iterator
{
    typedef typename internal::HashTableMTraits<T, linked, detachment>::Iterator Base;
    typedef HashTableM<T, linked, detachment> HashTable; // The corresponding hash table container
public:
    HashTableMI(const HashTable &ht) : Base(ht) { }
    HashTableMI(const HashTable *ht) : Base(ht) { }
public:
    lifeGuardNewAndDeleteMacro
};

template<class T>
struct HashTableX {
    typedef typename internal::HashTablePTraits<T, false, true>::HashTable   UnlinkedP;
    typedef typename internal::HashTablePTraits<T, false, true>::Iterator    UnlinkedPI;
    typedef typename internal::HashTablePTraits<T, true, true>::HashTable    LinkedP;
    typedef typename internal::HashTablePTraits<T, true, true>::Iterator     LinkedPI;
    typedef typename internal::HashTableQTraits<T, false, true>::HashTable   UnlinkedQ;
    typedef typename internal::HashTableQTraits<T, false, true>::Iterator    UnlinkedQI;
    typedef typename internal::HashTableQTraits<T, true, true>::HashTable    LinkedQ;
    typedef typename internal::HashTableQTraits<T, true, true>::Iterator     LinkedQI;
};

template<class K, class T>
struct HashTableKeyX {
    typedef typename internal::HashTableKeyLTraits<K, T, false, true>::HashTable UnlinkedL;
    typedef typename internal::HashTableKeyLTraits<K, T, false, true>::Iterator  UnlinkedLI;
    typedef typename internal::HashTableKeyLTraits<K, T, true, true>::HashTable  LinkedL;
    typedef typename internal::HashTableKeyLTraits<K, T, true, true>::Iterator   LinkedLI;
    typedef typename internal::HashTableKeyMTraits<K, T, false, true>::HashTable UnlinkedM;
    typedef typename internal::HashTableKeyMTraits<K, T, false, true>::Iterator  UnlinkedMI;
    typedef typename internal::HashTableKeyMTraits<K, T, true, true>::HashTable  LinkedM;
    typedef typename internal::HashTableKeyMTraits<K, T, true, true>::Iterator   LinkedMI;
};

#ifndef RUNTIME
// default linked hash table in compile time
#define DEFAULT_LINKED_HASH_TABLE true
#else
# 1859 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
#define DEFAULT_LINKED_HASH_TABLE false
#endif
# 1861 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"

#if defined(ENGINEER)
#if 0 /* expanded by -frewrite-includes */
#include "engineer_hash.hh"
#endif /* expanded by -frewrite-includes */
# 1863 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 1864 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
#else
# 1865 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
template <class T, bool linked = DEFAULT_LINKED_HASH_TABLE, bool detachment = true>
class HashTableP : public internal::HashTablePTraits<T, linked, detachment>::HashTable
{
    typedef typename internal::HashTablePTraits<T, linked, detachment>::HashTable Base;
public:
    HashTableP(uint (*pHashFunc)(const T *),
            bool (*pEqFunc)(const T *, const T *),
            int pSize)
        : Base(pHashFunc, pEqFunc, pSize)
    {
    }
    HashTableP(uint (*pHashFunc)(const T *), bool (*pEqFunc)(const T *, const T *))
        : Base(pHashFunc, pEqFunc)
    {
    }
    HashTableP() { }
private:
    HashTableP(const HashTableP &); // = deleted; // not implemented
    HashTableP &operator=(const HashTableP &); // = deleted; // not implemented
public:
    lifeGuardNewAndDeleteMacro
};

// Simple wrapper for pointers, with predefined pointer hash function.
template <class T, bool linked = DEFAULT_LINKED_HASH_TABLE, bool detachment = true>
class HashTablePtrP : public HashTableP<T, linked, detachment>
{
    typedef HashTableP<T, linked, detachment> Base;
public:
    explicit HashTablePtrP(int pSize)
        : Base(HashTableBase::defaultPtrHash, HashTableBase::defaultPtrEq, pSize)
    {
    }
    HashTablePtrP()
        : Base(HashTableBase::defaultPtrHash, HashTableBase::defaultPtrEq)
    {
    }
private:
    HashTablePtrP(const HashTablePtrP &); // = deleted; // not implemented
    HashTablePtrP &operator=(const HashTablePtrP &); // = deleted; // not implemented
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked = false, bool detachment = true>
class HashTableQ : public internal::HashTableQTraits<T, linked, detachment>::HashTable
{
    typedef typename internal::HashTableQTraits<T, linked, detachment>::HashTable Base;
public:
    HashTableQ(uint (*pHashFunc)(const T *),
            bool (*pEqFunc)(const T *, const T *),
            int pSize)
        : Base(pHashFunc, pEqFunc, pSize)
    {
    }
    HashTableQ(uint (*pHashFunc)(const T *), bool (*pEqFunc)(const T *, const T *))
        : Base(pHashFunc, pEqFunc)
    {
    }
    HashTableQ() { }
private:
    HashTableQ(const HashTableQ &); // = deleted; // not implemented
    HashTableQ &operator=(const HashTableQ &); // = deleted; // not implemented
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T, bool linked = DEFAULT_LINKED_HASH_TABLE, bool detachment = true>
class HashTableKeyL : public internal::HashTableKeyLTraits<K, T, linked, detachment>::HashTable
{
    typedef typename internal::HashTableKeyLTraits<K, T, linked, detachment>::HashTable Base;
public:
    HashTableKeyL(uint (*pHashFuncKey)(K),
            uint (*pHashFuncItem)(const T *),
            bool (*pEqFunc)(K, const T *),
            int pSize)
        : Base(pHashFuncKey, pHashFuncItem, pEqFunc, pSize)
    {
    }
    HashTableKeyL(uint (*pHashFuncKey)(K),
            uint (*pHashFuncItem)(const T *),
            bool (*pEqFunc)(K, const T *))
        : Base(pHashFuncKey, pHashFuncItem, pEqFunc)
    {
    }
    HashTableKeyL() { }
private:
    HashTableKeyL(const HashTableKeyL &); // = deleted; // not implemented
    HashTableKeyL &operator=(const HashTableKeyL &); // = deleted; // not implemented
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T, bool linked = DEFAULT_LINKED_HASH_TABLE, bool detachment = true>
class HashTableKeyM : public internal::HashTableKeyMTraits<K, T, linked, detachment>::HashTable
{
    typedef typename internal::HashTableKeyMTraits<K, T, linked, detachment>::HashTable Base;
public:
    HashTableKeyM(uint (*pHashFuncKey)(const K &),
            uint (*pHashFuncItem)(const T *),
            bool (*pEqFunc)(const K &, const T *),
            int pSize)
        : Base(pHashFuncKey, pHashFuncItem, pEqFunc, pSize)
    {
    }
    HashTableKeyM(uint (*pHashFuncKey)(const K &),
            uint (*pHashFuncItem)(const T *),
            bool (*pEqFunc)(const K &, const T *))
        : Base(pHashFuncKey, pHashFuncItem, pEqFunc)
    {
    }
    HashTableKeyM() { }
private:
    HashTableKeyM(const HashTableKeyM &); // = deleted; // not implemented
    HashTableKeyM &operator=(const HashTableKeyM &); // = deleted; // not implemented
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked = DEFAULT_LINKED_HASH_TABLE, bool detachment = true>
class HashTablePI : public internal::HashTablePTraits<T, linked, detachment>::Iterator
{
    typedef typename internal::HashTablePTraits<T, linked, detachment>::Iterator Base;
    typedef HashTableP<T, linked, detachment> HashTable; // The corresponding hash table container
public:
    HashTablePI(const HashTable &ht) : Base(ht) { }
    HashTablePI(const HashTable *ht) : Base(ht) { }
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <class T, bool linked = false, bool detachment = true>
class HashTableQI : public internal::HashTableQTraits<T, linked, detachment>::Iterator
{
    typedef typename internal::HashTableQTraits<T, linked, detachment>::Iterator Base;
    typedef HashTableQ<T, linked, detachment> HashTable; // The corresponding hash table container
public:
    HashTableQI(const HashTable &ht) : Base(ht) { }
    HashTableQI(const HashTable *ht) : Base(ht) { }
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T, bool linked = DEFAULT_LINKED_HASH_TABLE, bool detachment = true>
class HashTableKeyLI : public internal::HashTableKeyLTraits<K, T, linked, detachment>::Iterator
{
    typedef typename internal::HashTableKeyLTraits<K, T, linked, detachment>::Iterator Base;
    typedef HashTableKeyL<K, T, linked, detachment> HashTable; // The corresponding hash table container
public:
    HashTableKeyLI(const HashTable &ht) : Base(ht) { }
    HashTableKeyLI(const HashTable *ht) : Base(ht) { }
public:
    lifeGuardNewAndDeleteMacro
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename K, class T, bool linked = DEFAULT_LINKED_HASH_TABLE, bool detachment = true>
class HashTableKeyMI : public internal::HashTableKeyMTraits<K, T, linked, detachment>::Iterator
{
    typedef typename internal::HashTableKeyMTraits<K, T, linked, detachment>::Iterator Base;
    typedef HashTableKeyM<K, T, linked, detachment> HashTable; // The corresponding hash table container
public:
    HashTableKeyMI(const HashTable &ht) : Base(ht) { }
    HashTableKeyMI(const HashTable *ht) : Base(ht) { }
public:
    lifeGuardNewAndDeleteMacro
};
#endif // ENGINEER
# 2046 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"

//////////////////////////////////////////////////////////////////////////////////////////
// Legacy codes have widely used HashTableXLI by typedef.
// We dont' want to clean up those legacy codes although HashTableXLI is deprecated.
// So, we just declare the class template here to make compiler happy.
template <class T> class HashTableLLI;
template <class T> class HashTableMLI;
template <class T> class HashTablePLI;
template <class T> class HashTableQLI;
template <typename K, class T> class HashTableKeyLLI;
template <typename K, class T> class HashTableKeyMLI;

#ifdef INLINE_TMPL
#define TMPL_INLINE inline
#else
# 2061 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
#define TMPL_INLINE
#endif
# 2063 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"


// Templated definitions of Hash Table definitions.
// ==============================================================
// The templates are targetted to instantiate two kind
// of hash table.
// 1) Hash table whose key is the address of the class
//    itself.eg: Node Hash Table
// 2) Hash table whose key is some function of the members
//    of the class. For these classes, you have to add two methods
//    a) uint getKey(), which return the key with which you would
//       like to hash.
//       eg: MyHashTable = initHashTable<Class Type>(size)
//    b) bool isEqual(const <ClassType>*). This method should return
//       true, if another class is same as this class.
//       eg: MyHashTable = initHashTableWKey<Class Type>(size)

template<class T> TMPL_INLINE  uint hashFunc(const T* item)
{
    return HashTableBase::hash((UP)item);
}

template<class T> TMPL_INLINE  uint pHashFunc(const T* item)
{
    return HashTableBase::hash((void *)item);
}

template<class T> TMPL_INLINE  uint hashFuncWKey(const T* item)
{
    return item->getKey();
}

template<class T> TMPL_INLINE  bool eqFunc(const T* item1, const T* item2)
{
    return (item1 == item2);
}

template<class T> TMPL_INLINE  bool eqFuncWKey(const T* item1, const T* item2)
{
    return (item1->isEqual(item2));
}

// FIXME: Traditional C++ compiler doesn't support default template argument
// in function template.
/*
template <class T, bool linked = false, bool detachment = true> TMPL_INLINE
HashTableP<T, linked, detachment> *initHashTable(int size = 37)
{
    return new HashTableP<T, linked, detachment>(hashFunc<T>, eqFunc<T>, size);
}
*/

template<class T> TMPL_INLINE  HashTableP<T>* initHashTable(int size = 37)
{
    return new HashTableP<T>(hashFunc<T>, eqFunc<T>, size);
}

template<class T> TMPL_INLINE  HashTableP<T>* initHashTableWKey(int size = 37)
{
    return new HashTableP<T>(hashFuncWKey<T>, eqFuncWKey<T>, size);
}

template<class T> TMPL_INLINE  HashTableQ<T>* initHashTableQWKey(int size = 37)
{
    return new HashTableQ<T>(hashFuncWKey<T>, eqFuncWKey<T>, size);
}

template<class T> TMPL_INLINE  typename HashTableX<T>::UnlinkedP* initUnlinkedHashTable(int size = 37)
{
    return new typename HashTableX<T>::UnlinkedP(hashFunc<T>, eqFunc<T>, size);
}

template<class T> TMPL_INLINE  typename HashTableX<T>::UnlinkedP* initUnlinkedHashTableWKey(int size = 37)
{
    return new typename HashTableX<T>::UnlinkedP(hashFuncWKey<T>, eqFuncWKey<T>, size);
}

template<class T> TMPL_INLINE  typename HashTableX<T>::UnlinkedQ* initUnlinkedHashTableQWKey(int size = 37)
{
    return new typename HashTableX<T>::UnlinkedQ(hashFuncWKey<T>, eqFuncWKey<T>, size);
}

#ifdef _AIX
#undef fprintf
#undef printf
#endif
# 2149 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"

#if 0 /* expanded by -frewrite-includes */
#include "hash_conf.h"
#endif /* expanded by -frewrite-includes */
# 2150 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash_conf.h" 1
/* SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
 * of Synopsys, Inc., and is fully protected under copyright and trade
 * secret laws. You may not view, use, disclose, copy, or distribute
 * this file or any information contained herein except pursuant to a
 * valid written license from Synopsys.
 */

#ifndef HASH_CONF_HH
#define HASH_CONF_HH

#ifdef __cplusplus
extern "C" {
#endif
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash_conf.h"

void setLinkedHashTable(int on);
void setLinkedHashTableRange(unsigned low, unsigned high);
void enableHashTableDiagnostics(void);
void printHashTableDiagnostics(void);

#ifdef __cplusplus
} /* extern "C" */
#endif
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash_conf.h"

#endif /* HASH_CONF_HH */
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash_conf.h"

# 2151 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh" 2

#endif // _HASH_HH_
# 2153 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/hash.hh"

# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "pool.hh"
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 1 3
// <vector> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/vector
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_VECTOR
#define _GLIBCXX_VECTOR 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/allocator.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_construct.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 1 3
// nonstandard construct and destroy functions -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_construct.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */

#ifndef _STL_CONSTRUCT_H
#define _STL_CONSTRUCT_H 1

#if 0 /* expanded by -frewrite-includes */
#include <new>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/alloc_traits.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   * Constructs an object in existing memory by invoking an allocated
   * object's constructor with an initializer.
   */
#if __cplusplus >= 201103L
  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
#else
# 77 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_]allocator::construct
      ::new(static_cast<void*>(__p)) _T1(__value);
    }
#endif
# 86 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3

  /**
   * Destroy the object pointed to by a pointer type.
   */
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
	{
	  for (; __first != __last; ++__first)
	    std::_Destroy(std::__addressof(*__first));
	}
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };

  /**
   * Destroy a range of objects.  If the value_type of the object has
   * a trivial destructor, the compiler should optimize all of this
   * away, otherwise the objects' destructors must be invoked.
   */
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
	__destroy(__first, __last);
    }

  /**
   * Destroy a range of objects using the supplied allocator.  For
   * nondefault allocators we do not optimize away invocation of 
   * destroy() even if _Tp has a trivial destructor.
   */

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
	     _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
	__traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
	     allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif /* _STL_CONSTRUCT_H */
# 158 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_construct.h" 3

# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_uninitialized.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 1 3
// Raw memory manipulators -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_uninitialized.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */

#ifndef _STL_UNINITIALIZED_H
#define _STL_UNINITIALIZED_H 1

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
		      _ForwardIterator __result)
        {
	  _ForwardIterator __cur = __result;
	  __try
	    {
	      for (; __first != __last; ++__first, ++__cur)
		std::_Construct(std::__addressof(*__cur), *__first);
	      return __cur;
	    }
	  __catch(...)
	    {
	      std::_Destroy(__result, __cur);
	      __throw_exception_again;
	    }
	}
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
		      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };

  /**
   *  @brief Copies the range [first,last) into result.
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   __result + (__first - __last)
   *
   *  Like copy(), but does not require an initialized output range.
  */
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
		       _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
	_ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType2;
#if __cplusplus < 201103L
      const bool __assignable = true;
#else
# 117 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3
      // trivial types can have deleted assignment
      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
#endif
# 122 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3

      return std::__uninitialized_copy<__is_trivial(_ValueType1)
				       && __is_trivial(_ValueType2)
				       && __assignable>::
	__uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
		      const _Tp& __x)
        {
	  _ForwardIterator __cur = __first;
	  __try
	    {
	      for (; __cur != __last; ++__cur)
		std::_Construct(std::__addressof(*__cur), __x);
	    }
	  __catch(...)
	    {
	      std::_Destroy(__first, __cur);
	      __throw_exception_again;
	    }
	}
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
		      const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };

  /**
   *  @brief Copies the value x into the range [first,last).
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __x      The source value.
   *  @return   Nothing.
   *
   *  Like fill(), but does not require an initialized output range.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
		       const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;
#if __cplusplus < 201103L
      const bool __assignable = true;
#else
# 181 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3
      // trivial types can have deleted assignment
      const bool __assignable = is_copy_assignable<_ValueType>::value;
#endif
# 184 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3

      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
	__uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
			const _Tp& __x)
        {
	  _ForwardIterator __cur = __first;
	  __try
	    {
	      for (; __n > 0; --__n, ++__cur)
		std::_Construct(std::__addressof(*__cur), __x);
	      return __cur;
	    }
	  __catch(...)
	    {
	      std::_Destroy(__first, __cur);
	      __throw_exception_again;
	    }
	}
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
			const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };

   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // DR 1339. uninitialized_fill_n should return the end of its range
  /**
   *  @brief Copies the value x into the range [first,first+n).
   *  @param  __first  An input iterator.
   *  @param  __n      The number of copies to make.
   *  @param  __x      The source value.
   *  @return   Nothing.
   *
   *  Like fill_n(), but does not require an initialized output range.
  */
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;
#if __cplusplus < 201103L
      const bool __assignable = true;
#else
# 243 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3
      // trivial types can have deleted assignment
      const bool __assignable = is_copy_assignable<_ValueType>::value;
#endif
# 246 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3
      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
	__uninit_fill_n(__first, __n, __x);
    }

  // Extensions: versions of uninitialized_copy, uninitialized_fill,
  //  and uninitialized_fill_n that take an allocator parameter.
  //  We dispatch back to the standard versions when we're given the
  //  default allocator.  For nondefault allocators we do not use 
  //  any of the POD optimizations.

  template<typename _InputIterator, typename _ForwardIterator,
	   typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
			   _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      __try
	{
	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
	  for (; __first != __last; ++__first, ++__cur)
	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
	  return __cur;
	}
      __catch(...)
	{
	  std::_Destroy(__result, __cur, __alloc);
	  __throw_exception_again;
	}
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
			   _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
	   typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
			   _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
					 __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
	   typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
				       _InputIterator __last,
				       _ForwardIterator __result,
				       _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
			   const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      __try
	{
	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
	  for (; __cur != __last; ++__cur)
	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
	}
      __catch(...)
	{
	  std::_Destroy(__first, __cur, __alloc);
	  __throw_exception_again;
	}
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
			   const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
	   typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
			     const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      __try
	{
	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
	  for (; __n > 0; --__n, ++__cur)
	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
	  return __cur;
	}
      __catch(...)
	{
	  std::_Destroy(__first, __cur, __alloc);
	  __throw_exception_again;
	}
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
	   typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
			     const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }


  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
  // __uninitialized_fill_move, __uninitialized_move_fill.
  // All of these algorithms take a user-supplied allocator, which is used
  // for construction and destruction.

  // __uninitialized_copy_move
  // Copies [first1, last1) into [result, result + (last1 - first1)), and
  //  move [first2, last2) into
  //  [result, result + (last1 - first1) + (last2 - first2)).
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
			      _InputIterator1 __last1,
			      _InputIterator2 __first2,
			      _InputIterator2 __last2,
			      _ForwardIterator __result,
			      _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
							   __result,
							   __alloc);
      __try
	{
	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
	}
      __catch(...)
	{
	  std::_Destroy(__result, __mid, __alloc);
	  __throw_exception_again;
	}
    }

  // __uninitialized_move_copy
  // Moves [first1, last1) into [result, result + (last1 - first1)), and
  //  copies [first2, last2) into
  //  [result, result + (last1 - first1) + (last2 - first2)).
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
			      _InputIterator1 __last1,
			      _InputIterator2 __first2,
			      _InputIterator2 __last2,
			      _ForwardIterator __result,
			      _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
							   __result,
							   __alloc);
      __try
	{
	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
	}
      __catch(...)
	{
	  std::_Destroy(__result, __mid, __alloc);
	  __throw_exception_again;
	}
    }
  
  // __uninitialized_fill_move
  // Fills [result, mid) with x, and moves [first, last) into
  //  [mid, mid + (last - first)).
  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
	   typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
			      const _Tp& __x, _InputIterator __first,
			      _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      __try
	{
	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
	}
      __catch(...)
	{
	  std::_Destroy(__result, __mid, __alloc);
	  __throw_exception_again;
	}
    }

  // __uninitialized_move_fill
  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
  //  fills [first2 + (last1 - first1), last2) with x.
  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
	   typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
			      _ForwardIterator __first2,
			      _ForwardIterator __last2, const _Tp& __x,
			      _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
							    __first2,
							    __alloc);
      __try
	{
	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
	}
      __catch(...)
	{
	  std::_Destroy(__first2, __mid2, __alloc);
	  __throw_exception_again;
	}
    }

#if __cplusplus >= 201103L
  // Extensions: __uninitialized_default, __uninitialized_default_n,
  // __uninitialized_default_a, __uninitialized_default_n_a.

  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
	  _ForwardIterator __cur = __first;
	  __try
	    {
	      for (; __cur != __last; ++__cur)
		std::_Construct(std::__addressof(*__cur));
	    }
	  __catch(...)
	    {
	      std::_Destroy(__first, __cur);
	      __throw_exception_again;
	    }
	}
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
	  typedef typename iterator_traits<_ForwardIterator>::value_type
	    _ValueType;

	  std::fill(__first, __last, _ValueType());
	}
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
	  _ForwardIterator __cur = __first;
	  __try
	    {
	      for (; __n > 0; --__n, ++__cur)
		std::_Construct(std::__addressof(*__cur));
	      return __cur;
	    }
	  __catch(...)
	    {
	      std::_Destroy(__first, __cur);
	      __throw_exception_again;
	    }
	}
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
	  typedef typename iterator_traits<_ForwardIterator>::value_type
	    _ValueType;

	  return std::fill_n(__first, __n, _ValueType());
	}
    };

  // __uninitialized_default
  // Fills [first, last) with std::distance(first, last) default
  // constructed value_types(s).
  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
			    _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;
      // trivial types can have deleted assignment
      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
				     && __assignable>::
	__uninit_default(__first, __last);
    }

  // __uninitialized_default_n
  // Fills [first, first + n) with n default constructed value_type(s).
  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;
      // trivial types can have deleted assignment
      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
				       && __assignable>::
	__uninit_default_n(__first, __n);
    }


  // __uninitialized_default_a
  // Fills [first, last) with std::distance(first, last) default
  // constructed value_types(s), constructed with the allocator alloc.
  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
			      _ForwardIterator __last,
			      _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      __try
	{
	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
	  for (; __cur != __last; ++__cur)
	    __traits::construct(__alloc, std::__addressof(*__cur));
	}
      __catch(...)
	{
	  std::_Destroy(__first, __cur, __alloc);
	  __throw_exception_again;
	}
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
			      _ForwardIterator __last,
			      allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }


  // __uninitialized_default_n_a
  // Fills [first, first + n) with n default constructed value_types(s),
  // constructed with the allocator alloc.
  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
				_Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      __try
	{
	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
	  for (; __n > 0; --__n, ++__cur)
	    __traits::construct(__alloc, std::__addressof(*__cur));
	  return __cur;
	}
      __catch(...)
	{
	  std::_Destroy(__first, __cur, __alloc);
	  __throw_exception_again;
	}
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
				allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
	   typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
			   _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      __try
	{
	  for (; __n > 0; --__n, ++__first, ++__cur)
	    std::_Construct(std::__addressof(*__cur), *__first);
	  return __cur;
	}
      __catch(...)
	{
	  std::_Destroy(__result, __cur);
	  __throw_exception_again;
	}
    }

  template<typename _RandomAccessIterator, typename _Size,
	   typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
			   _ForwardIterator __result,
			   random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  /**
   *  @brief Copies the range [first,first+n) into result.
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  __result + __n
   *
   *  Like copy_n(), but does not require an initialized output range.
  */
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
			 _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
					 std::__iterator_category(__first)); }
#endif
# 684 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _STL_UNINITIALIZED_H */
# 689 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_uninitialized.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_vector.h>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 1 3
// Vector implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this  software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_vector.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 */

#ifndef _STL_VECTOR_H
#define _STL_VECTOR_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_funcs.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/functexcept.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
#endif
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /// See bits/stl_deque.h's _Deque_base for an explanation.
  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
       	pointer;

      struct _Vector_impl 
      : public _Tp_alloc_type
      {
	pointer _M_start;
	pointer _M_finish;
	pointer _M_end_of_storage;

	_Vector_impl()
	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
	{ }

	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
	: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
	{ }

#if __cplusplus >= 201103L
	_Vector_impl(_Tp_alloc_type&& __a) noexcept
	: _Tp_alloc_type(std::move(__a)),
	  _M_start(), _M_finish(), _M_end_of_storage()
	{ }
#endif
# 100 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

	void _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT
	{
	  std::swap(_M_start, __x._M_start);
	  std::swap(_M_finish, __x._M_finish);
	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
	}
      };
      
    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }

#if __cplusplus >= 201103L
      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
	if (__x.get_allocator() == __a)
	  this->_M_impl._M_swap_data(__x._M_impl);
	else
	  {
	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
	    _M_create_storage(__n);
	  }
      }
#endif
# 158 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      ~_Vector_base() _GLIBCXX_NOEXCEPT
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
	if (__p)
	  _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
	this->_M_impl._M_start = this->_M_allocate(__n);
	this->_M_impl._M_finish = this->_M_impl._M_start;
	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };


  /**
   *  @brief A standard container which offers fixed time access to
   *  individual elements in any order.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a> with the
   *  %exception of @c push_front and @c pop_front.
   *
   *  In some terminology a %vector can be described as a dynamic
   *  C-style array, it offers fast and efficient access to individual
   *  elements in any order and saves the user from worrying about
   *  memory and size allocation.  Subscripting ( @c [] ) access is
   *  also provided as with C-style arrays.
  */
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      // Concept requirements.
      typedef typename _Alloc::value_type                _Alloc_value_type;
      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
      
      typedef _Vector_base<_Tp, _Alloc>			 _Base;
      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;

    public:
      typedef _Tp					 value_type;
      typedef typename _Base::pointer                    pointer;
      typedef typename _Alloc_traits::const_pointer      const_pointer;
      typedef typename _Alloc_traits::reference          reference;
      typedef typename _Alloc_traits::const_reference    const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
      typedef std::reverse_iterator<iterator>		 reverse_iterator;
      typedef size_t					 size_type;
      typedef ptrdiff_t					 difference_type;
      typedef _Alloc                        		 allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:
      // [23.2.4.1] construct/copy/destroy
      // (assign() and get_allocator() are also listed in this section)

      /**
       *  @brief  Creates a %vector with no elements.
       */
      vector()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
#endif
# 257 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      : _Base() { }

      /**
       *  @brief  Creates a %vector with no elements.
       *  @param  __a  An allocator object.
       */
      explicit
      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
      : _Base(__a) { }

#if __cplusplus >= 201103L
      /**
       *  @brief  Creates a %vector with default constructed elements.
       *  @param  __n  The number of elements to initially create.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n default
       *  constructed elements.
       */
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }

      /**
       *  @brief  Creates a %vector with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n copies of @a __value.
       */
      vector(size_type __n, const value_type& __value,
	     const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
#else
# 294 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      /**
       *  @brief  Creates a %vector with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n copies of @a __value.
       */
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
	     const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
#endif
# 308 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  @brief  %Vector copy constructor.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  The newly-created %vector uses a copy of the allocation
       *  object used by @a __x.  All the elements of @a __x are copied,
       *  but any extra memory in
       *  @a __x (for fast expansion) will not be copied.
       */
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
				      this->_M_impl._M_start,
				      _M_get_Tp_allocator());
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  %Vector move constructor.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  The newly-created %vector contains the exact contents of @a __x.
       *  The contents of @a __x are a valid, but unspecified %vector.
       */
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }

      /// Copy constructor with alternative allocator
      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
				      this->_M_impl._M_start,
				      _M_get_Tp_allocator());
      }

      /// Move constructor with alternative allocator
      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
	if (__rv.get_allocator() != __m)
	  {
	    this->_M_impl._M_finish =
	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
					  this->_M_impl._M_start,
					  _M_get_Tp_allocator());
	    __rv.clear();
	  }
      }

      /**
       *  @brief  Builds a %vector from an initializer list.
       *  @param  __l  An initializer_list.
       *  @param  __a  An allocator.
       *
       *  Create a %vector consisting of copies of the elements in the
       *  initializer_list @a __l.
       *
       *  This will call the element type's copy constructor N times
       *  (where N is @a __l.size()) and do no memory reallocation.
       */
      vector(initializer_list<value_type> __l,
	     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
	_M_range_initialize(__l.begin(), __l.end(),
			    random_access_iterator_tag());
      }
#endif
# 381 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  @brief  Builds a %vector from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __a  An allocator.
       *
       *  Create a %vector consisting of copies of the elements from
       *  [first,last).
       *
       *  If the iterators are forward, bidirectional, or
       *  random-access, then this will call the elements' copy
       *  constructor N times (where N is distance(first,last)) and do
       *  no memory reallocation.  But if only input iterators are
       *  used, then this will do at most 2N calls to the copy
       *  constructor, and logN memory reallocations.
       */
#if __cplusplus >= 201103L
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        vector(_InputIterator __first, _InputIterator __last,
	       const allocator_type& __a = allocator_type())
	: _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
#else
# 406 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
	       const allocator_type& __a = allocator_type())
	: _Base(__a)
        {
	  // Check whether it's an integral type.  If so, it's not an iterator.
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_initialize_dispatch(__first, __last, _Integral());
	}
#endif
# 416 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  The dtor only erases the elements, and note that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector() _GLIBCXX_NOEXCEPT
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator()); }

      /**
       *  @brief  %Vector assignment operator.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but any extra memory in
       *  @a __x (for fast expansion) will not be copied.  Unlike the
       *  copy constructor, the allocator object is not copied.
       */
      vector&
      operator=(const vector& __x);

#if __cplusplus >= 201103L
      /**
       *  @brief  %Vector move assignment operator.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  The contents of @a __x are moved into this %vector (without copying,
       *  if the allocators permit it).
       *  @a __x is a valid, but unspecified %vector.
       */
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x),
                       integral_constant<bool, __move_storage>());
	return *this;
      }

      /**
       *  @brief  %Vector list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %vector with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
      vector&
      operator=(initializer_list<value_type> __l)
      {
	this->assign(__l.begin(), __l.end());
	return *this;
      }
#endif
# 476 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  @brief  Assigns a given value to a %vector.
       *  @param  __n  Number of elements to be assigned.
       *  @param  __val  Value to be assigned.
       *
       *  This function fills a %vector with @a __n copies of the given
       *  value.  Note that the assignment completely changes the
       *  %vector and that the resulting %vector's size is the same as
       *  the number of elements assigned.  Old data may be lost.
       */
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }

      /**
       *  @brief  Assigns a range to a %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function fills a %vector with copies of the elements in the
       *  range [__first,__last).
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
#if __cplusplus >= 201103L
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
#else
# 510 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
	  // Check whether it's an integral type.  If so, it's not an iterator.
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_assign_dispatch(__first, __last, _Integral());
	}
#endif
# 519 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Assigns an initializer list to a %vector.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %vector with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }
#endif
# 536 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /// Get a copy of the memory allocation object.
      using _Base::get_allocator;

      // iterators
      /**
       *  Returns a read/write iterator that points to the first
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return const_iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %vector.  Iteration is done in
       *  ordinary element order.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return const_iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read/write reverse iterator that points to the
       *  last element in the %vector.  Iteration is done in reverse
       *  element order.
       */
      reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last element in the %vector.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(end()); }

      /**
       *  Returns a read/write reverse iterator that points to one
       *  before the first element in the %vector.  Iteration is done
       *  in reverse element order.
       */
      reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(begin()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first element in the %vector.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(begin()); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %vector.  Iteration is done in
       *  ordinary element order.
       */
      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last element in the %vector.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first element in the %vector.  Iteration
       *  is done in reverse element order.
       */
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }
#endif
# 650 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }

      /**  Returns the size() of the largest possible %vector.  */
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Resizes the %vector to the specified number of elements.
       *  @param  __new_size  Number of elements the %vector should contain.
       *
       *  This function will %resize the %vector to the specified
       *  number of elements.  If the number is smaller than the
       *  %vector's current size the %vector is truncated, otherwise
       *  default constructed elements are appended.
       */
      void
      resize(size_type __new_size)
      {
	if (__new_size > size())
	  _M_default_append(__new_size - size());
	else if (__new_size < size())
	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }

      /**
       *  @brief  Resizes the %vector to the specified number of elements.
       *  @param  __new_size  Number of elements the %vector should contain.
       *  @param  __x  Data with which new elements should be populated.
       *
       *  This function will %resize the %vector to the specified
       *  number of elements.  If the number is smaller than the
       *  %vector's current size the %vector is truncated, otherwise
       *  the %vector is extended and new elements are populated with
       *  given data.
       */
      void
      resize(size_type __new_size, const value_type& __x)
      {
	if (__new_size > size())
	  insert(end(), __new_size - size(), __x);
	else if (__new_size < size())
	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
#else
# 701 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      /**
       *  @brief  Resizes the %vector to the specified number of elements.
       *  @param  __new_size  Number of elements the %vector should contain.
       *  @param  __x  Data with which new elements should be populated.
       *
       *  This function will %resize the %vector to the specified
       *  number of elements.  If the number is smaller than the
       *  %vector's current size the %vector is truncated, otherwise
       *  the %vector is extended and new elements are populated with
       *  given data.
       */
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
	if (__new_size > size())
	  insert(end(), __new_size - size(), __x);
	else if (__new_size < size())
	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
#endif
# 721 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

#if __cplusplus >= 201103L
      /**  A non-binding request to reduce capacity() to size().  */
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }
#endif
# 728 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  Returns the total number of elements that the %vector can
       *  hold before needing to allocate more memory.
       */
      size_type
      capacity() const _GLIBCXX_NOEXCEPT
      { return size_type(this->_M_impl._M_end_of_storage
			 - this->_M_impl._M_start); }

      /**
       *  Returns true if the %vector is empty.  (Thus begin() would
       *  equal end().)
       */
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return begin() == end(); }

      /**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          elements.
       *  @param  __n  Number of elements required.
       *  @throw  std::length_error  If @a n exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %vector to hold the specified number of elements.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the number of elements
       *  that will be required, the user can reserve the memory in
       *  %advance, and thus prevent a possible reallocation of memory
       *  and copying of %vector data.
       */
      void
      reserve(size_type __n);

      // element access
      /**
       *  @brief  Subscript access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      reference
      operator[](size_type __n) _GLIBCXX_NOEXCEPT
      { return *(this->_M_impl._M_start + __n); }

      /**
       *  @brief  Subscript access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      const_reference
      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
      { return *(this->_M_impl._M_start + __n); }

    protected:
      /// Safety check used only from at().
      void
      _M_range_check(size_type __n) const
      {
	if (__n >= this->size())
	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
				       "(which is %zu) >= this->size() "
				       "(which is %zu)"),
				   __n, this->size());
      }

    public:
      /**
       *  @brief  Provides access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter
       *  is first checked that it is in the range of the vector.  The
       *  function throws out_of_range if the check fails.
       */
      reference
      at(size_type __n)
      {
	_M_range_check(__n);
	return (*this)[__n]; 
      }

      /**
       *  @brief  Provides access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter
       *  is first checked that it is in the range of the vector.  The
       *  function throws out_of_range if the check fails.
       */
      const_reference
      at(size_type __n) const
      {
	_M_range_check(__n);
	return (*this)[__n];
      }

      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %vector.
       */
      reference
      front() _GLIBCXX_NOEXCEPT
      { return *begin(); }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %vector.
       */
      const_reference
      front() const _GLIBCXX_NOEXCEPT
      { return *begin(); }

      /**
       *  Returns a read/write reference to the data at the last
       *  element of the %vector.
       */
      reference
      back() _GLIBCXX_NOEXCEPT
      { return *(end() - 1); }
      
      /**
       *  Returns a read-only (constant) reference to the data at the
       *  last element of the %vector.
       */
      const_reference
      back() const _GLIBCXX_NOEXCEPT
      { return *(end() - 1); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 464. Suggestion for new member functions in standard containers.
      // data access
      /**
       *   Returns a pointer such that [data(), data() + size()) is a valid
       *   range.  For a non-empty %vector, data() == &front().
       */
#if __cplusplus >= 201103L
      _Tp*
#else
# 888 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      pointer
#endif
# 890 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      data() _GLIBCXX_NOEXCEPT
      { return _M_data_ptr(this->_M_impl._M_start); }

#if __cplusplus >= 201103L
      const _Tp*
#else
# 896 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      const_pointer
#endif
# 898 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      data() const _GLIBCXX_NOEXCEPT
      { return _M_data_ptr(this->_M_impl._M_start); }

      // [23.2.4.3] modifiers
      /**
       *  @brief  Add data to the end of the %vector.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %vector and assigns the given data
       *  to it.  Due to the nature of a %vector this operation can be
       *  done in constant time if the %vector has preallocated space
       *  available.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
	                             __x);
	    ++this->_M_impl._M_finish;
	  }
	else
#if __cplusplus >= 201103L
	  _M_emplace_back_aux(__x);
#else
# 925 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
	  _M_insert_aux(end(), __x);
#endif
# 927 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      }

#if __cplusplus >= 201103L
      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
#endif
# 938 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation. It shrinks the %vector by one.
       *
       *  Note that no data is returned, and if the last element's
       *  data is needed, it should be retrieved before pop_back() is
       *  called.
       */
      void
      pop_back() _GLIBCXX_NOEXCEPT
      {
	--this->_M_impl._M_finish;
	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts an object in %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __args  Arguments.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert an object of type T constructed
       *  with T(std::forward<Args>(args)...) before the specified location.
       *  Note that this kind of operation could be expensive for a %vector
       *  and if it is frequently used the user should consider using
       *  std::list.
       */
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);

      /**
       *  @brief  Inserts given value into %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       */
      iterator
      insert(const_iterator __position, const value_type& __x);
#else
# 986 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      /**
       *  @brief  Inserts given value into %vector before specified iterator.
       *  @param  __position  An iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       */
      iterator
      insert(iterator __position, const value_type& __x);
#endif
# 1000 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts given rvalue into %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given rvalue before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       */
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }

      /**
       *  @brief  Inserts an initializer_list into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __l  An initializer_list.
       *
       *  This function will insert copies of the data in the 
       *  initializer_list @a l into the %vector before the location
       *  specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       */
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      { return this->insert(__position, __l.begin(), __l.end()); }
#endif
# 1034 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts a number of copies of given data into the %vector.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a specified number of copies of
       *  the given data before the location specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       */
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
	difference_type __offset = __position - cbegin();
	_M_fill_insert(begin() + __offset, __n, __x);
	return begin() + __offset;
      }
#else
# 1058 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      /**
       *  @brief  Inserts a number of copies of given data into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *
       *  This function will insert a specified number of copies of
       *  the given data before the location specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       */
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
#endif
# 1075 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts a range into the %vector.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %vector before the location specified
       *  by @a pos.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       */
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
	       _InputIterator __last)
        {
	  difference_type __offset = __position - cbegin();
	  _M_insert_dispatch(begin() + __offset,
			     __first, __last, __false_type());
	  return begin() + __offset;
	}
#else
# 1104 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      /**
       *  @brief  Inserts a range into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %vector before the location specified
       *  by @a pos.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       */
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
	       _InputIterator __last)
        {
	  // Check whether it's an integral type.  If so, it's not an iterator.
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_insert_dispatch(__position, __first, __last, _Integral());
	}
#endif
# 1128 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  @brief  Remove element at given position.
       *  @param  __position  Iterator pointing to element to be erased.
       *  @return  An iterator pointing to the next element (or end()).
       *
       *  This function will erase the element at the given position and thus
       *  shorten the %vector by one.
       *
       *  Note This operation could be expensive and if it is
       *  frequently used the user should consider using std::list.
       *  The user is also cautioned that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
#else
# 1149 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      erase(iterator __position)
      { return _M_erase(__position); }
#endif
# 1152 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  @brief  Remove a range of elements.
       *  @param  __first  Iterator pointing to the first element to be erased.
       *  @param  __last  Iterator pointing to one past the last element to be
       *                  erased.
       *  @return  An iterator pointing to the element pointed to by @a __last
       *           prior to erasing (or end()).
       *
       *  This function will erase the elements in the range
       *  [__first,__last) and shorten the %vector accordingly.
       *
       *  Note This operation could be expensive and if it is
       *  frequently used the user should consider using std::list.
       *  The user is also cautioned that this function only erases
       *  the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       */
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __first, const_iterator __last)
      {
	const auto __beg = begin();
	const auto __cbeg = cbegin();
	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
#else
# 1180 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      erase(iterator __first, iterator __last)
      { return _M_erase(__first, __last); }
#endif
# 1183 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      /**
       *  @brief  Swaps data with another %vector.
       *  @param  __x  A %vector of the same element and allocator types.
       *
       *  This exchanges the elements between two vectors in constant time.
       *  (Three pointers, so it should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(v1,v2) will feed to this function.
       */
      void
      swap(vector& __x)
#if __cplusplus >= 201103L
      noexcept(_Alloc_traits::_S_nothrow_swap())
#endif
# 1198 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      {
	this->_M_impl._M_swap_data(__x._M_impl);
	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
	                          __x._M_get_Tp_allocator());
      }

      /**
       *  Erases all the elements.  Note that this function only erases the
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:
      /**
       *  Memory expansion handler.  Uses the member allocation function to
       *  obtain @a n bytes of memory, and then copies [first,last) into it.
       */
      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
			     _ForwardIterator __first, _ForwardIterator __last)
        {
	  pointer __result = this->_M_allocate(__n);
	  __try
	    {
	      std::__uninitialized_copy_a(__first, __last, __result,
					  _M_get_Tp_allocator());
	      return __result;
	    }
	  __catch(...)
	    {
	      _M_deallocate(__result, __n);
	      __throw_exception_again;
	    }
	}


      // Internal constructor functions follow.

      // Called by the range constructor to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
	  this->_M_impl._M_end_of_storage =
	    this->_M_impl._M_start + static_cast<size_type>(__n);
	  _M_fill_initialize(static_cast<size_type>(__n), __value);
	}

      // Called by the range constructor to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
			       __false_type)
        {
	  typedef typename std::iterator_traits<_InputIterator>::
	    iterator_category _IterCategory;
	  _M_range_initialize(__first, __last, _IterCategory());
	}

      // Called by the second initialize_dispatch above
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
			    _InputIterator __last, std::input_iterator_tag)
        {
	  for (; __first != __last; ++__first)
#if __cplusplus >= 201103L
	    emplace_back(*__first);
#else
# 1276 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
	    push_back(*__first);
#endif
# 1278 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
	}

      // Called by the second initialize_dispatch above
      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
			    _ForwardIterator __last, std::forward_iterator_tag)
        {
	  const size_type __n = std::distance(__first, __last);
	  this->_M_impl._M_start = this->_M_allocate(__n);
	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
	  this->_M_impl._M_finish =
	    std::__uninitialized_copy_a(__first, __last,
					this->_M_impl._M_start,
					_M_get_Tp_allocator());
	}

      // Called by the first initialize_dispatch above and by the
      // vector(n,value,a) constructor.
      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
	this->_M_impl._M_finish =
	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
					_M_get_Tp_allocator());
      }

#if __cplusplus >= 201103L
      // Called by the vector(n) constructor.
      void
      _M_default_initialize(size_type __n)
      {
	this->_M_impl._M_finish =
	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
					   _M_get_Tp_allocator());
      }
#endif
# 1315 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      // Internal assign functions follow.  The *_aux functions do the actual
      // assignment work for the range versions.

      // Called by the range assign to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }

      // Called by the range assign to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
			   __false_type)
        {
	  typedef typename std::iterator_traits<_InputIterator>::
	    iterator_category _IterCategory;
	  _M_assign_aux(__first, __last, _IterCategory());
	}

      // Called by the second assign_dispatch above
      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
		      std::input_iterator_tag);

      // Called by the second assign_dispatch above
      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
		      std::forward_iterator_tag);

      // Called by assign(n,t), and the range assign when it turns out
      // to be the same thing.
      void
      _M_fill_assign(size_type __n, const value_type& __val);


      // Internal insert functions follow.

      // Called by the range insert to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
			   __true_type)
        { _M_fill_insert(__pos, __n, __val); }

      // Called by the range insert to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
			   _InputIterator __last, __false_type)
        {
	  typedef typename std::iterator_traits<_InputIterator>::
	    iterator_category _IterCategory;
	  _M_range_insert(__pos, __first, __last, _IterCategory());
	}

      // Called by the second insert_dispatch above
      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
			_InputIterator __last, std::input_iterator_tag);

      // Called by the second insert_dispatch above
      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
			_ForwardIterator __last, std::forward_iterator_tag);

      // Called by insert(p,n,x), and the range insert when it turns out to be
      // the same thing.
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);

#if __cplusplus >= 201103L
      // Called by resize(n).
      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
#endif
# 1405 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      // Called by insert(p,x)
#if __cplusplus < 201103L
      void
      _M_insert_aux(iterator __position, const value_type& __x);
#else
# 1411 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);
#endif
# 1419 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

      // Called by the latter.
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
	if (max_size() - size() < __n)
	  __throw_length_error(__N(__s));

	const size_type __len = size() + std::max(size(), __n);
	return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      // Internal erase functions follow.

      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
      // _M_assign_aux.
      void
      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
      {
	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
	this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);

#if __cplusplus >= 201103L
    private:
      // Constant-time move assignment when source object's memory can be
      // moved, either because the source's allocator will move too
      // or because the allocators are equal.
      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
	vector __tmp(get_allocator());
	this->_M_impl._M_swap_data(__tmp._M_impl);
	this->_M_impl._M_swap_data(__x._M_impl);
	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }

      // Do move assignment when it might not be possible to move source
      // object's memory, resulting in a linear-time operation.
      void
      _M_move_assign(vector&& __x, std::false_type)
      {
	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
	  _M_move_assign(std::move(__x), std::true_type());
	else
	  {
	    // The rvalue's allocator cannot be moved and is not equal,
	    // so we need to individually move each element.
	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
			 std::__make_move_if_noexcept_iterator(__x.end()));
	    __x.clear();
	  }
      }
#endif
# 1479 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3

#if __cplusplus >= 201103L
      template<typename _Up>
	_Up*
	_M_data_ptr(_Up* __ptr) const
	{ return __ptr; }

      template<typename _Ptr>
	typename std::pointer_traits<_Ptr>::element_type*
	_M_data_ptr(_Ptr __ptr) const
	{ return empty() ? nullptr : std::__addressof(*__ptr); }
#else
# 1491 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
      template<typename _Ptr>
	_Ptr
	_M_data_ptr(_Ptr __ptr) const
	{ return __ptr; }
#endif
# 1496 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
    };


  /**
   *  @brief  Vector equality comparison.
   *  @param  __x  A %vector.
   *  @param  __y  A %vector of the same type as @a __x.
   *  @return  True iff the size and elements of the vectors are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  vectors.  Vectors are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  */
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
	      && std::equal(__x.begin(), __x.end(), __y.begin())); }

  /**
   *  @brief  Vector ordering relation.
   *  @param  __x  A %vector.
   *  @param  __y  A %vector of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  vectors.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
					  __y.begin(), __y.end()); }

  /// Based on operator==
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }

  /// See std::vector::swap().
  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif /* _STL_VECTOR_H */
# 1566 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_vector.h" 3
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_bvector.h> 
#endif /* expanded by -frewrite-includes */
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 1 3
// vector<bool> specialization -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1999
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_bvector.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 */

#ifndef _STL_BVECTOR_H
#define _STL_BVECTOR_H 1

#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
#endif
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(__CHAR_BIT__ * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() _GLIBCXX_NOEXCEPT : _M_p(0), _M_mask(0) { }

    operator bool() const _GLIBCXX_NOEXCEPT
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) _GLIBCXX_NOEXCEPT
    {
      if (__x)
	*_M_p |= _M_mask;
      else
	*_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) _GLIBCXX_NOEXCEPT
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() _GLIBCXX_NOEXCEPT
    { *_M_p ^= _M_mask; }
  };

#if __cplusplus >= 201103L
  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }
#endif
# 135 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
	{
	  _M_offset = 0;
	  ++_M_p;
	}
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
	{
	  _M_offset = int(_S_word_bit) - 1;
	  --_M_p;
	}
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
	{
	  __n += int(_S_word_bit);
	  --_M_p;
	}
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
	     || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
	    + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference  reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator   iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool                 reference;
    typedef bool                 const_reference;
    typedef const bool*          pointer;
    typedef _Bit_const_iterator  const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator 
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
	std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
	__fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
	__fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
	_Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
	_Bit_iterator 	_M_start;
	_Bit_iterator 	_M_finish;
	_Bit_pointer 	_M_end_of_storage;

	_Bvector_impl()
	: _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
	{ }
 
	_Bvector_impl(const _Bit_alloc_type& __a)
	: _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
	{ }

#if __cplusplus >= 201103L
	_Bvector_impl(_Bit_alloc_type&& __a)
	: _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
	  _M_end_of_storage()
	{ }
#endif
# 440 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

	_Bit_type*
	_M_end_addr() const _GLIBCXX_NOEXCEPT
	{
	  if (_M_end_of_storage)
	    return std::__addressof(_M_end_of_storage[-1]) + 1;
	  return 0;
	}
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() _GLIBCXX_NOEXCEPT
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const _GLIBCXX_NOEXCEPT
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }
      
      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }

#if __cplusplus >= 201103L
      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
	this->_M_impl._M_start = __x._M_impl._M_start;
	this->_M_impl._M_finish = __x._M_impl._M_finish;
	this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
	__x._M_impl._M_start = _Bit_iterator();
	__x._M_impl._M_finish = _Bit_iterator();
	__x._M_impl._M_end_of_storage = nullptr;
      }
#endif
# 483 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
	if (_M_impl._M_start._M_p)
	  {
	    const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
	    _Bit_alloc_traits::deallocate(_M_impl,
					  _M_impl._M_end_of_storage - __n,
					  __n);
	  }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

// Declare a partial specialization of vector<T, Alloc>.
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_vector.h>
#endif /* expanded by -frewrite-includes */
# 515 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
# 516 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /**
   *  @brief  A specialization of vector for booleans which offers fixed time
   *  access to individual elements in any order.
   *
   *  @ingroup sequences
   *
   *  @tparam _Alloc  Allocator type.
   *
   *  Note that vector<bool> does not actually meet the requirements for being
   *  a container.  This is because the reference and pointer types are not
   *  really references and pointers to bool.  See DR96 for details.  @see
   *  vector for function documentation.
   *
   *  In some terminology a %vector can be described as a dynamic
   *  C-style array, it offers fast and efficient access to individual
   *  elements in any order and saves the user from worrying about
   *  memory and size allocation.  Subscripting ( @c [] ) access is
   *  also provided as with C-style arrays.
  */
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc>			 _Base;
    typedef typename _Base::_Bit_pointer		 _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits		 _Bit_alloc_traits;

#if __cplusplus >= 201103L
    template<typename> friend struct hash;
#endif
# 550 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

  public:
    typedef bool                                         value_type;
    typedef size_t                                       size_type;
    typedef ptrdiff_t                                    difference_type;
    typedef _Bit_reference                               reference;
    typedef bool                                         const_reference;
    typedef _Bit_reference*                              pointer;
    typedef const bool*                                  const_pointer;
    typedef _Bit_iterator                                iterator;
    typedef _Bit_const_iterator                          const_iterator;
    typedef std::reverse_iterator<const_iterator>        const_reverse_iterator;
    typedef std::reverse_iterator<iterator>              reverse_iterator;
    typedef _Alloc                        		 allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
#endif
# 579 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

#if __cplusplus >= 201103L
    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value, 
	   const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
		__value ? ~0 : 0);
    }
#else
# 600 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    explicit
    vector(size_type __n, const bool& __value = bool(), 
	   const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
		__value ? ~0 : 0);
    }
#endif
# 610 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

#if __cplusplus >= 201103L
    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
	{
	  this->_M_impl._M_start = __x._M_impl._M_start;
	  this->_M_impl._M_finish = __x._M_impl._M_finish;
	  this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
	  __x._M_impl._M_start = _Bit_iterator();
	  __x._M_impl._M_finish = _Bit_iterator();
	  __x._M_impl._M_end_of_storage = nullptr;
	}
      else
	{
	  _M_initialize(__x.size());
	  _M_copy_aligned(__x.begin(), __x.end(), begin());
	  __x.clear();
	}
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
	   const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
			  random_access_iterator_tag());
    }
#endif
# 658 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

#if __cplusplus >= 201103L
    template<typename _InputIterator,
	     typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
	     const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
#else
# 667 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
	     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	_M_initialize_dispatch(__first, __last, _Integral());
      }
#endif
# 676 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    ~vector() _GLIBCXX_NOEXCEPT { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
	return *this;
#if __cplusplus >= 201103L
      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
	{
	  if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
	    {
	      this->_M_deallocate();
	      std::__alloc_on_copy(_M_get_Bit_allocator(),
				   __x._M_get_Bit_allocator());
	      _M_initialize(__x.size());
	    }
	  else
	    std::__alloc_on_copy(_M_get_Bit_allocator(),
				 __x._M_get_Bit_allocator());
	}
#endif
# 699 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
      if (__x.size() > capacity())
	{
	  this->_M_deallocate();
	  _M_initialize(__x.size());
	}
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
						begin());
      return *this;
    }

#if __cplusplus >= 201103L
    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
	  || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
	{
	  this->_M_deallocate();
	  this->_M_impl._M_start = __x._M_impl._M_start;
	  this->_M_impl._M_finish = __x._M_impl._M_finish;
	  this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
	  __x._M_impl._M_start = _Bit_iterator();
	  __x._M_impl._M_finish = _Bit_iterator();
	  __x._M_impl._M_end_of_storage = nullptr;
	  std::__alloc_on_move(_M_get_Bit_allocator(),
			       __x._M_get_Bit_allocator());
	}
      else
	{
	  if (__x.size() > capacity())
	    {
	      this->_M_deallocate();
	      _M_initialize(__x.size());
	    }
	  this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
						    begin());
	  __x.clear();
	}
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }
#endif
# 747 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    // assign(), a generalized assignment member function.  Two
    // versions: one that takes a count, and one that takes a range.
    // The range version is a member template, so we dispatch on whether
    // or not the type is an integer.
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

#if __cplusplus >= 201103L
    template<typename _InputIterator,
	     typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
#else
# 763 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	_M_assign_dispatch(__first, __last, _Integral());
      }
#endif
# 771 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

#if __cplusplus >= 201103L
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }
#endif
# 777 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    iterator
    begin() _GLIBCXX_NOEXCEPT
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const _GLIBCXX_NOEXCEPT
    { return this->_M_impl._M_start; }

    iterator
    end() _GLIBCXX_NOEXCEPT
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const _GLIBCXX_NOEXCEPT
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() _GLIBCXX_NOEXCEPT
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const _GLIBCXX_NOEXCEPT
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() _GLIBCXX_NOEXCEPT
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const _GLIBCXX_NOEXCEPT
    { return const_reverse_iterator(begin()); }

#if __cplusplus >= 201103L
    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }
#endif
# 827 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    size_type
    size() const _GLIBCXX_NOEXCEPT
    { return size_type(end() - begin()); }

    size_type
    max_size() const _GLIBCXX_NOEXCEPT
    {
      const size_type __isize =
	__gnu_cxx::__numeric_traits<difference_type>::__max
	- int(_S_word_bit) + 1;
      const size_type __asize
	= _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
	      ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const _GLIBCXX_NOEXCEPT
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
		       - begin()); }

    bool
    empty() const _GLIBCXX_NOEXCEPT
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
		       + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
			     + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
	__throw_out_of_range_fmt(__N("vector<bool>::_M_range_check: __n "
				     "(which is %zu) >= this->size() "
				     "(which is %zu)"),
				 __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
	__throw_length_error(__N("vector::reserve"));
      if (capacity() < __n)
	_M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }

    // _GLIBCXX_RESOLVE_LIB_DEFECTS
    // DR 464. Suggestion for new member functions in standard containers.
    // N.B. DR 464 says nothing about vector<bool> but we need something
    // here due to the way we are implementing DR 464 in the debug-mode
    // vector class.
    void
    data() _GLIBCXX_NOEXCEPT { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
#if __cplusplus >= 201103L
      noexcept(_Bit_alloc_traits::_S_nothrow_swap())
#endif
# 934 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage, 
		__x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
				    __x._M_get_Bit_allocator());
    }

    // [23.2.5]/1, third-to-last entry in synopsis listing
    static void
    swap(reference __x, reference __y) _GLIBCXX_NOEXCEPT
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
#if __cplusplus >= 201103L
    insert(const_iterator __position, const bool& __x = bool())
#else
# 956 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    insert(iterator __position, const bool& __x = bool())
#endif
# 958 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
	  && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }

#if __cplusplus >= 201103L
    template<typename _InputIterator,
	     typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
	     _InputIterator __first, _InputIterator __last)
      {
	difference_type __offset = __position - cbegin();
	_M_insert_dispatch(__position._M_const_cast(),
			   __first, __last, __false_type());
	return begin() + __offset;
      }
#else
# 981 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      insert(iterator __position,
	     _InputIterator __first, _InputIterator __last)
      {
	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	_M_insert_dispatch(__position, __first, __last, _Integral());
      }
#endif
# 990 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

#if __cplusplus >= 201103L
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }
#else
# 1000 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }
#endif
# 1004 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

#if __cplusplus >= 201103L
    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }
#endif
# 1010 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
#if __cplusplus >= 201103L
    erase(const_iterator __position)
#else
# 1019 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    erase(iterator __position)
#endif
# 1021 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    { return _M_erase(__position._M_const_cast()); }

    iterator
#if __cplusplus >= 201103L
    erase(const_iterator __first, const_iterator __last)
#else
# 1027 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    erase(iterator __first, iterator __last)
#endif
# 1029 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

#if __cplusplus >= 201103L
    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }
#endif
# 1045 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    void
    flip() _GLIBCXX_NOEXCEPT
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() _GLIBCXX_NOEXCEPT
    { _M_erase_at_end(begin()); }

#if __cplusplus >= 201103L
    template<typename... _Args>
      void
      emplace_back(_Args&&... __args)
      { push_back(bool(__args...)); }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }
#endif
# 1069 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

  protected:
    // Precondition: __first._M_offset == 0 && __result._M_offset == 0.
    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
		    iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
		       iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);

#if __cplusplus >= 201103L
    bool
    _M_shrink_to_fit();
#endif
# 1097 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

    // Check whether it's an integral type.  If so, it's not an iterator.

    // _GLIBCXX_RESOLVE_LIB_DEFECTS
    // 438. Ambiguity in the "do the right thing" clause
    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
	_M_initialize(static_cast<size_type>(__n));
	std::fill(this->_M_impl._M_start._M_p, 
		  this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void 
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
			     __false_type)
      { _M_initialize_range(__first, __last, 
			    std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
			  std::input_iterator_tag)
      {
	for (; __first != __last; ++__first)
	  push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
			  std::forward_iterator_tag)
      {
	const size_type __n = std::distance(__first, __last);
	_M_initialize(__n);
	std::copy(__first, __last, this->_M_impl._M_start);
      }

    // _GLIBCXX_RESOLVE_LIB_DEFECTS
    // 438. Ambiguity in the "do the right thing" clause
    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
			 __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
	{
	  std::fill(this->_M_impl._M_start._M_p, 
		    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
	  insert(end(), __n - size(), __x);
	}
      else
	{
	  _M_erase_at_end(begin() + __n);
	  std::fill(this->_M_impl._M_start._M_p, 
		    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
	}
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
		    std::input_iterator_tag)
      {
	iterator __cur = begin();
	for (; __first != __last && __cur != end(); ++__cur, ++__first)
	  *__cur = *__first;
	if (__first == __last)
	  _M_erase_at_end(__cur);
	else
	  insert(end(), __first, __last);
      }
    
    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
		    std::forward_iterator_tag)
      {
	const size_type __len = std::distance(__first, __last);
	if (__len < size())
	  _M_erase_at_end(std::copy(__first, __last, begin()));
	else
	  {
	    _ForwardIterator __mid = __first;
	    std::advance(__mid, size());
	    std::copy(__first, __mid, begin());
	    insert(end(), __mid, __last);
	  }
      }

    // Check whether it's an integral type.  If so, it's not an iterator.

    // _GLIBCXX_RESOLVE_LIB_DEFECTS
    // 438. Ambiguity in the "do the right thing" clause
    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
			 __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
			 _InputIterator __first, _InputIterator __last,
			 __false_type)
      { _M_insert_range(__pos, __first, __last,
			std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first, 
		      _InputIterator __last, std::input_iterator_tag)
      {
	for (; __first != __last; ++__first)
	  {
	    __pos = insert(__pos, *__first);
	    ++__pos;
	  }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first, 
		      _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
	__throw_length_error(__N(__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#if __cplusplus >= 201103L

#if 0 /* expanded by -frewrite-includes */
#include <bits/functional_hash.h>
#endif /* expanded by -frewrite-includes */
# 1265 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
# 1266 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // DR 1182.
  /// std::hash specialization for vector<bool>.
  template<typename _Alloc>
    struct hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>
    : public __hash_base<size_t, _GLIBCXX_STD_C::vector<bool, _Alloc>>
    {
      size_t
      operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>&) const noexcept;
    };

_GLIBCXX_END_NAMESPACE_VERSION
}// namespace std

#endif // C++11
# 1285 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3

#endif
# 1287 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_bvector.h" 3
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/range_access.h>
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3

#ifndef _GLIBCXX_EXPORT_TEMPLATE
#if 0 /* expanded by -frewrite-includes */
# include <bits/vector.tcc>
#endif /* expanded by -frewrite-includes */
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 1 3
// Vector implementation (out of line) -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this  software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/vector.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 */

#ifndef _VECTOR_TCC
#define _VECTOR_TCC 1

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
	__throw_length_error(__N("vector::reserve"));
      if (this->capacity() < __n)
	{
	  const size_type __old_size = size();
	  pointer __tmp = _M_allocate_and_copy(__n,
	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
			_M_get_Tp_allocator());
	  _M_deallocate(this->_M_impl._M_start,
			this->_M_impl._M_end_of_storage
			- this->_M_impl._M_start);
	  this->_M_impl._M_start = __tmp;
	  this->_M_impl._M_finish = __tmp + __old_size;
	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
	}
    }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }
#endif
# 104 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
#if __cplusplus >= 201103L
    insert(const_iterator __position, const value_type& __x)
#else
# 111 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
    insert(iterator __position, const value_type& __x)
#endif
# 113 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
	  && __position == end())
	{
	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
	  ++this->_M_impl._M_finish;
	}
      else
	{
#if __cplusplus >= 201103L
	  const auto __pos = begin() + (__position - cbegin());
	  if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	    {
	      _Tp __x_copy = __x;
	      _M_insert_aux(__pos, std::move(__x_copy));
	    }
	  else
	    _M_insert_aux(__pos, __x);
#else
# 133 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	    _M_insert_aux(__position, __x);
#endif
# 135 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	}
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
	_GLIBCXX_MOVE3(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
	{
	  if (__last != end())
	    _GLIBCXX_MOVE3(__last, end(), __first);
	  _M_erase_at_end(__first.base() + (end() - __last));
	}
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
	{
#if __cplusplus >= 201103L
	  if (_Alloc_traits::_S_propagate_on_copy_assign())
	    {
	      if (!_Alloc_traits::_S_always_equal()
	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
	        {
		  // replacement allocator cannot free existing storage
		  this->clear();
		  _M_deallocate(this->_M_impl._M_start,
				this->_M_impl._M_end_of_storage
				- this->_M_impl._M_start);
		  this->_M_impl._M_start = nullptr;
		  this->_M_impl._M_finish = nullptr;
		  this->_M_impl._M_end_of_storage = nullptr;
		}
	      std::__alloc_on_copy(_M_get_Tp_allocator(),
				   __x._M_get_Tp_allocator());
	    }
#endif
# 191 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	  const size_type __xlen = __x.size();
	  if (__xlen > capacity())
	    {
	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
						   __x.end());
	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
			    _M_get_Tp_allocator());
	      _M_deallocate(this->_M_impl._M_start,
			    this->_M_impl._M_end_of_storage
			    - this->_M_impl._M_start);
	      this->_M_impl._M_start = __tmp;
	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
	    }
	  else if (size() >= __xlen)
	    {
	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
			    end(), _M_get_Tp_allocator());
	    }
	  else
	    {
	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
			this->_M_impl._M_start);
	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
					  __x._M_impl._M_finish,
					  this->_M_impl._M_finish,
					  _M_get_Tp_allocator());
	    }
	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
	}
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
	{
	  vector __tmp(__n, __val, _M_get_Tp_allocator());
	  __tmp._M_impl._M_swap_data(this->_M_impl);
	}
      else if (__n > size())
	{
	  std::fill(begin(), end(), __val);
	  this->_M_impl._M_finish =
	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
					  __n - size(), __val,
					  _M_get_Tp_allocator());
	}
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
		    std::input_iterator_tag)
      {
	pointer __cur(this->_M_impl._M_start);
	for (; __first != __last && __cur != this->_M_impl._M_finish;
	     ++__cur, ++__first)
	  *__cur = *__first;
	if (__first == __last)
	  _M_erase_at_end(__cur);
	else
	  insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
		    std::forward_iterator_tag)
      {
	const size_type __len = std::distance(__first, __last);

	if (__len > capacity())
	  {
	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
			  _M_get_Tp_allocator());
	    _M_deallocate(this->_M_impl._M_start,
			  this->_M_impl._M_end_of_storage
			  - this->_M_impl._M_start);
	    this->_M_impl._M_start = __tmp;
	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
	  }
	else if (size() >= __len)
	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
	else
	  {
	    _ForwardIterator __mid = __first;
	    std::advance(__mid, size());
	    std::copy(__first, __mid, this->_M_impl._M_start);
	    this->_M_impl._M_finish =
	      std::__uninitialized_copy_a(__mid, __last,
					  this->_M_impl._M_finish,
					  _M_get_Tp_allocator());
	  }
      }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
	const size_type __n = __position - begin();
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
	    && __position == end())
	  {
	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
				     std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish;
	  }
	else
	  _M_insert_aux(begin() + (__position - cbegin()),
			std::forward<_Args>(__args)...);
	return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)
#else
# 324 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
#endif
# 329 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
	{
	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
			           _GLIBCXX_MOVE(*(this->_M_impl._M_finish
				                   - 1)));
	  ++this->_M_impl._M_finish;
#if __cplusplus < 201103L
	  _Tp __x_copy = __x;
#endif
# 339 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
				  this->_M_impl._M_finish - 2,
				  this->_M_impl._M_finish - 1);
#if __cplusplus < 201103L
	  *__position = __x_copy;
#else
# 345 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	  *__position = _Tp(std::forward<_Args>(__args)...);
#endif
# 347 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	}
      else
	{
	  const size_type __len =
	    _M_check_len(size_type(1), "vector::_M_insert_aux");
	  const size_type __elems_before = __position - begin();
	  pointer __new_start(this->_M_allocate(__len));
	  pointer __new_finish(__new_start);
	  __try
	    {
	      // The order of the three operations is dictated by the C++0x
	      // case, where the moves could alter a new element belonging
	      // to the existing vector.  This is an issue only for callers
	      // taking the element by const lvalue ref (see 23.1/13).
	      _Alloc_traits::construct(this->_M_impl,
		                       __new_start + __elems_before,
#if __cplusplus >= 201103L
				       std::forward<_Args>(__args)...);
#else
# 366 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	                               __x);
#endif
# 368 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
	      __new_finish = pointer();

	      __new_finish
		= std::__uninitialized_move_if_noexcept_a
		(this->_M_impl._M_start, __position.base(),
		 __new_start, _M_get_Tp_allocator());

	      ++__new_finish;

	      __new_finish
		= std::__uninitialized_move_if_noexcept_a
		(__position.base(), this->_M_impl._M_finish,
		 __new_finish, _M_get_Tp_allocator());
	    }
          __catch(...)
	    {
	      if (!__new_finish)
		_Alloc_traits::destroy(this->_M_impl,
		                       __new_start + __elems_before);
	      else
		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
	      _M_deallocate(__new_start, __len);
	      __throw_exception_again;
	    }
	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
			_M_get_Tp_allocator());
	  _M_deallocate(this->_M_impl._M_start,
			this->_M_impl._M_end_of_storage
			- this->_M_impl._M_start);
	  this->_M_impl._M_start = __new_start;
	  this->_M_impl._M_finish = __new_finish;
	  this->_M_impl._M_end_of_storage = __new_start + __len;
	}
    }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
	const size_type __len =
	  _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
	pointer __new_start(this->_M_allocate(__len));
	pointer __new_finish(__new_start);
	__try
	  {
	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
				     std::forward<_Args>(__args)...);
	    __new_finish = pointer();

	    __new_finish
	      = std::__uninitialized_move_if_noexcept_a
	      (this->_M_impl._M_start, this->_M_impl._M_finish,
	       __new_start, _M_get_Tp_allocator());

	    ++__new_finish;
	  }
	__catch(...)
	  {
	    if (!__new_finish)
	      _Alloc_traits::destroy(this->_M_impl, __new_start + size());
	    else
	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
	    _M_deallocate(__new_start, __len);
	    __throw_exception_again;
	  }
	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
		      _M_get_Tp_allocator());
	_M_deallocate(this->_M_impl._M_start,
		      this->_M_impl._M_end_of_storage
		      - this->_M_impl._M_start);
	this->_M_impl._M_start = __new_start;
	this->_M_impl._M_finish = __new_finish;
	this->_M_impl._M_end_of_storage = __new_start + __len;
      }
#endif
# 446 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
	{
	  if (size_type(this->_M_impl._M_end_of_storage
			- this->_M_impl._M_finish) >= __n)
	    {
	      value_type __x_copy = __x;
	      const size_type __elems_after = end() - __position;
	      pointer __old_finish(this->_M_impl._M_finish);
	      if (__elems_after > __n)
		{
		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
					      this->_M_impl._M_finish,
					      this->_M_impl._M_finish,
					      _M_get_Tp_allocator());
		  this->_M_impl._M_finish += __n;
		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
					  __old_finish - __n, __old_finish);
		  std::fill(__position.base(), __position.base() + __n,
			    __x_copy);
		}
	      else
		{
		  this->_M_impl._M_finish =
		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
						  __n - __elems_after,
						  __x_copy,
						  _M_get_Tp_allocator());
		  std::__uninitialized_move_a(__position.base(), __old_finish,
					      this->_M_impl._M_finish,
					      _M_get_Tp_allocator());
		  this->_M_impl._M_finish += __elems_after;
		  std::fill(__position.base(), __old_finish, __x_copy);
		}
	    }
	  else
	    {
	      const size_type __len =
		_M_check_len(__n, "vector::_M_fill_insert");
	      const size_type __elems_before = __position - begin();
	      pointer __new_start(this->_M_allocate(__len));
	      pointer __new_finish(__new_start);
	      __try
		{
		  // See _M_insert_aux above.
		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
						__n, __x,
						_M_get_Tp_allocator());
		  __new_finish = pointer();

		  __new_finish
		    = std::__uninitialized_move_if_noexcept_a
		    (this->_M_impl._M_start, __position.base(),
		     __new_start, _M_get_Tp_allocator());

		  __new_finish += __n;

		  __new_finish
		    = std::__uninitialized_move_if_noexcept_a
		    (__position.base(), this->_M_impl._M_finish,
		     __new_finish, _M_get_Tp_allocator());
		}
	      __catch(...)
		{
		  if (!__new_finish)
		    std::_Destroy(__new_start + __elems_before,
				  __new_start + __elems_before + __n,
				  _M_get_Tp_allocator());
		  else
		    std::_Destroy(__new_start, __new_finish,
				  _M_get_Tp_allocator());
		  _M_deallocate(__new_start, __len);
		  __throw_exception_again;
		}
	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
			    _M_get_Tp_allocator());
	      _M_deallocate(this->_M_impl._M_start,
			    this->_M_impl._M_end_of_storage
			    - this->_M_impl._M_start);
	      this->_M_impl._M_start = __new_start;
	      this->_M_impl._M_finish = __new_finish;
	      this->_M_impl._M_end_of_storage = __new_start + __len;
	    }
	}
    }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
	{
	  if (size_type(this->_M_impl._M_end_of_storage
			- this->_M_impl._M_finish) >= __n)
	    {
	      this->_M_impl._M_finish =
		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
						 __n, _M_get_Tp_allocator());
	    }
	  else
	    {
	      const size_type __len =
		_M_check_len(__n, "vector::_M_default_append");
	      const size_type __old_size = this->size();
	      pointer __new_start(this->_M_allocate(__len));
	      pointer __new_finish(__new_start);
	      __try
		{
		  __new_finish
		    = std::__uninitialized_move_if_noexcept_a
		    (this->_M_impl._M_start, this->_M_impl._M_finish,
		     __new_start, _M_get_Tp_allocator());
		  __new_finish =
		    std::__uninitialized_default_n_a(__new_finish, __n,
						     _M_get_Tp_allocator());
		}
	      __catch(...)
		{
		  std::_Destroy(__new_start, __new_finish,
				_M_get_Tp_allocator());
		  _M_deallocate(__new_start, __len);
		  __throw_exception_again;
		}
	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
			    _M_get_Tp_allocator());
	      _M_deallocate(this->_M_impl._M_start,
			    this->_M_impl._M_end_of_storage
			    - this->_M_impl._M_start);
	      this->_M_impl._M_start = __new_start;
	      this->_M_impl._M_finish = __new_finish;
	      this->_M_impl._M_end_of_storage = __new_start + __len;
	    }
	}
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
	return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }
#endif
# 598 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
		      _InputIterator __last, std::input_iterator_tag)
      {
	for (; __first != __last; ++__first)
	  {
	    __pos = insert(__pos, *__first);
	    ++__pos;
	  }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
		      _ForwardIterator __last, std::forward_iterator_tag)
      {
	if (__first != __last)
	  {
	    const size_type __n = std::distance(__first, __last);
	    if (size_type(this->_M_impl._M_end_of_storage
			  - this->_M_impl._M_finish) >= __n)
	      {
		const size_type __elems_after = end() - __position;
		pointer __old_finish(this->_M_impl._M_finish);
		if (__elems_after > __n)
		  {
		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
						this->_M_impl._M_finish,
						this->_M_impl._M_finish,
						_M_get_Tp_allocator());
		    this->_M_impl._M_finish += __n;
		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
					    __old_finish - __n, __old_finish);
		    std::copy(__first, __last, __position);
		  }
		else
		  {
		    _ForwardIterator __mid = __first;
		    std::advance(__mid, __elems_after);
		    std::__uninitialized_copy_a(__mid, __last,
						this->_M_impl._M_finish,
						_M_get_Tp_allocator());
		    this->_M_impl._M_finish += __n - __elems_after;
		    std::__uninitialized_move_a(__position.base(),
						__old_finish,
						this->_M_impl._M_finish,
						_M_get_Tp_allocator());
		    this->_M_impl._M_finish += __elems_after;
		    std::copy(__first, __mid, __position);
		  }
	      }
	    else
	      {
		const size_type __len =
		  _M_check_len(__n, "vector::_M_range_insert");
		pointer __new_start(this->_M_allocate(__len));
		pointer __new_finish(__new_start);
		__try
		  {
		    __new_finish
		      = std::__uninitialized_move_if_noexcept_a
		      (this->_M_impl._M_start, __position.base(),
		       __new_start, _M_get_Tp_allocator());
		    __new_finish
		      = std::__uninitialized_copy_a(__first, __last,
						    __new_finish,
						    _M_get_Tp_allocator());
		    __new_finish
		      = std::__uninitialized_move_if_noexcept_a
		      (__position.base(), this->_M_impl._M_finish,
		       __new_finish, _M_get_Tp_allocator());
		  }
		__catch(...)
		  {
		    std::_Destroy(__new_start, __new_finish,
				  _M_get_Tp_allocator());
		    _M_deallocate(__new_start, __len);
		    __throw_exception_again;
		  }
		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
			      _M_get_Tp_allocator());
		_M_deallocate(this->_M_impl._M_start,
			      this->_M_impl._M_end_of_storage
			      - this->_M_impl._M_start);
		this->_M_impl._M_start = __new_start;
		this->_M_impl._M_finish = __new_finish;
		this->_M_impl._M_end_of_storage = __new_start + __len;
	      }
	  }
      }


  // vector<bool>
  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), __start);
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
	return;
      if (capacity() - size() >= __n)
	{
	  std::copy_backward(__position, end(),
			     this->_M_impl._M_finish + difference_type(__n));
	  std::fill(__position, __position + difference_type(__n), __x);
	  this->_M_impl._M_finish += difference_type(__n);
	}
      else
	{
	  const size_type __len = 
	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
	  _Bit_pointer __q = this->_M_allocate(__len);
	  iterator __start(std::__addressof(*__q), 0);
	  iterator __i = _M_copy_aligned(begin(), __position, __start);
	  std::fill(__i, __i + difference_type(__n), __x);
	  this->_M_impl._M_finish = std::copy(__position, end(),
					      __i + difference_type(__n));
	  this->_M_deallocate();
	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
	  this->_M_impl._M_start = __start;
	}
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first, 
		      _ForwardIterator __last, std::forward_iterator_tag)
      {
	if (__first != __last)
	  {
	    size_type __n = std::distance(__first, __last);
	    if (capacity() - size() >= __n)
	      {
		std::copy_backward(__position, end(),
				   this->_M_impl._M_finish
				   + difference_type(__n));
		std::copy(__first, __last, __position);
		this->_M_impl._M_finish += difference_type(__n);
	      }
	    else
	      {
		const size_type __len =
		  _M_check_len(__n, "vector<bool>::_M_insert_range");
		_Bit_pointer __q = this->_M_allocate(__len);
		iterator __start(std::__addressof(*__q), 0);
		iterator __i = _M_copy_aligned(begin(), __position, __start);
		__i = std::copy(__first, __last, __i);
		this->_M_impl._M_finish = std::copy(__position, end(), __i);
		this->_M_deallocate();
		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
		this->_M_impl._M_start = __start;
	      }
	  }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
	{
	  std::copy_backward(__position, this->_M_impl._M_finish, 
			     this->_M_impl._M_finish + 1);
	  *__position = __x;
	  ++this->_M_impl._M_finish;
	}
      else
	{
	  const size_type __len =
	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
	  _Bit_pointer __q = this->_M_allocate(__len);
	  iterator __start(std::__addressof(*__q), 0);
	  iterator __i = _M_copy_aligned(begin(), __position, __start);
	  *__i++ = __x;
	  this->_M_impl._M_finish = std::copy(__position, end(), __i);
	  this->_M_deallocate();
	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
	  this->_M_impl._M_start = __start;
	}
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
	_M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

#if __cplusplus >= 201103L
  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
	return false;
      __try
	{
	  _M_reallocate(size());
	  return true;
	}
      __catch(...)
	{ return false; }
    }
#endif
# 839 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#if __cplusplus >= 201103L

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<typename _Alloc>
    size_t
    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using _GLIBCXX_STD_C::_S_word_bit;
      using _GLIBCXX_STD_C::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
	{
	  const size_t __clength = __words * sizeof(_Bit_type);
	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
	}

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
	{
	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

	  const size_t __clength
	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
	  if (__words)
	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
	  else
	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
	}

      return __hash;
    }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // C++11
# 886 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3

#endif /* _VECTOR_TCC */
# 888 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/vector.tcc" 3
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 2 3
#endif
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3

#ifdef _GLIBCXX_DEBUG
#if 0 /* expanded by -frewrite-includes */
# include <debug/vector>
#endif /* expanded by -frewrite-includes */
# 73 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 74 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
#endif
# 75 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3

#ifdef _GLIBCXX_PROFILE
#if 0 /* expanded by -frewrite-includes */
# include <profile/vector>
#endif /* expanded by -frewrite-includes */
# 77 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
# 78 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3
#endif
# 79 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3

#endif /* _GLIBCXX_VECTOR */
# 81 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/vector" 3

# 14 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 15 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
#if 0 /* expanded by -frewrite-includes */
#include "lp-src/runtime/include/nlp_sim_types.h"
#endif /* expanded by -frewrite-includes */
# 15 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_sim_types.h" 1
/***************************************************************************
  SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work of
  Synopsys, Inc., and is fully protected under copyright and trade secret
  laws. You may not view, use, disclose, copy, or distribute this file or
  any information contained herein except pursuant to a valid written
  license from Synopsys.
 ***************************************************************************/

/***************************************************************************
Author: Harsh Chilwal
Purpose: Simulation Run time Interface
Detailed Description: This file controls the run time simulation of the
UPF parser.
 ***************************************************************************/

///@file upfsimtypes.hh

#ifndef _NLP_SIMTYPES_H__
#define _NLP_SIMTYPES_H__

#define LP_DBG_UNINIT    -2
#define LP_DBG_INIT      -1
#define LP_DBG_TRACE     6
#define LP_DBG_LVL0      0
#define LP_DBG_LVL1      1
#define LP_DBG_LVL2      2
#define LP_DBG_LVL3      3
#define LP_DBG_LVL4      4
#define LP_DBG_LVL5      5

#ifdef __cplusplus
extern "C" {
#endif
# 34 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_sim_types.h"


typedef enum {
    SIM_NORMAL,
    SIM_SILENT
} SimModeType;

typedef enum {
    AssertNoControlC = 0,
    AssertSuspendC,
    AssertContinueC,
    AssertKillC
} AssertControlType;

typedef enum {
    UnmarkedReinitC = 0,
    ReinitC,
    DontReinitC,
    TransitiveReinitC,
    TransitiveDontReinitC
} ReinitType;

typedef enum {
    SUPPLY_OFF,
    SUPPLY_UNDETERMINED,
    SUPPLY_PARTIAL_ON,
    SUPPLY_FULL_ON
} supply_state;

typedef struct supply_net_type_s {
    supply_state   state_;
    int            voltage_;
} supply_net_type;

/* Power Domain State */
typedef enum {
    NORMAL = 0,
    CORRUPT,
    CORRUPT_ON_ACTIVITY,
    CORRUPT_ON_CHANGE,
    CORRUPT_STATE_ON_ACTIVITY,
    CORRUPT_STATE_ON_CHANGE
} power_state_simstate;

typedef enum {
    Corrupt_X_C = 0,
    Corrupt_Z_C,
    Corrupt_1_C,
    Corrupt_0_C,
    Corrupt_01_C,
    Corrupt_01X_C,
    Corrupt_01XZ_C,
    NoCorruptionC
} CorruptionType;

typedef enum {
    Logic0 = 0,
    Logic1,
    LogicZ,
    LogicX
} LogicType;

typedef enum {
    HDL2UPF_UNDEF,
    SV_LOGIC2UPF,
    SV_LOGIC2UPF_GNDZERO,
    SV_LOGIC2UPF_MD,
    SV_LOGIC2UPF_GNDZERO_MD,
    SV_LOGIC2UPF_2S,
    SV_LOGIC2UPF_GNDZERO_2S
} Sv2UpfInbuiltType;

typedef enum {
    UPF2HDL_UNDEF,
    SV_TIED_HI,
    SV_TIED_LO,
    UPF_GNDZERO2SV_LOGIC,
    UPF2SV_LOGIC
} Upf2SvInbuiltType;

typedef enum {
    VHDL2UPF_UNDEF,
    VHDL_SL2UPF,
    VHDL_SL2UPF_GNDZERO
} Vh2UpfInbuiltType;

typedef enum {
    UPF2VHDL_UNDEF,
    UPF2VHDL_SL,
    UPF_GNDZERO2VHDL_SL,
    VHDL_TIED_HI,
    VHDL_TIED_LO
} Upf2VhInbuiltType;

typedef enum {
    UNCONNECTED = 0,
    IMPLICIT_CONNECTION,
    EXPLICIT_CONNECTION,
    ALWAYS_ON,
    POLICY_CONNECTION,
    ATTRIBUTE_CONNECTION,
    ALREADY_CONNECTED,
    UNASSOCIATED_INSTANCE
} ConnectionType;

typedef enum {
    CorruptGateC = 0,
    ClampGateC
} XoverGateControlType;

typedef enum {
    UNDEFINED_POLICY = 0,
    ISOLATION_POLICY,
    RETENTION_POLICY,
    LEVEL_SHIFTER_POLICY,
    POWER_SWITCH_POLICY,
    SRSN_POLICY,
    SPA_POLICY,
    SPICE_CSN
} PolicyType;

typedef enum {
    NoForceSemanticC = 0,
    ForcePriorityC,
    ForceAndCorruptC,
    FlushForcesC,
    DeferForcesC
} ForceSemanticType;
#ifdef __cplusplus
}
#endif
# 165 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_sim_types.h"

#endif
# 167 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_sim_types.h"
# 16 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "lp-src/runtime/include/nlp_ip_info.h"
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_ip_info.h" 1
/***************************************************************************
   SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work of
   Synopsys, Inc., and is fully protected under copyright and trade secret
   laws. You may not view, use, disclose, copy, or distribute this file or
   any information contained herein except pursuant to a valid written
   license from Synopsys.
 ***************************************************************************/
#ifndef _NLP_IP_INFO_H__
#define _NLP_IP_INFO_H__

#ifdef __cplusplus
extern "C" {
#endif
# 14 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_ip_info.h"

typedef enum {
    NLP_ASSERT_CONTROL_STATE_MASK = 0x1,
    NLP_ASSERT_CONTROL_TYPE_MASK = 0x6,
    NLP_REINIT_MASK          = 0x38,
    NLP_POWER_BOUNDARY_MASK  = 0x40,
    NLP_PRIMARY_POWER_MASK   = 0x80,
    NLP_PRIMARY_GROUND_MASK  = 0x100,
    NLP_SIMSTATE_MASK        = 0xE00,
    NLP_CORRUPTION_TYPE_MASK = 0x7000,
    NLP_PLI_WRITES_DISABLE_MASK   = 0x8000,
    NLP_DOMAIN_ID_MASK       = 0x7FFF0000,
    NLP_REAL_CORRUPTION_MASK = 0x80000000
} IpBitMaskT;

typedef enum {
    NLP_ASSERT_CONTROL_STATE_INDX = 0,
    NLP_ASSERT_CONTROL_TYPE_INDX  = 1,
    NLP_REINIT_INDX           = 3,
    NLP_POWER_BOUNDARY_INDX   = 6,
    NLP_PRIMARY_POWER_INDX    = 7,
    NLP_PRIMARY_GROUND_INDX   = 8,
    NLP_SIMSTATE_INDX         = 9,
    NLP_CORRUPTION_TYPE_INDX  = 12,
    NLP_PLI_WRITES_DISABLE_INDX    = 15,
    NLP_DOMAIN_ID_INDX        = 16,
    NLP_REAL_CORRUPTION_INDX  = 31
} IpBitPositionT;

typedef enum {
    NLP_PG_SUPPLYNET_ID_MASK    = 0xffff,
    NLP_PG_SUPPLY_STATE_MASK    = 0x30000,
    NLP_PG_VCT_MASK             = 0x1FFC0000,
    NLP_PG_CONN_TYPE_MASK       = 0xE0000000
} PgFlagBitMaskT;

typedef enum {
    NLP_PG_SUPPLYNET_ID_INDX    = 0,
    NLP_PG_SUPPLY_STATE_INDX    = 16,
    NLP_PG_VCT_INDX             = 18,
    NLP_PG_CONN_TYPE_INDX       = 29
} PgFlagBitPositionT;

typedef struct IpPowerMarkingS {
    unsigned              assertControlState_ : 1;
    AssertControlType     assertControlType_ : 2;
    ReinitType            reinit_ : 3;
    unsigned              powerBoundary_ : 1,
                          primaryPowerOff_ : 1,
                          primaryGroundOff_ : 1;
    power_state_simstate  simstate_ : 3;
    CorruptionType        corruptType_ : 3;
    unsigned              pliWritesDisabled_ : 1,
                          domainId_ : 15,
                          realCorrupt_ : 1;
} IpPowerMarkingT, *IpPowerMarkingP;

unsigned packIpPowerMarkingInNumber(IpPowerMarkingP marking);

IpPowerMarkingT getIpPowerMarking(unsigned marking);

int isIpPowerManaged(void* ip);

IpPowerMarkingT getIpPowerState(void* ip);
void setIpPowerState(void* ip, IpPowerMarkingP marking);

typedef struct QirdPowerMarkingS {
    unsigned forRent_ : 1,
             isBlackBox_ : 1,
             powerNetworkModule_ : 1,
             powerSwitchModule_ : 1,
             powerScopeModule_ : 1,
             powerManaged_ : 1,
             powerAware_ :1,
             cellMapped_ : 1,
             hasCellInstances_ :1,
             lowPowerModule_ : 1,
             bindModule_ : 1,
             lpaChecker_ : 1,
             alwaysOn_ : 1;
    ReinitType reinit_ : 3;
    unsigned   cellId_ : 16;
} QirdPowerMarkingT, *QirdPowerMarkingP;

unsigned packQirdPowerMarkingInNumber(QirdPowerMarkingP marking);

QirdPowerMarkingT getQirdPowerMarking(unsigned marking);

typedef struct IpUpf2SvPgPinFlagInfoS {
    unsigned                supplyNetId_ : 16;
    supply_state            supplyState_ : 2;
    Upf2SvInbuiltType      vct_ : 11;
    ConnectionType          connectionType_ : 3;
} IpUpf2SvPgPinFlagInfoT, *IpUpf2SvPgPinFlagInfoP;

unsigned packIpUpf2SvPgPinFlagInfoInNumber(IpUpf2SvPgPinFlagInfoP info);

IpUpf2SvPgPinFlagInfoT getIpUpf2SvPgPinFlagInfo(unsigned info);

bool isPowerDownIP(void* sigH, const char*,const char*,const char*, int ,int);
bool isPowerDownCheckEnabled();

#ifdef __cplusplus
}
#endif
# 119 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_ip_info.h"

#endif /* _NLP_IP_INFO_H__ */
# 121 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/nlp_ip_info.h"
# 17 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "buffer.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh" 1
// Copyright (C) 1995-1997 Radiant Design Tools.  All Rights Reserved.
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

#ifndef _BUFFER_HH_
#define _BUFFER_HH_

#ifndef _POOL_HH_
#if 0 /* expanded by -frewrite-includes */
#    include "pool.hh"
#endif /* expanded by -frewrite-includes */
# 10 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
#endif
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
#ifndef _UTIL_HH_
#if 0 /* expanded by -frewrite-includes */
#    include "util.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
#if 0 /* expanded by -frewrite-includes */
#include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
#if 0 /* expanded by -frewrite-includes */
#include <string.h>
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"


// RFE--Matute, plug in what pool new/delete you want here.  GA
template<class T> class VolatileBuffer
{
public:
    VolatileBuffer(int startingSize)
        : currentSize(startingSize), claimed(false) {
        buffer = new T[(currentSize <= 0) ? 1 : currentSize];
        memcheck(buffer);
    }

    T*      claim(int size) {
        fassert(!claimed, msg("Claiming buffer not released"));
        claimed = true;
        if (size > currentSize) {
            // Must resize it. Monotonic growth--no shrink until deleted.
            nullcheck(buffer);
            delete [] buffer;
            currentSize = size;
            buffer = new T[currentSize];
            memcheck(buffer);
        }
        return buffer;
    }

    void    release() {
        fassert(claimed, msg("Releasing buffer not claimed"));
        claimed = false;
    }

    ~VolatileBuffer() {
        // DTOR of static objects may be called twice from
        // __tcf_3 () and also from
        // _dl_fini -> _fini -> __do_global_dtors_aux --> __cxa_finalize --> __tcf_3
        if (buffer) {
            delete [] buffer;
            buffer = NULL;
        }
    }

private:
    T*      buffer;
    int     currentSize;
    bool    claimed;
};

typedef VolatileBuffer<char>    CharVolatileBuffer;
typedef VolatileBuffer<uint>    UIntVolatileBuffer;


/// Helper class for non-intrusive parsing of strings.
///
/// @note StringSlice does not create a copy of the string it's working on. The
/// user must ensure that StringSlice::sBase remains unchanged while there are
/// any live StringSlice objects.
class StringSlice
{
public:
    /// @name Constructors
    //@{
    /// Creates an empty string slice.
    StringSlice()
        : sBase(NULL), iMin(0), iMax1(0) { }

    /// Creates a string slice spanning the entire string.
    explicit StringSlice(const char* s)
        : sBase(s), iMin(0), iMax1(s ? strlen(s) : 0) { }

    /// Creates a string slice s[i:j). Assumes that the caller verified that
    /// indices were correct.
    StringSlice(const char* s, unsigned i, unsigned j)
        : sBase(s), iMin(i), iMax1(j) {
        nullcheck(s);
        fassert(i <= j, msg("invalid slice bounds: %u:%u", i, j));
    }
    //@}

public:
    /// @name Read-only accessors
    //@{
    /// Returns true if the slice is empty.
    bool    isEmpty() const
    { return (iMin >= iMax1); }

    /// Returns the length of the slice.
    unsigned    getLength() const
    { return (iMax1 - iMin); }

    /// Returns the first character of the slice. The returned value is '\0' if
    /// isEmpty() == true.
    char        getFirstChar() const
    { return (isEmpty() ? '\0' : sBase[iMin]); }

    /// Returns a pointer to the first character of the slice. The returned
    /// value is NULL if isEmpty() == true.
    /// @attention The string may not be terminated with a '\0'.
    const char* getFirstCharPtr() const
    { return (isEmpty() ? NULL : (sBase + iMin)); }

    /// Copies the slice to char buf[sz]. Asserts if the string was too long.
    void    copyToBuffer(char* buf, unsigned sz) const;

    /// Unchecked version of copyToBuffer(). Only call this method if you are
    /// sure that the slice will fit in the buffer.
    void    copyToBufferUnchecked(char* buf) const;

    /// Returns a pointer to a copy of the slice allocated on the heap using
    /// operator new[]. Returns NULL for empty slices.
    char*   makeCopyOnHeap() const;

    /// Returns true if the slice starts with the given string.
    bool    startsWith(const char* s) const;

    /// Returns true if the slice ends with the given string.
    bool        endsWith(const char* s) const;

    /// Returns true if the slice has the same contents as the given string.
    bool    isSameAs(const char* s) const;

    /// Returns true if the slice is not empty and is a suffix of the given
    /// string.
    bool    isSuffixOf(const char* s) const;

    /// Returns the result of strcmp(slice, r).
    int         strCmp(const StringSlice& r) const;

    /// Returns the result of strcmp(slice, r).
    int         strCmp(const char* r) const
    { return strCmp(StringSlice(r)); }

    /// Returns the result of strtol() executed on the string. Returns 0 if
    /// the slice is longer than the internal buffer used by getIntValue().
    int     getIntValue() const;
    //@}

public:
    /// @name Operations that change the contents of the slice
    //@{
    /// Sets the length of the slice to newLength.
    /// @note If newLength is negative, getLength() + newLength will be used
    /// as the effective length.
    /// @attention If the requested effective length exceeds the actual length
    /// of the slice, an assertion is raised.
    void        setLength(int newLength);

    /// Removes the first character from the slice. Does nothing if the slice
    /// was empty.
    void        removeFirstChar()
    { if (!isEmpty()) { ++iMin; } }

    /// Combination of removeFirstChar() and getFirstChar().
    char        getNextChar()
    { removeFirstChar(); return getFirstChar(); }

    /// Removes the character from the slice. Asserts if the slice didn't start
    /// with the character.
    void        removePrefix(char c);

    /// Removes the string from the beginning of the slice. Asserts if the slice
    /// didn't start with the string.
    void        removePrefix(const char* s);

    /// Removes the string from the end of the slice. Asserts if the slice
    /// didn't end with the string.
    void        removeSuffix(const char* s);

    /// Strips white space off both ends of the slice.
    void    trim();

    /// Extracts a prefix from the slice.
    /// @param sep The character separating the prefix from the rest of the
    ///     slice.
    /// @param doTrim If true (the default value), trim() is called on both the
    ///     return value and the slice.
    /// @param delSep If true (the default value), the separator is removed from
    ///     the string.
    /// @return Returns the part of the slice that precedes sep. If the slice
    ///     doesn't contain sep, returns the entire slice.
    /// @note This operation is destructive: it removes from the slice both the
    ///     returned prefix and (if delSep is true) the separator.
    StringSlice extractPrefix(char sep, bool doTrim = true, bool delSep = true);
    //@}

private:
    const char* sBase;      ///< Base of the string
    unsigned    iMin;       ///< The first character of the string
    unsigned    iMax1;      ///< One past the last character
};


/// StringBuf -- automatically growing string buffer.
/// @todo RFE -- merge this somehow with VolatileBuffer.
class StringBuf
{
public:
    lifeGuardNewAndDeleteMacro

    StringBuf()
        : index_(0), size_(OnStackStringLengthC), isOnHeap_(false) { }
    explicit StringBuf(const char *str)
        : index_(0), size_(OnStackStringLengthC), isOnHeap_(false) { 
        if (str) {
            this->add(str);
        }
    }
    ~StringBuf();

    void            add(char chr);
    void            add(const char* str);
    void            add(const char* str, size_t len);
    void            add(int i);
    void            add(uint i);
    void            add(const StringSlice& ss) {
        add(ss.getFirstCharPtr(), ss.getLength());
    }
    void            addFormattedVA(const char* fmt, va_list args);
    void            addFormatted(const char* fmt, ...);

    void            reset() { index_ = 0; }

    void            end()   { }                     // obsolete
    void            claim() { reset(); }            // obsolete
    void            release() { }                   // obsolete

    char*           getStr() const {
        char* const string = getPointer();
        string[index_] = '\0';
        return string;
    }
    size_t             getStrLen() const {
        return index_;
    }
    void            truncateToLength(size_t n);

    char*           tokenize(const char *delim) {
        return strtok(getStr(), delim);
    }    
    char*           nextTok(const char *delim) {
        return strtok(NULL, delim);
    }

private:
    bool            tryFormattedVA(const char* fmt, va_list args);

protected:
    char*           getPointer() const {
        return isOnHeap_ ? str_.onHeap : str_.onStack;
    }
    size_t             getCapacity() const {
        return size_;
    }
    void            reallocStr(size_t deltaSize);

private:
    // Can't copy StringBuf contents.
    StringBuf(const StringBuf&);
    StringBuf& operator =(const StringBuf&);

private:
    enum { OnStackStringLengthC = 88 };

private:
    size_t        index_;
    size_t        size_;
    bool          isOnHeap_;
    union {
        mutable char onStack[OnStackStringLengthC];
        char*       onHeap;
    } str_;
};

#endif
# 290 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/buffer.hh"
# 18 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh" 2

#define NAMESPACE_UPFIR_BEGIN namespace upfir {
#define NAMESPACE_UPFIR_END } // upfir
#define UPFIR upfir
#define NAMESPACE_CPFIR_BEGIN namespace cpfir {
#define NAMESPACE_CPFIR_END } // cpfir
#define CPFIR cpfir

#define _LP_MAX_ISO_ENABLE 8

NAMESPACE_UPFIR_BEGIN

LifeGuard* getUpfLifeGuard();

#define upfLifeGuardNewAndDeleteMacro  \
    void*           operator new(size_t p_sz) { \
        return getUpfLifeGuard()->create(p_sz); \
    } \
    void            operator delete(void* p_item, size_t p_sz) { \
        getUpfLifeGuard()->destroy(p_item, p_sz); \
    }


enum UpfParsingMode {
    NATIVE_LPC = 0,
    NATIVE_MVC,
    MVSIM_REGRESSIONC
};

enum UpfParsingFileMode {
    UpfFileC=0,
    LpaBindC,
    ConfigC,
    ErrorC
};

//This is used to indicate the type of instance pointer 
//Mainly used to find the parent instance of a given instance
enum DESIGN_TREE_TYPE {
    EL_TREE,      
    SIGNET_TREE     
};

//This enum is used to identify the  flop control signal types
enum FlopCtrlSigType {
    FlopCtrlNoneC,
    FlopCtrlClockC,
    FlopCtrlAsyncC,
    FlopCtrlBothC
};

//This structure holds data about lower_domain_boundary attribute
//The attribute's value and the scope where it's set
struct LowerDomainBoundaryData {
    bool value_;
    std::string scopeName_;
    std::string fileName_;
    unsigned int lineNo_; 
};

typedef enum NetFunctionEnum {
    UNKNOWN_FUNCTION_TYPE,
    POWER_FUNCTION_TYPE,
    GROUND_FUNCTION_TYPE,
    PWELL_FUNCTION_TYPE,
    NWELL_FUNCTION_TYPE,
    DEEP_PWELL_FUNCTION_TYPE,
    DEEP_NWELL_FUNCTION_TYPE
} SupplyNetFunctionT;

class DesignModel;
class LpSourceInfo;
class ReInitInfo;
class DesignElementToken; 
typedef SlistL<DesignElementToken> DesignElementTokenL;
typedef SlistLI<DesignElementToken> DesignElementTokenLI;

class UpfLogicNet;

//enum for black_box marking for DesignElementType
enum BLACK_BOX_TYPE {
    NO_BLACK_BOX = 0,
    INSIDE_BLACK_BOX = 1,
    AT_BLACK_BOX = 2,
    AUTOMATIC_BLACK_BOX = 3
};
///This structure will be used by design element call back.
struct DesignElementType {
    void *instance_;
    void *elabInstance_;
    void *object_;
    UpfLogicNet *lNet_;
    void *process_;
    char *dataType;
    const char* cell;
    char *designName_; //Actual designElement Name from design
    char *vhName_; //name for VHDL instance. needed to create vhpi handle at runtime.
    char *resolvedName_;
    char *targetName_;
    char *resolvedNameRT_;   //Resolved name required to get mhpi handle at runtime. This is little different from resolvedName when there are escape chars
    int startPosOfTargetName_;
    DesignElementTokenL  *tokenL_;
    //is design element exist.
    unsigned int DESIGN_EXIST          :1;
    unsigned int DESIGN_SIGNAL         :1;
    unsigned int DESIGN_PORT           :1;
    unsigned int DESIGN_I_PORT         :1;
    unsigned int DESIGN_O_PORT         :1;
    unsigned int DESIGN_IO_PORT        :1;
    unsigned int DESIGN_INSTANCE       :1;
    unsigned int DESIGN_GATE_INSTANCE  :1;
    unsigned int DESIGN_MOD_INSTANCE   :1;
    unsigned int DESIGN_UDP_INSTANCE   :1;
    unsigned int DESIGN_TOP_MODULE     :1;
    unsigned int GENERATE_OR_BLOCK     :1;
    unsigned int PROCESS               :1;
    unsigned int DESIGN_NOT_SUPPORTED  :1;
    unsigned int IS_VERILOG        :1;
    unsigned int CELL_MAPPED       :1;
    unsigned int DESIGN_MODEL          :1;
    unsigned int UPF_LOGIC_NET         :1;
    unsigned int UPF_LOGIC_PORT        :1;
    BLACK_BOX_TYPE BLACK_BOX;
    /*
        01 - INSIDE_BLACK_BOX
        10 - AT_BLACK_BOX
        11 - AUTOMATIC_BLACK_BOX
    */

    unsigned int WHITE_BOX             :1;
    unsigned int SPICE_I_PORT          :1;
    unsigned int SPICE_O_PORT          :1;
    unsigned int SPICE_IO_PORT         :1;
    unsigned int WILDCARD_CLASSREF     :1;
    unsigned int INSIDE_CELL_DB        :1; //Inside DB hierarchy
    unsigned int AT_CELL_DB            :1; //At the DB level
    unsigned int AT_MACRO_CELL_DB      :1; //At the macro DB level
    unsigned int OUT_OF_POWER_TOP      :1; //out of power top.
    unsigned int ATNON_MACRO_DB        :1; //non macro lib cell.
    unsigned int SV_INTERFACE_MODPORT  :1; // SV interface / modport
    unsigned int IS_ENCRYPT            :1; // encrypted mangle based flow
    unsigned int IS_WREAL_PORT         :1; // Wreal Port
    unsigned int USER_SPECIFIED  :1; // element is explicitly specified 
    unsigned int OUT_OF_RANGE_STATUS : 1;
    int          cellId;
    DesignElementType () : instance_(NULL),elabInstance_(NULL),object_(NULL),lNet_(NULL),process_(NULL),dataType(NULL),cell(NULL), designName_(NULL), vhName_(NULL), resolvedName_(NULL), targetName_(NULL), resolvedNameRT_(NULL) {}
};

struct UpfTokenProp {
    char* name_;
    unsigned int selectPos_:23;
    unsigned int isVlog_:1;
    unsigned int isGen_:1;
    unsigned int isEscaped_:1;
    unsigned int isStruct_:1;
    unsigned int isTarget_:1;
    unsigned int isResidualName_:1;
    unsigned int isInst_:1;
    unsigned int isEncrypted_:1;
    unsigned int isBBoxToken_:1;
    unsigned int isDBToken_:1;
    UpfTokenProp() : name_(0),selectPos_(0),isVlog_(0),isGen_(0),isEscaped_(0),isStruct_(0),isTarget_(0),isResidualName_(0),isInst_(0),isEncrypted_(0),isBBoxToken_(0),isDBToken_(0) {}
};

///@file This file will define all enums required for UPF representation
///This also define all required iterators.

enum UpfClassType {
    UpfNamedObjC = 0,
    PowerNetworkC,
    PowerDomainC,
    PowerStateTableC,
    PstStateC,
    PstEntryC,
    Hdl2UpfVctC,
    Upf2HdlVctC,
    BindCheckerC,
    NameFormatC,
    SaveUpfC,
    LoadUpfC,
    SupplyNetC,
    SupplyNetPairC,
    SupplyNetHandleC,
    SupplyPortC,
    LogicNetC,
    LogicPortC,
    DesignPortC,
    PowerSwitchC,
    BoolConstC,
    BoolExprIdC,
    BoolSupplyExprC,
    BoolExprUnaryC,
    BoolExprBinaryC,
    BoolExprConcatC,
    OnPortStateC,
    ControlPortC,
    AckPortC,
    SwitchStateC,
    LevelShifterC,
    IsolationC,
    SRSNStrategyC,
    RetentionC,
    RetentionSignalC,
    UpfElementC,
    DesignScopeC,
    DesignModelC,
    DesignElementTokenC,
    UpfRetentionElementC,
    RtnPortMapC,
    MapRtnElementC,
    ScopeTableC,
    PowerStateSimstateC,
    CurrentPowerStateC,
    SupplyNetAnalysisC,
    PowerScopeC,
    IsolationCellFuncC,
    IsolationCellSupplyC,
    MetaInstanceC,
    AttributeValueC,
    PortAttributeC,
    PortBBAttributeC,
    SupplySetStateC,
    SupplySetHandleC,
    SupplyNetFunctionC,
    XoverGateC,
    SpiceConnectC,
    SupplyStateC,
    UpfSupplySourceC,
    UpfRootSupplyDriverC,
    UpfPgSimDriverLoadsC,
    UpfSupplyPortStateC,
    PowerSwitchStateC,
    StateC,
    StateEntryC,
    StateEntryPairC,
    TransitionC,
    TransitionGroupC,
    StateMachineC,
    LpSourceInfoC,
    ReInitInfoC,
    CorrSupplyGroupC,
    IsoSinkDomainsDBC,
    CdcClockC,
    CdcInstanceC,
    UpfGroupC,
    UpfGroupStateC,
    UnresolvedEquivalentSupplyC,
    UpfEquivalentSupplySourcesC,
    BlackBoxModelC,
    ControlSignalInfoC,
    ContextResetGroupC,
    cUpfClassType
};

///Forward declarations of UPF interface classes
class UpfObj;
class PowerNetwork;
class PowerNetworkForIPPartition;
class PowerDomain;
class PowerStateTable;
class PstState;
class PstEntry;
class Hdl2UpfVct;
class Upf2HdlVct;
class BindChecker;
class NameFormat;
class SaveUpf;
class LoadUpf;
class SupplyNet;
class SupplyNetPair;
class SupplyPort;
class UpfLogicPort;
class PowerSwitch;
class LevelShifterStrategy;
class XoverGate;
class IsolationStrategy;
class SRSNStrategy;
class RetentionSignal;
class RetentionStrategy;
class RetentionElements;
class RtnPortMap;
class MapRtnElement;
class OnPortState;
class AckPort;
class AckDelay;
class SwitchState;
class ControlPort;
class UpfPort;
class BoolExpr;
class BoolExprId;
class BoolExprUnary;
class BoolExprBinary;
class BoolExprConcat;
class ScopeTable;
class UpfModel;
class DesignObject;
class DesignScope;
class UpfDesignPort;
class SupplyNetAnalysis;
class PowerScope;
class SupplySetHandle;
class SupplySetState;
class UpfExprVisitor;
class IsolationCellFunc;
class IsolationCellSupply;
class PortAttribute;
class AttributeValue;
class UpfSimstate;
class SupplyNetFunction;
class SupplyNetHandle;
class SupplyState;
class State;
class StateEntry;
class StateEntryPair;
class Transition;
class TransitionGroup;
class StateMachine;
class UpfPgSimDriverLoads; 
class UpfPgSimScope;
class UpfGroup;
class UpfGroupState;

class DomainCondition;
class ActiveStateCondition;
class SetSimControl;
class NominalCondition;
class PowerMode;
class PowerModeCtrlGrp;
class PowerDesign ;
class DomainMappingMgr;
class MetaInstance;
class CorrelatedSupplyGroup;
class PortMap;
class ParameterMap;
class CorrelatedSupplyGroup;

class UpfSupplyNet;
class UpfSupplyPort;
class UpfSupplySource;
class UpfRootSupplyDriver;
class UpfSupplyPortState;
class SpiceConnect;
class IsoSinkDomainsDB;
class CdcClock;
class CdcInstance;
class CdcInstanceDb;
class BlackBoxModel;
class ControlSignalInfo;


typedef SlistL<UpfSupplyNet> UpfSupplyNetL;
typedef SlistLI<UpfSupplyNet> UpfSupplyNetLI;
typedef SlistL<UpfSupplyPort> UpfSupplyPortL;
typedef SlistLI<UpfSupplyPort> UpfSupplyPortLI;
typedef SlistL<UpfSupplySource> UpfSupplySourceL;
typedef SlistLI<UpfSupplySource> UpfSupplySourceLI;
typedef SlistL<UpfRootSupplyDriver> UpfRootSupplyDriverL;
typedef SlistLI<UpfRootSupplyDriver> UpfRootSupplyDriverLI;
typedef SlistL<UpfSupplyPortState> UpfSupplyPortStateL;
typedef SlistLI<UpfSupplyPortState> UpfSupplyPortStateLI;
typedef HashTableL<UpfSupplyPortState> UpfSupplyPortStateTableL;
typedef SlistL<SpiceConnect> SpiceConnectL;
typedef SlistLI<SpiceConnect> SpiceConnectLI;
typedef SlistL<UpfGroup> UpfGroupL;
typedef SlistLI<UpfGroup> UpfGroupLI;
typedef HashTableL<UpfGroup> UpfGroupTableL;
typedef HashTableLI<UpfGroup> UpfGroupTableLI;
typedef SlistL<UpfGroupState>  UpfGroupStateL;
typedef SlistLI<UpfGroupState>  UpfGroupStateLI;
typedef HashTableL<UpfGroupState> UpfGroupStateTableL;
typedef HashTableLI<UpfGroupState> UpfGroupStateTableLI;

typedef SlistLI<SupplySetHandle>    SupplySetLI;
typedef HashTableLI<SupplySetHandle> SupplySetTableLI;
typedef HashTablePI<SupplySetHandle> SupplySetTablePI;
typedef HashTableLI<SupplySetHandle>  SupplySetHandleTableLI;
typedef HashTableLI<SupplySetHandle>  SupplySetHandleTableLI;
typedef SlistLI<SupplySetState>  SupplySetStateLI;
typedef HashTableLI<SupplyNetFunction> SupplyNetFunctionLI;
typedef HashTableLI<SupplyNetFunctionT> SupplyNetFunctionTLI;
typedef HashTableLI<SupplyNetHandle> SupplyNetHandleLI;
typedef SlistLI<SupplyNetHandle> SupplyNetHandleSLI;

///All required iterators
typedef SlistLI<SupplySetHandle>  SupplySetHandleLI;
typedef SlistLI<IsolationCellFunc> IsolationCellFuncLI;
typedef SlistLI<IsolationCellSupply> IsolationCellSupplyLI;
typedef SlistLI<AttributeValue> AttributeValueLI;
typedef SlistLI<DesignModel> DesignModelLI;
typedef HashTableLI<DesignModel> DesignModelTableLI;
typedef SlistLI<CorrelatedSupplyGroup> CorrSupplyGroupLI;


typedef HashTableL<SupplyNet> SupplyNetTableL;
typedef HashTableLI<SupplyNet> SupplyNetTableLI;
typedef HashTableP<SupplyNet> SupplyNetTableP;
typedef HashTablePI<SupplyNet> SupplyNetTablePI;
typedef HashTableP<DesignObject> DesignObjectTableP;
typedef HashTablePI<DesignObject> DesignObjectTablePI;
typedef HashTableL<SupplyPort> SupplyPortTableL;
typedef HashTableLI<SupplyPort> SupplyPortTableLI;
typedef HashTableP<SupplyPort> SupplyPortTableP;
typedef HashTablePI<SupplyPort> SupplyPortTablePI;
typedef HashTableLI<SupplyNetPair>  SupplyNetPairLI;
typedef HashTableL<CdcClock> CdcClockTableL;
typedef HashTableLI<CdcClock>  CdcClockTableLI;
typedef HashTableL<CdcInstance> CdcInstanceTableL;
typedef HashTableLI<CdcInstance>  CdcInstanceTableLI;

typedef SlistLI<UpfDesignPort> UpfDesignPortLI;
typedef HashTableLI<UpfDesignPort> UpfDesignPortTableLI;
typedef SlistL<PowerScope> PowerScopeL;
typedef SlistLI<PowerScope> PowerScopeLI;
typedef HashTableL<DesignObject>   DesignObjectTableL;
typedef HashTableLI<DesignObject>  DesignObjectTableLI;
typedef HashTableLI<PowerDomain>   PowerDomainTableLI;
typedef HashTableLI<PowerScope>    PowerScopeTableLI;
typedef HashTableLI<PowerSwitch>   PowerSwitchTableLI;
typedef HashTableLI<SupplyPort>    SupplyPortTableLI;
typedef HashTableLI<SupplyNet>     SupplyNetTableLI;
typedef HashTablePI<DesignScope>   DesignScopeTablePI;
typedef SlistL<DesignScope>   DesignScopeL;
typedef SlistLI<DesignScope>   DesignScopeLI;
typedef HashTableL<RetentionStrategy> RetentionStrategyTableL;
typedef HashTableLI<RetentionStrategy> RetentionStrategyTableLI;


typedef SlistL<UpfObj> UpfObjL;
typedef SlistLI<UpfObj> UpfObjLI;
typedef SlistLI<char> charLI;
typedef SlistLI<PowerDomain> PowerDomainLI;
typedef SlistLI<PowerStateTable> PowerStateTableLI;
typedef HashTableLI<PowerStateTable> PSTTableLI;
typedef SlistLI<Hdl2UpfVct> Hdl2UpfVctLI;
typedef SlistLI<Upf2HdlVct> Upf2HdlVctLI;
typedef SlistLI<SaveUpf> SaveUpfLI;
typedef SlistLI<LoadUpf> LoadUpfLI;
typedef SlistLI<DesignObject > DesignObjectLI;
typedef SlistLI<Pair1<int, int> > ValuePairLI;
typedef SlistLI<SupplyNet> SupplyNetLI;
typedef SlistLI<SupplyPort> SupplyPortLI;
typedef SlistL<SupplyPort >     SupplyPortL;
typedef SlistLI<PowerSwitch> PowerSwitchLI;
typedef SlistLI<LevelShifterStrategy> LevelShifterLI;
typedef SlistLI<XoverGate> XoverGateLI;
typedef SlistLI<IsolationStrategy> IsolationLI;
typedef SlistLI<SRSNStrategy> SRSNStrategyLI;
typedef SlistLI<RetentionStrategy> RetentionLI;
typedef SlistL<RetentionStrategy> RetentionL;
typedef SlistLI<RetentionElements> RetentionElementsLI;
typedef SlistLI<RtnPortMap> RtnPortMapLI;
typedef SlistLI<MapRtnElement> MapRtnElementLI;
typedef SlistLI<OnPortState> OnPortStateLI;
typedef SlistLI<PstState> PstStateTableLI;
typedef SlistLI<PstEntry> PstEntryL;
typedef SlistLI<AckPort> AckPortLI;
typedef SlistLI<SwitchState> SwitchStateLI;
typedef SlistLI<ControlPort> ControlPortLI;
typedef SlistLI<UpfPort> UpfPortLI;
typedef SlistLI<RetentionSignal> RetentionSignalLI;
typedef SlistLI<BoolExpr> BoolExprLI;
typedef SlistLI<MetaInstance> MetaInstanceLI;
typedef SlistL< char > IsolationCellNameL;
typedef SlistLI < char > IsolationCellNameLI;
typedef SlistL<UpfLogicPort>        UpfLogicPortL;
typedef SlistLI<UpfLogicPort>       UpfLogicPortLI;
typedef HashTableL<UpfLogicPort>    UpfLogicPortTableL;
typedef HashTableLI<UpfLogicPort>   UpfLogicPortTableLI;
typedef HashTableL<UpfLogicNet>     UpfLogicNetTableL;
typedef HashTableLI<UpfLogicNet>    UpfLogicNetTableLI;
typedef SlistL<DesignObject > DesignObjectL;
typedef SlistL<MetaInstance> MetaInstanceL;

typedef SlistL<ActiveStateCondition> ActiveStateCondL;
typedef SlistLI<ActiveStateCondition> ActiveStateCondLI;
typedef SlistL<SetSimControl> SetSimControlL;
typedef SlistLI<SetSimControl> SetSimControlLI;
typedef SlistL<DomainCondition> DomainConditionL ;
typedef SlistLI<DomainCondition> DomainConditionLI;
typedef SlistL<NominalCondition> NominalCondL;
typedef SlistLI<NominalCondition> NominalCondLI;
typedef HashTableL<NominalCondition>   NominalCondTableL;
typedef HashTableLI<NominalCondition>   NominalCondTableLI;
typedef HashTableL<PowerMode>   PowerModeTableL;
typedef HashTableLI<PowerMode>   PowerModeTableLI;
typedef SlistL<PowerMode>    PowerModeL;
typedef SlistLI<PowerMode>   PowerModeLI;
typedef SlistL<PowerModeCtrlGrp> PowerModeCtrlGrpL ;
typedef SlistLI<PowerModeCtrlGrp> PowerModeCtrlGrpLI;
typedef SlistL<PowerSwitch> PowerSwitchRuleL;
typedef SlistLI<PowerSwitch> PowerSwitchRuleLI;
typedef SlistL<PowerDesign> PowerDesignL;
typedef SlistLI<PowerDesign> PowerDesignLI;
typedef HashTableL<IsolationStrategy> IsolationTableL;
typedef HashTableLI<IsolationStrategy> IsolationTableLI;
typedef SlistL<PortMap> PortMapL;
typedef SlistLI<PortMap> PortMapLI;
typedef SlistL<ParameterMap> ParameterMapL;
typedef SlistLI<ParameterMap> ParameterMapLI;

typedef SlistL<char >                    InstanceDesignObjectL;
typedef SlistLI<char >                    InstanceDesignObjectLI;
typedef SlistL<char >                    InstanceNameL;
typedef SlistLI<char >                    InstanceNameLI;
typedef SlistL<char >                    IgnoredIsoPNameL;
typedef SlistLI<char >                    IgnoredIsoPNameLI;
class NamePair;
typedef SlistL<NamePair>        NamePairL;
typedef SlistLI<NamePair>       NamePairLI;
typedef SlistL<DesignModel> DesignModelL;

typedef SlistL<BindChecker>           BindCheckerL;
typedef SlistLI<BindChecker>          BindCheckerLI;

typedef HashTableLI<SupplyState>     SupplyStateTableLI;
typedef SlistLI<SupplyState>         SupplyStateLI;

typedef SlistLI<State>               StateLI;
typedef HashTableLI<State>           StateTableLI;
typedef SlistLI<StateEntry>          StateEntryLI;
typedef SlistLI<StateEntryPair>      StateEntryPairLI;
typedef SlistLI<Transition>          TransitionLI;
typedef HashTableLI<Transition>       TransitionTableLI;
typedef HashTableLI<TransitionGroup> TransitionGroupTableLI;
typedef SlistLI<TransitionGroup>     TransitionGroupLI;
typedef SlistLI<StateMachine>     StateMachineLI;


typedef SlistL<UpfPgSimDriverLoads>        PgSimDriverLoadsL;
typedef SlistLI<UpfPgSimDriverLoads>       PgSimDriverLoadsLI;
typedef HashTableL<UpfPgSimDriverLoads>    PgSimDriverLoadsTableL;
typedef HashTableLI<UpfPgSimDriverLoads>   PgSimDriverLoadsTableLI;
typedef HashTableP<UpfPgSimScope>          PgSimScopeTableP;
typedef HashTablePI<UpfPgSimScope>         PgSimScopeTablePI;
typedef SlistL<IsoSinkDomainsDB >          IsoSinkDomainsDBL;
typedef SlistLI<IsoSinkDomainsDB >         IsoSinkDomainsDBLI;

typedef SlistL<BlackBoxModel>              BlackBoxModelL;
typedef SlistLI<BlackBoxModel>             BlackBoxModelLI;

enum UpfPowerStateSimstate {
    NOT_NORMALC,
    DEFAULT_NORMALC,
    NORMALC,
    CORRUPTC,
    CORRUPT_ON_ACTIVITYC,
    CORRUPT_ON_CHANGEC,
    CORRUPT_STATE_ON_ACTIVITYC,
    CORRUPT_STATE_ON_CHANGEC
};

enum LegalityType {
    IgnoreC,
    LegalC,
    IllegalC
};

enum UpfSupplyNetState {
    OFFC,
    UNDETERMINEDC,
    PARTIAL_ONC,
    FULL_ONC
};

enum UpfSupplyVoltageType {
    SUPPLY_STATE_C,
    SUPPLY_NET_STATE_C,
    SUPPLY_RANGE_C,
    SUPPLY_TRIPLET_C
};

///Enumeration for supply port direction
enum UpfPortDirection {
    UpfPortInC,
    UpfPortOutC,
    UpfPortInOutC,
    UpfUnspecifiedInC
};

enum UpfDesignDirection {
    UpfDesignInternalC,
    UpfDesignInputC,
    UpfDesignInoutC,
    UpfDesignOutputC
};


enum UpfHdlType {
    UpfVerilogC,
    UpfVHDLC,
    UpfMixedC,
    UpfUnknownHdlC
};
///Enumeration for supply net resolution function
enum UpfResolveType {
    UpfUnresolvedC,
    UpfOneHotC,
    UpfParallelC,
    UpfParallelOneHotC,
    UpfEitherC,
    UpfStrongC,
    UpfWeakC,
    UpfCustomC
};

///Enumeration for different HDL's
enum HdlType {
    VhdlC,
    VlogC,
    SvC
};
///-clamp_value
enum ClampValueType {
    ZeroC, //0
    OneC, //1
    HighImpedenceC, //Z
    LatchC, //latch
    AnyC,
    ValueC,
    UpfClampUnspecifiedC
};
///for -applies_to
enum ApplyDirectionType {
    OutputsC,
    InputsC,
    BothIosC,
    UpfUnspecifiedADC
};

/// for -parameter in set_retention_control
enum AssertCorruptType {
    COR_AUTO,
    COR_NONE,
    COR_NORMAL,
    COR_BOTH,
    COR_RET
};

enum RetentionSignalType {
    RetSaveC,
    RetRestoreC,
    RetSaveRestoreC,
    RetSaveAssertC,
    RetRestoreAssertC,
    RetSaveRestoreAssertC
};

enum RetentionModeType {
    RetentionNormal,
    RetentionAccurate,
    RetentionPessimistic
};

///-location
enum LocationType {
    AutomaticLC,
    SelfLC,
    ParentLC,
    SiblingLC,
    FanoutLC,
    ToLC,
    FromLC
};

///-rule
enum LevelShifterRuleType {
    LowToHighC,
    HighToLowC,
    BothLowHighC
};

///-save_signal/-restore_signal
enum SignalLevel {
    SignalHighLevelC,
    SignalLowLevelC,
    SignalPosedgeC,
    SignalNegedgeC
};

/// isolation sense
enum IsolationSenseType {
    HighC,
    LowC
};

//PowerUpStates in CPF
enum PowerUpStatesCpf {
    High,
    Low,
    Random,
    Undefined
};

//Nominal Condirtion States in Cpf
enum NomCondStateCpf {
    On,
    Off,
    Standby
};

//Retention target Types for CPF
enum CpfRetTarget {
    Flop,
    Latch,
    Both
};

enum PowerFormatType
{
    UpfC,
    CpfC,
    UNKNOWN_FORMAT
};

///Boolean operators for expressions
enum UpfOpType {
    UpfNotC,
    UpfBitNotC,
    UpfAndC,
    UpfNandC,
    UpfOrC,
    UpfNorC,
    UpfXorC,
    UpfXnorC,
    UpfBitAndC,
    UpfBitOrC,
    UpfEqualC,
    UpfNotEqualC,
    UpfGtEqualC,
    UpfLtEqualC,
    UpfLtC,
    UpfGtC,
    UpfCaseEqualC,
    UpfCaseNotEqualC
};
typedef enum
{
    UnknownPurposeC,
    RequiredPurposeC,
    OptionalPurposeC
} RtnPurposeType;

typedef enum
{
    UnknownAppliesTo,
    RequiredAppliesToC,
    OptionalAppliesToC,
    NotRequiredAppliesToC,
    NotOptionalAppliesToC
} RtnAppilesToType;

typedef enum {
    POWER_DOMAIN,
    MACRO_POWER_DOMAIN,
    CPF_ISOLATION,
    UPF_ISOLATION,
    ISOLATION_SIGNAL,
    ISOLATION_CONTROL,
    LEVEL_SHIFTING,
    RETENTION,
    RETENTION_FLOP,
    RETENTION_LATCH,
    RETENTION_EXCLUDE,
    RETENTION_SAVE,
    RETENTION_RESTORE,
    RETENTION_ASSERT_R,
    RETENTION_ASSERT_S,
    RETENTION_ASSERT_RS,
    RETENTION_ELEM_LIST,
    SRSN_CMD,
    SPA_ELEMENTS,
    SPA_PORTS,
    SPA_EXCLUDE_PORTS,
    SUPPLY_PORTS,
    CONNECT_SUPPLY_NET,
    CONNECT_LOGIC_NET,
    MAP_CMD,
    SDA_ELEMENTS,    //set_design_attribute elements
    SDA_ELEMENTS_CONTEXT_RESET,
    SDA_ELEMENTS_CONTEXT_RESET_EXCLUDE_FLOP,
    SDA_ELEMENTS_CONTEXT_RESET_EXCLUDE_INST,
    SDA_ELEMENTS_RET_MODE,
    SET_SCOPE,
    LOAD_UPF,
    SET_DESIGN_TOP,
    POWER_SWITCH_CTRL,
    POWER_SWITCH_ACK,
    FIND_OBJ_SCOPE,
    SIMSTATE_BEHAV,
    UNKNOWN_CMD
} QueryCmdType;

typedef enum
{
    INST = 1,
    PROCESS = 2,
    PORT = 4,
    NET = 8,
    ALL_NETS = 16,
    DEFAULT = 15,
    STRUCT = 64,
    MODEL = 128,
    UNKNOWN_OBJECT = 0
} FindObjType;

typedef enum 
{
    POWER_AWARE,
    BOUNDARY_ONLY,
    SIMSTATE_ONLY,
    FULL_UPF
} MacroCorruptionType;

typedef enum
{
    NOT_FOUND,
    INSIDE_BB,
    FOUND_AT_BB,
    NOT_FOUND_AT_BB,
    INSIDE_DB,
    FOUND_AT_DB,
    NOT_FOUND_AT_DB,
    OUT_OF_POWER_TOP,
    FOUND,
    SELECT_ON_SCALAR, // written a select expr on scalar.
    INV_SEL_EXPR,  // written a select expr on MDA/vector but out of range
    FOUND_AT_MACRO_CELL_DB
} FindObjReason;

typedef enum {
    PST_STATE_MACHINE,
    PSW_STATE_MACHINE,
    SUPPLY_SET_STATE_MACHINE,
    STATE_SOURCE_STATE_MACHINE,
    PD_STATE_MACHINE,
    CTRL_SIG_STATE_MACHINE,
    PST_TRANSITION_STATE_MACHINE,
    GROUP_STATE_MACHINE,
    INVALID_STATE_MACHINE

} StateMachineType;

typedef enum 
{
    BIAS_UNSET,
    BIAS_ON,
    BIAS_OFF,
    MIXED_BIAS
} BiasState;

typedef enum {
    NOT_A_DRIVER,
    UNDRIVEN_SUPPLY_PORT_T,
    UNDRIVEN_SUPPLY_NET_T,
    HDL_SUPPLY_NET_T,
    POWER_SWITCH_PORT_T,
    HDL_TO_UPF_CONNECTION_T,
    PG_SIM_CONNECTION_T,
    HAS_TRACED_SPICE_DRIVER_T
} UpfRootSupplyDriverType;

typedef enum {
    UPF_TO_SPICE,
    SPICE_TO_UPF
} SpiceConnectType;

typedef SlistL <char > charL;
typedef SlistLI <char > charLI;
typedef SlistL<PowerDomain>     PowerDomainL;
typedef SlistLI<PowerDomain>     PowerDomainLI;
typedef SlistL<IsolationStrategy>     IsolationL;
typedef SlistL<LpSourceInfo> LpSourceInfoL;
typedef SlistLI<LpSourceInfo> LpSourceInfoLI;
typedef SlistL<ReInitInfo> ReInitInfoL;
typedef SlistLI<ReInitInfo> ReInitInfoLI;

typedef enum {
    VhdlIntegerCorrupt_UnSpecified,
    VhdlIntegerCorrupt_LeftBound,
    VhdlIntegerCorrupt_Zero,
    VhdlIntegerCorrupt_NoCorrupt
} VhdlIntegerCorruptMode;

NAMESPACE_UPFIR_END
#endif //__UpfTypeDef_hh__
# 903 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfTypeDef.hh"
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh" 2

#if 0 /* expanded by -frewrite-includes */
#include "vcs_serialization.hh"
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================
#ifndef VCS_GENERIC_SERIALIZATION_HH_
#define VCS_GENERIC_SERIALIZATION_HH_

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/porting.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#define VCS_GENERIC_SERIALIZATION_PORTING_HH_

// None of the macros defined in this header file should
// be defined somewhere else. We error out otherwise.

#if defined(VCS_HAS_NAMESPACE_STD) || \
    defined(VCS_HAS_NEW_HEADERS)   || \
    defined(VCS_STD_NAMESPACE)     || \
    defined(VCS_TYPENAME)          || \
    defined(VCS_USING)
#error Clashing macro definitions
#endif
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/porting.hh"

// At times aCC doesn't like 'typename' as much as other compilers.

#ifdef __HP_aCC
#define VCS_TYPENAME /* typename */
#else
# 28 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/porting.hh"
#define VCS_TYPENAME typename
#endif
# 30 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/porting.hh"

// Mainly, we have to pull tricks for vintage versions of HP's aCC
// that, at times, we run without giving -AA.

#if defined(__HP_aCC) && !defined(_HP_NAMESPACE_STD)

// vintage aCC w/o -AA

#define VCS_STD_NAMESPACE
#define VCS_USING(x) /* nop */

#else
# 42 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/porting.hh"

// everything else

#define VCS_HAS_NAMESPACE_STD 1
#define VCS_HAS_NEW_HEADERS 1

#define VCS_STD_NAMESPACE std::
#define VCS_USING(x) using x;
#endif
# 51 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/porting.hh"

#endif // VCS_GENERIC_SERIALIZATION_PORTING_HH_
# 53 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/porting.hh"

# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#define VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_

#ifndef INCLUDED_CSTDIO_
#if 0 /* expanded by -frewrite-includes */
#include <cstdio>
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cstdio
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdio.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 27.8.2  C Library files
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
#if 0 /* expanded by -frewrite-includes */
#include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
# 43 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3

#ifndef _GLIBCXX_CSTDIO
#define _GLIBCXX_CSTDIO 1

#ifndef _GLIBCXX_HAVE_GETS
extern "C" char* gets (char* __s) __attribute__((__deprecated__));
#endif
# 50 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3

// Get rid of those macros defined in <stdio.h> in lieu of real functions.
#undef clearerr
#undef fclose
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef fwrite
#undef getc
#undef getchar
#if __cplusplus <= 201103L
# undef gets
#endif
# 76 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
#undef perror
#undef printf
#undef putc
#undef putchar
#undef puts
#undef remove
#undef rename
#undef rewind
#undef scanf
#undef setbuf
#undef setvbuf
#undef sprintf
#undef sscanf
#undef tmpfile
#undef tmpnam
#undef ungetc
#undef vfprintf
#undef vprintf
#undef vsprintf

namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
#if __cplusplus <= 201103L
  // LWG 2249
  using ::gets;
#endif
# 126 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
#if _GLIBCXX_USE_TMPNAM
  using ::tmpnam;
#endif
# 143 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
} // namespace

#if _GLIBCXX_USE_C99

#undef snprintf
#undef vfscanf
#undef vscanf
#undef vsnprintf
#undef vsscanf

namespace __gnu_cxx
{
#if _GLIBCXX_USE_C99_CHECK || _GLIBCXX_USE_C99_DYNAMIC
  extern "C" int
  (snprintf)(char * __restrict, std::size_t, const char * __restrict, ...)
  throw ();
  extern "C" int
  (vfscanf)(FILE * __restrict, const char * __restrict, __gnuc_va_list);
  extern "C" int (vscanf)(const char * __restrict, __gnuc_va_list);
  extern "C" int
  (vsnprintf)(char * __restrict, std::size_t, const char * __restrict,
	      __gnuc_va_list) throw ();
  extern "C" int
  (vsscanf)(const char * __restrict, const char * __restrict, __gnuc_va_list)
  throw ();
#endif
# 173 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3

#if !_GLIBCXX_USE_C99_DYNAMIC
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
#endif
# 181 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
} // namespace __gnu_cxx

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
} // namespace std

#endif // _GLIBCXX_USE_C99
# 193 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3

#endif
# 195 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdio" 3
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh" 2
#define INCLUDED_CSTDIO_
#endif
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"

#ifndef INCLUDED_STRING_
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
#define INCLUDED_STRING_
#endif
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"

#ifndef INCLUDED_TYPEINFO_
#if 0 /* expanded by -frewrite-includes */
#include <typeinfo>
#endif /* expanded by -frewrite-includes */
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 1 3
// RTTI support for -*- C++ -*-
// Copyright (C) 1994-2015 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file typeinfo
 *  This is a Standard C++ Library header.
 */

#ifndef _TYPEINFO
#define _TYPEINFO

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 33 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3

#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <bits/hash_bytes.h>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
#endif
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
} // namespace __cxxabiv1

// Determine whether typeinfo names for the same type are merged (in which
// case comparison can just compare pointers) or not (in which case strings
// must be compared), and whether comparison is to be implemented inline or
// not.  We used to do inline pointer comparison by default if weak symbols
// are available, but even with weak symbols sometimes names are not merged
// when objects are loaded with RTLD_LOCAL, so now we always use strcmp by
// default.  For ABI compatibility, we do the strcmp inline if weak symbols
// are available, and out-of-line if not.  Out-of-line pointer comparison
// is used where the object files are to be portable to multiple systems,
// some of which may not be able to use pointer comparison, but the
// particular system for which libstdc++ is being built can use pointer
// comparison; in particular for most ARM EABI systems, where the ABI
// specifies out-of-line comparison.  The compiler's target configuration
// can override the defaults by defining __GXX_TYPEINFO_EQUALITY_INLINE to
// 1 or 0 to indicate whether or not comparison is inline, and
// __GXX_MERGED_TYPEINFO_NAMES to 1 or 0 to indicate whether or not pointer
// comparison can be used.

#ifndef __GXX_MERGED_TYPEINFO_NAMES
// By default, typeinfo names are not merged.
#define __GXX_MERGED_TYPEINFO_NAMES 0
#endif
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3

// By default follow the old inline rules to avoid ABI changes.
#ifndef __GXX_TYPEINFO_EQUALITY_INLINE
  #if !__GXX_WEAK__
    #define __GXX_TYPEINFO_EQUALITY_INLINE 0
  #else
# 76 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
    #define __GXX_TYPEINFO_EQUALITY_INLINE 1
  #endif
# 78 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
#endif
# 79 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3

namespace std
{
  /**
   *  @brief  Part of RTTI.
   *
   *  The @c type_info class describes type information generated by
   *  an implementation.
  */
  class type_info
  {
  public:
    /** Destructor first. Being the first non-inline virtual function, this
     *  controls in which translation unit the vtable is emitted. The
     *  compiler makes use of that information to know where to emit
     *  the runtime-mandated type_info structures in the new-abi.  */
    virtual ~type_info();

    /** Returns an @e implementation-defined byte string; this is not
     *  portable between compilers!  */
    const char* name() const _GLIBCXX_NOEXCEPT
    { return __name[0] == '*' ? __name + 1 : __name; }

#if !__GXX_TYPEINFO_EQUALITY_INLINE
    // In old abi, or when weak symbols are not supported, there can
    // be multiple instances of a type_info object for one
    // type. Uniqueness must use the _name value, not object address.
    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT;
#else
# 109 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
  #if !__GXX_MERGED_TYPEINFO_NAMES
    /** Returns true if @c *this precedes @c __arg in the implementation's
     *  collation order.  */
    // Even with the new abi, on systems that support dlopen
    // we can run into cases where type_info names aren't merged,
    // so we still need to do string comparison.
    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    { return (__name[0] == '*' && __arg.__name[0] == '*')
	? __name < __arg.__name
	: __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    {
      return ((__name == __arg.__name)
	      || (__name[0] != '*' &&
		  __builtin_strcmp (__name, __arg.__name) == 0));
    }
  #else
# 127 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
    // On some targets we can rely on type_info's NTBS being unique,
    // and therefore address comparisons are sufficient.
    bool before(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    { return __name < __arg.__name; }

    bool operator==(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    { return __name == __arg.__name; }
  #endif
# 135 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
#endif
# 136 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const _GLIBCXX_NOEXCEPT
    { return !operator==(__arg); }

#if __cplusplus >= 201103L
    size_t hash_code() const noexcept
    {
#  if !__GXX_MERGED_TYPEINFO_NAMES
      return _Hash_bytes(name(), __builtin_strlen(name()),
			 static_cast<size_t>(0xc70f6907UL));
#  else
# 146 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
      return reinterpret_cast<size_t>(__name);
#  endif
# 148 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
    }
#endif // C++11
# 150 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3

    // Return true if this is a pointer type of some kind
    virtual bool __is_pointer_p() const;

    // Return true if this is a function type
    virtual bool __is_function_p() const;

    // Try and catch a thrown type. Store an adjusted pointer to the
    // caught type in THR_OBJ. If THR_TYPE is not a pointer type, then
    // THR_OBJ points to the thrown object. If THR_TYPE is a pointer
    // type, then THR_OBJ is the pointer itself. OUTER indicates the
    // number of outer pointers, and whether they were const
    // qualified.
    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
			    unsigned __outer) const;

    // Internally used during catch matching
    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
			     void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:
    /// Assigning type_info is not supported.
    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };

  /**
   *  @brief  Thrown during incorrect typecasting.
   *  @ingroup exceptions
   *
   *  If you attempt an invalid @c dynamic_cast expression, an instance of
   *  this class (or something derived from this class) is thrown.  */
  class bad_cast : public exception
  {
  public:
    bad_cast() _GLIBCXX_USE_NOEXCEPT { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_cast() _GLIBCXX_USE_NOEXCEPT;

    // See comment in eh_exception.cc.
    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
  };

  /**
   *  @brief Thrown when a NULL pointer in a @c typeid expression is used.
   *  @ingroup exceptions
   */
  class bad_typeid : public exception
  {
  public:
    bad_typeid () _GLIBCXX_USE_NOEXCEPT { }

    // This declaration is not useless:
    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
    virtual ~bad_typeid() _GLIBCXX_USE_NOEXCEPT;

    // See comment in eh_exception.cc.
    virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
  };
} // namespace std

} // extern "C++"

#pragma GCC visibility pop

#endif
# 223 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/typeinfo" 3
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh" 2
#define INCLUDED_TYPEINFO_
#endif
# 26 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 28 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
# 29 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
#endif
# 30 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"

#ifndef VCS_GENERIC_SERIALIZATION_EXCEPTIONS_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/exceptions.hh"
#endif /* expanded by -frewrite-includes */
# 32 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_EXCEPTIONS_HH_
#define VCS_GENERIC_SERIALIZATION_EXCEPTIONS_HH_

#ifndef INCLUDED_EXCEPTION_
#if 0 /* expanded by -frewrite-includes */
#include <exception>
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"
#define INCLUDED_EXCEPTION_
#endif
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"

#ifndef INCLUDED_STRING_
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"
#define INCLUDED_STRING_
#endif
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"
#endif
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"

namespace vcs {
namespace generic {
namespace serialization {

// ----------------------------------------------------------------------------
//  CLASS : Exception
// ----------------------------------------------------------------------------

/** Exception is the base class for all serialization exceptions.

    In order to ease debugging (read: when you don't know how to make
    your debugger intercept exceptions when they're thrown) you can
    set a breakpoint in vcs::generic::serialization::stopHere(). This
    routine is called before any exception is thrown.
 */

class Exception
    : public VCS_STD_NAMESPACE exception
{
public:

    Exception();

    /** This returns a description of the exception. */
    const char* what() const throw() { return mWhat.c_str(); }

    ~Exception() throw() {}

protected:

    VCS_STD_NAMESPACE string mWhat;
};


// ----------------------------------------------------------------------------
//  Serialization exceptions
// ----------------------------------------------------------------------------

/** This exception is thrown if an archive is
    opened with a mode other than "r" or "w".
*/

struct InvalidArchiveMode : Exception
{
    explicit InvalidArchiveMode(const VCS_STD_NAMESPACE string& mode);
};


/** This exception is thrown if an archive is opened with a
    mode that doesn't match the mode of the archive library.
*/

struct ArchiveModeMismatch : Exception
{
    explicit ArchiveModeMismatch(const VCS_STD_NAMESPACE string& mode);
};


/** This exception is thrown if an archive library is opened
    with a mode other than "r", "w", "rw", or "r+".
*/

struct InvalidArchiveLibMode : Exception
{
    explicit InvalidArchiveLibMode(const VCS_STD_NAMESPACE string& mode);
};


/** This exception is thrown if an archive library is opened
    twice with a different mode.
*/

struct ArchiveLibModeMismatch : Exception
{
    ArchiveLibModeMismatch(const VCS_STD_NAMESPACE string& name,
    const VCS_STD_NAMESPACE string& mode);
};


/** This exception is thrown in case of an
    invalid file name, e.g., a NULL pointer.
*/

struct InvalidFileName : Exception
{
    InvalidFileName();
};


/** This exception is thrown if opening a file failed. */

struct OpenFileFailed : Exception
{
    OpenFileFailed(const char* fname, int errnum);
};


/** This exception is thrown if closing a file failed. */

struct CloseFileFailed : Exception
{
    CloseFileFailed(const char* fname, int errnum);
    CloseFileFailed(const char* fname, const char* error);
};


/** This exception is thrown if accessing a file failed. */

struct AccessFileFailed : Exception
{
    explicit AccessFileFailed(int errnum);
};


/** This exception is thrown if making a directory failed. */

struct MakeDirectoryFailed : Exception
{
    MakeDirectoryFailed(const char* dir, int errnum);
};


/** This exception is thrown in case of an invalid alias, e.g., a NULL
    string or an empty string.
*/

struct InvalidAlias : Exception
{
    InvalidAlias();
};


/** This exception is thrown if a given alias does not denote a new,
    unique identifier.  That is, if the alias is identical to an
    existing class name or alias.
*/

struct AliasNotUnique : Exception
{
    AliasNotUnique(
        const VCS_STD_NAMESPACE string& alias,
        const char* currTypeName, const char* prevTypeName);
};


/** This exception will be thrown if an object (specified by object ID
    and, in case of an out-of-archive reference, an archive ID) cannot
    be located.
*/

struct CannotFindObject : Exception
{
    explicit CannotFindObject(int objectId);
    CannotFindObject(int archiveId, int objectId);
};


/** This exception will be thrown if an archive cannot be loaded,
    e.g., because of a NULL load function pointer.
*/

struct CannotLoadArchive : Exception
{
    explicit CannotLoadArchive(int archiveId);
};


/** This exception will be thrown if an archive of the a certain
    archive type with a given seed already exists.
*/

struct ArchiveInfoExists : Exception
{
    ArchiveInfoExists(
        const char* archiveTypeName, const VCS_STD_NAMESPACE string& seed);
};


/** This exception will be thrown if the serialization cannot locate
    information regarding a particular archive.
*/

struct CannotFindArchiveInfo : Exception
{
    CannotFindArchiveInfo(
        const char* archiveTypeName, const VCS_STD_NAMESPACE string& seed);
};


/** This exception is thrown in the case of a type mismatch. */

struct TypeMismatch : Exception
{
    TypeMismatch(const char* fromTypeName, const char* toTypeName);
};


/** This exception is thrown if one tries to save the same object
    multiple times. For instance, this can happen if an object was
    serialized through a pointer and then later serialized through a
    reference.
*/

struct ObjectAlreadySaved : Exception
{
    ObjectAlreadySaved(int archiveId, int objectId, const char* typeName);
};


/** This exception is thrown if the serialization infrastructure
    encounters an unexpected NULL object, for instance, when
    serializing an object through a reference.
*/

struct UnexpectedNull : Exception
{
    UnexpectedNull();
};


/** This exception is thrown if an ID seems to be invalid. This can
    happen if, for instance, the serialization infrastructure detects
    an object ID where it expects an archive ID, and vice
    versa.
*/

struct UnexpectedObjectId : Exception
{
    explicit UnexpectedObjectId(int objectId);
    UnexpectedObjectId(int archiveId, int objectId);
};


/** This exception is thrown if an archive seems to contain a more
    recent version of a class with an alias name. "More recent
    version" means that the version number if higher than the one we
    know about.
*/

struct VersionGreaterForAlias : Exception
{
    explicit VersionGreaterForAlias(const VCS_STD_NAMESPACE string& alias);
};


/** This exception is thrown if an archive seems to contain a more
    recent version of a class with an alias name. "More recent
    version" means that the version number if higher than the one we
    know about.
*/

struct VersionGreaterForTypeName : Exception
{
    explicit VersionGreaterForTypeName(const char* typeName);
};


/** This exception is thrown if an archive seems to contain a more
    recent version of a class. "More recent version" means that the
    version number if higher than the one we know about.
*/

struct CannotFindTypeName : Exception
{
    explicit CannotFindTypeName(const char* typeName);
};


/** This exception is thrown if the serialization infrastructure
    cannot locate information regarding a particular archive type.
*/

struct CannotFindArchiveType : Exception
{
    explicit CannotFindArchiveType(const char* typeName);
};


/** This exception is thrown if an out-of-range object ID is
    detected.
*/

struct ObjectIdOutOfRange : Exception
{
    explicit ObjectIdOutOfRange(int objectId);
};


/** This exception is thrown if an out-of-range class ID is
    detected.
*/

struct ClassIdOutOfRange : Exception
{
    explicit ClassIdOutOfRange(int classId);
};


/** This exception is thrown if an out-of-range archive ID is
    detected.
*/

struct ArchiveIdOutOfRange : Exception
{
    explicit ArchiveIdOutOfRange(int archiveId);
};


/** This exception is thrown during saving when the class ID returned
    for the object to be saved is zero, which means that the class is
    not serializable.
*/

struct ClassNotSerializable : Exception
{
    explicit ClassNotSerializable(const char* typeName);
};


/** This exception is thrown if a file save action failed. */

struct FileSaveFailed : Exception
{
    explicit FileSaveFailed(int errnum);
};


/** This exception is thrown if a file load action failed. */

struct FileLoadFailed : Exception
{
    explicit FileLoadFailed(int errnum);
};


/** This exception is thrown if creating a wrapper failed. */

struct CreateWrapperFailed : Exception
{
    explicit CreateWrapperFailed(const char* typeName);
};


/** This exception is thrown if a downcast failed. */

struct DownCastFailed : Exception
{
    DownCastFailed(const char* fromTypeName, const char* toTypeName);
};


/** This exception is thrown if an upcast failed. */

struct UpCastFailed : Exception
{
    UpCastFailed(const char* fromTypeName, const char* toTypeName);
};


/** This exception is thrown if a non-const member function
    is called from an archive library that is closed.
*/

struct ArchiveLibClosed : Exception
{
    explicit ArchiveLibClosed(const VCS_STD_NAMESPACE string& name);
};


/** This exception is thrown if a non-const member function
    is called from an archive library group that is closed.
*/

struct ArchiveLibGroupClosed : Exception
{
    ArchiveLibGroupClosed();
};


/** This exception is thrown if the resetObjectAddress() archive
    member function is called with an invalid new address argument.
*/

struct InvalidNewAddress : Exception
{
    InvalidNewAddress();
};


/** This exception is thrown if the resetObjectAddress() archive
    member function is called with an invalid old address argument.
*/

struct InvalidOldAddress : Exception
{
    InvalidOldAddress();
};


/** This exception is thrown if the resetObjectAddress() archive
    member function cannot find old address in the object table.
*/

struct CannotFindOldAddress : Exception
{
    CannotFindOldAddress();
};


/** This exception is thrown if the size of a bit-field exceeds
    the size of an unsigned int.
*/

struct BitFieldCapacityExceeded : Exception
{
    BitFieldCapacityExceeded(int size, int capacity);
};


/** This exception is thrown if a broken archive dependency is found,
    that is, if the archive referee is newer than the archive referer.
*/

struct ArchiveDependencyBroken : Exception
{
    explicit ArchiveDependencyBroken(const char* message);
};


/** This exception is thrown if reloading the class information of an
    archive library fails.
*/

struct ReloadClassInfoFailed : Exception
{
    explicit ReloadClassInfoFailed(
        const VCS_STD_NAMESPACE string& archiveLibName);
};


/** This exception is thrown if reloading the archive information of an
    archive library fails.
*/

struct ReloadArchiveInfoFailed : Exception
{
    explicit ReloadArchiveInfoFailed(
        const VCS_STD_NAMESPACE string& archiveLibName);
};


/** This exception is thrown if we're actually saving an object by pointer
    and assertNotOwner_ is set in the archive.
*/

struct NotOwner : Exception
{
    NotOwner();
};


/** This exception is thrown if there's no more specific exception.
    A message string and/or errno can be passed to this exception.
*/

struct GeneralError : Exception /*  VCSMSG_EXCLUDE */
{
    GeneralError(const char* message, int errnum); /*  VCSMSG_EXCLUDE */
};


/** This exception is thrown if a routine is called that has not yet
    been implemented.
*/

struct NotYetImplemented : Exception
{
    NotYetImplemented();
};

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_EXCEPTIONS_HH_
# 511 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/exceptions.hh"
# 33 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh" 2
#endif
# 34 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"

#ifndef VCS_GENERIC_SERIALIZATION_SERIALIZABLE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/serializable.hh"
#endif /* expanded by -frewrite-includes */
# 36 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_SERIALIZABLE_HH_
#define VCS_GENERIC_SERIALIZATION_SERIALIZABLE_HH_

#ifndef VCS_GENERIC_SERIALIZATION_EXCEPTIONS_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/exceptions.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh"

#ifndef VCS_GENERIC_SERIALIZATION_VISIBILITY_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/visibility.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/visibility.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_VISIBILITY_HH_
#define VCS_GENERIC_SERIALIZATION_VISIBILITY_HH_

namespace vcs {
namespace generic {
namespace serialization {

// ----------------------------------------------------------------------------
//  ENUM : Visibility
// ----------------------------------------------------------------------------

/** Enumeration type for persistent object visibility. */

enum Visibility
{
    NoV = 0,        // no visibility
    ArchiveV,       // archive visibility
    LibraryV,       // archive library visibility
    GlobalV     // archive library group visibility
};

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_VISIBILITY_HH_
# 35 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/visibility.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh" 2
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh"

namespace vcs {
namespace generic {
namespace serialization {

// forward declarations
class Archive;

// ----------------------------------------------------------------------------
//  CLASS : Serializable
// ----------------------------------------------------------------------------

/** Abstract base class for intrusive serializable classes.
    \note Use virtual inheritance when deriving from this class.
*/

class Serializable
{
    friend class Archive;

protected:

    Serializable() {}

    /** This method is called when serializing an object. The Archive&
        passed as an argument refers to the archive used for serialization.
        In order to make a class serializable this method needs to be
        implemented.
    */
    virtual void serialize(Archive&) { throw NotYetImplemented(); }

    /** Returns the class id of the dynamic type of this. This method
        should not be implemented "manually". Instead the
        VCS_DECL_SERIALIZABLE macro will take care of its
        implementation.
    */
    virtual int getSerializableClassId() const { return 0; }

    /** Allows to make this object unique in case of reduced object
    visibility. In order to do that one needs to re-implement
    this method in a (direct or indirect) subclass of Serializable.
    */
    virtual Serializable* makeSelfUnique() { return this; }

    /** Called in case resetObjectAddress() was called internally for
    oldObject during de-serialization and watchReplaceObject()
    was called successfully for oldObjec before that.
    */
    virtual bool notifyReplaceObject(
        Serializable* oldObject, Serializable* newObject) { return false; }

    virtual ~Serializable() {}

public:

    /** Enables customizing persistent object visibility per-class and
    per instance. In order to do that one needs to re-implement
    this method in a (direct or indirect) subclass of Serializable.
    */
    virtual Visibility getObjectVisibility() const { return GlobalV; }

    /** No persistent object visibility is aka no bookkeeping. */
    bool getNoBookkeeping() const { return (getObjectVisibility() == NoV); }
};

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_SERIALIZABLE_HH_
# 89 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/serializable.hh"
# 37 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh" 2
#endif
# 38 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"

namespace vcs {
namespace generic {
namespace serialization {

// forward declarations
class ArchiveLib;
class ArchiveLibGroup;
class ArchiveType;

typedef const VCS_STD_NAMESPACE type_info TypeInfo;

namespace detail {

// forward declarations
class ArchiveRep;
class ArchiveLibRep;
class ArchiveLibGroupRep;
class ArchiveInfo;
class WrapperBase;

// ----------------------------------------------------------------------------
//  TYPEDEF : CreateSerializableF
// ----------------------------------------------------------------------------

/** The void* argument is used to pass c'tor arguments to classes
    with references (data members are references), which may need
    non-default c'tors. */

typedef Serializable* (*CreateSerializableF)(void*);


// ----------------------------------------------------------------------------
//  TYPEDEF : CastF
// ----------------------------------------------------------------------------

typedef void* (*CastF)(void*);


// ----------------------------------------------------------------------------
//  FUNCTION : registerClassInfo
// ----------------------------------------------------------------------------

/** Serializable classes register their class info at static constructor
    time by calling this function. A unique class id is returned. */

int registerClassInfo(TypeInfo&, CreateSerializableF, unsigned version);


// ----------------------------------------------------------------------------
//  FUNCTION : registerAliasInfo
// ----------------------------------------------------------------------------

/** Serializable classes can register their alias info at static
    constructor time by calling this function. */

int registerAliasInfo(TypeInfo&, const char* alias, int classId);


// ----------------------------------------------------------------------------
//  FUNCTION : registerCastInfo
// ----------------------------------------------------------------------------

/** For non-intrusive serializable classes their base class(es) cast info
    is registered at static constructor time by calling this function. */

int registerCastInfo(TypeInfo&, TypeInfo&, CastF, CastF);


// ----------------------------------------------------------------------------
//  FUNCTION : registerArchiveType
// ----------------------------------------------------------------------------

/** Archive types register themselves by calling this function. */

void registerArchiveType(ArchiveType*);

} // detail


// ----------------------------------------------------------------------------
//  FUNCTION : watchReplaceObject
// ----------------------------------------------------------------------------

/** Watch for resetObjectAddress() being called for object. If this happens
    call the notifyReplaceObject() method of useObject. Returns true if a
    watch could be set (if object is currently being de-serialized
    and has reduced object visibility). Returns false otherwise.
    @note Only for intrusive serializable objects. */

bool watchReplaceObject(Serializable* object, Serializable* useObject);


// ----------------------------------------------------------------------------
//  FUNCTION : removeAnyWatchForUseObject
// ----------------------------------------------------------------------------

/** ... */

bool removeAnyWatchForUseObject(Serializable* useObject);


// ----------------------------------------------------------------------------
//  FUNCTION : deletingReplacedObject
// ----------------------------------------------------------------------------

/** Returns true if the object replaced with resetObjectAddress() internally
    is being deleted. Returns false otherwise.
    @note Only for intrusive serializable objects.
*/

bool deletingReplacedObject();


// ----------------------------------------------------------------------------
//  CLASS : Archive
// ----------------------------------------------------------------------------

/** Abstract base class for serialization archives.
    Serialization archives are used for both saving and loading. */

class Archive
{
    friend class ArchiveLib;
    friend class detail::ArchiveLibRep;

public:

    /** An archive is either saving or loading. */
    bool isSaving() const;
    bool isLoading() const;
    bool isLocalString() const { return isLocalStr_;}

    void setAssertNotOwner(bool);
    bool getAssertNotOwner() const;

    /** Return the class version given either a serializable object or
    a type info. During saving the class version is taken from the
    registered class info. During loading the class version is taken
    from the class info read from the underlying storage. */
    unsigned getClassVersion(const Serializable&) const;
    unsigned getClassVersion(TypeInfo&) const;

    /** Allow direct access to the underlying storage. */
    virtual void saveBinary(
        const void* address, VCS_STD_NAMESPACE size_t count) = 0;
    virtual void loadBinary(
        void* address, VCS_STD_NAMESPACE size_t count) = 0;

    /** Replaces 'oldObject' with 'newObject' in the object table.
    \note Use this function only if you know what you are doing. */
    void resetObjectAddress(
        void* newObject, void* oldObject, TypeInfo&);
    void resetObjectAddress(
        Serializable* newObject, Serializable* oldObject, TypeInfo&);

    /** ... */
    void adjustObjectVisibility(Visibility);
    void endAdjustObjectVisibility();

    Visibility getObjectVisibility(void*) const;
    Visibility getObjectVisibility(Serializable*) const;

    /** If this archive belongs to an archive library, this function
    returns the name of that library. Otherwise 0 is returned.
    */
    const char* getLibName() const;

    /** For debugging purposes. */
    void printStatistics() const;

    void close();

    virtual ~Archive();

public:
    // NOT to be called directly by user code!

    /** These functions take care of intrusive serializable object
    (de)serialization. */
    void saveObjectByPtrI(Serializable*);
    void loadObjectByPtrI(Serializable*&, int&);
    void saveObjectByRefI(Serializable&);
    void loadObjectByRefI(Serializable&);

    /** These functions take care of non-intrusive serializable object
    (de)serialization. */
    void saveObjectByPtrNI(TypeInfo&, TypeInfo*, void*);
    void loadObjectByPtrNI(TypeInfo&, void*&, void*&);
    void saveObjectByRefNI(TypeInfo&, TypeInfo&, void*);
    void loadObjectByRefNI(TypeInfo&, TypeInfo&, void*);

    /** These functions take care of character string (de)serialization. */
    void saveString(char*);
    void loadString(char*&);

#define DECL_PRIM_SAVE_LOAD(primType)                   \
    virtual void save(primType) = 0;                    \
    virtual void load(primType&) = 0

    DECL_PRIM_SAVE_LOAD(bool);
    DECL_PRIM_SAVE_LOAD(char);
    DECL_PRIM_SAVE_LOAD(short int);
    DECL_PRIM_SAVE_LOAD(int);
    DECL_PRIM_SAVE_LOAD(long int);
    DECL_PRIM_SAVE_LOAD(long long int);
    DECL_PRIM_SAVE_LOAD(unsigned char);
    DECL_PRIM_SAVE_LOAD(unsigned short int);
    DECL_PRIM_SAVE_LOAD(unsigned int);
    DECL_PRIM_SAVE_LOAD(unsigned long int);
    DECL_PRIM_SAVE_LOAD(unsigned long long int);
    DECL_PRIM_SAVE_LOAD(float);
    DECL_PRIM_SAVE_LOAD(double);

    // FIXME: Should we support the following types?
    // - signed char
    // - wchar_t
    // - long double

#undef DECL_PRIM_SAVE_LOAD

    virtual void save(const char*) = 0;
    virtual void load(char*&) = 0;

    virtual void save(const VCS_STD_NAMESPACE string&) = 0;
    virtual void load(VCS_STD_NAMESPACE string&) = 0;

    bool addBaseAddress(void*);
    // Called by the VirtualBaseObject helper.

protected:

    explicit Archive(const VCS_STD_NAMESPACE string& mode);
    Archive(bool saveMode, ArchiveLib&);

    void serializeClassInfoTable();

    virtual void beginClassInfo() = 0;
    virtual void endClassInfo() = 0;

    virtual void doClose() = 0;
    // called by close()

private:

    void notifyReplaceObject(Serializable*, Serializable*);

    // disabled
    Archive();
    Archive(const Archive&);
    Archive& operator = (const Archive&);

private:

    bool                isSaving_;
    bool                assertNotOwner_;
    bool                isLocalStr_;
    detail::ArchiveRep* rep_;
};


// IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

inline
bool Archive::isSaving() const
{
    return isSaving_;
}

inline
bool Archive::isLoading() const
{
    return !isSaving_;
}

inline
void Archive::setAssertNotOwner(bool b)
{
    assertNotOwner_ = b;
}

inline
bool Archive::getAssertNotOwner() const
{
    return assertNotOwner_;
}


// ----------------------------------------------------------------------------
//  CLASS : ArchiveLib
// ----------------------------------------------------------------------------

/** Class for representing a library of serialization archives. */

class ArchiveLib
{
    friend class Archive;
    friend class ArchiveLibGroup;
    friend class detail::ArchiveLibRep;
    friend class detail::ArchiveLibGroupRep;

public:

    ArchiveLib(
        const VCS_STD_NAMESPACE string& name,
        const VCS_STD_NAMESPACE string& pathName,
        const VCS_STD_NAMESPACE string& mode,
        int libraryId = 0,
        detail::ArchiveLibGroupRep* = 0);

    const VCS_STD_NAMESPACE string& getName() const;
    const VCS_STD_NAMESPACE string& getPathName() const;

    const VCS_STD_NAMESPACE string
    getPathFileName(const VCS_STD_NAMESPACE string& fileName) const;

    /** An archive library can be saving and/or loading. */
    bool isSaving() const;
    bool isLoading() const;

    Archive& openArchive(
        ArchiveType*, const VCS_STD_NAMESPACE string& seed,
        const VCS_STD_NAMESPACE string& mode);

    /** Reloads the archive information and class information of this
    archive library. The to-be-loaded archive information and
    class information must be a proper extension of the already
    loaded archive information and class information, otherwise the
    behavior is undefined.
    This archive library should not be closed.
    */
    void reloadInfo();

    void close();

    ~ArchiveLib();

private:

    void saveClassInfoTable();
    void loadClassInfoTable();
    void reloadClassInfoTable();

    void saveArchiveInfoTable();
    void loadArchiveInfoTable();
    void reloadArchiveInfoTable();

    void loadArchive(int, detail::ArchiveInfo*);

    // disabled
    ArchiveLib();
    ArchiveLib(const ArchiveLib&);
    ArchiveLib& operator = (const ArchiveLib&);

private:

    detail::ArchiveLibRep* rep_;
};


// ----------------------------------------------------------------------------
//  CLASS : ArchiveLibGroup
// ----------------------------------------------------------------------------

/** Class for representing a group of libraries of serialization archives. */

class ArchiveLibGroup
{
    friend class ArchiveLib;

public:

    ArchiveLibGroup();

    void addArchiveLibMapping(
        const VCS_STD_NAMESPACE string& archiveLibName,
        const VCS_STD_NAMESPACE string& archiveLibPathName);

    ArchiveLib& openArchiveLib(
        const VCS_STD_NAMESPACE string& archiveLibName,
        const VCS_STD_NAMESPACE string& mode);

    /** Reloads the archive information and class information of the
    specified archive library. The to-be-loaded archive information
    and class information must be a proper extension of the already
    loaded archive information and class information, otherwise the
    behavior is undefined.
    The specified archive library should not be closed.
    */
    void reloadArchiveLibInfo(
        const VCS_STD_NAMESPACE string& archiveLibName);

    void close();

    ~ArchiveLibGroup();

private:

    // disabled
    ArchiveLibGroup(const ArchiveLibGroup&);
    ArchiveLibGroup& operator = (const ArchiveLibGroup&);

private:

    detail::ArchiveLibGroupRep* rep_;
};


namespace detail {

// ----------------------------------------------------------------------------
//  FUNCTION TEMPLATE : serializeI
// ----------------------------------------------------------------------------

/** Serialize functions for intrusive serializable objects.
    NOT to be called directly by user code! */

template <class SerializableT>
inline
void serializeI(Archive& ar, SerializableT*& objectPtr)
{
    if (ar.isSaving()) {
#if defined(__HP_aCC)
        // Hitting an aCC bug here (upward cast not properly handled
        // in case of NULL pointer => SEGV). The bug even strikes
        // if we write
        //     ar.saveObjectByPtrI(objectPtr ? objectPtr : 0);
        // or
        //     Serializable* tmp = objectPtr ? objectPtr : 0;
        Serializable* tmp = 0;
        if (objectPtr) {
            tmp = objectPtr;
        }
        ar.saveObjectByPtrI(tmp);
#else
# 473 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
        ar.saveObjectByPtrI(objectPtr);
#endif
# 475 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
    }
    else {
        Serializable* objectPtr2;
        int contObject = 0;
        ar.loadObjectByPtrI(objectPtr2, contObject);
        if (!objectPtr2) {
            objectPtr = 0;
        }
        else {
            objectPtr = dynamic_cast<SerializableT*>(objectPtr2);
            if (!objectPtr) {
                throw TypeMismatch(
                    typeid(*objectPtr2).name(), typeid(objectPtr).name());
            }
            if (contObject) {
                bool updateObjectPtr = (contObject > 0);
                ar.loadObjectByPtrI(objectPtr2, contObject);
                if (updateObjectPtr) {
                    objectPtr = dynamic_cast<SerializableT*>(objectPtr2);
                    if (!objectPtr) {
                        throw TypeMismatch(
                            typeid(*objectPtr2).name(),
                            typeid(objectPtr).name());
                    }
                }
            }
        }
    }
}

template <class SerializableT>
inline
void serializeI(Archive& ar, SerializableT& object)
{
    if (ar.isSaving()) {
        ar.saveObjectByRefI(object);
    }
    else {
        ar.loadObjectByRefI(object);
    }
}

} // detail

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
# 524 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive.hh"
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/archive_type.hh"
#endif /* expanded by -frewrite-includes */
# 20 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPE_HH_
#define VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPE_HH_

#ifndef INCLUDED_STRING_
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"
#define INCLUDED_STRING_
#endif
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"
#endif
# 20 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"

#ifndef VCS_GENERIC_SERIALIZATION_VISIBILITY_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/visibility.hh"
#endif /* expanded by -frewrite-includes */
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"
#endif
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"

namespace vcs {
namespace generic {
namespace serialization {

// forward declarations
class Archive;
class ArchiveLib;

// ----------------------------------------------------------------------------
//  TYPEDEF : LoadArchiveF
// ----------------------------------------------------------------------------

/** Type definition for pointer to function that can load an archive.
 */

typedef void (*LoadArchiveF)(Archive&, const VCS_STD_NAMESPACE string& seed);


// ----------------------------------------------------------------------------
//  TYPEDEF : StringType
// ----------------------------------------------------------------------------

/** Type definition for string types.

    Zero is reserved for default handling. Non-zero means application
    specific handling, that is, newString() must be called during
    loading.
 */

typedef unsigned char StringType;


// ----------------------------------------------------------------------------
//  CLASS : ArchiveType
// ----------------------------------------------------------------------------

/** Abstract base class for archive types.
 */

class ArchiveType
{
    friend class Archive;
    friend class ArchiveLib;
    friend class detail::ArchiveLibRep;

public:

    virtual const char* getName() const = 0;

protected:

    virtual Archive& openArchive(
        const VCS_STD_NAMESPACE string& seed, long& offset, bool saveMode,
        ArchiveLib&) const = 0;

    virtual LoadArchiveF getLoadFunction() const
    {
        return 0;
    }

    virtual Visibility getObjectVisibility() const
    {
        return GlobalV;
    }

    virtual Visibility getStringVisibility(const char* /* theString */) const
    {
        return GlobalV;
    }

    virtual StringType getStringType(const char* /* theString */) const
    {
        return 0;
    }

    virtual char* newString(char* theString, StringType) const
    {
        return theString;
    }

    virtual ~ArchiveType()
    {}
};

} // serialization
} // generic
} // vcs


// ----------------------------------------------------------------------------
//  MACRO : VCS_DECL_ARCHIVE_TYPE
// ----------------------------------------------------------------------------

/** Use this macro as part of the declaration of a new archive type.

    Archive types are implemented as singletons that can be accessed
    through className::id().

    \note This macro must come first in the class declaration.
*/

#define VCS_DECL_ARCHIVE_TYPE(className)                \
    \
    friend class vcs::generic::serialization::ArchiveLib;       \
    \
    private:                                \
    \
    static className*  sInstance;                   \
    static const char* sName;                   \
    \
    private:                                \
    \
    className()                         \
    {}                              \
    \
    /* disabled */                          \
    className(const className&);                    \
    className& operator = (const className&);           \
    \
    public:                             \
    \
    static vcs::generic::serialization::ArchiveType* id()       \
    {                               \
        return sInstance;                       \
    }                               \
    \
    static className* staticInit()                  \
    {                               \
        className* at = new className;              \
        vcs::generic::serialization::detail::registerArchiveType(at); \
        return at;                          \
    }                               \
    \
    const char* getName() const                 \
    {                               \
        return sName;                       \
    }                               \
    \
    protected:


// ----------------------------------------------------------------------------
//  MACRO : VCS_IMPL_ARCHIVE_TYPE
// ----------------------------------------------------------------------------

/** Use this macro as part of the implementation of a new archive type.

    \note Don't use this macro in a header file.
*/

#define VCS_IMPL_ARCHIVE_TYPE(className)                \
    \
    className*  className::sInstance = className::staticInit();     \
    const char* className::sName = #className;

#endif // VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPE_HH_
# 181 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_type.hh"
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPES_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/archive_types.hh"
#endif /* expanded by -frewrite-includes */
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPES_HH_
#define VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPES_HH_

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive_type.hh"
#endif /* expanded by -frewrite-includes */
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"
#endif
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"

namespace vcs {
namespace generic {
namespace serialization {

// ----------------------------------------------------------------------------
//  Predefined archive types
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
//  CLASS : TextAT
// ----------------------------------------------------------------------------

/**  Simple text archive type.

     One text archive per file. The seed is used as file name.
 */

class TextAT
    : public ArchiveType
{
    // This macro must come first.
    VCS_DECL_ARCHIVE_TYPE(TextAT)

    Archive& openArchive(
        const VCS_STD_NAMESPACE string& seed, long& offset, bool saveMode,
        ArchiveLib&) const;
};


// ----------------------------------------------------------------------------
//  CLASS : BinaryAT
// ----------------------------------------------------------------------------

/**  Simple binary archive type.

     One binary archive per file. The seed is used as file name.
 */

class BinaryAT
    : public ArchiveType
{
    // This macro must come first.
    VCS_DECL_ARCHIVE_TYPE(BinaryAT)

    Archive& openArchive(
        const VCS_STD_NAMESPACE string& seed, long& offset, bool saveMode,
        ArchiveLib&) const;
};

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_ARCHIVE_TYPES_HH_
# 78 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/archive_types.hh"
# 25 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 26 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_BINARY_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/binary_archive.hh"
#endif /* expanded by -frewrite-includes */
# 28 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_BINARY_ARCHIVE_HH_
#define VCS_GENERIC_SERIALIZATION_BINARY_ARCHIVE_HH_

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh"
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh"

namespace vcs {
namespace generic {
namespace serialization {

namespace detail {

// forward declaration
class BinaryArchiveRep;

} // detail


// ----------------------------------------------------------------------------
//  CLASS : BinaryArchive
// ----------------------------------------------------------------------------

/** Simple non-portable binary archive. */

class BinaryArchive
    : public Archive
{
public:

    BinaryArchive(
        const VCS_STD_NAMESPACE string& fileName,
        const VCS_STD_NAMESPACE string& mode);

    BinaryArchive(
        const VCS_STD_NAMESPACE string& fileName,
        bool saveMode, ArchiveLib&);
    BinaryArchive(
        const VCS_STD_NAMESPACE string& fileName,
        long& offset, bool saveMode, ArchiveLib&);

    void saveBinary(const void* address, VCS_STD_NAMESPACE size_t count);
    void loadBinary(void* address, VCS_STD_NAMESPACE size_t count);

    ~BinaryArchive();

public:
    // NOT to be called directly by user code!

#define DECL_PRIM_SAVE_LOAD(primType)                   \
    void save(primType);                        \
    void load(primType&)

    DECL_PRIM_SAVE_LOAD(bool);
    DECL_PRIM_SAVE_LOAD(char);
    DECL_PRIM_SAVE_LOAD(short int);
    DECL_PRIM_SAVE_LOAD(int);
    DECL_PRIM_SAVE_LOAD(long int);
    DECL_PRIM_SAVE_LOAD(long long int);
    DECL_PRIM_SAVE_LOAD(unsigned char);
    DECL_PRIM_SAVE_LOAD(unsigned short int);
    DECL_PRIM_SAVE_LOAD(unsigned int);
    DECL_PRIM_SAVE_LOAD(unsigned long int);
    DECL_PRIM_SAVE_LOAD(unsigned long long int);
    DECL_PRIM_SAVE_LOAD(float);
    DECL_PRIM_SAVE_LOAD(double);

#undef DECL_PRIM_SAVE_LOAD

    void save(const char*);
    void load(char*&);

    void save(const VCS_STD_NAMESPACE string&);
    void load(VCS_STD_NAMESPACE string&);

protected:

    void beginClassInfo();
    void endClassInfo();

    void doClose();

private:

    // disabled
    BinaryArchive();
    BinaryArchive(const BinaryArchive&);
    BinaryArchive& operator = (const BinaryArchive&);

private:

    VCS_STD_NAMESPACE string  fileName_;
    bool                      isStandAlone_;
    detail::BinaryArchiveRep* rep_;
};

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_BINARY_ARCHIVE_HH_
# 114 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/binary_archive.hh"
# 29 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 30 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_BITFIELD_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/bitfield.hh"
#endif /* expanded by -frewrite-includes */
# 32 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_BITFIELD_HH_
#define VCS_GENERIC_SERIALIZATION_BITFIELD_HH_

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"

#ifndef VCS_GENERIC_SERIALIZATION_OPERATORS_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/operators.hh"
#endif /* expanded by -frewrite-includes */
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/operators.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_OPERATORS_HH_
#define VCS_GENERIC_SERIALIZATION_OPERATORS_HH_

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/operators.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/operators.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/operators.hh"

namespace vcs {
namespace generic {
namespace serialization {

// ----------------------------------------------------------------------------
//  Predefined serialization operators
// ----------------------------------------------------------------------------

#define DEFN_PRIM_SERIALIZE_OP(primType)                \
    \
    inline Archive& operator & (Archive& ar, primType& obj)     \
    {                                   \
        if (ar.isSaving()) {                        \
            ar.save(obj);                       \
        }                               \
        else {                              \
            ar.load(obj);                       \
        }                               \
        return ar;                          \
    }

DEFN_PRIM_SERIALIZE_OP(bool);
DEFN_PRIM_SERIALIZE_OP(char);
DEFN_PRIM_SERIALIZE_OP(short int);
DEFN_PRIM_SERIALIZE_OP(int);
DEFN_PRIM_SERIALIZE_OP(long int);
DEFN_PRIM_SERIALIZE_OP(long long int);
DEFN_PRIM_SERIALIZE_OP(unsigned char);
DEFN_PRIM_SERIALIZE_OP(unsigned short int);
DEFN_PRIM_SERIALIZE_OP(unsigned int);
DEFN_PRIM_SERIALIZE_OP(unsigned long int);
DEFN_PRIM_SERIALIZE_OP(unsigned long long int);
DEFN_PRIM_SERIALIZE_OP(float);
DEFN_PRIM_SERIALIZE_OP(double);

#undef DEFN_PRIM_SERIALIZE_OP

inline Archive& operator & (Archive& ar, char*& objP)
{
    if (ar.isSaving()) {
        ar.saveString(objP);
    }
    else {
        ar.loadString(objP);
    }
    return ar;
}

inline Archive& operator & (Archive& ar, const char*& objP)
{
    if (ar.isSaving()) {
        ar.saveString(const_cast<char*&>(objP));
    }
    else {
        ar.loadString(const_cast<char*&>(objP));
    }
    return ar;
}

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_OPERATORS_HH_
# 80 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/operators.hh"
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh" 2
#endif
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"

namespace vcs {
namespace generic {
namespace serialization {

class BitFieldPacked;


// ----------------------------------------------------------------------------
//  CLASS : BitFieldData
// ----------------------------------------------------------------------------

/**
   Abstract base class for storing the data of a bit-field member.
   Objects of classes derived from this class can be packed and
   serialized together, or they can be serialized individually.
*/

class BitFieldData
{
protected:

    BitFieldData(unsigned field, int size)
        : field_(field) , size_(size), next_(0)
    {}

public:

    unsigned getField() const { return field_; }
    int      getSize() const  { return size_; }

    void setField(unsigned field) { field_ = field; }

    BitFieldData*& next() { return next_; }

    BitFieldPacked& operator + (const BitFieldData&);

    friend Archive& operator & (Archive& ar, const BitFieldData& object)
    {
        ar & const_cast<BitFieldData&>(object).field_;
        return ar;
    }

    ~BitFieldData()
    {}

private:

    // disabled
    BitFieldData();
    /* BitFieldData(const BitFieldData&); */
    BitFieldData& operator = (const BitFieldData&);

private:

    unsigned      field_;
    int           size_;
    BitFieldData* next_;
};


// ----------------------------------------------------------------------------
//  CLASS : BitFieldPacked
// ----------------------------------------------------------------------------

/**
   Class for packing and serializing BitFieldData objects. The number
   of bits used by each object should not exceed the size of an
   unsigned int.
*/

class BitFieldPacked
{
    friend class BitFieldData;

    explicit BitFieldPacked(const BitFieldData& bfd)
    {
        BitFieldData* elem = const_cast<BitFieldData*>(&bfd);
        head_ = elem;
        tail_ = elem;
    }

public:

    BitFieldPacked& operator + (const BitFieldData& bfd)
    {
        BitFieldData* elem = const_cast<BitFieldData*>(&bfd);
        tail_->next() = elem;
        tail_ = elem;
        return *this;
    }

    friend Archive& operator & (Archive&, BitFieldPacked&);

    ~BitFieldPacked()
    {}

private:

    // disabled
    BitFieldPacked();
    BitFieldPacked(const BitFieldPacked&);
    BitFieldPacked& operator = (const BitFieldPacked&);

private:

    BitFieldData* head_;
    BitFieldData* tail_;
};


inline
BitFieldPacked& BitFieldData::operator + (const BitFieldData& bfd)
{
    BitFieldPacked& bfp = *new BitFieldPacked(*this);
    return (bfp + bfd);
}

} // serialization
} // generic
} // vcs


// ----------------------------------------------------------------------------
//  MACRO : VCS_DECL_BITFIELD
// ----------------------------------------------------------------------------

/**
   Use this macro to make a bit-field member serializable.
*/

#define VCS_DECL_BITFIELD(parentType, fieldType, fieldName, fieldSize)  \
    \
    struct fieldName ## BitFieldProxy                   \
            : vcs::generic::serialization::BitFieldData         \
    {                                   \
        fieldName ## BitFieldProxy(parentType& parent)          \
            : vcs::generic::serialization::BitFieldData(        \
                                                                parent.fieldName, fieldSize)                \
            , parent_(parent)                       \
        {}                              \
        \
        friend vcs::generic::serialization::Archive& operator & (   \
                                                                    vcs::generic::serialization::Archive& ar,           \
                                                                    const fieldName ## BitFieldProxy& object)           \
        {                               \
            ar & static_cast<                       \
            const vcs::generic::serialization::BitFieldData&>(object); \
            return ar;                          \
        }                               \
        \
        ~ fieldName ## BitFieldProxy()                  \
        {                               \
            parent_.fieldName = (fieldType) getField();         \
        }                               \
        \
    private:                                \
        \
        parentType& parent_;                        \
    };                                  \
    \
    friend class fieldName ## BitFieldProxy


// ----------------------------------------------------------------------------
//  MACRO : VCS_BITFIELD
// ----------------------------------------------------------------------------

/**
   Use this macro to serialize a bit-field member.
*/

#define VCS_BITFIELD(fieldName)                     \
    \
    fieldName ## BitFieldProxy(*this)


// ----------------------------------------------------------------------------
//  MACRO : VCS_DECL_STRUCT_BITFIELD
// ----------------------------------------------------------------------------

/**
   Use this macro to make a bit-field member inside a member struct serializable.
*/

#define VCS_DECL_STRUCT_BITFIELD(parentType, fieldType, structObj, fieldName, fieldSize)    \
    \
    struct structObj ## fieldName ## BitFieldProxy                  \
            : vcs::generic::serialization::BitFieldData         \
    {                                   \
        structObj ## fieldName ## BitFieldProxy(parentType& parent)         \
            : vcs::generic::serialization::BitFieldData(        \
                                                                parent.structObj.fieldName, fieldSize)              \
            , parent_(parent)                       \
        {}                              \
        \
        friend vcs::generic::serialization::Archive& operator & (   \
                                                                    vcs::generic::serialization::Archive& ar,           \
                                                                    const structObj ## fieldName ## BitFieldProxy& object)          \
        {                               \
            ar & static_cast<                       \
            const vcs::generic::serialization::BitFieldData&>(object); \
            return ar;                          \
        }                               \
        \
        ~ structObj ## fieldName ## BitFieldProxy()                 \
        {                               \
            parent_.structObj.fieldName = (fieldType) getField();           \
        }                               \
        \
    private:                                \
        \
        parentType& parent_;                        \
    };                                  \
    \
    friend class structObj ## fieldName ## BitFieldProxy


// ----------------------------------------------------------------------------
//  MACRO : VCS_STRUCT_BITFIELD
// ----------------------------------------------------------------------------

/**
   Use this macro to serialize a bit-field member of a member struct.
*/

#define VCS_STRUCT_BITFIELD(structObj, fieldName)                       \
    \
    structObj ## fieldName ## BitFieldProxy(*this)

#endif // VCS_GENERIC_SERIALIZATION_BITFIELD_HH_
# 254 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/bitfield.hh"
# 33 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 34 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_CAST_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/cast.hh"
#endif /* expanded by -frewrite-includes */
# 36 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/cast.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_CAST_HH_
#define VCS_GENERIC_SERIALIZATION_CAST_HH_

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/cast.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/cast.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/cast.hh"

namespace vcs {
namespace generic {
namespace serialization {

namespace detail {

// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : Cast
// ----------------------------------------------------------------------------

/** Helper class for performing down and up and casts between two
    types given their type info.
 */

template <class SuperT, class SubT>
class Cast
{
    friend class vcs::generic::serialization::Archive;

protected:

    typedef Cast<SuperT, SubT> ThisT;

protected:

    static void* down(void* subPtr)
    {
        return dynamic_cast<SuperT*>(reinterpret_cast<SubT*>(subPtr));
    }

    static void* up(void* superPtr)
    {
        return dynamic_cast<SubT*>(reinterpret_cast<SuperT*>(superPtr));
    }

    static int sInit;

private:

    // disabled
    Cast();
    Cast(const ThisT&);
    ThisT& operator = (const ThisT&);
};


// IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

template <class SuperT, class SubT>
int Cast<SuperT, SubT>::sInit =
    vcs::generic::serialization::detail::registerCastInfo(
        typeid(SuperT),
        typeid(SubT),
        Cast<SuperT, SubT>::down,
        Cast<SuperT, SubT>::up);

} // detail

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_CAST_HH_
# 79 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/cast.hh"
# 37 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 38 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_EXCEPTIONS_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/exceptions.hh"
#endif /* expanded by -frewrite-includes */
# 40 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 41 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
#endif
# 42 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_HELPERS_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/helpers.hh"
#endif /* expanded by -frewrite-includes */
# 44 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_HELPERS_HH_
#define VCS_GENERIC_SERIALIZATION_HELPERS_HH_

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh"
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh"

namespace vcs {
namespace generic {
namespace serialization {

// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : BaseObject
// ----------------------------------------------------------------------------

/**  BaseObject is a helper class for serializing intrusive
     non-virtual base classes.  The serialize() function of this
     helper class simply calls the serialize() function of the base
     class.

    Derived classes have to trigger the serialization of their
    base. However, they must not call the base classes' serialize()
    methods directly. Instead either
        \code
        BaseObject<base_type>(*this);
    \endcode
    or
        \code
        VirtualBaseObject<base_type>(*this)
        \endcode
    should be used, where 'base_type' denotes the type of the base
    class. In case of virtual inhertance we use 'VirtualBaseObject'.

    Multiple inheritance (MI) is supported.

    Example:
    \code

    // file: MySubClass.h
    #include "MyClass.h"
    #include "MyOtherClass.h"

    struct MySubClass : MyClass, virtual MyOtherClass {
        VCS_DECL_SERIALIZABLE(MySubClass)
        MySubClass() {}
    int m_i;
        void serialize(Archive&);
    };

    // file: MySubClass.cpp
    #include "MySubClass.h"
    VCS_IMPL_SERIALIZABLE(MySubClass, 1)
    void MyOtherClass::serialize(Archive& ar)
    {
        ar & BaseObject<MyClass>(*this)
           & VirtualBaseObject<MyOtherClass>(*this)
           & m_i;
    }
    \endcode

*/

template <class BaseT>
class BaseObject
{
public:

    typedef BaseObject<BaseT> ThisT;

public:

    explicit BaseObject(BaseT& object)
        : mObject(object)
    {}

    friend Archive& operator & (Archive& ar, const ThisT& helper)
    {
        helper.mObject.BaseT::serialize(ar);
        return ar;
    }

    ~BaseObject()
    {}

private:

    // disabled
    BaseObject();
    /* BaseObject(const ThisT&); */
    ThisT& operator = (const ThisT&);

private:

    BaseT& mObject;
};


// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : VirtualBaseObject
// ----------------------------------------------------------------------------

/**  VirtualBaseObject is a helper class for serializing intrusive
     virtual base classes.  The serialize() function of this helper
     class makes sure the serialize() function of the virtual base
     class is called only once.

    Derived classes have to trigger the serialization of their
    base. However, they must not call the base classes' serialize()
    methods directly. Instead either
        \code
        BaseObject<base_type>(*this);
    \endcode
    or
        \code
        VirtualBaseObject<base_type>(*this)
        \endcode
    should be used, where 'base_type' denotes the type of the base
    class. In case of virtual inhertance we use 'VirtualBaseObject'.

    Multiple inheritance (MI) is supported.

    Example:
    \code

    // file: MySubClass.h
    #include "MyClass.h"
    #include "MyOtherClass.h"

    struct MySubClass : MyClass, virtual MyOtherClass {
        VCS_DECL_SERIALIZABLE(MySubClass)
        MySubClass() {}
    int m_i;
        void serialize(Archive&);
    };

    // file: MySubClass.cpp
    #include "MySubClass.h"
    VCS_IMPL_SERIALIZABLE(MySubClass, 1)
    void MyOtherClass::serialize(Archive& ar)
    {
        ar & BaseObject<MyClass>(*this)
           & VirtualBaseObject<MyOtherClass>(*this)
           & m_i;
    }
    \endcode

*/

template <class BaseT>
class VirtualBaseObject
{
public:

    typedef VirtualBaseObject<BaseT> ThisT;

public:

    explicit VirtualBaseObject(BaseT& object)
        : mObject(object)
    {}

    friend Archive& operator & (Archive& ar, const ThisT& helper)
    {
        BaseT& object = helper.mObject;
        if (ar.addBaseAddress(&object)) {
            object.BaseT::serialize(ar);
        }
        return ar;
    }

    ~VirtualBaseObject()
    {}

private:

    // disabled
    VirtualBaseObject();
    /* VirtualBaseObject(const ThisT&); */
    ThisT& operator = (const ThisT&);

private:

    BaseT& mObject;
};


// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : BaseObjectNI
// ----------------------------------------------------------------------------

/** BaseObjectNI is a helper class for serializing non-intrusive
    non-virtual base classes.  The serialize() function of this helper
    class simply calls the serialize() function of the base class.

    Triggering the serialization of base classes is handled in a
    similar way to the intrusive case. However, we now use
        \code
        BaseObjectNI<base_type>(*this);
    \endcode
    and
        \code
        VirtualBaseObjectNI<base_type>(this*)
        \endcode
    instead of
        \code
        BaseObject<base_type>(*this);
        \endcode
    or
        \code
        VirtualBaseObject<base_type>(*this)
        \endcode

    In addition we need give the serialization library some hints
    regarding serializable base classes. We do that using
      \code
      VCS_NI_SERIALIZABLE_BASE(subtype, supertype)
      \endcode

    Let's look at an example. Assume we have

      \code
      struct FooBar : public Sub_1, public Sub_2 {
          float m_float;
          ...
      };
      \endcode

    where both Sub_1 and Sub_2 are serializable.

    We'd then write something like

      \code
      VCS_NI_SERIALIZABLE(FooBar, 1)
      VCS_NI_SERIALIZABLE_BASE(FooBar, Sub_1)
      VCS_NI_SERIALIZABLE_BASE(FooBar, Sub_2)
      \endcode

    in addition to the actual serialize() routine, which may look like

      \code
      void serialize(Archive& ar, FooBar &obj) {
          FooBar::counter++;
          ar & BaseObjectNI<Sub_1>(obj);
          ar & BaseObjectNI<Sub_2>(obj);
          ar & obj.m_float;
      }
      \endcode

*/

template <class BaseT>
class BaseObjectNI
{
public:

    typedef BaseObjectNI<BaseT> ThisT;

public:

    explicit BaseObjectNI(BaseT& object)
        : mObject(object)
    {}

    friend Archive& operator & (Archive& ar, const ThisT& helper)
    {
        serialize(ar, helper.mObject);
        return ar;
    }

    ~BaseObjectNI()
    {}

private:

    // disabled
    BaseObjectNI();
    /* BaseObjectNI(const ThisT&); */
    ThisT& operator = (const ThisT&);

private:

    BaseT& mObject;
};


// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : VirtualBaseObjectNI
// ----------------------------------------------------------------------------

/** VirtualBaseObjectNI is a helper class for serializing
    non-intrusive virtual base classes.  The serialize() function of
    this helper class makes sure the serialize() function of the
    virtual base class is called only once.

    Triggering the serialization of base classes is handled in a
    similar way to the intrusive case. However, we now use
        \code
        BaseObjectNI<base_type>(*this);
    \endcode
    and
        \code
        VirtualBaseObjectNI<base_type>(this*)
        \endcode
    instead of
        \code
        BaseObject<base_type>(*this);
        \endcode
    or
        \code
        VirtualBaseObject<base_type>(*this)
        \endcode

    In addition we need give the serialization library some hints
    regarding serializable base classes. We do that using
      \code
      VCS_NI_SERIALIZABLE_BASE(subtype, supertype)
      \endcode

    Let's look at an example. Assume we have

      \code
      struct FooBar : public virtual Sub_1, public virtual Sub_2 {
          float m_float;
          ...
      };
      \endcode

    where both Sub_1 and Sub_2 are serializable.

    We'd then write something like

      \code
      VCS_NI_SERIALIZABLE(FooBar, 1)
      VCS_NI_SERIALIZABLE_BASE(FooBar, Sub_1)
      VCS_NI_SERIALIZABLE_BASE(FooBar, Sub_2)
      \endcode

    in addition to the actual serialize() routine, which may look like

      \code
      void serialize(Archive& ar, FooBar &obj) {
          FooBar::counter++;
          ar & VirtualBaseObjectNI<Sub_1>(obj);
          ar & VirtualBaseObjectNI<Sub_2>(obj);
          ar & obj.m_float;
      }
      \endcode


*/

template <class BaseT>
class VirtualBaseObjectNI
{
public:

    typedef VirtualBaseObjectNI<BaseT> ThisT;

public:

    explicit VirtualBaseObjectNI(BaseT& object)
        : mObject(object)
    {}

    friend Archive& operator & (Archive& ar, const ThisT& helper)
    {
        BaseT& object = helper.mObject;
        if (ar.addBaseAddress(&object)) {
            serialize(ar, object);
        }
        return ar;
    }

    ~VirtualBaseObjectNI()
    {}

private:

    // disabled
    VirtualBaseObjectNI();
    /* VirtualBaseObjectNI(const ThisT&); */
    ThisT& operator = (const ThisT&);

private:

    BaseT& mObject;
};


// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : Enum
// ----------------------------------------------------------------------------

/** Enum is a helper class for serializing enums.

   The following example shows its use.

    \code
    #include "vcs_serialization.hh"

    enum my_enum { Blue = 2, Green, Red, White};

    struct my_struct
        : public virtual vcs::generic::serialization::Serializable {
        VCS_DECL_SERIALIZABLE(my_struct)
        my_enum m_color;
        my_struct() : m_color(White) {}
        void serialize(vcs::generic::serialization::Archive& ar) {
            ar & Enum<my_enum>(m_color);
        }
    };
    VCS_IMPL_SERIALIZABLE(my_struct, 1)
    \endcode

 */

template <class EnumT>
class Enum
{
public:

    typedef Enum<EnumT> ThisT;

public:

    explicit Enum(EnumT& object)
        : mObject(object)
    {}

    friend Archive& operator & (Archive& ar, const ThisT& helper)
    {
        int v;
        if (ar.isSaving()) {
            v = helper.mObject;
            ar.save(v);
        }
        else {
            ar.load(v);
            helper.mObject = static_cast<EnumT>(v);
        }
        return ar;
    }

    ~Enum()
    {}

private:

    // disabled
    Enum();
    /* Enum(const ThisT&); */
    ThisT& operator = (const ThisT&);

private:

    EnumT& mObject;
};


// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : Array
// ----------------------------------------------------------------------------

/** Array is a helper class for serializing C-style arrays. (E.g. int a[10];)

    The serialization base library does not have the same level of
    built-in support for C-style arrays that it has for integer and
    floating point data types.

    However, one can use the Array helper class to serialize C-style
    arrays. The following example shows how to use it.

    \code
    // file: MyOtherClass.h
    #include "MyClass.h"
    #include "vcs_serialization.hh"
    #define ARRAY_SIZE 10
    struct MyOtherClass
        : public virtual vcs::generic::serialization::Serializable {
        VCS_DECL_SERIALIZABLE(MyOtherClass)
        MyOtherClass() {}
        MyClass m_x[ARRAY_SIZE];
        void serialize(vcs::generic::serialization::Archive&);
    };

    // file: MyOtherClass.cpp
    #include "MyOtherClass.h"
    using vcs::generic::serialization::Archive;
    VCS_IMPL_SERIALIZABLE(MyOtherClass, 1)
    void MyOtherClass::serialize(Archive& ar)
    {
        ar & Array<MyClass, ARRAY_SIZE>(m_x);
    }
    \endcode

 */

template <class ArrayT, VCS_STD_NAMESPACE size_t Size>
class Array
{
public:

    typedef Array<ArrayT, Size> ThisT;

public:

    explicit Array(ArrayT* array)
        : mArray(array)
    {}

    friend Archive& operator & (Archive& ar, const ThisT& helper)
    {
        ArrayT* array = helper.mArray;
        VCS_STD_NAMESPACE size_t n = Size;
        while (n--) {
            ar & *array++;
        }
        return ar;
    }

    ~Array()
    {}

private:

    // disabled
    Array();
    /* Array(const ThisT&); */
    ThisT& operator = (const ThisT&);

private:

    ArrayT* mArray;
};

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_HELPERS_HH_
# 553 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/helpers.hh"
# 45 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 46 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_MACROS_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/macros.hh"
#endif /* expanded by -frewrite-includes */
# 48 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/macros.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_MACROS_HH_
#define VCS_GENERIC_SERIALIZATION_MACROS_HH_


// ----------------------------------------------------------------------------
//  MACRO : VCS_DECL_SERIALIZABLE
// ----------------------------------------------------------------------------

/** VCS_DECL_SERIALIZABLE is used inside a class declaration. It is
    used to declare that the given class will be made serializable
    using the intrusive style. The one and only argument is the class
    name.

    VCS_DECL_SERIALIZABLE has to be called in derived classes
    too. That is, if MyBaseClass has been made serializable (and
    VCS_DECL_SERIALIZABLE(MyBaseClass) was called in the process) and
    we now make MySubClass (derived from MyBaseClass) serializable
    then we still do have to call VCS_DECL_SERIALIZABLE(MySubClass)
    from within the class declaration of MySubClass.
*/

#define VCS_DECL_SERIALIZABLE(className)                \
    \
    static vcs::generic::serialization::Serializable*           \
    createSerializableObject(void*)                 \
    {                                   \
        return new className;                       \
    }                                   \
    \
    static int sSerializableClassId;                    \
    static int sSerializableAliasId;                    \
    \
    int getSerializableClassId() const                  \
    {                                   \
        return sSerializableClassId;                    \
    }                                   \
    \
    friend vcs::generic::serialization::Archive& operator & (       \
            vcs::generic::serialization::Archive& ar, className*& objP) \
    {                                   \
        vcs::generic::serialization::detail::serializeI(ar, objP);  \
        return ar;                          \
    }                                   \
    \
    friend vcs::generic::serialization::Archive& operator & (       \
            vcs::generic::serialization::Archive& ar, className& obj)   \
    {                                   \
        vcs::generic::serialization::detail::serializeI(ar, obj);   \
        return ar;                          \
    }


// ----------------------------------------------------------------------------
//  MACRO : VCS_IMPL_SERIALIZABLE
// ----------------------------------------------------------------------------

/** VCS_IMPL_SERIALIZABLE is used as part of implementing
    serialization using the intrusive scheme.

    It has 2 parameters: class name and version number.

    For a class template, VCS_IMPL_SERIALIZABLE should appear in the
    corresponding header file. In case of a non-template class this
    macro must not be called in a header file, it needs to be called
    in a source code file. */

#define VCS_IMPL_SERIALIZABLE(className, version)           \
    \
    int className::sSerializableClassId =               \
                                                        vcs::generic::serialization::detail::registerClassInfo(     \
                                                                typeid(className),                      \
                                                                className::createSerializableObject,            \
                                                                version);


// ----------------------------------------------------------------------------
//  MACRO : VCS_DECL_SERIALIZABLE_ABSTRACT
// ----------------------------------------------------------------------------

/** VCS_DECL_SERIALIZABLE_ABSTRACT is similar to
    VCS_DECL_SERIALIZABLE, except that VCS_DECL_SERIALIZABLE_ABSTRACT
    is used in the case of abstract classes.  */

#define VCS_DECL_SERIALIZABLE_ABSTRACT(className)           \
    \
    friend vcs::generic::serialization::Archive& operator & (       \
            vcs::generic::serialization::Archive& ar, className*& objP) \
    {                                   \
        vcs::generic::serialization::detail::serializeI(ar, objP);  \
        return ar;                          \
    }                                   \
    \
    friend vcs::generic::serialization::Archive& operator & (       \
            vcs::generic::serialization::Archive& ar, className& obj)   \
    {                                   \
        vcs::generic::serialization::detail::serializeI(ar, obj);   \
        return ar;                          \
    }


// ----------------------------------------------------------------------------
//  MACRO : VCS_DECL_SERIALIZABLE_T
// ----------------------------------------------------------------------------

/** VCS_DECL_SERIALIZABLE_T is similar to VCS_DECL_SERIALIZABLE,
    except that VCS_DECL_SERIALIZABLE_T is used in the case of class
    templates. Another difference is that it does not require an
    argument. */

#define VCS_DECL_SERIALIZABLE_T                     \
    \
    static vcs::generic::serialization::Serializable*           \
    createSerializableObject(void*);                    \
    \
    static int staticInitClassId();                 \
    static int staticInitAliasId(const char* alias);            \
    \
    static int sSerializableClassId;                    \
    static int sSerializableAliasId;                    \
    \
    int getSerializableClassId() const                  \
    {                                   \
        return sSerializableClassId;                    \
    }


// ----------------------------------------------------------------------------
//  MACRO : VCS_IMPL_SERIALIZABLE_T1
// ----------------------------------------------------------------------------

/** VCS_IMPL_SERIALIZABLE_T1 is similar to VCS_IMPL_SERIALIZABLE,
    except that VCS_IMPL_SERIALIZABLE_T1 is used for class templates
    with one template parameter.

    Use VCS_IMPL_SERIALIZABLE_T2 for class templates with 2
    parameters. Additional macros for class templates with more
    parameters can be added on demand.

    VCS_IMPL_SERIALIZABLE_T1 has 3 additional arguments if compared to
    VCS_IMPL_SERIALIZABLE, which takes only the class name.

    Arguments:
    - classname: the, err, classname (without template parameters)
    - arg_type1: the type of the argument
     - either "class" (without the quotes, of course)
     - or some integer data type such as "int" (again, no quotes)
    - arg_name1: the name of the template parameter
    - version: the version number of the class (for non-template
      classes this is specified via VCS_IMPL_SERIALIZABLE)

 */

#define VCS_IMPL_SERIALIZABLE_T1(                   \
                                                    className, argType1, argName1, version)             \
\
template <argType1 argName1 >                   \
vcs::generic::serialization::Serializable*              \
className<argName1 >::createSerializableObject(void*)       \
{                                   \
    return new className<argName1 >;                \
}                                   \
\
template <argType1 argName1 >                   \
int className<argName1 >::staticInitClassId()           \
{                                   \
    return vcs::generic::serialization::detail::registerClassInfo(  \
            typeid(className),                      \
            createSerializableObject,                   \
            version);                           \
}                                   \
\
template <argType1 argName1 >                   \
int className<argName1 >::staticInitAliasId(            \
                                                        const char* alias)                      \
{                                   \
    return vcs::generic::serialization::detail::registerAliasInfo(  \
            typeid(className),                      \
            alias,                          \
            sSerializableClassId);                  \
}                                   \
\
template <argType1 argName1 >                   \
int className<argName1 >::sSerializableClassId =            \
                                                            className<argName1 >::staticInitClassId();          \
\
template <argType1 argName1 >                   \
inline vcs::generic::serialization::Archive& operator & (       \
        vcs::generic::serialization::Archive& ar,           \
        className<argName1 >*& objP)                    \
{                                   \
    vcs::generic::serialization::detail::serializeI(ar, objP);  \
    return ar;                          \
}                                   \
\
template <argType1 argName1 >                   \
inline vcs::generic::serialization::Archive& operator & (       \
        vcs::generic::serialization::Archive& ar,           \
        className<argName1 >& obj)                  \
{                                   \
    vcs::generic::serialization::detail::serializeI(ar, obj);   \
    return ar;                          \
}


// ----------------------------------------------------------------------------
//  MACRO : VCS_IMPL_SERIALIZABLE_T2
// ----------------------------------------------------------------------------

/** VCS_IMPL_SERIALIZABLE_T2 is similar to VCS_IMPL_SERIALIZABLE_T1,
    except that VCS_IMPL_SERIALIZABLE_T2 supports class templates with
    two template parameters.
 */

#define VCS_IMPL_SERIALIZABLE_T2(                   \
                                                    className, argType1, argName1, argType2, argName2, version)     \
\
template <argType1 argName1, argType2 argName2 >            \
vcs::generic::serialization::Serializable*              \
className<argName1, argName2 >::createSerializableObject(void*) \
{                                   \
    return new className<argName1, argName2 >;          \
}                                   \
\
template <argType1 argName1, argType2 argName2 >            \
int className<argName1, argName2 >::staticInitClassId()     \
{                                   \
    return vcs::generic::serialization::detail::registerClassInfo(  \
            typeid(className),                      \
            createSerializableObject,                   \
            version);                           \
}                                   \
\
template <argType1 argName1, argType2 argName2 >            \
int className<argName1, argName2 >::staticInitAliasId(      \
                                                            const char* alias)                      \
{                                   \
    return vcs::generic::serialization::detail::registerAliasInfo(  \
            typeid(className),                      \
            alias,                          \
            sSerializableClassId);                  \
}                                   \
\
template <argType1 argName1, argType2 argName2 >            \
int className<argName1, argName2 >::sSerializableClassId =      \
        className<argName1, argName2 >::staticInitClassId();        \
\
template <argType1 argName1, argType2 argName2 >            \
inline vcs::generic::serialization::Archive& operator & (       \
        vcs::generic::serialization::Archive& ar,           \
        className<argName1, argName2 >*& objP)              \
{                                   \
    vcs::generic::serialization::detail::serializeI(ar, objP);  \
    return ar;                          \
}                                   \
\
template <argType1 argName1, argType2 argName2 >            \
inline vcs::generic::serialization::Archive& operator & (       \
        vcs::generic::serialization::Archive& ar,           \
        className<argName1, argName2 >& obj)                \
{                                   \
    vcs::generic::serialization::detail::serializeI(ar, obj);   \
    return ar;                          \
}


// ----------------------------------------------------------------------------
//  MACRO : VCS_IMPL_SERIALIZABLE_ALIAS
// ----------------------------------------------------------------------------

/** VCS_IMPL_SERIALIZABLE_ALIAS is used to define a class name alias
    for classes that have been made serializable using the intrusive
    style (that is, for classes that are direct or indirect subclasses
    of Serializable).

    It can be used for class templates too as long as the types are
    fully qualified, e.g., "std::list<int>".

    Arguments:
    - className: the, err, classname
    - alias: the alias name

    Please note that the classname must not contain a comma. A
    corollary to that is that typedefs must be used in case of class
    templates with more than one template parameter.

    Example:
      \code
      ...
      typedef my_class_template<int, 42> zonk;
      ...
      VCS_IMPL_SERIALIZABLE_ALIAS(zonk, call_me_ishmael)
      ...
      \endcode

    Please note that VCS_IMPL_SERIALIZABLE_ALIAS should not be used in
    a header file.

 */

#define VCS_IMPL_SERIALIZABLE_ALIAS(className, alias)           \
    \
    int className::sSerializableAliasId =               \
                                                        vcs::generic::serialization::detail::registerAliasInfo(     \
                                                                typeid(className),                      \
                                                                alias,                          \
                                                                className::sSerializableClassId);


// ----------------------------------------------------------------------------
//  MACRO : VCS_IMPL_SERIALIZABLE_ALIAS_T1
// ----------------------------------------------------------------------------

/** VCS_IMPL_SERIALIZABLE_ALIAS_T1 is similar to
    VCS_IMPL_SERIALIZABLE_ALIAS, except that it is used for class
    templates with a single template parameter.

    Arguments:
    - className: the classname without template arguments
    - argName1: the name of the 1st template argument
    - alias: the alias name

    Example:
      \code
      VCS_IMPL_SERIALIZABLE_ALIAS_T1(MyClass, T, some_alias)
      \endcode

    In contrast to VCS_IMPL_SERIALIZABLE_ALIAS, one does use
    VCS_IMPL_SERIALIZABLE_ALIAS_T1 in a header file.

 */

#define VCS_IMPL_SERIALIZABLE_ALIAS_T1(                 \
                                                        className, argName1, alias)                     \
\
template <>                             \
int className<argName1 >::sSerializableAliasId =            \
                                                            className<argName1 >::staticInitAliasId(alias);


// ----------------------------------------------------------------------------
//  MACRO : VCS_IMPL_SERIALIZABLE_ALIAS_T2
// ----------------------------------------------------------------------------

/** VCS_IMPL_SERIALIZABLE_ALIAS_T2 is similar to
    VCS_IMPL_SERIALIZABLE_ALIAS_T1, except that it is used for class
    templates with two template parameters.

    Arguments:
    - className: the classname without template arguments
    - argName1: the name of the 1st template argument
    - argName2: the name of the 2nd template argument
    - alias: the alias name

    Example:
      \code
      VCS_IMPL_SERIALIZABLE_ALIAS_T2(MyClass, T, N, some_alias)
      \endcode

    Additional variants of this macro supporting more template
    parameters can be added on demand.

 */

#define VCS_IMPL_SERIALIZABLE_ALIAS_T2(                 \
                                                        className, argName1, argName2, alias)               \
\
template <>                             \
int className<argName1, argName2 >::sSerializableAliasId =      \
        className<argName1, argName2 >::staticInitAliasId(alias);


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZE_FUNCTION
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_SERIALIZE_FUNCTION(arName, className, objName)       \
    \
    template <>                             \
    struct SerializeNI<className >                  \
    {                                   \
        static inline void f(                       \
                                                    vcs::generic::serialization::Archive&, className&);     \
    };                                  \
    \
    inline                              \
    void SerializeNI<className >::f(                    \
                                                        vcs::generic::serialization::Archive& arName,           \
                                                        className& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZE_FUNCTION_T1
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_SERIALIZE_FUNCTION_T1(                   \
                                                        arName, className, argType1, argName1, objName)         \
\
template <argType1 argName1 >                   \
struct SerializeNI<className<argName1 > >               \
{                                   \
    static inline void f(                       \
                                                vcs::generic::serialization::Archive&,          \
                                                className<argName1 >&);                 \
};                                  \
\
template <argType1 argName1 >                   \
inline                              \
void SerializeNI<className<argName1 > >::f(             \
                                                        vcs::generic::serialization::Archive& arName,           \
                                                        className<argName1 >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZE_FUNCTION_T1_S
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_SERIALIZE_FUNCTION_T1_S(                 \
                                                        arName, className, argType1, argName1, argName1S, objName)      \
\
template <argType1 argName1 >                   \
struct SerializeNI<className<argName1S > >              \
{                                   \
    static inline void f(                       \
                                                vcs::generic::serialization::Archive&,          \
                                                className<argName1S >&);                    \
};                                  \
\
template <argType1 argName1 >                   \
inline                              \
void SerializeNI<className<argName1S > >::f(            \
                                                        vcs::generic::serialization::Archive& arName,           \
                                                        className<argName1S >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZE_FUNCTION_T2
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_SERIALIZE_FUNCTION_T2(                   \
                                                        arName, className, argType1, argName1, argType2, argName2, objName) \
\
template <argType1 argName1, argType2 argName2 >            \
struct SerializeNI<className<argName1, argName2 > >         \
{                                   \
    static inline void f(                       \
                                                vcs::generic::serialization::Archive&,          \
                                                className<argName1, argName2 >&);               \
};                                  \
\
template <argType1 argName1, argType2 argName2 >            \
inline                              \
void SerializeNI<className<argName1, argName2 > >::f(       \
                                                            vcs::generic::serialization::Archive& arName,           \
                                                            className<argName1, argName2 >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZE_FUNCTION_T2_S
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_SERIALIZE_FUNCTION_T2_S(                 \
                                                        arName, className, argType1, argName1, argName1S,           \
                                                        argType2, argName2, argName2S, objName)             \
\
template <argType1 argName1, argType2 argName2 >            \
struct SerializeNI<className<argName1S, argName2S > >       \
{                                   \
    static inline void f(                       \
                                                vcs::generic::serialization::Archive&,          \
                                                className<argName1S, argName2S >&);             \
};                                  \
\
template <argType1 argName1, argType2 argName2 >            \
inline                              \
void SerializeNI<className<argName1S, argName2S > >::f(     \
                                                            vcs::generic::serialization::Archive& arName,           \
                                                            className<argName1S, argName2S >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION(className, objName)   \
    \
    template <>                             \
    struct GetObjectVisibilityNI<className >                \
    {                                   \
        static inline vcs::generic::serialization::Visibility f(    \
                                                                    const className&);                      \
    };                                  \
    \
    inline                              \
    vcs::generic::serialization::Visibility             \
    GetObjectVisibilityNI<className >::f(               \
                                                        const className& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T1
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T1(           \
                                                            className, argType1, argName1, objName)             \
\
template <argType1 argName1 >                   \
struct GetObjectVisibilityNI<className<argName1 > >         \
{                                   \
    static inline vcs::generic::serialization::Visibility f(    \
                                                                const className<argName1 >&);               \
};                                  \
\
template <argType1 argName1 >                   \
inline                              \
vcs::generic::serialization::Visibility             \
GetObjectVisibilityNI<className<argName1 > >::f(            \
                                                            const className<argName1 >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T1_S
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T1_S(         \
                                                            className, argType1, argName1, argName1S, objName)          \
\
template <argType1 argName1 >                   \
struct GetObjectVisibilityNI<className<argName1S > >        \
{                                   \
    static inline vcs::generic::serialization::Visibility f(    \
                                                                const className<argName1S >&);              \
};                                  \
\
template <argType1 argName1 >                   \
inline                              \
vcs::generic::serialization::Visibility             \
GetObjectVisibilityNI<className<argName1S > >::f(           \
                                                            const className<argName1S >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T2
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T2(           \
                                                            className, argType1, argName1, argType2, argName2, objName)     \
\
template <argType1 argName1, argType2 argName2 >            \
struct GetObjectVisibilityNI<className<argName1, argName2 > >   \
{                                   \
    static inline vcs::generic::serialization::Visibility f(    \
                                                                const className<argName1, argName2 >&);         \
};                                  \
\
template <argType1 argName1, argType2 argName2 >            \
inline                              \
vcs::generic::serialization::Visibility             \
GetObjectVisibilityNI<className<argName1, argName2 > >::f(      \
        const className<argName1, argName2 >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T2_S
// ----------------------------------------------------------------------------

/** ... */

#define VCS_NI_GET_OBJECT_VISIBILITY_FUNCTION_T2_S(         \
                                                            className, argType1, argName1, argName1S,               \
                                                            argType2, argName2, argName2S, objName)             \
\
template <argType1 argName1, argType2 argName2 >            \
struct GetObjectVisibilityNI<className<argName1S, argName2S > > \
{                                   \
    static inline vcs::generic::serialization::Visibility f(    \
                                                                const className<argName1S, argName2S >&);           \
};                                  \
\
template <argType1 argName1, argType2 argName2 >            \
inline                              \
vcs::generic::serialization::Visibility             \
GetObjectVisibilityNI<className<argName1S, argName2S > >::f(    \
        const className<argName1S, argName2S >& objName)


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZABLE
// ----------------------------------------------------------------------------

/** VCS_NI_SERIALIZABLE is used to generate the declarations needed to
    make a type serializable in a non-intrusive way ("NI" stands for
    "non-intrusive"). It is typically used in the same header file
    that is used to declare the corresponding serialize() routine.

    Example:
      \code
      // file: DontTouch.h
      struct DontTouch {
          int foobar;
          DontTouch* next;
      };

      // file: SerializeDontTouch.h
      #include "vcs_serialization.hh"
      VCS_NI_SERIALIZABLE(DontTouch, 1)
      void serialize(vcs::generic::serialization::Archive& ar, DontTouch& dt);

      // file: SerializeDontTouch.cpp
      #include "SerializeDontTouch.h"
      using vcs::generic::serialization::Archive;
      void serialize(archive& ar, DontTouch& dt)
      {
        ar & dt.foobar & dt.next;
      }
      \endcode

    Arguments:
    - className: the, err, classname
    - version: the version number

    It can be used for class templates too as long as the types are
    fully qualified, e.g., "std::list<int>".

    Please note that the classname must not contain a comma. A
    corollary to that is that typedefs must be used in case of class
    templates with more than one template parameter.

    Example:
      \code
      ...
      typedef my_class_template<int, 42> Zonk;
      ...
      VCS_NI_SERIALIZABLE(Zonk, 1)
      ...
      \endcode

 */

#define VCS_NI_SERIALIZABLE(className, version)             \
    \
    template class                          \
    vcs::generic::serialization::detail::Wrapper<className, version>;


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZABLE_W_ALIAS
// ----------------------------------------------------------------------------

/** VCS_NI_SERIALIZABLE_W_ALIAS is similar to VCS_NI_SERIALIZABLE,
    except that it has an additional argument that can be used to
    specify an alias name.

    Arguments:
    - className: the classname
    - version: the version number
    - alias: the alias name

 */

#define VCS_NI_SERIALIZABLE_W_ALIAS(className, version, alias)      \
    \
    namespace vcs {                         \
    namespace generic {                         \
    namespace serialization {                       \
    namespace detail {                          \
    \
    template class Wrapper<className, version>;             \
    \
    template <>                             \
    int Wrapper<className, version>::sSerializableAliasId =     \
                                                                Wrapper<className, version>::staticInitAliasId(alias);      \
    \
    } } } }


// ----------------------------------------------------------------------------
//  MACRO : VCS_NI_SERIALIZABLE_BASE
// ----------------------------------------------------------------------------

/** The serialization library needs to know about serializable base
    classes. When a class is made serializable using the non-intrusive
    approach one needs to use VCS_NI_SERIALIZABLE_BASE to explicity
    declare all serializable base classes (supertypes) or a given
    subtype.

    Arguments:
    - subType: the serializable class
    - superType: its serializable base class

    Example:
      \code
      // assume both Sub_1 and Sub_2 are serializable
      struct FooBar : public Sub_1, public Sub_2 {
          float m_float;
          ...
      };

      ...

      VCS_NI_SERIALIZABLE(FooBar, 1)
      VCS_NI_SERIALIZABLE_BASE(FooBar, Sub_1)
      VCS_NI_SERIALIZABLE_BASE(FooBar, Sub_2)
      \endcode

    VCS_NI_SERIALIZABLE_BASE can be used for class templates too as
    long as the types are fully qualified, e.g., "std::list<int>".

    Please note that the classname must not contain a comma. A
    corollary to that is that typedefs must be used in case of class
    templates with more than one template parameter.

    Additional versions of this macro (e.g., for class templates in
    general) can be provided on demand.

 */

#define VCS_NI_SERIALIZABLE_BASE(subType, superType)            \
    \
    template class                          \
    vcs::generic::serialization::detail::Cast<superType, subType >;

#endif // VCS_GENERIC_SERIALIZATION_MACROS_HH_
# 749 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/macros.hh"
# 49 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 50 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_OPERATORS_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/operators.hh"
#endif /* expanded by -frewrite-includes */
# 52 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 53 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
#endif
# 54 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_SERIALIZABLE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/serializable.hh"
#endif /* expanded by -frewrite-includes */
# 56 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 57 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
#endif
# 58 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_TEXT_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/text_archive.hh"
#endif /* expanded by -frewrite-includes */
# 60 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_TEXT_ARCHIVE_HH_
#define VCS_GENERIC_SERIALIZATION_TEXT_ARCHIVE_HH_

#ifndef VCS_GENERIC_SERIALIZATION_PORTING_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/porting.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh"

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh"
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh"

namespace vcs {
namespace generic {
namespace serialization {

namespace detail {

// forward declaration
class TextArchiveRep;

} // detail


// ----------------------------------------------------------------------------
//  CLASS : TextArchive
// ----------------------------------------------------------------------------

/** Simple text archive. */

class TextArchive
    : public Archive
{
public:

    TextArchive(
        const VCS_STD_NAMESPACE string& fileName,
        const VCS_STD_NAMESPACE string& mode);

    TextArchive(
        const VCS_STD_NAMESPACE string& fileName,
        bool saveMode, ArchiveLib&);
    TextArchive(
        const VCS_STD_NAMESPACE string& fileName,
        long& offset, bool saveMode, ArchiveLib&);

    void saveBinary(const void* address, VCS_STD_NAMESPACE size_t count);
    void loadBinary(void* address, VCS_STD_NAMESPACE size_t count);

    ~TextArchive();

public:
    // NOT to be called directly by user code!

#define DECL_PRIM_SAVE_LOAD(primType)                   \
    void save(primType);                        \
    void load(primType&)

    DECL_PRIM_SAVE_LOAD(bool);
    DECL_PRIM_SAVE_LOAD(char);
    DECL_PRIM_SAVE_LOAD(short int);
    DECL_PRIM_SAVE_LOAD(int);
    DECL_PRIM_SAVE_LOAD(long int);
    DECL_PRIM_SAVE_LOAD(long long int);
    DECL_PRIM_SAVE_LOAD(unsigned char);
    DECL_PRIM_SAVE_LOAD(unsigned short int);
    DECL_PRIM_SAVE_LOAD(unsigned int);
    DECL_PRIM_SAVE_LOAD(unsigned long int);
    DECL_PRIM_SAVE_LOAD(unsigned long long int);
    DECL_PRIM_SAVE_LOAD(float);
    DECL_PRIM_SAVE_LOAD(double);

#undef DECL_PRIM_SAVE_LOAD

    void save(const char*);
    void load(char*&);

    void save(const VCS_STD_NAMESPACE string&);
    void load(VCS_STD_NAMESPACE string&);

protected:

    void beginClassInfo();
    void endClassInfo();

    void doClose();

private:

    // disabled
    TextArchive();
    TextArchive(const TextArchive&);
    TextArchive& operator = (const TextArchive&);

private:

    VCS_STD_NAMESPACE string fileName_;
    bool                     isStandAlone_;
    detail::TextArchiveRep*  rep_;
};

} // serialization
} // generic
} // vcs

#endif // VCS_GENERIC_SERIALIZATION_TEXT_ARCHIVE_HH_
# 114 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/text_archive.hh"
# 61 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 62 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#ifndef VCS_GENERIC_SERIALIZATION_WRAPPER_HH_
#if 0 /* expanded by -frewrite-includes */
#include "vgcommon/serialization/include/wrapper.hh"
#endif /* expanded by -frewrite-includes */
# 64 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/wrapper.hh" 1
// ============================================================================
//  SYNOPSYS CONFIDENTIAL - This is an unpublished, proprietary work of
//  Synopsys, Inc., and is fully protected under copyright and trade secret
//  laws. You may not view, use, disclose, copy, or distribute this file or
//  any information contained herein except pursuant to a valid written
//  license from Synopsys.
// ============================================================================

#ifndef VCS_GENERIC_SERIALIZATION_WRAPPER_HH_
#define VCS_GENERIC_SERIALIZATION_WRAPPER_HH_

#ifndef VCS_GENERIC_SERIALIZATION_ARCHIVE_HH_
#if 0 /* expanded by -frewrite-includes */
#include "serialization/include/archive.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/wrapper.hh"
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/wrapper.hh"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/wrapper.hh"

// Function templates cannot be partially specialized.
// So we're using class templates for that as described
// by Herb Sutter in http://www.gotw.ca/publications/mill17.htm.

template <class ObjectT>
struct GetObjectVisibilityNI;

// Don't touch
template <class ObjectT>
vcs::generic::serialization::Visibility getObjectVisibility(const ObjectT& obj)
{
    return GetObjectVisibilityNI<ObjectT>::f(obj);
}

// Can be specialized
template <class ObjectT>
struct GetObjectVisibilityNI
{
    static vcs::generic::serialization::Visibility f(const ObjectT& /* obj */)
    {
        return vcs::generic::serialization::GlobalV;
    }
};

template <class ObjectT>
struct SerializeNI;

// Don't touch
template <class ObjectT>
void serialize(vcs::generic::serialization::Archive& ar, ObjectT& obj)
{
    SerializeNI<ObjectT>::f(ar, obj);
}

// Can be specialized
template <class ObjectT>
struct SerializeNI
{
    static void f(vcs::generic::serialization::Archive& ar, ObjectT& obj);
};


namespace vcs {
namespace generic {
namespace serialization {

namespace detail {

// ----------------------------------------------------------------------------
//  CLASS : WrapperBase
//
//  Abstract base class for class template Wrapper.
// ----------------------------------------------------------------------------

class WrapperBase
    : virtual public Serializable
{
    friend class vcs::generic::serialization::Archive;

protected:

    virtual void* getObjectPtr() = 0;

    virtual TypeInfo& getObjectTypeInfo() const = 0;
};


// ----------------------------------------------------------------------------
//  CLASS TEMPLATE : Wrapper
//
//  Wrapper class for objects of non-intrusive serializable classes.
// ----------------------------------------------------------------------------

template <class ObjectT, unsigned ObjectVersion>
class Wrapper
    : public WrapperBase
{
    friend class vcs::generic::serialization::Archive;

protected:

    typedef Wrapper<ObjectT, ObjectVersion> ThisT;

protected:

    static Serializable* createSerializableObject(void* objectPtr)
    {
        return new ThisT(objectPtr ? objectPtr : new ObjectT);
    }

    static int sSerializableClassId;
    static int sSerializableAliasId;

public:

    static int staticInitClassId()
    {
        return vcs::generic::serialization::detail::registerClassInfo(
            typeid(ObjectT), createSerializableObject, ObjectVersion);
    }

    static int staticInitAliasId(const char* alias)
    {
        return vcs::generic::serialization::detail::registerAliasInfo(
            typeid(ObjectT), alias, sSerializableClassId);
    }

protected:

    explicit Wrapper(void* objectPtr)
        : mObjectPtr(reinterpret_cast<ObjectT*>(objectPtr))
    {}

    void serialize(vcs::generic::serialization::Archive& ar)
    {
        ::serialize(ar, *mObjectPtr);
    }

    int getSerializableClassId() const
    {
        return sSerializableClassId;
    }

    Visibility getObjectVisibility() const
    {
        return ::getObjectVisibility(*mObjectPtr);
    }

    void* getObjectPtr()
    {
        return mObjectPtr;
    }

    TypeInfo& getObjectTypeInfo() const
    {
        return typeid(ObjectT);
    }

    ~Wrapper()
    {}

private:

    // disabled
    Wrapper();
    Wrapper(const ThisT&);
    ThisT& operator = (const ThisT&);

private:

    ObjectT* mObjectPtr;
};


// IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII

template <class ObjectT, unsigned ObjectVersion>
int Wrapper<ObjectT, ObjectVersion>::sSerializableClassId =
    Wrapper<ObjectT, ObjectVersion>::staticInitClassId();

} // detail


template <class ObjectT>
inline Archive& operator & (Archive& ar, ObjectT*& objP)
{
    if (ar.isSaving()) {
        ar.saveObjectByPtrNI(
            typeid(ObjectT), objP ? &typeid(*objP) : 0, objP);
    }
    else {
        void* objectPtr;
        void* contObject = 0;
        ar.loadObjectByPtrNI(typeid(ObjectT), objectPtr, contObject);
        objP = reinterpret_cast<ObjectT*>(objectPtr);
        if (contObject) {
            ar.loadObjectByPtrNI(typeid(ObjectT), objectPtr, contObject);
        }
    }
    return ar;
}

template <class ObjectT>
inline Archive& operator & (Archive& ar, ObjectT& obj)
{
    if (ar.isSaving()) {
        ar.saveObjectByRefNI(typeid(ObjectT), typeid(obj), &obj);
    }
    else {
        ar.loadObjectByRefNI(typeid(ObjectT), typeid(obj), &obj);
    }
    return ar;
}

} // serialization
} // generic
} // vcs
#endif // VCS_GENERIC_SERIALIZATION_WRAPPER_HH_
# 214 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/wrapper.hh"
# 65 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh" 2
#endif
# 66 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"

#endif // VCS_GENERIC_SERIALIZATION_HH_
# 68 "/remote/vgrnd13/bpham/VCS/vgcommon/serialization/include/vcs_serialization.hh"
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "LpMsgIntf.hh"
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/LpMsgIntf.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author: Ashish Chamoli


#ifndef LP_MSG_INTERFACE_HH__
#define LP_MSG_INTERFACE_HH__

#if 0 /* expanded by -frewrite-includes */
#include "lp_msg_typedefs.hh"
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/LpMsgIntf.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_typedefs.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author: Ashish Chamoli


#ifndef LP_MSG_TYPEDEFS_HH__
#define LP_MSG_TYPEDEFS_HH__

#define NAMESPACE_LPMSG_BEGIN namespace lpmsg {
#define NAMESPACE_LPMSG_END } // lpmsg


typedef enum {
    INVALID_MSG_ID = 0,
#define LP_MSG_TABLE_GENERATE_ENUM(id) id
#if 0 /* expanded by -frewrite-includes */
#include "lp_msg_table.hh"
#endif /* expanded by -frewrite-includes */
# 19 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_typedefs.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author: Ashish Chamoli

#if !defined(LP_MSG_TABLE_GENERATE_ENUM) && !defined(LP_MSG_TABLE_GENERATE_ENTRY) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_1) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_2) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_3) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_4) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_5) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_6) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_7) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_8) && !defined(LP_MSG_TABLE_GENERATE_ENTRY_9)
#error "LP_MSG_TABLE_GENERATE_ENUM or  (LP_MSG_TABLE_GENERATE_ENTRY and LP_MSG_TABLE_GENERATE_ENTRY_1 and LP_MSG_TABLE_GENERATE_ENTRY_2 and LP_MSG_TABLE_GENERATE_ENTRY_3 and LP_MSG_TABLE_GENERATE_ENTRY_4 and LP_MSG_TABLE_GENERATE_ENTRY_5 and LP_MSG_TABLE_GENERATE_ENTRY_6 and LP_MSG_TABLE_GENERATE_ENTRY_7 and LP_MSG_TABLE_GENERATE_ENTRY_8 and LP_MSG_TABLE_GENERATE_ENTRY_9) must be defined before including lp_msg_table.h"
#endif
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh"

#if defined(LP_MSG_TABLE_GENERATE_ENUM) && (defined(LP_MSG_TABLE_GENERATE_ENTRY) || defined(LP_MSG_TABLE_GENERATE_ENTRY_1) || defined(LP_MSG_TABLE_GENERATE_ENTRY_2) || defined(LP_MSG_TABLE_GENERATE_ENTRY_3) || defined(LP_MSG_TABLE_GENERATE_ENTRY_4) || defined(LP_MSG_TABLE_GENERATE_ENTRY_5) || defined(LP_MSG_TABLE_GENERATE_ENTRY_6) || defined(LP_MSG_TABLE_GENERATE_ENTRY_7) || defined(LP_MSG_TABLE_GENERATE_ENTRY_8) || defined(LP_MSG_TABLE_GENERATE_ENTRY_9))
#error "(LP_MSG_TABLE_GENERATE_ENTRY or LP_MSG_TABLE_GENERATE_ENTRY_1 or LP_MSG_TABLE_GENERATE_ENTRY_2 or LP_MSG_TABLE_GENERATE_ENTRY_3 or LP_MSG_TABLE_GENERATE_ENTRY_4 or LP_MSG_TABLE_GENERATE_ENTRY_5 or LP_MSG_TABLE_GENERATE_ENTRY_6 or LP_MSG_TABLE_GENERATE_ENTRY_7 or LP_MSG_TABLE_GENERATE_ENTRY_8 or LP_MSG_TABLE_GENERATE_ENTRY_9) cannot be defined with LP_MSG_TABLE_GENERATE_ENUM before including lp_msg_table.h"
#endif
# 15 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh"

#if !defined(LP_MSG_TABLE_GENERATE_ENUM) && (!defined(LP_MSG_TABLE_GENERATE_ENTRY) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_1) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_2) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_3) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_4) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_5) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_6) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_7) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_8) || !defined(LP_MSG_TABLE_GENERATE_ENTRY_9))
#error "All of (LP_MSG_TABLE_GENERATE_ENTRY and LP_MSG_TABLE_GENERATE_ENTRY_1 and LP_MSG_TABLE_GENERATE_ENTRY_2 and LP_MSG_TABLE_GENERATE_ENTRY_3 and LP_MSG_TABLE_GENERATE_ENTRY_4 and LP_MSG_TABLE_GENERATE_ENTRY_5 and LP_MSG_TABLE_GENERATE_ENTRY_6 and LP_MSG_TABLE_GENERATE_ENTRY_7 and LP_MSG_TABLE_GENERATE_ENTRY_8 and LP_MSG_TABLE_GENERATE_ENTRY_9) must be defined when LP_MSG_TABLE_GENERATE_ENUM is not defined before including lp_msg_table.h"
#endif
# 19 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh"


#ifdef LP_MSG_TABLE_GENERATE_ENUM

#define LP_MSG_TABLE_GENERATE_ENTRY(id, severity, enabled, isInternal, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_1(id, severity, enabled, isInternal, PowerObjectType1, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_2(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_3(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_4(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_5(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_6(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_7(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, PowerObjectType7,text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_8(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, PowerObjectType7, PowerObjectType8, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),

#define LP_MSG_TABLE_GENERATE_ENTRY_9(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, PowerObjectType7, PowerObjectType8, PowerObjectType9, text) \
    LP_MSG_TABLE_GENERATE_ENUM(id),
#endif
# 53 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh"

#define LP_MSG_TABLE_ENTRY(id, severity, enabled, isInternal, text) \
    LP_MSG_TABLE_GENERATE_ENTRY(id, severity, enabled, isInternal, text)

#define LP_MSG_TABLE_ENTRY_1(id, severity, enabled, isInternal, PowerObjectType1, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_1(id, severity, enabled, isInternal, PowerObjectType1, text)

#define LP_MSG_TABLE_ENTRY_2(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_2(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, text)

#define LP_MSG_TABLE_ENTRY_3(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_3(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, text)

#define LP_MSG_TABLE_ENTRY_4(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_4(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, text)

#define LP_MSG_TABLE_ENTRY_5(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_5(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, text)

#define LP_MSG_TABLE_ENTRY_6(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_6(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, text)

#define LP_MSG_TABLE_ENTRY_7(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, PowerObjectType7, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_7(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6,PowerObjectType7, text)

#define LP_MSG_TABLE_ENTRY_8(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, PowerObjectType7, PowerObjectType8, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_8(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6,PowerObjectType7, PowerObjectType8,text)

#define LP_MSG_TABLE_ENTRY_9(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6, PowerObjectType7, PowerObjectType8, PowerObjectType9, text) \
    LP_MSG_TABLE_GENERATE_ENTRY_9(id, severity, enabled, isInternal, PowerObjectType1, PowerObjectType2, PowerObjectType3, PowerObjectType4, PowerObjectType5, PowerObjectType6,PowerObjectType7, PowerObjectType8, PowerObjectType9, text)

#if 0 /* expanded by -frewrite-includes */
#include "lp_msg_table_entry.hh"
#endif /* expanded by -frewrite-includes */
# 84 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table_entry.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author: Ashish Chamoli && Rajaditya Mukherjee


//Keep only the table here. It is read by C++ files as well as SV files

//TABLE ENTRY MACRO ( MSG ID                Severity      isEnabled       isInternal     Object Types        Message text)

LP_MSG_TABLE_ENTRY_2(LP_MSG_ONOFF,                   InfoC,      true,    true,   UpfNamedObjC,       UpfNamedObjC,    "Message '%s' is now '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_MSG_NF,                      WarningC,   true,    true,   UpfNamedObjC,       UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC, "'%s', '%s': Message '%s' referenced in function '%s' not found.\n")
LP_MSG_TABLE_ENTRY_5(LP_MSG_INVALID_ARG,             WarningC,   true,    true,   UpfNamedObjC,       UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC, "'%s', '%s': Argument '%s' in function '%s' is invalid. Valid values are '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_MSG_SEV,                     InfoC,      true,    true,   UpfNamedObjC,       UpfNamedObjC,    "Severity of message '%s' is now '%s'.\n")
LP_MSG_TABLE_ENTRY_1(LP_MSG_REG,                     InfoC,      true,    true,   UpfNamedObjC,    "Message '%s' is registered successfully.\n")
LP_MSG_TABLE_ENTRY_3(LP_MSG_INT,                     WarningC,   true,    true,   UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC,"'%s', '%s': '%s' is an internal message. 'lp_msg_print' can be used only with messages registered through 'lp_msg_register'.\n")
LP_MSG_TABLE_ENTRY_4(LP_MSG_AE,                      WarningC,   true,    true,   UpfNamedObjC,       UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC, "'%s', '%s': Message '%s' in function '%s' already Exists. Already registered message cannot be registered again.\n")

//Power Domain Related Messages
LP_MSG_TABLE_ENTRY_2(LP_PD_INIT_STATE,               InfoC,      true,    false,   PowerDomainC,       UpfNamedObjC,    "Power domain '%s' started in '%s' state.\n")
LP_MSG_TABLE_ENTRY_3(LP_PD_STATE_CHANGE,             InfoC,      true,    false,    PowerDomainC,       UpfNamedObjC,    UpfNamedObjC,    "Power domain '%s' state changed from '%s' to '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_PD_TRANS,               InfoC,      true,    false,   PowerDomainC,       UpfNamedObjC,    "Power Domain '%s' transitioned to state '%s' \n")
LP_MSG_TABLE_ENTRY_1(LP_PD_PWRUP,                    InfoC,      true,    false,    PowerDomainC,           "Power Domain '%s' powered up.\n")
LP_MSG_TABLE_ENTRY_1(LP_PD_PWRDN,                    InfoC,      true,    false,    PowerDomainC,           "Power Domain '%s' powered down.\n")
LP_MSG_TABLE_ENTRY_1(LP_MACRO_PD_PWRUP,              InfoC,      true,    false,    PowerDomainC,           "Power Domain '%s' powered up.\n")
LP_MSG_TABLE_ENTRY_1(LP_MACRO_PD_PWRDN,              InfoC,      true,    false,    PowerDomainC,           "Power Domain '%s' powered down.\n")
//Prolly related to CSN >??
LP_MSG_TABLE_ENTRY_2(LP_SNET_HDL_SNET_UPDATE,        InfoC,      true,    false,    SupplyNetC,         UpfNamedObjC,    "HDL Supply Net '%s' updated to value '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SNET_HDL_SNET_CONN_UPDATE,   InfoC,      true,    false,    SupplyPortC,        SupplyNetC,      UpfNamedObjC,    "HDL Supply Port '%s' driving UPF Supply Net '%s' updated to value '%s'.\n")
//Related to CPF Domain mapping
LP_MSG_TABLE_ENTRY_2(LP_DM_MISMATCH,        ErrorC,      true,    false,    PowerDomainC,         PowerDomainC,    "State mismatch between domains '%s' and '%s' specified by domain mapping command.\n")
//Power Net related messages
LP_MSG_TABLE_ENTRY_3(LP_PPN_INIT_STATE,              InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,    "Primary power net '%s' of power domain '%s' started in %s state.\n")
LP_MSG_TABLE_ENTRY_3(LP_PPN_INIT_VALUE,              InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,    "Primary power net '%s' of power domain '%s' started with voltage %s V.\n")
LP_MSG_TABLE_ENTRY_3(LP_PGN_INIT_STATE,              InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,    "Primary ground net '%s' of power domain '%s' started in %s state.\n")
LP_MSG_TABLE_ENTRY_3(LP_PGN_INIT_VALUE,              InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,    "Primary ground net '%s' of power domain '%s' started with voltage %s V.\n")
LP_MSG_TABLE_ENTRY_4(LP_PPN_STATE_CHANGE,            InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,    "State of the primary power net '%s' of power domain '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_PGN_STATE_CHANGE,            InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,    "State of the primary ground net '%s' of power domain '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_PPN_VALUE_CHANGE,            InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,    "Voltage of the primary power net '%s' of power domain '%s' changed from %s V to %s V.\n")
LP_MSG_TABLE_ENTRY_4(LP_PGN_VALUE_CHANGE,            InfoC,      true,    false,   SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,    "Voltage of the primary ground net '%s' of power domain '%s' changed from %s V to %s V.\n")
//LP_MSG_TABLE_ENTRY_5(LP_PPN_STATE_GLITCH,              WarningC,   true,    false,    SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "Multiple changes at same time on State of the primary power net '%s' of power domain '%s'. State changed from %s -> %s -> %s.\n")
//LP_MSG_TABLE_ENTRY_5(LP_PGN_STATE_GLITCH,              WarningC,   true,    false,    SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "Multiple changes at same time on State of the primary ground net '%s' of power domain '%s'. State changed from %s -> %s -> %s.\n")
//LP_MSG_TABLE_ENTRY_5(LP_PPN_VALUE_GLITCH,              WarningC,   true,    false,    SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "Multiple voltage changes at same time on State of the primary power net '%s' of power domain '%s'. State changed from %s V -> %s V -> %s V.\n")
//LP_MSG_TABLE_ENTRY_5(LP_PGN_VALUE_GLITCH,              WarningC,   true,    false,    SupplyNetC,          PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "Multiple voltage changes at same time on State of the primary ground net '%s' of power domain '%s'. State changed from %s V -> %s V -> %s V.\n")
//Power State Table related messages
LP_MSG_TABLE_ENTRY_3(LP_GROUP_STATE_CHANGE,            InfoC,      true,        false,    UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Design state changed from '%s' to '%s' in group '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_GROUP_STATE_ILLEGAL,           WarningC,   true,        false,    UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Design state changed from '%s' to '%s' (illegal) in group '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_GROUP_INIT_ILLEGAL,            WarningC,   true,        false,    UpfNamedObjC,        UpfNamedObjC,   "Design started with '%s' state (illegal) in group '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_GROUP_INIT_STATE,              InfoC,      true,          false,    UpfNamedObjC,        UpfNamedObjC,   "Design started with '%s' state in group '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_PST_INIT_STATE,              InfoC,      true,    false,    UpfNamedObjC,        UpfNamedObjC,   "Design started with '%s' state in pst '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_PST_INIT_ILLEGAL,            WarningC,   true,    false,    UpfNamedObjC,        UpfNamedObjC,   "Design started with '%s' state (illegal) in pst '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_PST_STATE_CHANGE,            InfoC,      true,    false,    UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Design state changed from '%s' to '%s' in pst '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_PST_STATE_ILLEGAL,           WarningC,   true,    false,    UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Design state changed from '%s' to '%s' (illegal) in pst '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_PST_STATE_INIT, InfoC,   true,    false,    UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC, "Design started with '%s' state in pst '%s' with Supplies '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_PST_STATE_ILLEGAL_INIT, WarningC,   true,    false,    UpfNamedObjC,        UpfNamedObjC, "Design started with 'ILLEGAL' state in pst '%s' with Supplies '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_PST_STATE_ILLEGAL_COMBINATION_INIT, ErrorC,   true,    false,    UpfNamedObjC,        UpfNamedObjC, "Design started with 'ILLEGAL' state in pst '%s' with Supplies '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_PST_STATE_TRANSITION, InfoC,   true,    false,    UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Design state changed from '%s' to '%s' in pst '%s' with Supplies '%s' and Supply '%s' changed.\n")
LP_MSG_TABLE_ENTRY_5(LP_PST_STATE_ILLEGAL_TRANSITION, WarningC,   true,    false,    UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Design state changed from '%s' to '%s' in pst '%s' with Supplies '%s' and Supply '%s' changed.\n")
LP_MSG_TABLE_ENTRY_5(LP_PST_STATE_ILLEGAL_COMBINATION, ErrorC,   true,    false,    UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Design state changed from '%s' to '%s' in pst '%s' with Supplies '%s' and Supply '%s' changed.\n")
//Power Switch related messages
LP_MSG_TABLE_ENTRY_4(LP_PSW_CTRL_INIT_INVALID,               ErrorC,     true,    false,   UpfNamedObjC,        UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,    "Signal '%s' connected to control port '%s' of power switch '%s' started with an invalid value '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_PSW_CTRL_INIT_VALUE,             InfoC,      true,    false,   UpfNamedObjC,        UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,    "Signal '%s' connected to control port '%s' of power switch '%s' started with a value '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_PSW_ISP_INIT_STATE,          InfoC,      true,    false,   SupplyNetC,          UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,    "Supply net '%s' tied to input supply port '%s' of power switch '%s' started with state %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_PSW_ISP_INIT_VALUE,          InfoC,      true,    false,   SupplyNetC,          UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,    "Supply net '%s' tied to input supply port '%s' of power switch '%s' started with voltage %s V.\n")
LP_MSG_TABLE_ENTRY_4(LP_PSW_OSP_INIT_STATE,          InfoC,      true,    false,   SupplyNetC,          UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,    "Supply net '%s' tied to output supply port '%s' of power switch '%s' started with state %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_PSW_OSP_INIT_VALUE,          InfoC,      true,    false,   SupplyNetC,          UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,    "Supply net '%s' tied to output supply port '%s' of power switch '%s' started with voltage %s V.\n")
LP_MSG_TABLE_ENTRY_3(LP_PSW_INIT_STATE,              InfoC,      true,    false,    PowerSwitchC,        UpfNamedObjC,   UpfNamedObjC,   "Power switch '%s' started in %s (%s) state.\n")
LP_MSG_TABLE_ENTRY_5(LP_PSW_STATE_CHANGE,            InfoC,      true,    false,    PowerSwitchC,        UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "State of power switch '%s' changed from %s (%s) to %s (%s).\n")
LP_MSG_TABLE_ENTRY_5(LP_PSW_CTRL_CHANGE,             InfoC,      true,    false,    UpfNamedObjC,        UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,   UpfNamedObjC,   "Signal '%s' connected to control port '%s' of power switch '%s' changed from '%s' to '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_PSW_CTRL_INVALID,            ErrorC,     true,    false,    UpfNamedObjC,        UpfNamedObjC,   PowerSwitchC,   UpfNamedObjC,   UpfNamedObjC,   "Signal '%s' connected to control port '%s' of power switch '%s' changed from '%s' to an invalid value '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_PSW_OSP_STATE,               InfoC,      true,    false,    SupplyNetC,          UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "State of supply net '%s' tied to output supply port '%s' of power switch '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_PSW_OSP_VALUE,               InfoC,      true,    false,    SupplyNetC,          UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "Voltage of supply net '%s' tied to output supply port '%s' of power switch '%s' changed from %s V to %s V.\n")
LP_MSG_TABLE_ENTRY_5(LP_PSW_ISP_STATE,               InfoC,      true,    false,    SupplyNetC,          UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "State of supply net '%s' tied to input supply port '%s' of power switch '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESET_ASSERT_FAIL,               WarningC,      true, false,    UpfNamedObjC,          UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Reset has not been asserted within '%s' timeunit after power up. Instance: '%s', Domain : '%s', Reset : '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESET_DEASSERT_FAIL,               WarningC,      true, false,    UpfNamedObjC,          UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC,  "Reset is de-asserted within '%s' timeunit after power up. Instance: '%s', Domain : '%s', Reset : '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESET_ASSERT_FAIL_ON_ISO_DISABLE,               WarningC,      true, false,    UpfNamedObjC,          UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC,   "Reset is asserted. As reset is not active when the isolation signal gets disabled  after power up. Instance: '%s', Domain : '%s', Reset : '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_CLOCK_ASSERT_FAIL_ON_ISO_DISABLE,               WarningC,      true, false,    UpfNamedObjC,          UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Clock is asserted. As clock does not have '%s' cycles before isolation signal is disable after power-up. Instance: '%s', Domain : '%s', Clock : '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_PSW_ISP_VALUE,               InfoC,      true,    false,    SupplyNetC,          UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,   "Voltage of supply net '%s' tied to input supply port '%s' of power switch '%s' changed from %s V to %s V.\n")
//These are non concorded messages of PSW to PERF
// @todo : Kill them the moment you can
//LP_MSG_TABLE_ENTRY_5(LP_PSW_INIT,              InfoC,      true,    false,    PowerSwitchC,        UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC,   "Power Switch %s initialized to state %s. Output Supply Port '%s' is at state = '%s' and voltage = %s volt(s).\n")
//LP_MSG_TABLE_ENTRY_2(LP_PSW_STATE_CHANGE_1,              InfoC,      true,    false,    PowerSwitchC,        UpfNamedObjC,   "Power Switch '%s' changed to state = '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_PSW_SUPPLY_CHANGE,           InfoC,      true,    false,      PowerSwitchC,    UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC,  "Output Supply Port of Power Switch '%s' changed to state = '%s' and voltage = %s volt(s) with enable expression '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_PSW_INIT,        InfoC,      true,    false,      PowerSwitchC,    UpfNamedObjC,   UpfNamedObjC, "Output Supply Port of Power Switch '%s' initialized to state = '%s' and enable expression '%s'.\n")
// Active State Conditions
LP_MSG_TABLE_ENTRY_3(LP_ACTIVE_STATE_COND_EXPR, InfoC,    true,    false, UpfNamedObjC, PowerDomainC,  UpfNamedObjC,   "active_state_condition expression corresponding to Nominal condition '%s' for Power Domain '%s' is at logic value '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_ACTIVE_STATE_COND_MULTIPLE, ErrorC,    true,    false,  PowerDomainC,  UpfNamedObjC,   "For Power Domain '%s', multiple active_state_condition expressions corresponding to Nominal conditions '%s' have evaluated to True at the same time.\n")
LP_MSG_TABLE_ENTRY_2(LP_ACTIVE_STATE_COND_MULTIPLE_INIT, ErrorC,    true,    false,  PowerDomainC,  UpfNamedObjC,   "For Power Domain '%s', multiple active_state_condition expressions corresponding to Nominal conditions '%s' have started in True state.\n")
LP_MSG_TABLE_ENTRY_1(LP_ACTIVE_STATE_COND_SHUTOFF, WarningC,    true,    false,  PowerDomainC,  "For Power Domain '%s', none of the active_state_condition expressions have evaluated to True and the Power Domain has not shut off.\n")
LP_MSG_TABLE_ENTRY_1(LP_ACTIVE_STATE_COND_SHUTOFF_INIT, WarningC,    true,    false,  PowerDomainC,  "For Power Domain '%s', none of the active_state_condition expressions have started in True state and the Power Domain has not started in shut off.\n")
LP_MSG_TABLE_ENTRY_2(LP_ACTIVE_STATE_COND_NOT_ON, WarningC,    true,    false,  PowerDomainC,  UpfNamedObjC,   "For Power Domain '%s',  active_state_condition expression corresponding to Nominal condition '%s' has evaluated to True, however the Power Domain is shut off.\n")
LP_MSG_TABLE_ENTRY_2(LP_ACTIVE_STATE_COND_NOT_ON_INIT, WarningC,    true,    false,  PowerDomainC,  UpfNamedObjC,   "For Power Domain '%s',  active_state_condition expression corresponding to Nominal condition '%s' has started in True state, however the Power Domain has started in shut off.\n")
LP_MSG_TABLE_ENTRY_2(LP_ACTIVE_STATE_COND_TRANSITION, InfoC,    true,    false,  PowerDomainC,  UpfNamedObjC,   "Power Domain '%s' has transitioned to active_state_condition Nominal condition '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_ACTIVE_STATE_COND_TRANSITION_INIT, InfoC,    true,    false,  PowerDomainC,  UpfNamedObjC,   "Power Domain '%s' has started in active_state_condition Nominal condition '%s'.\n")

//Retention Related Messages
LP_MSG_TABLE_ENTRY_4(LP_RETPN_INIT,                  InfoC,      true,    false,    SupplyNetC,          RetentionC,   PowerDomainC,   UpfNamedObjC, "Retention power net '%s' for retention strategy '%s' of power domain '%s' started with %s state.\n")
LP_MSG_TABLE_ENTRY_4(LP_RETGN_INIT,                  InfoC,      true,    false,    SupplyNetC,          RetentionC,   PowerDomainC,   UpfNamedObjC, "Retention ground net '%s' for retention strategy '%s' of power domain '%s' started with %s state.\n")
LP_MSG_TABLE_ENTRY_5(LP_RETPN_STATE,                 InfoC,      true,    false,    SupplyNetC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   "State of retention power net '%s' for retention strategy '%s' of power domain '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_RETGN_STATE,                 InfoC,      true,    false,    SupplyNetC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   "State of retention ground net '%s' for retention strategy '%s' of power domain '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_RET_PWR_OFF,              WarningC,      true,    false,    RetentionC,       PowerDomainC ,   "Retention power for retention strategy '%s' of power domain '%s' turned OFF. Shadow registers are corrupted.\n")
//Save Restore related Messages
LP_MSG_TABLE_ENTRY_2(LP_SAVE_ON,                     InfoC,      true,    false,    RetentionC,        PowerDomainC ,    "Save asserted for retention strategy '%s' of power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_7(LP_SAVE_ON_GENERIC_CLOCK_ASYNC_LOAD,         InfoC,      true,    false,    RetentionC,        PowerDomainC ,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save asserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_SAVE_ON_GENERIC_CLOCK,             InfoC,      true,    false,    RetentionC,        PowerDomainC ,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save asserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_SAVE_ON_GENERIC_ASYNC_LOAD,             InfoC,      true,    false,    RetentionC,        PowerDomainC ,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save asserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_SAVE_OFF,                    InfoC,      true,    false,    RetentionC,         PowerDomainC,    "Save deasserted for retention strategy '%s' of power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_7(LP_SAVE_OFF_GENERIC_CLOCK_ASYNC_LOAD,        InfoC,      true,    false,    RetentionC,         PowerDomainC,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,  UpfNamedObjC, "Save deasserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_SAVE_OFF_GENERIC_CLOCK,            InfoC,      true,    false,    RetentionC,         PowerDomainC,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save deasserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_SAVE_OFF_GENERIC_ASYNC_LOAD,            InfoC,      true,    false,    RetentionC,         PowerDomainC,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save deasserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_SAVE_RETPWRDN,               ErrorC,      true,    false,    RetentionC,         PowerDomainC,    "Save event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF.\n")
LP_MSG_TABLE_ENTRY_7(LP_SAVE_RETPWRDN_GENERIC_CLOCK_ASYNC_LOAD,   ErrorC,      true,    false,    RetentionC,         PowerDomainC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,  "Save event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_SAVE_RETPWRDN_GENERIC_CLOCK,       ErrorC,      true,    false,    RetentionC,         PowerDomainC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,  "Save event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_SAVE_RETPWRDN_GENERIC_ASYNC_LOAD,       ErrorC,      true,    false,    RetentionC,         PowerDomainC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,  "Save event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_RESTORE_ON,                  InfoC,      true,    false,    RetentionC,         PowerDomainC,    "Restore asserted for retention strategy '%s' of power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_7(LP_RESTORE_ON_GENERIC_CLOCK_ASYNC_LOAD,      InfoC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore asserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_RESTORE_ON_GENERIC_CLOCK,          InfoC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore asserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_RESTORE_ON_GENERIC_ASYNC_LOAD,          InfoC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore asserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_RESTORE_OFF,                 InfoC,      true,    false,    RetentionC,         PowerDomainC,    "Restore deasserted for retention strategy '%s' of power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_7(LP_RESTORE_OFF_GENERIC_CLOCK_ASYNC_LOAD,     InfoC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore deasserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_RESTORE_OFF_GENERIC_CLOCK,         InfoC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore deasserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_RESTORE_OFF_GENERIC_ASYNC_LOAD,         InfoC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore deasserted for retention strategy '%s' of power domain '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_RESTORE_RETPWRDN,            ErrorC,      true,    false,    RetentionC,         PowerDomainC,    "Restore event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF.\n")
LP_MSG_TABLE_ENTRY_7(LP_RESTORE_RETPWRDN_GENERIC_CLOCK_ASYNC_LOAD, ErrorC,      true,    false,    RetentionC,         PowerDomainC,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_RESTORE_RETPWRDN_GENERIC_CLOCK,    ErrorC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_RESTORE_RETPWRDN_GENERIC_ASYNC_LOAD,    ErrorC,      true,    false,    RetentionC,         PowerDomainC,    UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Restore event triggered for retention strategy '%s' of power domain '%s' when retention power is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
// @ Another set of save restore related messages
LP_MSG_TABLE_ENTRY_5(LP_SAVE_INIT,                   InfoC,      true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   "Save signal '%s' for retention strategy '%s' of power domain '%s' started with a value '%s'. Save sense specified is '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_SAVE_INIT_INVALID,                   WarningC,   true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   "Save signal '%s' for retention strategy '%s' of power domain '%s' started with an invalid value '%s'.\n")
LP_MSG_TABLE_ENTRY_6(LP_SAVE_CHANGE,                 InfoC,      true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, "Save signal '%s' for retention strategy '%s' of power domain '%s' changed from '%s' to '%s'. Save sense specified is '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_SAVE_INVALID,                WarningC,   true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  "Save signal '%s' for retention strategy '%s' of power domain '%s' changed from '%s' to '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_SAVE_PRIMPWR_OFF,            WarningC,   true,    false,    RetentionC,      PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   "Save operation enabled for retention strategy '%s' of power domain '%s' while the primary power of domain is OFF. Save signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_9(LP_SAVE_PRIMPWR_OFF_GENERIC_CLOCK_ASYNC_LOAD,    WarningC,   true,    false,    RetentionC,      PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save operation enabled for retention strategy '%s' of power domain '%s' while the primary power of domain is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s. Save signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_8(LP_SAVE_PRIMPWR_OFF_GENERIC_CLOCK,    WarningC,   true,    false,    RetentionC,      PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save operation enabled for retention strategy '%s' of power domain '%s' while the primary power of domain is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s. Save signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_8(LP_SAVE_PRIMPWR_OFF_GENERIC_ASYNC_LOAD,    WarningC,   true,    false,    RetentionC,      PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Save operation enabled for retention strategy '%s' of power domain '%s' while the primary power of domain is OFF for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s. Save signal '%s' is at an active level '%s'.\n")
//LP_MSG_TABLE_ENTRY_4(LP_SAVE_ENABLED,                  InfoC,      true,    false,    RetentionC,   PowerDomainC,   UpfNamedObjC,  UpfNamedObjC, "Save operation enabled for retention strategy '%s' of power domain '%s'. Save signal '%s' is at an active value '%s'.\n")
//LP_MSG_TABLE_ENTRY_4(LP_SAVE_DISABLED,                 InfoC,      true,    false,    RetentionC,   PowerDomainC,   UpfNamedObjC,  UpfNamedObjC, "Save operation disabled for retention strategy '%s' of power domain '%s'. Save signal '%s' changed to an inactive value '%s'.\n")
//LP_MSG_TABLE_ENTRY_4(LP_SAVE_RETPWR_OFF,                   WarningC,   true,    false,    RetentionC,   PowerDomainC,   UpfNamedObjC,  UpfNamedObjC, "Save operation disabled. Retention power for retention strategy '%s' of power domain '%s' turned OFF while save signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_RESTORE_INIT,                InfoC,      true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,   "Restore signal '%s' for retention strategy '%s' of power domain '%s' started with a value '%s'. Restore sense specified is '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESTORE_INIT_INVALID,                WarningC,   true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   "Restore signal '%s' for retention strategy '%s' of power domain '%s' started with an invalid value '%s'.\n")
LP_MSG_TABLE_ENTRY_6(LP_RESTORE_CHANGE,                  InfoC,      true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, "Restore signal '%s' for retention strategy '%s' of power domain '%s' changed from '%s' to '%s'. Restore sense specified is '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_RESTORE_INVALID,                 WarningC,   true,    false,    UpfNamedObjC,          RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  "Restore signal '%s' for retention strategy '%s' of power domain '%s' changed from '%s' to '%s'.\n")
//LP_MSG_TABLE_ENTRY_4(LP_RESTORE_ENABLED,                   InfoC,      true,    false,    RetentionC,   PowerDomainC,   UpfNamedObjC,  UpfNamedObjC, "Restore operation enabled for retention strategy '%s' of power domain '%s'. Restore signal '%s' is at an active value '%s'.\n")
//LP_MSG_TABLE_ENTRY_4(LP_RESTORE_DISABLED,                  InfoC,      true,    false,    RetentionC,   PowerDomainC,   UpfNamedObjC,  UpfNamedObjC, "Restore operation disabled for retention strategy '%s' of power domain '%s'. Restore signal '%s' changed to an inactive value '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESTORE_PRIMPWR_OFF,                 WarningC,   true,    false,       PowerDomainC,   UpfNamedObjC, RetentionC, UpfNamedObjC, "Restore operation disabled. Primary power of power domain '%s' turned OFF while restore signal '%s' of retention strategy '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_9(LP_RESTORE_PRIMPWR_OFF_GENERIC_CLOCK_ASYNC_LOAD,   WarningC,   true,    false,       PowerDomainC,   UpfNamedObjC, RetentionC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Restore operation disabled. Primary power of power domain '%s' turned OFF while restore signal '%s' of retention strategy '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_PRIMPWR_OFF_GENERIC_CLOCK,  WarningC,   true,    false,    PowerDomainC,   UpfNamedObjC, RetentionC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Restore operation disabled. Primary power of power domain '%s' turned OFF while restore signal '%s' of retention strategy '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_PRIMPWR_OFF_GENERIC_ASYNC_LOAD,  WarningC,   true,    false,    PowerDomainC,   UpfNamedObjC, RetentionC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Restore operation disabled. Primary power of power domain '%s' turned OFF while restore signal '%s' of retention strategy '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
//LP_MSG_TABLE_ENTRY_2(LP_RESTORE_X,                 ErrorC,      true,    false,   PowerDomainC ,      RetentionC   ,    "Restoring X on the registers of power domain '%s'. Retention power for retention strategy '%s' is in OFF state when restore is applied.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESTORE_NOSAVE,                  ErrorC,     true,    false,       PowerDomainC,  RetentionC, UpfNamedObjC,   UpfNamedObjC, "Restoring X on the registers of power domain '%s'. Restore operation is enabled without a save event, after retention power is turned ON. Retention Strategy : '%s', Restore Signal : '%s', Save Signal : '%s'.\n")
LP_MSG_TABLE_ENTRY_9(LP_RESTORE_NOSAVE_GENERIC_CLOCK_ASYNC_LOAD, ErrorC, true,    false, PowerDomainC,  RetentionC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Restoring X on the registers of power domain '%s' . Restore operation is enabled without a save event, after retention power is turned ON. Retention Strategy : '%s', Restore Signal : '%s', Save Signal : '%s', for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_NOSAVE_GENERIC_CLOCK,    ErrorC,  true,    false, PowerDomainC,  RetentionC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Restoring X on the registers of power domain '%s'. Restore operation is enabled without a save event, after retention power is turned ON. Retention Strategy : '%s', Restore Signal : '%s', Save Signal : '%s', for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_NOSAVE_GENERIC_ASYNC_LOAD,    ErrorC,  true,    false, PowerDomainC,  RetentionC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Restoring X on the registers of power domain '%s'. Restore operation is enabled without a save event, after retention power is turned ON. Retention Strategy : '%s', Restore Signal : '%s', Save Signal : '%s', for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")

//save condition /restore condition is OFF
LP_MSG_TABLE_ENTRY_4(LP_SAVE_OFF_COND_FALSE,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, "Save operation disabled.  Save condition of retention strategy '%s' of power domain '%s' changed to FALSE while save signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESTORE_OFF_COND_FALSE,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, "Restore operation disabled.  Restore condition of retention strategy '%s' of power domain '%s' changed to FALSE while restore signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_9(LP_SAVE_OFF_COND_FALSE_GENERIC_CLOCK_ASYNC_LOAD,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Save operation disabled.  Save condition of retention strategy '%s' of power domain '%s' changed to FALSE while save signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_SAVE_OFF_COND_FALSE_GENERIC_CLOCK,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Save operation disabled.  Save condition of retention strategy '%s' of power domain '%s' changed to FALSE while save signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_SAVE_OFF_COND_FALSE_GENERIC_ASYNC_LOAD,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Save operation disabled.  Save condition of retention strategy '%s' of power domain '%s' changed to FALSE while save signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_9(LP_RESTORE_OFF_COND_FALSE_GENERIC_CLOCK_ASYNC_LOAD,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Restore operation disabled.  Restore condition of retention strategy '%s' of power domain '%s' changed to FALSE while restore signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_OFF_COND_FALSE_GENERIC_CLOCK,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Restore operation disabled.  Restore condition of retention strategy '%s' of power domain '%s' changed to FALSE while restore signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_OFF_COND_FALSE_GENERIC_ASYNC_LOAD,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Restore operation disabled.  Restore condition of retention strategy '%s' of power domain '%s' changed to FALSE while restore signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")

LP_MSG_TABLE_ENTRY_4(LP_SAVE_ACTIVE_COND_FALSE,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, "Save operation is not enabled.  Save condition of retention strategy '%s' of power domain '%s' is FALSE while save signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESTORE_ACTIVE_COND_FALSE,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, "Restore operation is not enabled.  Restore condition of retention strategy '%s' of power domain '%s' is FALSE while restore signal '%s' is at an active level '%s'.\n")
LP_MSG_TABLE_ENTRY_9(LP_SAVE_ACTIVE_COND_FALSE_GENERIC_CLOCK_ASYNC_LOAD,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Save operation is not enabled.  Save condition of retention strategy '%s' of power domain '%s' is FALSE while save signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_SAVE_ACTIVE_COND_FALSE_GENERIC_CLOCK,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Save operation is not enabled.  Save condition of retention strategy '%s' of power domain '%s' is FALSE while save signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_SAVE_ACTIVE_COND_FALSE_GENERIC_ASYNC_LOAD,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Save operation is not enabled.  Save condition of retention strategy '%s' of power domain '%s' is FALSE while save signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_9(LP_RESTORE_ACTIVE_COND_FALSE_GENERIC_CLOCK_ASYNC_LOAD,   InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC, "Restore operation is not enabled.  Restore condition of retention strategy '%s' of power domain '%s' is FALSE while restore signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s, Generic Async Load: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_ACTIVE_COND_FALSE_GENERIC_CLOCK,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Restore operation is not enabled.  Restore condition of retention strategy '%s' of power domain '%s' is FALSE while restore signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Clock: %s.\n")
LP_MSG_TABLE_ENTRY_8(LP_RESTORE_ACTIVE_COND_FALSE_GENERIC_ASYNC_LOAD,  InfoC,   true,    false,       RetentionC, PowerDomainC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Restore operation is not enabled.  Restore condition of retention strategy '%s' of power domain '%s' is FALSE while restore signal '%s' is at an active level '%s' for flops in instance '%s' in process (File: %s, Line: %s). Generic Async Load: %s.\n")

//Supply Set Related Messages
LP_MSG_TABLE_ENTRY_3(LP_SS_INIT,                     InfoC,      true,    false,   SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,  "Supply Set '%s' initialized to state '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SS_INITS,                    InfoC,      true,    false,   SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,  "Supply Set '%s' initialized to states '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SS_ILLEGAL,                  WarningC,   true,    false,   SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,  "Supply Set '%s' initialized to illegal state '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SS_ILLEGALS,                  WarningC,   true,    false,   SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,  "Supply Set '%s' initialized to illegal states '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SS_STATE_CHANGE,             InfoC,      true,    false,    SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,     "Supply Set '%s' transitioned to state '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SS_STATES_CHANGE,            InfoC,      true,    false,    SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,     "Supply Set '%s' transitioned to states '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SS_STATE_CHANGE_ILLEGAL,     WarningC,   true,    false,    SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,     "Supply Set '%s' transitioned to illegal state '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SS_STATES_CHANGE_ILLEGAL,    WarningC,   true,    false,    SupplySetHandleC,        UpfNamedObjC,   UpfNamedObjC,     "Supply Set '%s' transitioned to illegal states '%s' with simstate '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_SS_STATES_ILLEGAL_ACTIVE,    WarningC,   true,    false,    SupplySetHandleC,        UpfNamedObjC,   "Supply Set '%s' has active illegal states '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_SS_STATE_ILLEGAL_ACTIVE,     WarningC,   true,    false,    SupplySetHandleC,        UpfNamedObjC,   "Supply Set '%s' has active illegal state '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_SS_EXPR_MISMATCH,            ErrorC,     true,    false,    UpfNamedObjC,      UpfNamedObjC,   UpfNamedObjC,   SupplySetHandleC,   "Supply expression's value '%s' does not match with Logic expression value '%s' for state '%s' of Supply Set '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_POWER_STATE_NOT_FOUND,       WarningC,      true,    false,   UpfNamedObjC,  SupplySetHandleC, UpfNamedObjC,   UpfNamedObjC, "Power State '%s' specified in 'UPF::set_supply_set_state' function call not found for Supply Set '%s'. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_3(LP_SUPPLY_SET_NOT_FOUND,        WarningC,      true,    false,   SupplySetHandleC,  UpfNamedObjC,   UpfNamedObjC, "Supply Set '%s' not found in 'UPF::set_supply_set_state' function call. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_SUPPLY_SET_NO_SEXPR,         WarningC,      true,    false,   UpfNamedObjC, SupplySetHandleC,  UpfNamedObjC,   UpfNamedObjC, "State '%s' of Supply Set '%s' specified in 'UPF::set_supply_set_state' function call does not have a '-supply_expr' specified. The call will be ignored. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_SUPPLY_SET_SEXPR_UNSUPPORTED, WarningC,    true,    false,     UpfNamedObjC, UpfNamedObjC, SupplySetHandleC, UpfNamedObjC, UpfNamedObjC, "Supply expression '%s' for power state '%s' of Supply Set '%s' is not supported. 'UPF::set_supply_set_state' function call will be ignored. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_7(LP_SET_SUPPLY_SET_SEXPR_UPDATED,    InfoC,    true,    false,     UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, SupplySetHandleC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Supply Set function '%s' of '-supply_expr {%s}' for power state '%s' of Supply Set '%s' updated with state '%s' due to 'UPF::set_supply_set_state' function call. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_7(LP_SUPPLY_SET_SEXPR_DRIVEN,     WarningC,    true,    false,     UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, SupplySetHandleC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Supply Set function '%s' of '-supply_expr {%s}' for power state '%s' of Supply Set '%s' is already driven with driver '%s'. Ignoring the 'UPF::set_supply_set_state' function call. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_3(LP_SET_SS_STATE_MISMATCH_LOGIC_EXPR, ErrorC,    true,    false, SupplySetHandleC,   UpfNamedObjC,   UpfNamedObjC,  "For Supply Set %s, 'UPF::set_supply_set_state' function being used to set state to '%s' for non matching Logic expression value '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_SET_SS_STATE_MISMATCH_SUPPLY_EXPR, ErrorC,    true,    false, SupplySetHandleC,   UpfNamedObjC,   UpfNamedObjC,  "For Supply Set %s, 'UPF::set_supply_set_state' function being used to set state to '%s' for non matching Supply expression value '%s'.\n")


//Related to RS Mutex Assertions
LP_MSG_TABLE_ENTRY_6(LP_ASSERT_R_MUTEX,              ErrorC,      true,    false,    RetentionC,  PowerDomainC,       SupplyNetC,    UpfNamedObjC, UpfNamedObjC ,   UpfNamedObjC ,"'assert_r_mutex' defined for retention strategy '%s' of power domain '%s' failed. Restore signal '%s' ('%s') and signal '%s' ('%s') are not mutually exclusive.\n")
LP_MSG_TABLE_ENTRY_6(LP_ASSERT_S_MUTEX,              ErrorC,      true,    false,    RetentionC,   PowerDomainC,      SupplyNetC,    UpfNamedObjC, UpfNamedObjC ,   UpfNamedObjC , "'assert_s_mutex' defined for retention strategy '%s' of power domain '%s' failed. Save signal '%s' ('%s') and signal '%s' ('%s') are not mutually exclusive.\n")
LP_MSG_TABLE_ENTRY_6(LP_ASSERT_RS_MUTEX,             ErrorC,      true,    false,    RetentionC,   PowerDomainC,       UpfNamedObjC ,   UpfNamedObjC , UpfNamedObjC ,   UpfNamedObjC , "'assert_rs_mutex' defined for retention strategy '%s' of power domain '%s' failed. Restore signal '%s' ('%s') and save signal '%s' ('%s') are not mutually exclusive.\n")
//@another set of non concorded messages for LP assert mutex
//LP_MSG_TABLE_ENTRY_6(LP_ASSERT_R_MUTEX,            ErrorC,     true,    false,      RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, "Assert_R_Mutex defined for retention strategy '%s' of power domain '%s' failed. Signal '%s' ('%s') is not mutually exclusive with the restore signal '%s' ('%s').\n")
//LP_MSG_TABLE_ENTRY_6(LP_ASSERT_S_MUTEX,            ErrorC,     true,    false,      RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, "Assert_S_Mutex defined for retention strategy '%s' of power domain '%s' failed. Signal '%s' ('%s') is not mutually exclusive with the save signal '%s' ('%s').\n")
//LP_MSG_TABLE_ENTRY_8(LP_ASSERT_RS_MUTEX,           ErrorC,     true,    false,      RetentionC,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Assert_RS_Mutex defined for retention strategy '%s' of power domain '%s' failed. %s '%s' ('%s') and %s '%s' ('%s') are not mutually exclusive.\n")



//Isolation related messages
LP_MSG_TABLE_ENTRY_2(LP_ISO_EN,                      InfoC,       true,    false,     IsolationC,    PowerDomainC,           "Isolation enabled for isolation strategy '%s' of power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_ISO_EN_PWRDN,                InfoC,       true,    false,     IsolationC,         PowerDomainC,    "Isolation enabled for isolation strategy '%s' when Power Domain '%s' is OFF.\n")
LP_MSG_TABLE_ENTRY_2(LP_ISO_DIS,                     InfoC,       true,    false,     IsolationC,    PowerDomainC,         "Isolation disabled for isolation strategy '%s' of power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_ISO_DIS_PWRDN,               InfoC,       true,    false,     IsolationC,         PowerDomainC,    "Isolation disabled for isolation strategy '%s' when Power Domain '%s' is OFF.\n")
//LP_MSG_TABLE_ENTRY_1(LP_ISO_PWRDN,                   InfoC,       true,    false,     IsolationC,           "Isolation gates for isolation strategy '%s' powered down.\n")
//LP_MSG_TABLE_ENTRY_1(LP_ISO_PWRUP,                   InfoC,       true,    false,     IsolationC,           "Isolation gates for isolation strategy '%s' powered up.\n")
//@Another set of LPA ISO related messages
LP_MSG_TABLE_ENTRY_5(LP_ISOEN_INIT_VALUE,             InfoC,   true,    false,   UpfNamedObjC,       IsolationC,    PowerDomainC,   UpfNamedObjC,   UpfNamedObjC, "Isolation enable '%s' of isolation strategy '%s' of power domain '%s' started with value '%s'. Isolation sense specified is '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_MAP_ISOEN_INIT_VALUE,             InfoC,   true,    false,   UpfNamedObjC,       IsolationC,    PowerDomainC,   UpfNamedObjC, "Isolation enable '%s' of mapped isolation strategy '%s' of power domain '%s' started with value '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_ISO_INIT_OFF,              WarningC,      true,    false,    IsolationC,         PowerDomainC,    "Isolation strategy '%s' of power domain '%s' started in CORRUPT state.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISOEN_INIT_INVALID,          WarningC,   true,    false,    UpfNamedObjC,     IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' of isolation strategy '%s' of power domain '%s' started with an invalid value '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISOEN_INIT_INVALID_GATE,          WarningC,   true,    false,    UpfNamedObjC,     UpfNamedObjC, IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolated signal '%s' of isolation strategy '%s' of power domain '%s' started with an invalid value '%s'.\n")
LP_MSG_TABLE_ENTRY_6(LP_ISOEN_CHANGE,                InfoC,      true,    false,    UpfNamedObjC,        IsolationC  ,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, "Isolation enable '%s' of isolation strategy '%s' of power domain '%s' changed from '%s' to '%s'. Isolation sense specified is '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_MAP_ISOEN_CHANGE,                InfoC,      true,    false,    UpfNamedObjC,        IsolationC  ,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC, "Isolation enable '%s' of mapped isolation strategy '%s' of power domain '%s' changed from '%s' to '%s'.\n")
//LP_MSG_TABLE_ENTRY_6(LP_ISOEN_GLITCH,                  InfoC,      true,    false,    UpfNamedObjC,        IsolationC  ,   PowerDomainC,   UpfNamedObjC,   UpfNamedObjC,  UpfNamedObjC, "Glitch on isolation enable '%s' of isolation strategy '%s' of power domain '%s'. Isolation enable changed from %s -> %s -> %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISOEN_INVALID,           ErrorC,     true,    false,    UpfNamedObjC,     IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' of isolation strategy '%s' of power domain '%s' changed to an invalid value '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISOEN_INVALID_GATE,           ErrorC,     true,    false,    UpfNamedObjC,     UpfNamedObjC, IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolated signal '%s' of isolation strategy '%s' of power domain '%s' changed to an invalid value '%s'.\n")
//LP_MSG_TABLE_ENTRY_2(LP_ISO_APPLIED,                InfoC,       true,    false,     IsolationC,         PowerDomainC,    "Isolation applied for strategy '%s' of power domain '%s'.\n")
//LP_MSG_TABLE_ENTRY_2(LP_ISO_REMOVED,                InfoC,       true,    false,     IsolationC,         PowerDomainC,    "Isolation removed for strategy '%s' of power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISOPN_INIT,          InfoC,      true,    false,   SupplyNetC ,     IsolationC ,   PowerDomainC,   UpfNamedObjC, "Isolation power net '%s' for isolation strategy '%s' of power domain '%s' started in state %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISOPN_STATE,             InfoC,   true,    false,  SupplyNetC ,       IsolationC,    PowerDomainC,   UpfNamedObjC,   UpfNamedObjC, "State of isolation power net '%s' for isolation strategy '%s' of power domain '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISOGN_INIT,          InfoC,      true,    false,   SupplyNetC ,     IsolationC ,   PowerDomainC,   UpfNamedObjC, "Isolation ground net '%s' for isolation strategy '%s' of power domain '%s' started in state %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISOGN_STATE,             InfoC,   true,    false,  SupplyNetC ,       IsolationC,    PowerDomainC,   UpfNamedObjC,   UpfNamedObjC, "State of isolation ground net '%s' for isolation strategy '%s' of power domain '%s' changed from %s to %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISOPN_OFF,           WarningC,   true,    false,    SupplyNetC,     IsolationC ,   PowerDomainC,   UpfNamedObjC, "State of isolation power net '%s' for isolation strategy '%s' of power domain '%s' changed to %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISOPN_OFF_GATE,           WarningC,   true,    false,    SupplyNetC,     UpfNamedObjC, IsolationC ,   PowerDomainC,   UpfNamedObjC, "State of isolation power net '%s' for isolated signal '%s' of isolation strategy '%s' of power domain '%s' changed to %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISOGN_OFF,           WarningC,   true,    false,    SupplyNetC,     IsolationC ,   PowerDomainC,   UpfNamedObjC, "State of isolation ground net '%s' for isolation strategy '%s' of power domain '%s' changed to %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISOGN_OFF_GATE,           WarningC,   true,    false,    SupplyNetC,     UpfNamedObjC, IsolationC ,   PowerDomainC,   UpfNamedObjC, "State of isolation ground net '%s' for isolated signal '%s' of isolation strategy '%s' of power domain '%s' changed to %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISO_SEQFAIL1,        WarningC,   true,    false,   UpfNamedObjC ,     IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolation strategy '%s' is not active when the source power domain '%s' changed to %s state.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISO_SEQFAIL1_GATE,        WarningC,   true,    false,   UpfNamedObjC ,     UpfNamedObjC, IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolated signal '%s' of isolation strategy '%s' is not active when the source power domain '%s' changed to %s state.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISO_INACTIVE_SINKON,        WarningC,   true,    false,   UpfNamedObjC ,     IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolation strategy '%s' is not active when the source power domain '%s' is in %s simstate and at least one of the sink power domains changed to NORMAL simstate.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISO_INACTIVE_SINKON_GATE,        WarningC,   true,    false,   UpfNamedObjC ,     UpfNamedObjC, IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolated signal '%s' of isolation strategy '%s' is not active when the source power domain '%s' is in %s simstate and at least one of the sink power domains changed to NORMAL simstate.\n")
LP_MSG_TABLE_ENTRY_4(LP_ISO_INACTIVE_DOMAIN_OFF,        WarningC,   true,    false,   UpfNamedObjC ,     IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolation strategy '%s' changed to inactive state when the source power domain '%s' is in %s state.\n")
LP_MSG_TABLE_ENTRY_5(LP_ISO_INACTIVE_DOMAIN_OFF_GATE,        WarningC,   true,    false,   UpfNamedObjC ,     UpfNamedObjC, IsolationC ,   PowerDomainC,   UpfNamedObjC,   "Isolation enable '%s' for isolated signal '%s' of isolation strategy '%s' changed to incative state when the source power domain '%s' is in %s state.\n")
LP_MSG_TABLE_ENTRY(LP_ISO_GLOBAL_EN,                  InfoC,       true,    false,    "All isolation strategy are enabled by default .\n")
LP_MSG_TABLE_ENTRY(LP_ISO_GLOBAL_DIS,                  InfoC,       true,    false,    "All isolation strategies are disabled by the user .\n")
LP_MSG_TABLE_ENTRY_1(LP_ISO_LOCAL_EN,                  InfoC,       true,    false,     IsolationC,    "Isolation strategy '%s' is enabled by default .\n")
LP_MSG_TABLE_ENTRY_1(LP_ISO_LOCAL_DIS,                  InfoC,       true,    false,     IsolationC,    "Isolation strategy '%s' is disabled by the user .\n")
//LP_MSG_TABLE_ENTRY_2(LP_ISO_SEQFAIL2,              WarningC,      true,    false,   PowerDomainC ,        IsolationC ,    "Isolation removed before the source power domain '%s' turned ON. Isolation strategy : '%s'.\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_ISO_EN,                  InfoC,       true,    false,     IsolationC,    "Isolation enabled for isolation strategy '%s' .\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_ISO_DIS,                 InfoC,       true,    false,     IsolationC,    "Isolation disabled for isolation strategy '%s' .\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_ISO_SECONDARY_ON,                  InfoC,       true,    false,     IsolationC,    "Secondary Domain in 'On' state for isolation strategy '%s' .\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_ISO_SECONDARY_OFF,                  InfoC,       true,    false,     IsolationC,    "Secondary Domain in 'Off' state for isolation strategy '%s' .\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_SAVE_ON,                  InfoC,       true,    false,     RetentionC,    "Save asserted for retention strategy '%s'.\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_SAVE_OFF,                 InfoC,       true,    false,     RetentionC,    "Save deasserted for retention strategy '%s'.\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_RESTORE_ON,                  InfoC,       true,    false,    RetentionC ,    "Restore asserted for retention strategy '%s'.\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_RESTORE_OFF,                 InfoC,       true,    false,     RetentionC,    "Restore deasserted for retention strategy '%s'.\n")
LP_MSG_TABLE_ENTRY_1(LP_CPF_SAVE_RESTORE,                 ErrorC,       true,    false,     RetentionC,    "Save and Restore asserted simultaneously for retention strategy '%s'.\n")
//Runtime PERF Messages
LP_MSG_TABLE_ENTRY_2(LP_DOMAIN_RAND_SEED,            InfoC,       true,    false,    PowerDomainC,      UpfNamedObjC,   "Random corruption seed specified for domain '%s' is '%s'.\n")
LP_MSG_TABLE_ENTRY_1(LP_DESIGN_RAND_SEED,            InfoC,       true,    false,    UpfNamedObjC,   "Random corruption seed specified for design is: '%s'\n")
LP_MSG_TABLE_ENTRY_1(LP_AUTO_RAND_SEED,              InfoC,       true,    false,    UpfNamedObjC,   "Random corruption seed is not specified for design. Using automatic generated random corruption seed '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_COA_CORRUPT_ALW,           WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "LHS in always block corrupted due to activity on sensitivity list elements in simstate 'CORRUPT_ON_ACTIVITY'. Instance: %s, File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_3(LP_COA_CORRUPT_CA,                WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "LHS of cont-assign corrupted due to activity on RHS in simstate 'CORRUPT_ON_ACTIVITY'. Instance: %s, File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_3(LP_COA_CORRUPT_GATE,          WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Output of primitive gate corrupted due to activity on inputs in simstate 'CORRUPT_ON_ACTIVITY'.Instance : '%s', File: '%s', Line : '%s'.\n")
LP_MSG_TABLE_ENTRY_3(LP_COA_CORRUPT_UDP,           WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Output of UDP corrupted due to activity on inputs in simstate 'CORRUPT_ON_ACTIVITY'. Instance: %s, File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_1(LP_COA_CORRUPT_SIG,             WarningC,    true,    false,     UpfNamedObjC,           "Signal %s corrupted due to activity.\n")
LP_MSG_TABLE_ENTRY_1(LP_COA_CORRUPT_VAR,             WarningC,    true,    false,     UpfNamedObjC,           "Variable %s corrupted due to activity.\n")
LP_MSG_TABLE_ENTRY_1(LP_CFG_FILE_ERR,                ErrorC,      true,    false,    UpfNamedObjC,           "Cannot open specified config file: %s, please check for the file existence and file permissions and rerun the simulation.\n")
LP_MSG_TABLE_ENTRY_4(LP_SUPPLY_PAD_NOT_FOUND,        WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,      UpfNamedObjC,   "Supply Pad '%s' not found in 'UPF::%s' function. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_4(LP_CSOC_ASRT,        WarningC,    true,    false, UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC, UpfNamedObjC,   "Signal '%s' has changed it's value during CORRUPT_STATE_ON_CHANGE simstate, Instance: %s  File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_3(LP_SUPPLY_NET_NOT_FOUND,        ErrorC,    true,    false,      UpfNamedObjC,        UpfNamedObjC, UpfNamedObjC,   "Supply Net '%s' used in $upf_mirror_state, not found.  Source Information: File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_SUPPLY_PAD_NOT_FOUND_UCLI,        WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   "Supply Pad '%s' not found in 'UPF::%s' function called from UCLI.\n")
LP_MSG_TABLE_ENTRY_6(LP_SUPPLY_PORT_DRIVEN,        WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC,      UpfNamedObjC, UpfNamedObjC,  "Ignoring the 'UPF::%s' function on Supply Port '%s' which is already driven by a '%s' '%s'. File: %s, Line: %s. UPF::supply_on/supply_off functions are allowed only on undriven Supply Port/Net.\n")
LP_MSG_TABLE_ENTRY_4(LP_SUPPLY_PORT_DRIVEN_UCLI,   WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC, "Ignoring the 'UPF::%s' function on Supply Port '%s' which is already driven by a '%s' '%s'.UPF::supply_on/supply_off functions are allowed only on undriven Supply Port/Net.\n")
LP_MSG_TABLE_ENTRY_5(LP_SUPPLY_PAD_CALL,           InfoC,       true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Supply Pad function 'UPF::%s' called for Supply Pad '%s'. Supply Pad value changed to '%s'. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_6(LP_SUPPLY_PAD_CALL_OOR,            ErrorC,    true,    false,     UpfNamedObjC,    UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Supply Pad function 'UPF::%s' called with out of range voltage '%s' for Supply Pad '%s'. Supply Pad value changed to '%s'. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_3(LP_SUPPLY_PAD_CALL_UCLI,           InfoC,       true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC, "Supply Pad function 'UPF::%s' called for Supply Pad '%s'from UCLI. Supply Pad value changed to '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_SUPPLY_PAD_VOLTAGE,            WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Supply Pad function 'UPF::%s' called for Power Supply Pad '%s' with '0' voltage. Supply Pad value changed to '%s'. File: %s, Line: %s.\n")
LP_MSG_TABLE_ENTRY_3(LP_SUPPLY_PAD_VOLTAGE_UCLI,            WarningC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   "Supply Pad function 'UPF::%s' called for Power Supply Pad '%s' with '0' voltage from UCLI. Supply Pad value changed to '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_ROUT_INDEX_EXCEEDED,            ErrorC,    true,    false,     UpfNamedObjC,        UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC, "Rout table index exceeded while finding R Routine corresponding to named initial block '%s'. Rout index obtained is '%s' which should be lesser than total number of routines '%s' for the given ip '%s'.\n")
//MV_PERF messsages, added as a part of fix for star 9000505757
//LP_MSG_TABLE_ENTRY_1(LP_PST_STATE_CHANGE_ILLEGAL_1,      WarningC             ,      true,    false,    UpfNamedObjC,           "Power State Table `%s' has changed to illegal state\n")
//LP_MSG_TABLE_ENTRY_2(LP_PST_STATE_CHANGE_1,       InfoC,    true,    false,     UpfNamedObjC,      UpfNamedObjC,   "Power State Table `%s' has changed state to state `%s'\n")
//LP_MSG_TABLE_ENTRY_2(LP_PST_INIT_STATE_1,       InfoC,    true,    false,     UpfNamedObjC,      UpfNamedObjC,   "Power State Table `%s' has initialized to state `%s'\n")
// Message control messages these should always be at last
LP_MSG_TABLE_ENTRY(LP_MODE_STATE_CHANGE_ILLEGAL,      WarningC             ,      true,    false,   "Design Power Mode State has changed to illegal state\n")
LP_MSG_TABLE_ENTRY_1(LP_MODE_STATE_CHANGE,       InfoC,    true,    false,     UpfNamedObjC,      "Design Power Mode State has changed to state '%s'")
LP_MSG_TABLE_ENTRY_1(LP_MODE_INIT_STATE,       InfoC,    true,    false,     UpfNamedObjC, "Design Power Mode State has initialized to state '%s'")
//CPF Messages
LP_MSG_TABLE_ENTRY_4(LP_SHUTOFF_EXPR_MISMATCH,       ErrorC,     true,    false,   UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC, "External Shutoff Expression of Power Domain '%s' is %s but existing %s of the domain is %s.\n")

//Marvell Messages
LP_MSG_TABLE_ENTRY_5(LP_CLOCK_HIGH_RESTORE,      WarningC,  true, false,   UpfNamedObjC, RetentionC,   UpfNamedObjC,     UpfNamedObjC,       UpfNamedObjC, "Clock '%s' high during active restore of policy '%s' for flops in instance '%s' in process (File: %s, Line: %0d).\n")
LP_MSG_TABLE_ENTRY_5(LP_CLOCK_HIGH_SAVE,      WarningC,  true, false,         UpfNamedObjC, RetentionC,   UpfNamedObjC,       UpfNamedObjC,       UpfNamedObjC, "Clock '%s' high during active save of policy '%s' for flops in instance '%s' in process (File: %s, Line: %0d).\n")
LP_MSG_TABLE_ENTRY_5(LP_RESET_SAVE_RESTORE,      WarningC,  true, false,        UpfNamedObjC, RetentionC,   UpfNamedObjC,       UpfNamedObjC,       UpfNamedObjC, "Change on reset '%s' during active save/restore of retention strategy '%s' for flops in instance '%s' in process (File: %s, Line: %0d).\n")
LP_MSG_TABLE_ENTRY_4(LP_CLOCK_WIGGLE, WarningC, true, false, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, PowerDomainC, "Clock '%s' wiggling in instance '%s' during %s for the power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_4(LP_RESET_WIGGLE, WarningC, true, false, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, PowerDomainC, "Reset '%s' wiggling in instance '%s' during %s for the power domain '%s'.\n")
LP_MSG_TABLE_ENTRY_5(LP_PORT_STATE_CHANGE,               InfoC,      true, false,    SupplyNetC,          UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC,   "Supply Source '%s' changed to '%s' state with root net '%s' at state '%s' and voltage %s V.\n")
LP_MSG_TABLE_ENTRY_5(LP_PORT_STATE_INIT,               InfoC,      true, false,    SupplyNetC,          UpfNamedObjC, UpfNamedObjC, UpfNamedObjC,   UpfNamedObjC,   "Supply Source '%s' initialized to '%s' state with root net '%s' at state '%s' and voltage %s V.\n")

//NLP-XA
LP_MSG_TABLE_ENTRY_2(LP_XA_UNDETER_OFF,               WarningC,      true, false,    SupplyPortC,          UpfNamedObjC, "Spice Supply Port '%s' updated to value '%s' after translating 'UNDETERMINED' to 'OFF'.\n")

//LS related
LP_MSG_TABLE_ENTRY_4(LP_SUPPLY_OUT_OF_RANGE,    WarningC,      true, false,    SupplyNetC,   UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC,   "Supply Net '%s' has voltage '%s' which is out of range. %s voltage for this supply net is '%s'.\n")
//Automatic assertion for Fujitsu
LP_MSG_TABLE_ENTRY_6(LP_SRC_OFF_CLAMP,    ErrorC,      true, false,    UpfNamedObjC,   PowerDomainC, IsolationC,    UpfNamedObjC,   PowerDomainC,  UpfNamedObjC,  "Isolation enable is not asserted when input to isolation cell '%s' is corrupted due to source domain/supply '%s' being turned off.\nIsolation Strategy : '%s', Isolation Enable : '%s', Reference Domain : '%s', Port : '%s'.\n")

LP_MSG_TABLE_ENTRY_5(LP_HDL_XMR_WRITE_BLOCKED,             WarningC,   true, false,   UpfNamedObjC,       UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC, "XMR write from scope '%s' to signal/variable '%s' is blocked as the simstate of the corresponding power domain '%s' is 'CORRUPT'. File : %s, Line : %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_UCLI_SIGNAL_WRITE_BLOCKED,             WarningC,   true, false,   UpfNamedObjC,       UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC, "XMR write from scope '%s' to signal/variable '%s' is blocked as the simstate of the corresponding power domain '%s' is 'CORRUPT'. File : %s, Line : %s.\n")
LP_MSG_TABLE_ENTRY_5(LP_PLI_SIGNAL_WRITE_BLOCKED,             WarningC,   true, false,   UpfNamedObjC,       UpfNamedObjC,    UpfNamedObjC,   UpfNamedObjC,   UpfNamedObjC, "XMR write from scope '%s' to signal/variable '%s' is blocked as the simstate of the corresponding power domain '%s' is 'CORRUPT'. File : %s, Line : %s.\n")
LP_MSG_TABLE_ENTRY_2(LP_TIMING_CHECK_OFF,  InfoC,   true, false, PowerDomainC,       UpfNamedObjC, "All timing checks on elements inside power domain `%s' are turned OFF as the domain simstate changed from %s to CORRUPT.")
LP_MSG_TABLE_ENTRY_2(LP_TIMING_CHECK_ON,  InfoC,   true, false, PowerDomainC, UpfNamedObjC, "All timing checks on elements inside power domain `%s' are turned ON as the domain simstate changed from CORRUPT to %s.")

LP_MSG_TABLE_ENTRY_1(LP_DESIGN_REAL_CORRUPT,            InfoC,       true,    false,    UpfNamedObjC,   "Real corruption value specified for design is: '%s'.\n")
LP_MSG_TABLE_ENTRY_2(LP_DOMAIN_REAL_CORRUPT,            InfoC,       true,    false,    PowerDomainC,      UpfNamedObjC,   "Real corruption value specified for domain '%s' is '%s'.\n")

LP_MSG_TABLE_ENTRY_4(LP_ISO_OUT_TOGGLE, WarningC, true, false, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, UpfNamedObjC, "Output of isolation cell toggled from '%s' to '%s' when isolation enable was %s. Isolation output: %s.\n")

LP_MSG_TABLE_ENTRY_3(LP_BOUNDARY_PORT_NO_TOGGLE,    ErrorC,      true, false,    UpfNamedObjC,   PowerDomainC, PowerDomainC,  "Boundary port '%s' of power domain '%s' did not toggle after the state of source supply '%s' changed to FULL_ON.\n")

//Following is special summary message with blank text. Text is generated later. Keep this at last
LP_MSG_TABLE_ENTRY(LP_MSG_SUMMARY,                   InfoC,      true,    true,   "")




# 85 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh" 2


#ifdef LP_MSG_TABLE_GENERATE_ENUM
#undef LP_MSG_TABLE_GENERATE_ENTRY
#undef LP_MSG_TABLE_GENERATE_ENTRY_1
#undef LP_MSG_TABLE_GENERATE_ENTRY_2
#undef LP_MSG_TABLE_GENERATE_ENTRY_3
#undef LP_MSG_TABLE_GENERATE_ENTRY_4
#undef LP_MSG_TABLE_GENERATE_ENTRY_5
#undef LP_MSG_TABLE_GENERATE_ENTRY_6
#undef LP_MSG_TABLE_GENERATE_ENTRY_7
#undef LP_MSG_TABLE_GENERATE_ENTRY_8
#undef LP_MSG_TABLE_GENERATE_ENTRY_9
#endif
# 99 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_table.hh"


# 20 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_typedefs.hh" 2
#undef LP_MSG_TABLE_GENERATE_ENUM
    LAST_MSG_ID
} MsgFormId;

NAMESPACE_LPMSG_BEGIN

enum LpMsgSeverity {
    InfoC,
    WarningC,
    ErrorC,
    FatalC
};

enum LpMsgLogMode {
    DefaultC,
    CustomC,
    DefaultCustomC
};

typedef void (*LpMsgCallbackFn)(char* simTime, LpMsgSeverity sev, const char* code, const char* msg);
typedef char* (*LpMsgGetSimTimeFn)(void);
typedef void (*LpMsgExitFn)(int);

NAMESPACE_LPMSG_END

#endif //LP_MSG_TYPEDEFS_HH__
# 46 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/lp_msg_typedefs.hh"
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/LpMsgIntf.hh" 2


#ifdef __cplusplus
extern "C" {
#endif
# 18 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/LpMsgIntf.hh"

void initializeLpMsgController(lpmsg::LpMsgExitFn exit);
void* makeOrGetMsgController(void);
void cleanupLpMsgController(void);

#ifdef __cplusplus
}
#endif
# 26 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/LpMsgIntf.hh"


NAMESPACE_LPMSG_BEGIN

class LpMsgController
{
public:
    struct MsgSchema {
        int         _id;
        const char* _name;
        const char* _severity;
        const char* _text;
        MsgSchema(int i, const char* n, const char *s, const char* t) { _id = i; _name = n; _severity = s; _text = t; }
        int getId() { return _id; }
        const char* getName() { return _name; }
        const char* getSeverity() { return _severity; }
        const char* getText() { return _text; }
    };
public:
    virtual void registerMsgCallback(LpMsgCallbackFn fn) = 0;
    virtual void setRunTimeAdapter(LpMsgGetSimTimeFn timeFn, void* pLogFile,
                                   void* pLogFileName) = 0;

    virtual int getLpInfoCount() = 0;
    virtual int getLpWarningCount() = 0;
    virtual int getLpErrorCount() = 0;
    virtual int getLpFatalCount() = 0;
    virtual int getMessageFormCount() = 0;
    virtual void getMessageForms(MsgSchema* ) = 0;
    virtual void setSimExitStatus(int vcsExitStatus) = 0;
    virtual void lpMsgPrint(MsgFormId msgId, const char* text, bool calledByUser, const char* fileName, int lineno) = 0;
    virtual void lpMsgReportInternal(MsgFormId msgId, unsigned char excrypted) = 0;
    virtual void lpMsgReportInternal1(MsgFormId msgId, unsigned char encrypted, const char* str1) = 0;
    virtual void lpMsgReportInternal2(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2) = 0;
    virtual void lpMsgReportInternal3(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2, const char* str3) = 0;
    virtual void lpMsgReportInternal4(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2, const char* str3, const char* str4) = 0;
    virtual void lpMsgReportInternal5(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2, const char* str3, const char* str4, const char* str5) = 0;
    virtual void lpMsgReportInternal6(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2, const char* str3, const char* str4, const char* str5, const char* str6) = 0;
    virtual void lpMsgReportInternal7(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2, const char* str3, const char* str4, const char* str5, const char* str6, const char* str7) = 0;
    virtual void lpMsgReportInternal8(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2, const char* str3, const char* str4, const char* str5, const char* str6, const char* str7, const char* str8) = 0;
    virtual void lpMsgReportInternal9(MsgFormId msgId, unsigned char encrypted, const char* str1, const char* str2, const char* str3, const char* str4, const char* str5, const char* str6, const char* str7, const char* str8, const char* str9) = 0;

    virtual void lpMsgSetSeverity(const char* msgIds, const char* sev, const char* fileName, int lineno) = 0;
    virtual void lpMsgSetOnOff(const char* msgIds, const char* value, const char* fileName, int lineno) = 0;
    virtual void lpMsgSetLogSeverity(const char* sev, const char* fileName, int lineno) = 0;

    virtual void lpMsgRegisterMsg(const char* msgId, const char* severity, const char* onOff, const char* msgText, const char* fileName, int lineno) = 0;
    virtual void lpMsgPrint(const char* msgId, const char* text, bool calledByUser, const char* fileName, int lineno) = 0;
    virtual const char* lpMsgGetFormat(const char* msgId, const char* fileName, int lineno) = 0;
    virtual int lpMsgIsEnabled(const char* msgId, const char* fileName, int lineno) = 0;
    virtual void setMsgsEnabled(bool enabled, bool showConfirmation) = 0;

    virtual ~LpMsgController() {}
};

NAMESPACE_LPMSG_END

lpmsg::LpMsgController* makeOrGetLpMsgController(void);
#endif //LP_MSG_INCLUDE_HH__
# 85 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/LpMsgIntf.hh"
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh" 2

NAMESPACE_UPFIR_BEGIN
namespace ser {
using namespace vcs::generic::serialization;
}

/* Praveen NAMESPACE_UPFIR_BEGIN */
class UpfObj:public virtual ser::Serializable
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfObj);
    virtual UpfClassType getUpfClassType() const = 0;
    virtual unsigned int getLineNo() const = 0;
    virtual const char*  getFileName() const = 0;
    virtual const char*  getKindStr() const = 0;
    virtual char* computePNMSignature() { fassert(0, "should implement"); return NULL;}
    virtual void deleteUpfStr(char* str) { fassert(0, "should implement");}
    virtual unsigned getPNMCheckSum() const { fassert(0, "should implement"); return 0; }
    virtual void setPNMCheckSum(unsigned cc) {}
protected:
    virtual ~UpfObj() {}
};

class UpfEncryptedObjAbstract: public virtual ser::Serializable 
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfEncryptedObjAbstract);
    // Any concrete derived class should also derive from UpfEncryptedObj
    // so as to implement this function
    virtual bool isEncrypted() const = 0; 
};

class UpfNamedVhObj: public virtual ser::Serializable
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfNamedVhObj);
    // Any concrete derived class should also derive from UpfEncryptedObj
    // so as to implement this function
    virtual void setMangledName(const char* name) = 0;
    virtual char* getMangledName() const = 0;
    virtual void* getTargetInstance() const = 0;
    virtual bool isVerilog() const = 0;
};

class UpfNamedObj : public UpfObj, virtual public UpfEncryptedObjAbstract
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfNamedObj);
    virtual const char* getName() const = 0;
    virtual const char* getFullName() const { return getName(); }
    virtual const char* getTclFullName() {return getFullName();}
    virtual lpmsg::LpMsgSeverity getMsgSeverity() { fassert(0, "getMsgSeverity() shouldn't be called for this upfClassType"); return lpmsg::FatalC; }
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev) { fassert(0, "setMsgSeverity() shouldn't be called for this upfClassType"); }
    virtual bool getMsgEnabled() { fassert(0, "getMsgEnabled() shouldn't be called for this upfClassType"); return false; }
    virtual void setMsgEnabled(bool en) { fassert(0, "setMsgEnabled() shouldn't be called for this upfClassType"); }
    virtual DesignElementTokenLI getTokenLI() { fassert(0, "getTokenLI() should not be called for this upfClassType"); return NULL;}
    virtual DesignElementTokenL* getTokenL() { fassert(0, "getTokenL() should not be called for this upfClassType"); return NULL;}
};

NAMESPACE_UPFIR_END
#endif //__UpfObj_hh__
# 74 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfObj.hh"
# 15 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "LpMsgIntf.hh"
#endif /* expanded by -frewrite-includes */
# 15 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 16 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
///Few classes derived from UpfObj may have bind checker objects
#if 0 /* expanded by -frewrite-includes */
#include "UpfBindChecker.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfBindChecker.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

#ifndef __UPF_BIND_CHECKER_HH__
#define __UPF_BIND_CHECKER_HH__

#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfBindChecker.hh"
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfBindChecker.hh"
#if 0 /* expanded by -frewrite-includes */
#include <algorithm>
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfBindChecker.hh"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 1 3
// <algorithm> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/algorithm
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_ALGORITHM
#define _GLIBCXX_ALGORITHM 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3

#if 0 /* expanded by -frewrite-includes */
#include <utility> // UK-300.
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 1 3
// <utility> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/utility
 *  This is a Standard C++ Library header. 
 */

#ifndef _GLIBCXX_UTILITY
#define _GLIBCXX_UTILITY 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3

/**
 * @defgroup utilities Utilities
 *
 * Components deemed generally useful. Includes pair, tuple,
 * forward/move helpers, ratio, function object, metaprogramming and
 * type traits, time, date, and memory functions.
 */

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_relops.h>
#endif /* expanded by -frewrite-includes */
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_relops.h" 1 3
// std::rel_ops implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the, 2009 Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

/** @file bits/stl_relops.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 *
 *  Inclusion of this file has been removed from
 *  all of the other STL headers for safety reasons, except std_utility.h.
 *  For more information, see the thread of about twenty messages starting
 *  with http://gcc.gnu.org/ml/libstdc++/2001-01/msg00223.html, or
 *  http://gcc.gnu.org/onlinedocs/libstdc++/faq.html#faq.ambiguous_overloads
 *
 *  Short summary: the rel_ops operators should be avoided for the present.
 */

#ifndef _STL_RELOPS_H
#define _STL_RELOPS_H 1

namespace std _GLIBCXX_VISIBILITY(default)
{
  namespace rel_ops
  {
  _GLIBCXX_BEGIN_NAMESPACE_VERSION

    /** @namespace std::rel_ops
     *  @brief  The generated relational operators are sequestered here.
     */

    /**
     *  @brief Defines @c != for arbitrary types, in terms of @c ==.
     *  @param  __x  A thing.
     *  @param  __y  Another thing.
     *  @return   __x != __y
     *
     *  This function uses @c == to determine its result.
     */
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }

    /**
     *  @brief Defines @c > for arbitrary types, in terms of @c <.
     *  @param  __x  A thing.
     *  @param  __y  Another thing.
     *  @return   __x > __y
     *
     *  This function uses @c < to determine its result.
     */
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }

    /**
     *  @brief Defines @c <= for arbitrary types, in terms of @c <.
     *  @param  __x  A thing.
     *  @param  __y  Another thing.
     *  @return   __x <= __y
     *
     *  This function uses @c < to determine its result.
     */
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }

    /**
     *  @brief Defines @c >= for arbitrary types, in terms of @c <.
     *  @param  __x  A thing.
     *  @param  __y  Another thing.
     *  @return   __x >= __y
     *
     *  This function uses @c < to determine its result.
     */
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  _GLIBCXX_END_NAMESPACE_VERSION
  } // namespace rel_ops

} // namespace std

#endif /* _STL_RELOPS_H */
# 135 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_relops.h" 3
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_pair.h>
#endif /* expanded by -frewrite-includes */
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3

#if __cplusplus >= 201103L

#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 74 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
# 75 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 75 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
# 76 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  template<class _Tp>
    class tuple_size;

  template<std::size_t _Int, class _Tp>
    class tuple_element;

   // Various functions which give std::pair a tuple-like interface.

  /// Partial specialization for std::pair
  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };

  /// Partial specialization for std::pair
  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };
 
  /// Partial specialization for std::pair
  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

#if __cplusplus > 201103L

#define __cpp_lib_tuples_by_type 201304

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

#define __cpp_lib_exchange_function 201304

  /// Assign @p __new_val to @p __obj and return its previous value.
  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }
#endif
# 202 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3

  // Stores a tuple of indices.  Used by tuple and pair, and by bind() to
  // extract the elements in a tuple.
  template<size_t... _Indexes>
    struct _Index_tuple
    {
      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;
    };

  // Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.
  template<size_t _Num>
    struct _Build_index_tuple
    {
      typedef typename _Build_index_tuple<_Num - 1>::__type::__next __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };

#if __cplusplus > 201103L

#define __cpp_lib_integer_sequence 201304

  /// Class template integer_sequence
  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
	   typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num,  size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
		     "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };

  /// Alias template make_integer_sequence
  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;

  /// Alias template index_sequence
  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;

  /// Alias template make_index_sequence
  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;

  /// Alias template index_sequence_for
  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
#endif
# 266 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 271 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3

#endif /* _GLIBCXX_UTILITY */
# 273 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/utility" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algo.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 1 3
// Algorithm implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_algo.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */

#ifndef _STL_ALGO_H
#define _STL_ALGO_H 1

#if 0 /* expanded by -frewrite-includes */
#include <cstdlib>             // for rand
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 1 3
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cstdlib
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdlib.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 20.4.6  C library
//

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
# 42 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#ifndef _GLIBCXX_CSTDLIB
#define _GLIBCXX_CSTDLIB 1

#if !_GLIBCXX_HOSTED
// The C standard does not require a freestanding implementation to
// provide <stdlib.h>.  However, the C++ standard does still require
// <cstdlib> -- but only the functionality mentioned in
// [lib.support.start.term].

#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1

namespace std
{
  extern "C" void abort(void) throw () _GLIBCXX_NORETURN;
  extern "C" int atexit(void (*)(void)) throw ();
  extern "C" void exit(int) throw () _GLIBCXX_NORETURN;
#if __cplusplus >= 201103L
# ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
  extern "C" int at_quick_exit(void (*)(void)) throw ();
# endif
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
# ifdef _GLIBCXX_HAVE_QUICK_EXIT
  extern "C" void quick_exit(int) throw() _GLIBCXX_NORETURN;
# endif
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#endif
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
} // namespace std

#else
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#if 0 /* expanded by -frewrite-includes */
#include <stdlib.h>
#endif /* expanded by -frewrite-includes */
# 72 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
# 73 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

// Get rid of those macros defined in <stdlib.h> in lieu of real functions.
#undef abort
#undef abs
#undef atexit
#if __cplusplus >= 201103L
# ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
#  undef at_quick_exit
# endif
# 82 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#endif
# 83 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#undef atof
#undef atoi
#undef atol
#undef bsearch
#undef calloc
#undef div
#undef exit
#undef free
#undef getenv
#undef labs
#undef ldiv
#undef malloc
#undef mblen
#undef mbstowcs
#undef mbtowc
#undef qsort
#if __cplusplus >= 201103L
# ifdef _GLIBCXX_HAVE_QUICK_EXIT
#  undef quick_exit
# endif
# 103 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#endif
# 104 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#undef rand
#undef realloc
#undef srand
#undef strtod
#undef strtol
#undef strtoul
#undef system
#undef wcstombs
#undef wctomb

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
#if __cplusplus >= 201103L
# ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
  using ::at_quick_exit;
# endif
# 128 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#endif
# 129 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
#ifdef _GLIBCXX_HAVE_MBSTATE_T
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
#endif // _GLIBCXX_HAVE_MBSTATE_T
# 146 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
  using ::qsort;
#if __cplusplus >= 201103L
# ifdef _GLIBCXX_HAVE_QUICK_EXIT
  using ::quick_exit;
# endif
# 151 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#endif
# 152 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
#ifdef _GLIBCXX_USE_WCHAR_T
  using ::wcstombs;
  using ::wctomb;
#endif // _GLIBCXX_USE_WCHAR_T
# 163 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#ifndef __CORRECT_ISO_CPP_STDLIB_H_PROTO
  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
#endif
# 171 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#ifdef _GLIBCXX_USE_LONG_LONG
  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
#endif
# 176 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#if defined(__GLIBCXX_TYPE_INT_N_0)
  inline __GLIBCXX_TYPE_INT_N_0
  abs(__GLIBCXX_TYPE_INT_N_0 __x) { return __x >= 0 ? __x : -__x; }
#endif
# 181 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#if defined(__GLIBCXX_TYPE_INT_N_1)
  inline __GLIBCXX_TYPE_INT_N_1
  abs(__GLIBCXX_TYPE_INT_N_1 __x) { return __x >= 0 ? __x : -__x; }
#endif
# 185 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#if defined(__GLIBCXX_TYPE_INT_N_2)
  inline __GLIBCXX_TYPE_INT_N_2
  abs(__GLIBCXX_TYPE_INT_N_2 __x) { return __x >= 0 ? __x : -__x; }
#endif
# 189 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#if defined(__GLIBCXX_TYPE_INT_N_3)
  inline __GLIBCXX_TYPE_INT_N_3
  abs(__GLIBCXX_TYPE_INT_N_3 __x) { return __x >= 0 ? __x : -__x; }
#endif
# 193 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3


_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#if _GLIBCXX_USE_C99

#undef _Exit
#undef llabs
#undef lldiv
#undef atoll
#undef strtoll
#undef strtoull
#undef strtof
#undef strtold

namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  using ::lldiv_t;
#endif
# 216 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#if _GLIBCXX_USE_C99_CHECK || _GLIBCXX_USE_C99_DYNAMIC
  extern "C" void (_Exit)(int) throw () _GLIBCXX_NORETURN;
#endif
# 219 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#if !_GLIBCXX_USE_C99_DYNAMIC
  using ::_Exit;
#endif
# 222 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
#endif
# 232 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#if _GLIBCXX_USE_C99_LONG_LONG_CHECK || _GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  extern "C" long long int (atoll)(const char *) throw ();
  extern "C" long long int
    (strtoll)(const char * __restrict, char ** __restrict, int) throw ();
  extern "C" unsigned long long int
    (strtoull)(const char * __restrict, char ** __restrict, int) throw ();
#endif
# 240 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
#endif
# 245 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
  using ::strtof;
  using ::strtold;

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace __gnu_cxx

namespace std
{
#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  using ::__gnu_cxx::lldiv_t;
#endif
# 256 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
  using ::__gnu_cxx::_Exit;
#if !_GLIBCXX_USE_C99_LONG_LONG_DYNAMIC
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
#endif
# 262 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
} // namespace std

#endif // _GLIBCXX_USE_C99
# 270 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#endif // !_GLIBCXX_HOSTED
# 272 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3

#endif
# 274 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/cstdlib" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/algorithmfwd.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 1 3
// <algorithm> Forward declarations  -*- C++ -*-

// Copyright (C) 2007-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file bits/algorithmfwd.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */

#ifndef _GLIBCXX_ALGORITHMFWD_H
#define _GLIBCXX_ALGORITHMFWD_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 34 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/c++config.h>
#endif /* expanded by -frewrite-includes */
# 35 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_pair.h>
#endif /* expanded by -frewrite-includes */
# 36 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_types.h>
#endif /* expanded by -frewrite-includes */
# 37 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
# 38 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 39 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
# 40 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
#endif
# 41 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /*
    adjacent_find
    all_of (C++0x)
    any_of (C++0x)
    binary_search
    copy
    copy_backward
    copy_if (C++0x)
    copy_n (C++0x)
    count
    count_if
    equal
    equal_range
    fill
    fill_n
    find
    find_end
    find_first_of
    find_if
    find_if_not (C++0x)
    for_each
    generate
    generate_n
    includes
    inplace_merge
    is_heap (C++0x)
    is_heap_until (C++0x)
    is_partitioned (C++0x)
    is_sorted (C++0x)
    is_sorted_until (C++0x)
    iter_swap
    lexicographical_compare
    lower_bound
    make_heap
    max
    max_element
    merge
    min
    min_element
    minmax (C++0x)
    minmax_element (C++0x)
    mismatch
    next_permutation
    none_of (C++0x)
    nth_element
    partial_sort
    partial_sort_copy
    partition
    partition_copy (C++0x)
    partition_point (C++0x)
    pop_heap
    prev_permutation
    push_heap
    random_shuffle
    remove
    remove_copy
    remove_copy_if
    remove_if
    replace
    replace_copy
    replace_copy_if
    replace_if
    reverse
    reverse_copy
    rotate
    rotate_copy
    search
    search_n
    set_difference
    set_intersection
    set_symmetric_difference
    set_union
    shuffle (C++0x)
    sort
    sort_heap
    stable_partition
    stable_sort
    swap
    swap_ranges
    transform
    unique
    unique_copy
    upper_bound
  */

  /**
   * @defgroup algorithms Algorithms
   *
   * Components for performing algorithmic operations. Includes
   * non-modifying sequence, modifying (mutating) sequence, sorting,
   * searching, merge, partition, heap, set, minima, maxima, and
   * permutation operations.
   */

  /**
   * @defgroup mutating_algorithms Mutating
   * @ingroup algorithms
   */

  /**
   * @defgroup non_mutating_algorithms Non-Mutating
   * @ingroup algorithms
   */

  /**
   * @defgroup sorting_algorithms Sorting
   * @ingroup algorithms
   */

  /**
   * @defgroup set_algorithms Set Operation
   * @ingroup sorting_algorithms
   *
   * These algorithms are common set operations performed on sequences
   * that are already sorted. The number of comparisons will be
   * linear.
   */

  /**
   * @defgroup binary_search_algorithms Binary Search
   * @ingroup sorting_algorithms
   *
   * These algorithms are variations of a classic binary search, and
   * all assume that the sequence being searched is already sorted.
   * 
   * The number of comparisons will be logarithmic (and as few as
   * possible).  The number of steps through the sequence will be
   * logarithmic for random-access iterators (e.g., pointers), and
   * linear otherwise.
   * 
   * The LWG has passed Defect Report 270, which notes: <em>The
   * proposed resolution reinterprets binary search. Instead of
   * thinking about searching for a value in a sorted range, we view
   * that as an important special case of a more general algorithm:
   * searching for the partition point in a partitioned range.  We
   * also add a guarantee that the old wording did not: we ensure that
   * the upper bound is no earlier than the lower bound, that the pair
   * returned by equal_range is a valid range, and that the first part
   * of that pair is the lower bound.</em>
   *
   * The actual effect of the first sentence is that a comparison
   * functor passed by the user doesn't necessarily need to induce a
   * strict weak ordering relation.  Rather, it partitions the range.
   */

  // adjacent_find

#if __cplusplus >= 201103L
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);
#endif
# 202 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  template<typename _FIter, typename _Tp>
    bool 
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool 
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter 
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);

#if __cplusplus >= 201103L
  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);
#endif
# 228 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  // count
  // count_if

  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void 
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);

  // find

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  // find_first_of
  // find_if

#if __cplusplus >= 201103L
  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);
#endif
# 266 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  // for_each
  // generate
  // generate_n

  template<typename _IIter1, typename _IIter2>
    bool 
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool 
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void 
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void 
    inplace_merge(_BIter, _BIter, _BIter, _Compare);

#if __cplusplus >= 201103L
  template<typename _RAIter>
    bool 
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool 
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter 
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter 
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
	   typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool 
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool 
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter 
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter 
    is_sorted_until(_FIter, _FIter, _Compare);
#endif
# 333 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  template<typename _FIter1, typename _FIter2>
    void 
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter 
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter 
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void 
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp> 
    _GLIBCXX14_CONSTEXPR
    const _Tp& 
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    const _Tp& 
    max(const _Tp&, const _Tp&, _Compare);

  // max_element
  // merge

  template<typename _Tp> 
    _GLIBCXX14_CONSTEXPR
    const _Tp& 
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    const _Tp& 
    min(const _Tp&, const _Tp&, _Compare);

  // min_element

#if __cplusplus >= 201103L
  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    pair<const _Tp&, const _Tp&> 
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    _GLIBCXX14_CONSTEXPR
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);
#endif
# 430 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  // mismatch

  template<typename _BIter>
    bool 
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool 
    next_permutation(_BIter, _BIter, _Compare);

#if __cplusplus >= 201103L
  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);
#endif
# 446 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  // nth_element
  // partial_sort

  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);

  // partition

#if __cplusplus >= 201103L
  template<typename _IIter, typename _OIter1,
	   typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);
#endif
# 470 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  template<typename _RAIter>
    void 
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool 
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool 
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void 
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    push_heap(_RAIter, _RAIter, _Compare);

  // random_shuffle

  template<typename _FIter, typename _Tp>
    _FIter 
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter 
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter 
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter 
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);

  // replace

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter 
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter 
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);

  // replace_if

  template<typename _BIter>
    void 
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter 
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter 
    rotate_copy(_FIter, _FIter, _FIter, _OIter);

  // search
  // search_n
  // set_difference
  // set_intersection
  // set_symmetric_difference
  // set_union

#if (__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);
#endif
# 556 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  template<typename _RAIter>
    void 
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter 
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp> 
    void 
    swap(_Tp&, _Tp&)
#if __cplusplus >= 201103L
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
	            is_nothrow_move_assignable<_Tp>>::value)
#endif
# 576 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
    ;

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
#if __cplusplus >= 201103L
    noexcept(noexcept(swap(*__a, *__b)))
#endif
# 584 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
    ;

  template<typename _FIter1, typename _FIter2>
    _FIter2 
    swap_ranges(_FIter1, _FIter1, _FIter2);

  // transform

  template<typename _FIter>
    _FIter 
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter 
    unique(_FIter, _FIter, _BinaryPredicate);

  // unique_copy

  template<typename _FIter, typename _Tp>
    _FIter 
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter 
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);

_GLIBCXX_END_NAMESPACE_VERSION

_GLIBCXX_BEGIN_NAMESPACE_ALGO

  template<typename _FIter>
    _FIter 
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter 
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool 
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool 
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter 
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct 
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void 
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool 
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool 
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _GLIBCXX14_CONSTEXPR
    _FIter 
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    _FIter 
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter 
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter, 
	   typename _Compare>
    _OIter 
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _GLIBCXX14_CONSTEXPR
    _FIter 
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    _FIter 
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void 
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void 
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter 
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void 
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void 
    random_shuffle(_RAIter, _RAIter,
#if __cplusplus >= 201103L
		   _Generator&&);
#else
# 741 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
		   _Generator&);
#endif
# 743 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

  template<typename _FIter, typename _Tp>
    void 
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void 
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1 
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1 
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter 
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp, 
	   typename _BinaryPredicate>
    _FIter 
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter 
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter, 
	   typename _Compare>
    _OIter 
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter 
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
	   typename _Compare>
    _OIter 
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter, 
	   typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, 
			     _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter 
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
	   typename _Compare>
    _OIter 
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void 
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void 
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void 
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter 
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter, 
	   typename _BinaryOperation>
    _OIter 
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter 
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter 
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

_GLIBCXX_END_NAMESPACE_ALGO
} // namespace std

#ifdef _GLIBCXX_PARALLEL
#if 0 /* expanded by -frewrite-includes */
# include <parallel/algorithmfwd.h>
#endif /* expanded by -frewrite-includes */
# 843 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
# 844 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3
#endif
# 845 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

#endif
# 847 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/algorithmfwd.h" 3

# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_heap.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 1 3
// Heap implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_heap.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{queue}
 */

#ifndef _STL_HEAP_H
#define _STL_HEAP_H 1

#if 0 /* expanded by -frewrite-includes */
#include <debug/debug.h>
#endif /* expanded by -frewrite-includes */
# 58 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/move.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/predefined_ops.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   * @defgroup heap_algorithms Heap
   * @ingroup sorting_algorithms
   */

  template<typename _RandomAccessIterator, typename _Distance,
	   typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
		    _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
	{
	  if (__comp(__first + __parent, __first + __child))
	    return __child;
	  if ((__child & 1) == 0)
	    ++__parent;
	}
      return __n;
    }

  // __is_heap, a predicate testing whether or not a range is a heap.
  // This function is an extension, not part of the C++ standard.
  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
			__gnu_cxx::__ops::__iter_less_iter()) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
	   typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
	__gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }

  // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap,
  // + is_heap and is_heap_until in C++0x.

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
	   typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
		_Distance __holeIndex, _Distance __topIndex, _Tp __value,
		_Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
	{
	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));
	  __holeIndex = __parent;
	  __parent = (__holeIndex - 1) / 2;
	}
      *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);
    }

  /**
   *  @brief  Push an element onto a heap.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap + element.
   *  @ingroup heap_algorithms
   *
   *  This operation pushes the element at last-1 onto the valid heap
   *  over the range [__first,__last-1).  After completion,
   *  [__first,__last) is a valid heap.
  */
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	  _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	  _DistanceType;

      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_heap(__first, __last - 1);

      _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
		       _DistanceType(0), _GLIBCXX_MOVE(__value),
		       __gnu_cxx::__ops::__iter_less_val());
    }

  /**
   *  @brief  Push an element onto a heap using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap + element.
   *  @param  __comp   Comparison functor.
   *  @ingroup heap_algorithms
   *
   *  This operation pushes the element at __last-1 onto the valid
   *  heap over the range [__first,__last-1).  After completion,
   *  [__first,__last) is a valid heap.  Compare operations are
   *  performed using comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	  _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	  _DistanceType;

      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_heap_pred(__first, __last - 1, __comp);

      _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
		       _DistanceType(0), _GLIBCXX_MOVE(__value),
		       __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Distance,
	   typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
		  _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
	{
	  __secondChild = 2 * (__secondChild + 1);
	  if (__comp(__first + __secondChild,
		     __first + (__secondChild - 1)))
	    __secondChild--;
	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));
	  __holeIndex = __secondChild;
	}
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
	{
	  __secondChild = 2 * (__secondChild + 1);
	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first
						     + (__secondChild - 1)));
	  __holeIndex = __secondChild - 1;
	}
      std::__push_heap(__first, __holeIndex, __topIndex, 
		       _GLIBCXX_MOVE(__value),
		       __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
	       _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      _ValueType __value = _GLIBCXX_MOVE(*__result);
      *__result = _GLIBCXX_MOVE(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
			 _DistanceType(__last - __first),
			 _GLIBCXX_MOVE(__value), __comp);
    }

  /**
   *  @brief  Pop an element off a heap.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @pre    [__first, __last) is a valid, non-empty range.
   *  @ingroup heap_algorithms
   *
   *  This operation pops the top of the heap.  The elements __first
   *  and __last-1 are swapped and [__first,__last-1) is made into a
   *  heap.
  */
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
      __glibcxx_requires_non_empty_range(__first, __last);
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_heap(__first, __last);

      if (__last - __first > 1)
	{
	  --__last;
	  std::__pop_heap(__first, __last, __last,
			  __gnu_cxx::__ops::__iter_less_iter());
	}
    }

  /**
   *  @brief  Pop an element off a heap using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @param  __comp   Comparison functor to use.
   *  @ingroup heap_algorithms
   *
   *  This operation pops the top of the heap.  The elements __first
   *  and __last-1 are swapped and [__first,__last-1) is made into a
   *  heap.  Comparisons are made using comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
	     _RandomAccessIterator __last, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_non_empty_range(__first, __last);
      __glibcxx_requires_heap_pred(__first, __last, __comp);

      if (__last - __first > 1)
	{
	  --__last;
	  std::__pop_heap(__first, __last, __last,
			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
	}
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
		_Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	  _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	  _DistanceType;

      if (__last - __first < 2)
	return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
	{
	  _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));
	  std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value),
			     __comp);
	  if (__parent == 0)
	    return;
	  __parent--;
	}
    }
  
  /**
   *  @brief  Construct a heap over a range.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @ingroup heap_algorithms
   *
   *  This operation makes the elements in [__first,__last) into a heap.
  */
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__make_heap(__first, __last,
		       __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Construct a heap over a range using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @param  __comp   Comparison functor to use.
   *  @ingroup heap_algorithms
   *
   *  This operation makes the elements in [__first,__last) into a heap.
   *  Comparisons are made using __comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__make_heap(__first, __last,
		       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
		_Compare __comp)
    {
      while (__last - __first > 1)
	{
	  --__last;
	  std::__pop_heap(__first, __last, __last, __comp);
	}
    }

  /**
   *  @brief  Sort a heap.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @ingroup heap_algorithms
   *
   *  This operation sorts the valid heap in the range [__first,__last).
  */
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_heap(__first, __last);

      std::__sort_heap(__first, __last,
		       __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Sort a heap using comparison functor.
   *  @param  __first  Start of heap.
   *  @param  __last   End of heap.
   *  @param  __comp   Comparison functor to use.
   *  @ingroup heap_algorithms
   *
   *  This operation sorts the valid heap in the range [__first,__last).
   *  Comparisons are made using __comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_heap_pred(__first, __last, __comp);

      std::__sort_heap(__first, __last,
		       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

#if __cplusplus >= 201103L
  /**
   *  @brief  Search the end of a heap.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  An iterator pointing to the first element not in the heap.
   *  @ingroup heap_algorithms
   *
   *  This operation returns the last iterator i in [__first, __last) for which
   *  the range [__first, i) is a heap.
  */
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return __first + 
	std::__is_heap_until(__first, std::distance(__first, __last),
			     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Search the end of a heap using comparison functor.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor to use.
   *  @return  An iterator pointing to the first element not in the heap.
   *  @ingroup heap_algorithms
   *
   *  This operation returns the last iterator i in [__first, __last) for which
   *  the range [__first, i) is a heap.  Comparisons are made using __comp.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
		  _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      return __first
	+ std::__is_heap_until(__first, std::distance(__first, __last),
			       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief  Determines whether a range is a heap.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  True if range is a heap, false otherwise.
   *  @ingroup heap_algorithms
  */
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }

  /**
   *  @brief  Determines whether a range is a heap using comparison functor.
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor to use.
   *  @return  True if range is a heap, false otherwise.
   *  @ingroup heap_algorithms
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
	    _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }
#endif
# 528 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _STL_HEAP_H */
# 533 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_heap.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_tempbuf.h>  // for _Temporary_buffer
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tempbuf.h" 1 3
// Temporary buffer implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_tempbuf.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */

#ifndef _STL_TEMPBUF_H
#define _STL_TEMPBUF_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tempbuf.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tempbuf.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_construct.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tempbuf.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tempbuf.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief Allocates a temporary buffer.
   *  @param  __len  The number of objects of type Tp.
   *  @return See full description.
   *
   *  Reinventing the wheel, but this time with prettier spokes!
   *
   *  This function tries to obtain storage for @c __len adjacent Tp
   *  objects.  The objects themselves are not constructed, of course.
   *  A pair<> is returned containing <em>the buffer s address and
   *  capacity (in the units of sizeof(_Tp)), or a pair of 0 values if
   *  no storage can be obtained.</em>  Note that the capacity obtained
   *  may be less than that requested if the memory is unavailable;
   *  you should compare len with the .second return value.
   *
   * Provides the nothrow exception guarantee.
   */
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) _GLIBCXX_NOEXCEPT
    {
      const ptrdiff_t __max =
	__gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
	__len = __max;
      
      while (__len > 0) 
	{
	  _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp), 
							std::nothrow));
	  if (__tmp != 0)
	    return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
	  __len /= 2;
	}
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }

  /**
   *  @brief The companion to get_temporary_buffer().
   *  @param  __p  A buffer previously allocated by get_temporary_buffer.
   *  @return   None.
   *
   *  Frees the memory pointed to by __p.
   */
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }


  /**
   *  This class is used in two places: stl_algo.h and ext/memory,
   *  where it is wrapped as the temporary_buffer class.  See
   *  temporary_buffer docs for more notes.
   */
  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {
      // concept requirements
      __glibcxx_class_requires(_ForwardIterator, _ForwardIteratorConcept)

    public:
      typedef _Tp         value_type;
      typedef value_type* pointer;
      typedef pointer     iterator;
      typedef ptrdiff_t   size_type;

    protected:
      size_type  _M_original_len;
      size_type  _M_len;
      pointer    _M_buffer;

    public:
      /// As per Table mumble.
      size_type
      size() const
      { return _M_len; }

      /// Returns the size requested by the constructor; may be >size().
      size_type
      requested_size() const
      { return _M_original_len; }

      /// As per Table mumble.
      iterator
      begin()
      { return _M_buffer; }

      /// As per Table mumble.
      iterator
      end()
      { return _M_buffer + _M_len; }

      /**
       * Constructs a temporary buffer of a size somewhere between
       * zero and the size of the given range.
       */
      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
	std::_Destroy(_M_buffer, _M_buffer + _M_len);
	std::return_temporary_buffer(_M_buffer);
      }

    private:
      // Disable copy constructor and assignment operator.
      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
	      _ForwardIterator __seed)
        {
	  if(__first == __last)
	    return;

	  _Pointer __cur = __first;
	  __try
	    {
	      std::_Construct(std::__addressof(*__first),
			      _GLIBCXX_MOVE(*__seed));
	      _Pointer __prev = __cur;
	      ++__cur;
	      for(; __cur != __last; ++__cur, ++__prev)
		std::_Construct(std::__addressof(*__cur),
				_GLIBCXX_MOVE(*__prev));
	      *__seed = _GLIBCXX_MOVE(*__prev);
	    }
	  __catch(...)
	    {
	      std::_Destroy(__first, __cur);
	      __throw_exception_again;
	    }
	}
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };

  // Constructs objects in the range [first, last).
  // Note that while these new objects will take valid values,
  // their exact value is not defined. In particular they may
  // be 'moved from'.
  //
  // While *__seed may be altered during this algorithm, it will have
  // the same value when the algorithm finishes, unless one of the
  // constructions throws.
  //
  // Requirements: _Pointer::value_type(_Tp&&) is valid.
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
				  _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
	_ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
	  __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      __try
	{
	  std::pair<pointer, size_type> __p(std::get_temporary_buffer<
					    value_type>(_M_original_len));
	  _M_buffer = __p.first;
	  _M_len = __p.second;
	  if (_M_buffer)
	    std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
					       __first);
	}
      __catch(...)
	{
	  std::return_temporary_buffer(_M_buffer);
	  _M_buffer = 0;
	  _M_len = 0;
	  __throw_exception_again;
	}
    }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _STL_TEMPBUF_H */
# 271 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tempbuf.h" 3

# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/predefined_ops.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3

#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <random>     // for std::uniform_int_distribution
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
#endif
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3

// See concept_check.h for the __glibcxx_*_requires macros.

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
			   _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
	{
	  if (__comp(__b, __c))
	    std::iter_swap(__result, __b);
	  else if (__comp(__a, __c))
	    std::iter_swap(__result, __c);
	  else
	    std::iter_swap(__result, __a);
	}
      else if (__comp(__a, __c))
	std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
	std::iter_swap(__result, __c);
      else
	std::iter_swap(__result, __b);
    }

  /// This is an overload used by find algos for the Input Iterator case.
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
	      _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
	++__first;
      return __first;
    }

  /// This is an overload used by find algos for the RAI case.
  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
	__trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
	{
	  if (__pred(__first))
	    return __first;
	  ++__first;

	  if (__pred(__first))
	    return __first;
	  ++__first;

	  if (__pred(__first))
	    return __first;
	  ++__first;

	  if (__pred(__first))
	    return __first;
	  ++__first;
	}

      switch (__last - __first)
	{
	case 3:
	  if (__pred(__first))
	    return __first;
	  ++__first;
	case 2:
	  if (__pred(__first))
	    return __first;
	  ++__first;
	case 1:
	  if (__pred(__first))
	    return __first;
	  ++__first;
	case 0:
	default:
	  return __last;
	}
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
		       std::__iterator_category(__first));
    }

  /// Provided for stable_partition to use.
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
		  _Predicate __pred)
    {
      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__negate(__pred),
			    std::__iterator_category(__first));
    }

  /// Like find_if_not(), but uses and updates a count of the
  /// remaining range length instead of comparing against an end
  /// iterator.
  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
	if (!__pred(__first))
	  break;
      return __first;
    }

  // set_difference
  // set_intersection
  // set_symmetric_difference
  // set_union
  // for_each
  // find
  // find_if
  // find_first_of
  // adjacent_find
  // count
  // count_if
  // search

  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	     _BinaryPredicate  __predicate)
    {
      // Test for empty ranges
      if (__first1 == __last1 || __first2 == __last2)
	return __first1;

      // Test for a pattern of length 1.
      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
	return std::__find_if(__first1, __last1,
		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

      // General case.
      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
	{
	  __first1 =
	    std::__find_if(__first1, __last1,
		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

	  if (__first1 == __last1)
	    return __last1;

	  __p = __p1;
	  __current = __first1;
	  if (++__current == __last1)
	    return __last1;

	  while (__predicate(__current, __p))
	    {
	      if (++__p == __last2)
		return __first1;
	      if (++__current == __last1)
		return __last1;
	    }
	  ++__first1;
	}
      return __first1;
    }

  // search_n

  /**
   *  This is an helper function for search_n overloaded for forward iterators.
  */
  template<typename _ForwardIterator, typename _Integer,
	   typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
		   _Integer __count, _UnaryPredicate __unary_pred,
		   std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
	{
	  typename iterator_traits<_ForwardIterator>::difference_type
	    __n = __count;
	  _ForwardIterator __i = __first;
	  ++__i;
	  while (__i != __last && __n != 1 && __unary_pred(__i))
	    {
	      ++__i;
	      --__n;
	    }
	  if (__n == 1)
	    return __first;
	  if (__i == __last)
	    return __last;
	  __first = std::__find_if(++__i, __last, __unary_pred);
	}
      return __last;
    }

  /**
   *  This is an helper function for search_n overloaded for random access
   *  iterators.
  */
  template<typename _RandomAccessIter, typename _Integer,
	   typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
		   _Integer __count, _UnaryPredicate __unary_pred,
		   std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
	_DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize) // the main loop...
	{
	  __first += __remainder;
	  __tailSize -= __remainder;
	  // __first here is always pointing to one past the last element of
	  // next possible match.
	  _RandomAccessIter __backTrack = __first; 
	  while (__unary_pred(--__backTrack))
	    {
	      if (--__remainder == 0)
	        return (__first - __count); // Success
	    }
	  __remainder = __count + 1 - (__first - __backTrack);
	}
      return __last; // Failure
    }

  template<typename _ForwardIterator, typename _Integer,
           typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
	       _Integer __count,
	       _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
	return __first;

      if (__count == 1)
	return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
				 std::__iterator_category(__first));
    }

  // find_end for forward iterators.
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	       forward_iterator_tag, forward_iterator_tag,
	       _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
	return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
	{
	  _ForwardIterator1 __new_result
	    = std::__search(__first1, __last1, __first2, __last2, __comp);
	  if (__new_result == __last1)
	    return __result;
	  else
	    {
	      __result = __new_result;
	      __first1 = __new_result;
	      ++__first1;
	    }
	}
    }

  // find_end for bidirectional iterators (much faster).
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
	   typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
	       _BidirectionalIterator1 __last1,
	       _BidirectionalIterator2 __first2,
	       _BidirectionalIterator2 __last2,
	       bidirectional_iterator_tag, bidirectional_iterator_tag,
	       _BinaryPredicate __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator1>)
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator2>)

      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
					      _RevIterator2(__last2), __rlast2,
					      __comp);

      if (__rresult == __rlast1)
	return __last1;
      else
	{
	  _BidirectionalIterator1 __result = __rresult.base();
	  std::advance(__result, -std::distance(__first2, __last2));
	  return __result;
	}
    }

  /**
   *  @brief  Find last matching subsequence in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @return   The last iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
   *  @p *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the __first
   *  element of the sub-sequence, or @p __last1 if the sub-sequence
   *  is not found.  The sub-sequence will be the last such
   *  subsequence contained in [__first1,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__find_end(__first1, __last1, __first2, __last2,
			     std::__iterator_category(__first1),
			     std::__iterator_category(__first2),
			     __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief  Find last matching subsequence in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @param  __comp    The predicate to use.
   *  @return The last iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c
   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
   *  exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) using comp as a predicate and returns an
   *  iterator to the first element of the sub-sequence, or @p __last1
   *  if the sub-sequence is not found.  The sub-sequence will be the
   *  last such subsequence contained in [__first,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	     _BinaryPredicate __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__find_end(__first1, __last1, __first2, __last2,
			     std::__iterator_category(__first1),
			     std::__iterator_category(__first2),
			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

#if __cplusplus >= 201103L
  /**
   *  @brief  Checks that a predicate is true for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is true for each element in the range
   *  @p [__first,__last), and false otherwise.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }

  /**
   *  @brief  Checks that a predicate is false for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is false for each element in the range
   *  @p [__first,__last), and false otherwise.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }

  /**
   *  @brief  Checks that a predicate is false for at least an element
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if an element exists in the range @p
   *  [__first,__last) such that @p __pred is true, and false
   *  otherwise.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }

  /**
   *  @brief  Find the first element in a sequence for which a
   *          predicate is false.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
		_Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	      typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);
      return std::__find_if_not(__first, __last,
				__gnu_cxx::__ops::__pred_iter(__pred));
    }

  /**
   *  @brief  Checks whether the sequence is partitioned.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
   *  i.e. if all elements that satisfy @p __pred appear before those that
   *  do not.
  */
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
		   _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }

  /**
   *  @brief  Find the partition point of a partitioned range.
   *  @ingroup mutating_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __pred    A predicate.
   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
   *           and @p none_of(mid, __last, __pred) are both true.
  */
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
		    _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	      typename iterator_traits<_ForwardIterator>::value_type>)

      // A specific debug-mode test will be necessary...
      __glibcxx_requires_valid_range(__first, __last);

      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
	{
	  __half = __len >> 1;
	  __middle = __first;
	  std::advance(__middle, __half);
	  if (__pred(*__middle))
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
	    }
	  else
	    __len = __half;
	}
      return __first;
    }
#endif
# 635 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3

  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
		     _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
	if (!__pred(__first))
	  {
	    *__result = *__first;
	    ++__result;
	  }
      return __result;
    }

  /**
   *  @brief Copy a sequence, removing elements of a given value.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __value   The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) not equal
   *  to @p __value to the range beginning at @p __result.
   *  remove_copy() is stable, so the relative order of elements that
   *  are copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
		_OutputIterator __result, const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_copy_if(__first, __last, __result,
	__gnu_cxx::__ops::__iter_equals_val(__value));
    }

  /**
   *  @brief Copy a sequence, removing elements for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns false to the range beginning at @p __result.
   *
   *  remove_copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
		   _OutputIterator __result, _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_copy_if(__first, __last, __result,
				   __gnu_cxx::__ops::__pred_iter(__pred));
    }

#if __cplusplus >= 201103L
  /**
   *  @brief Copy the elements of a sequence for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p __result.
   *
   *  copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
	    _OutputIterator __result, _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	if (__pred(*__first))
	  {
	    *__result = *__first;
	    ++__result;
	  }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
	     _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
	{
	  while (true)
	    {
	      *__result = *__first;
	      ++__result;
	      if (--__n > 0)
		++__first;
	      else
		break;
	    }
	}
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
	   typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
	     _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }

  /**
   *  @brief Copies the range [first,first+n) into [result,result+n).
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  result+n.
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
  */
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)

      return std::__copy_n(__first, __n, __result,
			   std::__iterator_category(__first));
    }

  /**
   *  @brief Copy the elements of a sequence to separate output sequences
   *         depending on the truth value of a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __out_true   An output iterator.
   *  @param  __out_false  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   A pair designating the ends of the resulting sequences.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p out_true
   *  and each element for which @p __pred returns false to @p __out_false.
  */
  template<typename _InputIterator, typename _OutputIterator1,
	   typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
		   _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);
      
      for (; __first != __last; ++__first)
	if (__pred(*__first))
	  {
	    *__out_true = *__first;
	    ++__out_true;
	  }
	else
	  {
	    *__out_false = *__first;
	    ++__out_false;
	  }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }
#endif
# 854 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
		_Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
        if (!__pred(__first))
          {
            *__result = _GLIBCXX_MOVE(*__first);
            ++__result;
          }
      return __result;
    }

  /**
   *  @brief Remove elements from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements equal to @p __value are removed from the range
   *  @p [__first,__last).
   *
   *  remove() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
	   const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_if(__first, __last,
		__gnu_cxx::__ops::__iter_equals_val(__value));
    }

  /**
   *  @brief Remove elements from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __pred   A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements for which @p __pred returns true are removed from the range
   *  @p [__first,__last).
   *
   *  remove_if() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
	      _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__remove_if(__first, __last,
			      __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
		    _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
	return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
	{
	  if (__binary_pred(__first, __next))
	    return __first;
	  __first = __next;
	}
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
	     _BinaryPredicate __binary_pred)
    {
      // Skip the beginning, if already unique.
      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
	return __last;

      // Do the real copy work.
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
	if (!__binary_pred(__dest, __first))
	  *++__dest = _GLIBCXX_MOVE(*__first);
      return ++__dest;
    }

  /**
   *  @brief Remove consecutive duplicate values from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values that compare equal.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_EqualityComparableConcept<
		     typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__unique(__first, __last,
			   __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Remove consecutive values from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values for which @p __binary_pred returns true.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
		typename iterator_traits<_ForwardIterator>::value_type,
		typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__unique(__first, __last,
			   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

  /**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for forward iterators and output iterator as result.
  */
  template<typename _ForwardIterator, typename _OutputIterator,
	   typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
		  _OutputIterator __result, _BinaryPredicate __binary_pred,
		  forward_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- iterators already checked
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	  typename iterator_traits<_ForwardIterator>::value_type,
	  typename iterator_traits<_ForwardIterator>::value_type>)

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
	if (!__binary_pred(__first, __next))
	  {
	    __first = __next;
	    *++__result = *__first;
	  }
      return ++__result;
    }

  /**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and output iterator as result.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
		  _OutputIterator __result, _BinaryPredicate __binary_pred,
		  input_iterator_tag, output_iterator_tag)
    {
      // concept requirements -- iterators already checked
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	  typename iterator_traits<_InputIterator>::value_type,
	  typename iterator_traits<_InputIterator>::value_type>)

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
	__rebound_pred
	= __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
	if (!__rebound_pred(__first, __value))
	  {
	    __value = *__first;
	    *++__result = __value;
	  }
      return ++__result;
    }

  /**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and forward iterator as result.
  */
  template<typename _InputIterator, typename _ForwardIterator,
	   typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
		  input_iterator_tag, forward_iterator_tag)
    {
      // concept requirements -- iterators already checked
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	  typename iterator_traits<_ForwardIterator>::value_type,
	  typename iterator_traits<_InputIterator>::value_type>)
      *__result = *__first;
      while (++__first != __last)
	if (!__binary_pred(__result, __first))
	  *++__result = *__first;
      return ++__result;
    }

  /**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for bidirectional iterators.
  */
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
	      bidirectional_iterator_tag)
    {
      while (true)
	if (__first == __last || __first == --__last)
	  return;
	else
	  {
	    std::iter_swap(__first, __last);
	    ++__first;
	  }
    }

  /**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for random access iterators.
  */
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
	      random_access_iterator_tag)
    {
      if (__first == __last)
	return;
      --__last;
      while (__first < __last)
	{
	  std::iter_swap(__first, __last);
	  ++__first;
	  --__last;
	}
    }

  /**
   *  @brief Reverse a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @return   reverse() returns no value.
   *
   *  Reverses the order of the elements in the range @p [__first,__last),
   *  so that the first element becomes the last etc.
   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
   *  swaps @p *(__first+i) and @p *(__last-(i+1))
  */
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }

  /**
   *  @brief Copy a sequence, reversing its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A bidirectional iterator.
   *  @param  __last    A bidirectional iterator.
   *  @param  __result  An output iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements in the range @p [__first,__last) to the
   *  range @p [__result,__result+(__last-__first)) such that the
   *  order of the elements is reversed.  For every @c i such that @p
   *  0<=i<=(__last-__first), @p reverse_copy() performs the
   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
   *  The ranges @p [__first,__last) and @p
   *  [__result,__result+(__last-__first)) must not overlap.
  */
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
		 _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
		typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      while (__first != __last)
	{
	  --__last;
	  *__result = *__last;
	  ++__result;
	}
      return __result;
    }

  /**
   *  This is a helper function for the rotate algorithm specialized on RAIs.
   *  It returns the greatest common divisor of two integer values.
  */
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
	{
	  _EuclideanRingElement __t = __m % __n;
	  __m = __n;
	  __n = __t;
	}
      return __m;
    }

  inline namespace _V2
  {

  /// This is a helper function for the rotate algorithm.
  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
	     _ForwardIterator __middle,
	     _ForwardIterator __last,
	     forward_iterator_tag)
    {
      if (__first == __middle)
	return __last;
      else if (__last  == __middle)
	return __first;

      _ForwardIterator __first2 = __middle;
      do
	{
	  std::iter_swap(__first, __first2);
	  ++__first;
	  ++__first2;
	  if (__first == __middle)
	    __middle = __first2;
	}
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
	{
	  std::iter_swap(__first, __first2);
	  ++__first;
	  ++__first2;
	  if (__first == __middle)
	    __middle = __first2;
	  else if (__first2 == __last)
	    __first2 = __middle;
	}
      return __ret;
    }

   /// This is a helper function for the rotate algorithm.
  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
	     _BidirectionalIterator __middle,
	     _BidirectionalIterator __last,
	      bidirectional_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)

      if (__first == __middle)
	return __last;
      else if (__last  == __middle)
	return __first;

      std::__reverse(__first,  __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last,   bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
	{
	  std::iter_swap(__first, --__last);
	  ++__first;
	}

      if (__first == __middle)
	{
	  std::__reverse(__middle, __last,   bidirectional_iterator_tag());
	  return __last;
	}
      else
	{
	  std::__reverse(__first,  __middle, bidirectional_iterator_tag());
	  return __first;
	}
    }

  /// This is a helper function for the rotate algorithm.
  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
	     _RandomAccessIterator __middle,
	     _RandomAccessIterator __last,
	     random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)

      if (__first == __middle)
	return __last;
      else if (__last  == __middle)
	return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_ValueType;

      _Distance __n = __last   - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
	{
	  std::swap_ranges(__first, __middle, __middle);
	  return __middle;
	}

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
	{
	  if (__k < __n - __k)
	    {
	      if (__is_pod(_ValueType) && __k == 1)
		{
		  _ValueType __t = _GLIBCXX_MOVE(*__p);
		  _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
		  *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
		  return __ret;
		}
	      _RandomAccessIterator __q = __p + __k;
	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
		{
		  std::iter_swap(__p, __q);
		  ++__p;
		  ++__q;
		}
	      __n %= __k;
	      if (__n == 0)
		return __ret;
	      std::swap(__n, __k);
	      __k = __n - __k;
	    }
	  else
	    {
	      __k = __n - __k;
	      if (__is_pod(_ValueType) && __k == 1)
		{
		  _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
		  _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
		  *__p = _GLIBCXX_MOVE(__t);
		  return __ret;
		}
	      _RandomAccessIterator __q = __p + __n;
	      __p = __q - __k;
	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
		{
		  --__p;
		  --__q;
		  std::iter_swap(__p, __q);
		}
	      __n %= __k;
	      if (__n == 0)
		return __ret;
	      std::swap(__n, __k);
	    }
	}
    }

   // _GLIBCXX_RESOLVE_LIB_DEFECTS
   // DR 488. rotate throws away useful information
  /**
   *  @brief Rotate the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  first + (last - middle).
   *
   *  Rotates the elements of the range @p [__first,__last) by 
   *  @p (__middle - __first) positions so that the element at @p __middle
   *  is moved to @p __first, the element at @p __middle+1 is moved to
   *  @p __first+1 and so on for each element in the range
   *  @p [__first,__last).
   *
   *  This effectively swaps the ranges @p [__first,__middle) and
   *  @p [__middle,__last).
   *
   *  Performs
   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
	   _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      return std::__rotate(__first, __middle, __last,
			   std::__iterator_category(__first));
    }

  } // namespace _V2

  /**
   *  @brief Copy a sequence, rotating its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements of the range @p [__first,__last) to the
   *  range beginning at @result, rotating the copied elements by 
   *  @p (__middle-__first) positions so that the element at @p __middle
   *  is moved to @p __result, the element at @p __middle+1 is moved
   *  to @p __result+1 and so on for each element in the range @p
   *  [__first,__last).
   *
   *  Performs 
   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
		typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }

  /// This is a helper function...
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
		_Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
	return __first;

      while (__pred(*__first))
	if (++__first == __last)
	  return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
	if (__pred(*__next))
	  {
	    std::iter_swap(__first, __next);
	    ++__first;
	  }

      return __first;
    }

  /// This is a helper function...
  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
		_Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
	{
	  while (true)
	    if (__first == __last)
	      return __first;
	    else if (__pred(*__first))
	      ++__first;
	    else
	      break;
	  --__last;
	  while (true)
	    if (__first == __last)
	      return __first;
	    else if (!bool(__pred(*__last)))
	      --__last;
	    else
	      break;
	  std::iter_swap(__first, __last);
	  ++__first;
	}
    }

  // partition

  /// This is a helper function...
  /// Requires __first != __last and !__pred(__first)
  /// and __len == distance(__first, __last).
  ///
  /// !__pred(__first) allows us to guarantee that we don't
  /// move-assign an element onto itself.
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
	   typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
				_ForwardIterator __last,
				_Predicate __pred, _Distance __len,
				_Pointer __buffer,
				_Distance __buffer_size)
    {
      if (__len == 1)
	return __first;

      if (__len <= __buffer_size)
	{
	  _ForwardIterator __result1 = __first;
	  _Pointer __result2 = __buffer;

	  // The precondition guarantees that !__pred(__first), so
	  // move that element to the buffer before starting the loop.
	  // This ensures that we only call __pred once per element.
	  *__result2 = _GLIBCXX_MOVE(*__first);
	  ++__result2;
	  ++__first;
	  for (; __first != __last; ++__first)
	    if (__pred(__first))
	      {
		*__result1 = _GLIBCXX_MOVE(*__first);
		++__result1;
	      }
	    else
	      {
		*__result2 = _GLIBCXX_MOVE(*__first);
		++__result2;
	      }

	  _GLIBCXX_MOVE3(__buffer, __result2, __result1);
	  return __result1;
	}

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
	std::__stable_partition_adaptive(__first, __middle, __pred,
					 __len / 2, __buffer,
					 __buffer_size);

      // Advance past true-predicate values to satisfy this
      // function's preconditions.
      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
	std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
	__right_split =
	  std::__stable_partition_adaptive(__right_split, __last, __pred,
					   __right_len,
					   __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
		       _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
	return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
	std::__stable_partition_adaptive(__first, __last, __pred,
					 _DistanceType(__buf.requested_size()),
					 __buf.begin(),
					 _DistanceType(__buf.size()));
    }

  /**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence, preserving relative ordering.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [first,middle) and false for each @p i
   *  in the range @p [middle,last).
   *
   *  Performs the same function as @p partition() with the additional
   *  guarantee that the relative ordering of elements in each group is
   *  preserved, so any two elements @p x and @p y in the range
   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
   *  relative ordering after calling @p stable_partition().
  */
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
		     _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__stable_partition(__first, __last,
				     __gnu_cxx::__ops::__pred_iter(__pred));
    }

  /// This is a helper function for the sort routines.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
		  _RandomAccessIterator __middle,
		  _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
	if (__comp(__i, __first))
	  std::__pop_heap(__first, __middle, __i, __comp);
    }

  // partial_sort

  template<typename _InputIterator, typename _RandomAccessIterator,
	   typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
			_RandomAccessIterator __result_first,
			_RandomAccessIterator __result_last,
			_Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
	_InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
	return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
	{
	  *__result_real_last = *__first;
	  ++__result_real_last;
	  ++__first;
	}
      
      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
	{
	  if (__comp(__first, __result_first))
	    std::__adjust_heap(__result_first, _DistanceType(0),
			       _DistanceType(__result_real_last
					     - __result_first),
			       _InputValueType(*__first), __comp);
	  ++__first;
	}
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }

  /**
   *  @brief Copy the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p __result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  *j<*i is false.
   *  The value returned is @p __result_first+N.
  */
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
		      _RandomAccessIterator __result_first,
		      _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
	_InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
				  _OutputValueType>)
      __glibcxx_function_requires(_LessThanOpConcept<_InputValueType,
				                     _OutputValueType>)
      __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_valid_range(__result_first, __result_last);

      return std::__partial_sort_copy(__first, __last,
				      __result_first, __result_last,
				      __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Copy the smallest elements of a sequence using a predicate for
   *         comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    Another input iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @param  __comp    A comparison functor.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  @p __comp(*j,*i) is false.
   *  The value returned is @p __result_first+N.
  */
  template<typename _InputIterator, typename _RandomAccessIterator,
	   typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
		      _RandomAccessIterator __result_first,
		      _RandomAccessIterator __result_last,
		      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
	_InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
				  _OutputValueType>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _InputValueType, _OutputValueType>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _OutputValueType, _OutputValueType>)
      __glibcxx_requires_valid_range(__first, __last);
      __glibcxx_requires_valid_range(__result_first, __result_last);

      return std::__partial_sort_copy(__first, __last,
				      __result_first, __result_last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
			      _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
	__val = _GLIBCXX_MOVE(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
	{
	  *__last = _GLIBCXX_MOVE(*__next);
	  __last = __next;
	  --__next;
	}
      *__last = _GLIBCXX_MOVE(__val);
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
		     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	{
	  if (__comp(__i, __first))
	    {
	      typename iterator_traits<_RandomAccessIterator>::value_type
		__val = _GLIBCXX_MOVE(*__i);
	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
	      *__first = _GLIBCXX_MOVE(__val);
	    }
	  else
	    std::__unguarded_linear_insert(__i,
				__gnu_cxx::__ops::__val_comp_iter(__comp));
	}
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
			       _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
	std::__unguarded_linear_insert(__i,
				__gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  /**
   *  @doctodo
   *  This controls some aspect of the sort routines.
  */
  enum { _S_threshold = 16 };

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
			   _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
	{
	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
					  __comp);
	}
      else
	std::__insertion_sort(__first, __last, __comp);
    }

  /// This is a helper function...
  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
			  _RandomAccessIterator __last,
			  _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
	{
	  while (__comp(__first, __pivot))
	    ++__first;
	  --__last;
	  while (__comp(__pivot, __last))
	    --__last;
	  if (!(__first < __last))
	    return __first;
	  std::iter_swap(__first, __last);
	  ++__first;
	}
    }

  /// This is a helper function...
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
				_RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
				  __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
		   _RandomAccessIterator __middle,
		   _RandomAccessIterator __last,
		   _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }

  /// This is a helper function for the sort routine.
  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
		     _RandomAccessIterator __last,
		     _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
	{
	  if (__depth_limit == 0)
	    {
	      std::__partial_sort(__first, __last, __last, __comp);
	      return;
	    }
	  --__depth_limit;
	  _RandomAccessIterator __cut =
	    std::__unguarded_partition_pivot(__first, __last, __comp);
	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
	  __last = __cut;
	}
    }

  // sort

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
	   _Compare __comp)
    {
      if (__first != __last)
	{
	  std::__introsort_loop(__first, __last,
				std::__lg(__last - __first) * 2,
				__comp);
	  std::__final_insertion_sort(__first, __last, __comp);
	}
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
		  _RandomAccessIterator __last, _Size __depth_limit,
		  _Compare __comp)
    {
      while (__last - __first > 3)
	{
	  if (__depth_limit == 0)
	    {
	      std::__heap_select(__first, __nth + 1, __last, __comp);
	      // Place the nth largest element in its final position.
	      std::iter_swap(__first, __nth);
	      return;
	    }
	  --__depth_limit;
	  _RandomAccessIterator __cut =
	    std::__unguarded_partition_pivot(__first, __last, __comp);
	  if (__cut <= __nth)
	    __first = __cut;
	  else
	    __last = __cut;
	}
      std::__insertion_sort(__first, __last, __comp);
    }

  // nth_element

  // lower_bound moved to stl_algobase.h

  /**
   *  @brief Finds the first position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return An iterator pointing to the first element <em>not less
   *           than</em> @p __val, or end() if every element is less
   *           than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _ValueType, _Tp>)
      __glibcxx_requires_partitioned_lower_pred(__first, __last,
						__val, __comp);

      return std::__lower_bound(__first, __last, __val,
				__gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
		  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
	{
	  _DistanceType __half = __len >> 1;
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp(__val, __middle))
	    __len = __half;
	  else
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
	    }
	}
      return __first;
    }

  /**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
  */
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
      __glibcxx_requires_partitioned_upper(__first, __last, __val);

      return std::__upper_bound(__first, __last, __val,
				__gnu_cxx::__ops::__val_less_iter());
    }

  /**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _Tp, _ValueType>)
      __glibcxx_requires_partitioned_upper_pred(__first, __last,
						__val, __comp);

      return std::__upper_bound(__first, __last, __val,
				__gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
	   typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
		  const _Tp& __val,
		  _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
	_DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
	{
	  _DistanceType __half = __len >> 1;
	  _ForwardIterator __middle = __first;
	  std::advance(__middle, __half);
	  if (__comp_it_val(__middle, __val))
	    {
	      __first = __middle;
	      ++__first;
	      __len = __len - __half - 1;
	    }
	  else if (__comp_val_it(__val, __middle))
	    __len = __half;
	  else
	    {
	      _ForwardIterator __left
		= std::__lower_bound(__first, __middle, __val, __comp_it_val);
	      std::advance(__first, __len);
	      _ForwardIterator __right
		= std::__upper_bound(++__middle, __first, __val, __comp_val_it);
	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
	    }
	}
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }

  /**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val),
   *                   upper_bound(__first, __last, __val))
   *  @endcode
   *  but does not actually call those functions.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);
      __glibcxx_requires_partitioned_upper(__first, __last, __val);      

      return std::__equal_range(__first, __last, __val,
				__gnu_cxx::__ops::__iter_less_val(),
				__gnu_cxx::__ops::__val_less_iter());
    }

  /**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
   *                   upper_bound(__first, __last, __val, __comp))
   *  @endcode
   *  but does not actually call those functions.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
		const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _ValueType, _Tp>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower_pred(__first, __last,
						__val, __comp);
      __glibcxx_requires_partitioned_upper_pred(__first, __last,
						__val, __comp);

      return std::__equal_range(__first, __last, __val,
				__gnu_cxx::__ops::__iter_comp_val(__comp),
				__gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  /**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return True if @p __val (or its equivalent) is in [@p
   *  __first,@p __last ].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
  */
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);
      __glibcxx_requires_partitioned_upper(__first, __last, __val);

      _ForwardIterator __i
	= std::__lower_bound(__first, __last, __val,
			     __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }

  /**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType;

      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
				  _Tp, _ValueType>)
      __glibcxx_requires_partitioned_lower_pred(__first, __last,
						__val, __comp);
      __glibcxx_requires_partitioned_upper_pred(__first, __last,
						__val, __comp);

      _ForwardIterator __i
	= std::__lower_bound(__first, __last, __val,
			     __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }

  // merge

  /// This is a helper function for the __merge_adaptive routines.
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
			  _InputIterator2 __first2, _InputIterator2 __last2,
			  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first2, __first1))
	    {
	      *__result = _GLIBCXX_MOVE(*__first2);
	      ++__first2;
	    }
	  else
	    {
	      *__result = _GLIBCXX_MOVE(*__first1);
	      ++__first1;
	    }
	  ++__result;
	}
      if (__first1 != __last1)
	_GLIBCXX_MOVE3(__first1, __last1, __result);
    }

  /// This is a helper function for the __merge_adaptive routines.
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
	   typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
				   _BidirectionalIterator1 __last1,
				   _BidirectionalIterator2 __first2,
				   _BidirectionalIterator2 __last2,
				   _BidirectionalIterator3 __result,
				   _Compare __comp)
    {
      if (__first1 == __last1)
	{
	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
	  return;
	}
      else if (__first2 == __last2)
	return;

      --__last1;
      --__last2;
      while (true)
	{
	  if (__comp(__last2, __last1))
	    {
	      *--__result = _GLIBCXX_MOVE(*__last1);
	      if (__first1 == __last1)
		{
		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
		  return;
		}
	      --__last1;
	    }
	  else
	    {
	      *--__result = _GLIBCXX_MOVE(*__last2);
	      if (__first2 == __last2)
		return;
	      --__last2;
	    }
	}
    }

  /// This is a helper function for the merge routines.
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
	   typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
		      _BidirectionalIterator1 __middle,
		      _BidirectionalIterator1 __last,
		      _Distance __len1, _Distance __len2,
		      _BidirectionalIterator2 __buffer,
		      _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
	{
	  if (__len2)
	    {
	      __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
	      _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
	      return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
	    }
	  else
	    return __first;
	}
      else if (__len1 <= __buffer_size)
	{
	  if (__len1)
	    {
	      __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
	      _GLIBCXX_MOVE3(__middle, __last, __first);
	      return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
	    }
	  else
	    return __last;
	}
      else
	{
	  std::rotate(__first, __middle, __last);
	  std::advance(__first, std::distance(__middle, __last));
	  return __first;
	}
    }

  /// This is a helper function for the merge routines.
  template<typename _BidirectionalIterator, typename _Distance, 
	   typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
		     _BidirectionalIterator __last,
		     _Distance __len1, _Distance __len2,
		     _Pointer __buffer, _Distance __buffer_size,
		     _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
	{
	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
				     __first, __comp);
	}
      else if (__len2 <= __buffer_size)
	{
	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
					      __buffer_end, __last, __comp);
	}
      else
	{
	  _BidirectionalIterator __first_cut = __first;
	  _BidirectionalIterator __second_cut = __middle;
	  _Distance __len11 = 0;
	  _Distance __len22 = 0;
	  if (__len1 > __len2)
	    {
	      __len11 = __len1 / 2;
	      std::advance(__first_cut, __len11);
	      __second_cut
		= std::__lower_bound(__middle, __last, *__first_cut,
				     __gnu_cxx::__ops::__iter_comp_val(__comp));
	      __len22 = std::distance(__middle, __second_cut);
	    }
	  else
	    {
	      __len22 = __len2 / 2;
	      std::advance(__second_cut, __len22);
	      __first_cut
		= std::__upper_bound(__first, __middle, *__second_cut,
				     __gnu_cxx::__ops::__val_comp_iter(__comp));
	      __len11 = std::distance(__first, __first_cut);
	    }

	  _BidirectionalIterator __new_middle
	    = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
				     __len1 - __len11, __len22, __buffer,
				     __buffer_size);
	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
				__len22, __buffer, __buffer_size, __comp);
	  std::__merge_adaptive(__new_middle, __second_cut, __last,
				__len1 - __len11,
				__len2 - __len22, __buffer,
				__buffer_size, __comp);
	}
    }

  /// This is a helper function for the merge routines.
  template<typename _BidirectionalIterator, typename _Distance,
	   typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
			   _BidirectionalIterator __last,
			   _Distance __len1, _Distance __len2,
			   _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
	return;

      if (__len1 + __len2 == 2)
	{
	  if (__comp(__middle, __first))
	    std::iter_swap(__first, __middle);
	  return;
	}

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
	{
	  __len11 = __len1 / 2;
	  std::advance(__first_cut, __len11);
	  __second_cut
	    = std::__lower_bound(__middle, __last, *__first_cut,
				 __gnu_cxx::__ops::__iter_comp_val(__comp));
	  __len22 = std::distance(__middle, __second_cut);
	}
      else
	{
	  __len22 = __len2 / 2;
	  std::advance(__second_cut, __len22);
	  __first_cut
	    = std::__upper_bound(__first, __middle, *__second_cut,
				 __gnu_cxx::__ops::__val_comp_iter(__comp));
	  __len11 = std::distance(__first, __first_cut);
	}

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
				  __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
				  __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
		    _BidirectionalIterator __middle,
		    _BidirectionalIterator __last,
		    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;

      if (__first == __middle || __middle == __last)
	return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
	std::__merge_without_buffer
	  (__first, __middle, __last, __len1, __len2, __comp);
      else
	std::__merge_adaptive
	  (__first, __middle, __last, __len1, __len2, __buf.begin(),
	   _DistanceType(__buf.size()), __comp);
    }

  /**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [__middle,__last), and puts the result in [__first,__last).  The
   *  output will be sorted.  The sort is @e stable, that is, for
   *  equivalent elements in the two ranges, elements from the first
   *  range will always come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
  */
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
		  _BidirectionalIterator __middle,
		  _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
	    _BidirectionalIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_sorted(__first, __middle);
      __glibcxx_requires_sorted(__middle, __last);

      std::__inplace_merge(__first, __middle, __last,
			   __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [middle,last), and puts the result in [__first,__last).  The output will
   *  be sorted.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
		  _BidirectionalIterator __middle,
		  _BidirectionalIterator __last,
		  _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
	    _BidirectionalIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_BidirectionalIterator>::value_type,
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_sorted_pred(__first, __middle, __comp);
      __glibcxx_requires_sorted_pred(__middle, __last, __comp);

      std::__inplace_merge(__first, __middle, __last,
			   __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  /// This is a helper function for the __merge_sort_loop routines.
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
		 _InputIterator __first2, _InputIterator __last2,
		 _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first2, __first1))
	    {
	      *__result = _GLIBCXX_MOVE(*__first2);
	      ++__first2;
	    }
	  else
	    {
	      *__result = _GLIBCXX_MOVE(*__first1);
	      ++__first1;
	    }
	  ++__result;
	}
      return _GLIBCXX_MOVE3(__first2, __last2,
			    _GLIBCXX_MOVE3(__first1, __last1,
					   __result));
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
	   typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
		      _RandomAccessIterator1 __last,
		      _RandomAccessIterator2 __result, _Distance __step_size,
		      _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
	{
	  __result = std::__move_merge(__first, __first + __step_size,
				       __first + __step_size,
				       __first + __two_step,
				       __result, __comp);
	  __first += __two_step;
	}
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
			__first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
	   typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
			   _RandomAccessIterator __last,
			   _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
	{
	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
	  __first += __chunk_size;
	}
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
			     _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
	{
	  std::__merge_sort_loop(__first, __last, __buffer,
				 __step_size, __comp);
	  __step_size *= 2;
	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
				 __step_size, __comp);
	  __step_size *= 2;
	}
    }

  template<typename _RandomAccessIterator, typename _Pointer,
	   typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
			   _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
	{
	  std::__stable_sort_adaptive(__first, __middle, __buffer,
				      __buffer_size, __comp);
	  std::__stable_sort_adaptive(__middle, __last, __buffer,
				      __buffer_size, __comp);
	}
      else
	{
	  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
	  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
	}
      std::__merge_adaptive(__first, __middle, __last,
			    _Distance(__middle - __first),
			    _Distance(__last - __middle),
			    __buffer, __buffer_size,
			    __comp);
    }

  /// This is a helper function for the stable sorting routines.
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
			  _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
	{
	  std::__insertion_sort(__first, __last, __comp);
	  return;
	}
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
				  __middle - __first,
				  __last - __middle,
				  __comp);
    }

  // stable_sort

  // Set algorithms: includes, set_union, set_intersection, set_difference,
  // set_symmetric_difference.  All of these algorithms have the precondition
  // that their input ranges are sorted and the postcondition that their output
  // ranges are sorted.

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
	       _InputIterator2 __first2, _InputIterator2 __last2,
	       _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first2, __first1))
	  return false;
	else if (__comp(__first1, __first2))
	  ++__first1;
	else
	  ++__first1, ++__first2;

      return __first2 == __last2;
    }

  /**
   *  @brief Determines whether all elements of a sequence exists in a range.
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @return  True if each element in [__first2,__last2) is contained in order
   *  within [__first1,__last1).  False otherwise.
   *  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1).
   *  The iterators over each range only move forward, so this is a
   *  linear algorithm.  If an element in [__first2,__last2) is not
   *  found before the search iterator reaches @p __last2, false is
   *  returned.
  */
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2, _InputIterator2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return std::__includes(__first1, __last1, __first2, __last2,
			     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Determines whether all elements of a sequence exists in a range
   *  using comparison.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @param  __comp    Comparison function to use.
   *  @return True if each element in [__first2,__last2) is contained
   *  in order within [__first1,__last1) according to comp.  False
   *  otherwise.  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1),
   *  using comp to decide.  The iterators over each range only move
   *  forward, so this is a linear algorithm.  If an element in
   *  [__first2,__last2) is not found before the search iterator
   *  reaches @p __last2, false is returned.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
	     _InputIterator2 __first2, _InputIterator2 __last2,
	     _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return std::__includes(__first1, __last1, __first2, __last2,
			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  // nth_element
  // merge
  // set_difference
  // set_intersection
  // set_union
  // stable_sort
  // set_symmetric_difference
  // min_element
  // max_element

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
		       _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
	return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
	return false;
      __i = __last;
      --__i;

      for(;;)
	{
	  _BidirectionalIterator __ii = __i;
	  --__i;
	  if (__comp(__i, __ii))
	    {
	      _BidirectionalIterator __j = __last;
	      while (!__comp(__i, --__j))
		{}
	      std::iter_swap(__i, __j);
	      std::__reverse(__ii, __last,
			     std::__iterator_category(__first));
	      return true;
	    }
	  if (__i == __first)
	    {
	      std::__reverse(__first, __last,
			     std::__iterator_category(__first));
	      return false;
	    }
	}
    }

  /**
   *  @brief  Permute range into the next @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the next one of this set.
   *  Returns true if there are more sequences to generate.  If the sequence
   *  is the largest of the set, the smallest is generated and false returned.
  */
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__next_permutation
	(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Permute range into the next @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the next one of this set.  Returns true if there are more
   *  sequences to generate.  If the sequence is the largest of the set, the
   *  smallest is generated and false returned.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_BidirectionalIterator>::value_type,
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__next_permutation
	(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
		       _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
	return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
	return false;
      __i = __last;
      --__i;

      for(;;)
	{
	  _BidirectionalIterator __ii = __i;
	  --__i;
	  if (__comp(__ii, __i))
	    {
	      _BidirectionalIterator __j = __last;
	      while (!__comp(--__j, __i))
		{}
	      std::iter_swap(__i, __j);
	      std::__reverse(__ii, __last,
			     std::__iterator_category(__first));
	      return true;
	    }
	  if (__i == __first)
	    {
	      std::__reverse(__first, __last,
			     std::__iterator_category(__first));
	      return false;
	    }
	}
    }

  /**
   *  @brief  Permute range into the previous @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the previous one of this
   *  set.  Returns true if there are more sequences to generate.  If the
   *  sequence is the smallest of the set, the largest is generated and false
   *  returned.
  */
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__prev_permutation(__first, __last,
				     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Permute range into the previous @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the previous one of this set.  Returns true if there are
   *  more sequences to generate.  If the sequence is the smallest of the set,
   *  the largest is generated and false returned.
  */
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
		     _BidirectionalIterator __last, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
				  _BidirectionalIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_BidirectionalIterator>::value_type,
	    typename iterator_traits<_BidirectionalIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__prev_permutation(__first, __last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  // replace
  // replace_if

  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
		      _OutputIterator __result,
		      _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, ++__result)
	if (__pred(__first))
	  *__result = __new_value;
	else
	  *__result = *__first;
      return __result;
    }

  /**
   *  @brief Copy a sequence, replacing each element of one value with another
   *         value.
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p result+(last-first).
   *
   *  Copies each element in the input range @p [__first,__last) to the
   *  output range @p [__result,__result+(__last-__first)) replacing elements
   *  equal to @p __old_value with @p __new_value.
  */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
		 _OutputIterator __result,
		 const _Tp& __old_value, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__replace_copy_if(__first, __last, __result,
			__gnu_cxx::__ops::__iter_equals_val(__old_value),
					      __new_value);
    }

  /**
   *  @brief Copy a sequence, replacing each value for which a predicate
   *         returns true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p __result+(__last-__first).
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  @p [__result,__result+(__last-__first)) replacing elements for which
   *  @p __pred returns true with @p __new_value.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
		    _OutputIterator __result,
		    _Predicate __pred, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__replace_copy_if(__first, __last, __result,
				__gnu_cxx::__ops::__pred_iter(__pred),
					      __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
	if (__pred(__first))
	  ++__n;
      return __n;
    }

#if __cplusplus >= 201103L
  /**
   *  @brief  Determines whether the elements of a sequence are sorted.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  True if the elements are sorted, false otherwise.
  */
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }

  /**
   *  @brief  Determines whether the elements of a sequence are sorted
   *          according to a comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  True if the elements are sorted, false otherwise.
  */
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
	      _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
		      _Compare __comp)
    {
      if (__first == __last)
	return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
	if (__comp(__next, __first))
	  return __next;
      return __next;
    }

  /**
   *  @brief  Determines the end of a sorted sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__is_sorted_until(__first, __last,
				    __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Determines the end of a sorted sequence using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  */
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
		    _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__is_sorted_until(__first, __last,
				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  */
  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
	               : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  /**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  */
  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
	                      : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
		     _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
	  || ++__next == __last)
	return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
	{
	  __min = __next;
	  __max = __first;
	}
      else
	{
	  __min = __first;
	  __max = __next;
	}

      __first = __next;
      ++__first;

      while (__first != __last)
	{
	  __next = __first;
	  if (++__next == __last)
	    {
	      if (__comp(__first, __min))
		__min = __first;
	      else if (!__comp(__first, __max))
		__max = __first;
	      break;
	    }

	  if (__comp(__next, __first))
	    {
	      if (__comp(__next, __min))
		__min = __next;
	      if (!__comp(__first, __max))
		__max = __first;
	    }
	  else
	    {
	      if (__comp(__first, __min))
		__min = __first;
	      if (!__comp(__next, __max))
		__max = __next;
	    }

	  __first = __next;
	  ++__first;
	}

      return std::make_pair(__min, __max);
    }

  /**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  */
  template<typename _ForwardIterator>
    _GLIBCXX14_CONSTEXPR
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__minmax_element(__first, __last,
				   __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  */
  template<typename _ForwardIterator, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
		   _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__minmax_element(__first, __last,
				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  // N2722 + DR 915.
  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    _GLIBCXX14_CONSTEXPR
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
	std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
	std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {
      // Efficiently compare identical prefixes:  O(N) if sequences
      // have the same elements in the same order.
      for (; __first1 != __last1; ++__first1, ++__first2)
	if (!__pred(__first1, __first2))
	  break;

      if (__first1 == __last1)
	return true;

      // Establish __last2 assuming equal ranges by iterating over the
      // rest of the list.
      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
	{
	  if (__scan != std::__find_if(__first1, __scan,
			  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
	    continue; // We've seen this one before.
	  
	  auto __matches
	    = std::__count_if(__first2, __last2,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
	  if (0 == __matches ||
	      std::__count_if(__scan, __last1,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
	      != __matches)
	    return false;
	}
      return true;
    }

  /**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __first2 + (__last1 - __first1)), beginning with 
   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
   *          returns true; otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
		typename iterator_traits<_ForwardIterator1>::value_type,
		typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);

      return std::__is_permutation(__first1, __last1, __first2,
				   __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in
   *          the range [__first2, __first2 + (__last1 - __first1)),
   *          beginning with ForwardIterator2 begin, such that
   *          equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);

      return std::__is_permutation(__first1, __last1, __first2,
				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }

#if __cplusplus > 201103L
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
		     _BinaryPredicate __pred)
    {
      using _Cat1
	= typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
	= typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
	{
	  auto __d1 = std::distance(__first1, __last1);
	  auto __d2 = std::distance(__first2, __last2);
	  if (__d1 != __d2)
	    return false;
	}

      // Efficiently compare identical prefixes:  O(N) if sequences
      // have the same elements in the same order.
      for (; __first1 != __last1 && __first2 != __last2;
	  ++__first1, ++__first2)
	if (!__pred(__first1, __first2))
	  break;

      if (__ra_iters)
	{
	  if (__first1 == __last1)
	    return true;
	}
      else
	{
	  auto __d1 = std::distance(__first1, __last1);
	  auto __d2 = std::distance(__first2, __last2);
	  if (__d1 == 0 && __d2 == 0)
	    return true;
	  if (__d1 != __d2)
	    return false;
	}

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
	{
	  if (__scan != std::__find_if(__first1, __scan,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
	    continue; // We've seen this one before.

	  auto __matches = std::__count_if(__first2, __last2,
		__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
	  if (0 == __matches
	      || std::__count_if(__scan, __last1,
			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
	      != __matches)
	    return false;
	}
      return true;
    }

  /**
   *  @brief  Checks whether a permutaion of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, begin) returns true;
   *          otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return
	std::__is_permutation(__first1, __last1, __first2, __last2,
			      __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
		   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
		   _BinaryPredicate __pred)
    {
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__is_permutation(__first1, __last1, __first2, __last2,
				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
#endif
# 3700 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3

#ifdef _GLIBCXX_USE_C99_STDINT_TR1
  /**
   *  @brief Shuffle the elements of a sequence using a uniform random
   *         number generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __g to
   *  provide random numbers.
  */
  template<typename _RandomAccessIterator,
	   typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
	    _UniformRandomNumberGenerator&& __g)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
#endif
# 3740 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3

#endif // C++11
# 3742 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3

_GLIBCXX_END_NAMESPACE_VERSION

_GLIBCXX_BEGIN_NAMESPACE_ALGO

  /**
   *  @brief Apply a function to every element of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __f      A unary function object.
   *  @return   @p __f (std::move(@p __f) in C++0x).
   *
   *  Applies the function object @p __f to each element in the range
   *  @p [first,last).  @p __f must not modify the order of the sequence.
   *  If @p __f has a return value it is ignored.
  */
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_requires_valid_range(__first, __last);
      for (; __first != __last; ++__first)
	__f(*__first);
      return _GLIBCXX_MOVE(__f);
    }

  /**
   *  @brief Find the first occurrence of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __val    The value to find.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
	 const _Tp& __val)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
		typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);
      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__iter_equals_val(__val));
    }

  /**
   *  @brief Find the first element in a sequence for which a
   *         predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
  */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
	    _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	      typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__pred_iter(__pred));
    }

  /**
   *  @brief  Find element from a set in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  */
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
		  _ForwardIterator __first2, _ForwardIterator __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      for (; __first1 != __last1; ++__first1)
	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
	  if (*__first1 == *__iter)
	    return __first1;
      return __last1;
    }

  /**
   *  @brief  Find element from a set in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @param  __comp    Predicate to use.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
   *  such iterator exists.
   *

   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  */
  template<typename _InputIterator, typename _ForwardIterator,
	   typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
		  _ForwardIterator __first2, _ForwardIterator __last2,
		  _BinaryPredicate __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_InputIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      for (; __first1 != __last1; ++__first1)
	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
	  if (__comp(*__first1, *__iter))
	    return __first1;
      return __last1;
    }

  /**
   *  @brief Find two adjacent values in a sequence that are equal.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
   *  or @p __last if no such iterator exists.
  */
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_EqualityComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__adjacent_find(__first, __last,
				  __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Find two adjacent values in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first         A forward iterator.
   *  @param  __last          A forward iterator.
   *  @param  __binary_pred   A binary predicate.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that
   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
   *  exists.
  */
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
		  _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__adjacent_find(__first, __last,
			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }

  /**
   *  @brief Count the number of copies of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be counted.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @c *i == @p __value
  */
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__count_if(__first, __last,
			     __gnu_cxx::__ops::__iter_equals_val(__value));
    }

  /**
   *  @brief Count the elements of a sequence for which a predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @p __pred(*i) is true.
  */
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__count_if(__first, __last,
			     __gnu_cxx::__ops::__pred_iter(__pred));
    }

  /**
   *  @brief Search a sequence for a matching sub-sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @param  __last2   A forward iterator.
   *  @return The first iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
   *  *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the first element
   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
   *  found.
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.
   *
   *  This means that the returned iterator @c i will be in the range
   *  @p [__first1,__last1-(__last2-__first2))
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__search(__first1, __last1, __first2, __last2,
			   __gnu_cxx::__ops::__iter_equal_to_iter());
    }

  /**
   *  @brief Search a sequence for a matching sub-sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1     A forward iterator.
   *  @param  __last1      A forward iterator.
   *  @param  __first2     A forward iterator.
   *  @param  __last2      A forward iterator.
   *  @param  __predicate  A binary predicate.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that
   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2), using @p __predicate to determine equality,
   *  and returns an iterator to the first element of the
   *  sub-sequence, or @p __last1 if no such iterator exists.
   *
   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
  */
  template<typename _ForwardIterator1, typename _ForwardIterator2,
	   typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
	   _BinaryPredicate  __predicate)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator1>::value_type,
	    typename iterator_traits<_ForwardIterator2>::value_type>)
      __glibcxx_requires_valid_range(__first1, __last1);
      __glibcxx_requires_valid_range(__first2, __last2);

      return std::__search(__first1, __last1, __first2, __last2,
			   __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }

  /**
   *  @brief Search a sequence for a number of consecutive values.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __count  The number of consecutive values.
   *  @param  __val    The value to find.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
   *  each @c N in the range @p [0,__count), or @p __last if no such
   *  iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p count consecutive elements
   *  equal to @p __val.
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
	     _Integer __count, const _Tp& __val)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__search_n(__first, __last, __count,
			     __gnu_cxx::__ops::__iter_equals_val(__val));
    }


  /**
   *  @brief Search a sequence for a number of consecutive values using a
   *         predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __count        The number of consecutive values.
   *  @param  __val          The value to find.
   *  @param  __binary_pred  A binary predicate.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @p
   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
   *  @p [0,__count), or @p __last if no such iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p __count
   *  consecutive elements for which the predicate returns true.
  */
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
	     _Integer __count, const _Tp& __val,
	     _BinaryPredicate __binary_pred)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__search_n(__first, __last, __count,
		__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }


  /**
   *  @brief Perform an operation on a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first     An input iterator.
   *  @param  __last      An input iterator.
   *  @param  __result    An output iterator.
   *  @param  __unary_op  A unary operator.
   *  @return   An output iterator equal to @p __result+(__last-__first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
   *  range @p [0,__last-__first).
   *
   *  @p unary_op must not alter its argument.
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
	      _OutputIterator __result, _UnaryOperation __unary_op)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
            // "the type returned by a _UnaryOperation"
            __typeof__(__unary_op(*__first))>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first, ++__result)
	*__result = __unary_op(*__first);
      return __result;
    }

  /**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1     An input iterator.
   *  @param  __last1      An input iterator.
   *  @param  __first2     An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __binary_op  A binary operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *  Evaluates @p
   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
   *  @c N in the range @p [0,__last1-__first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
	      _InputIterator2 __first2, _OutputIterator __result,
	      _BinaryOperation __binary_op)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
            // "the type returned by a _BinaryOperation"
            __typeof__(__binary_op(*__first1,*__first2))>)
      __glibcxx_requires_valid_range(__first1, __last1);

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
	*__result = __binary_op(*__first1, *__first2);
      return __result;
    }

  /**
   *  @brief Replace each occurrence of one value in a sequence with another
   *         value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   replace() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
  */
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
	    const _Tp& __old_value, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	if (*__first == __old_value)
	  *__first = __new_value;
    }

  /**
   *  @brief Replace each value in a sequence for which a predicate returns
   *         true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   replace_if() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
   *  is true then the assignment @c *i = @p __new_value is performed.
  */
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
	       _Predicate __pred, const _Tp& __new_value)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	if (__pred(*__first))
	  *__first = __new_value;
    }

  /**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   generate() returns no value.
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__last).
  */
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
	     _Generator __gen)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_GeneratorConcept<_Generator,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first)
	*__first = __gen();
    }

  /**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __n      The length of the sequence.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   The end of the sequence, @p __first+__n
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__first+__n).
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 865. More algorithms that throw away information
  */
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {
      // concept requirements
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
            // "the type returned by a _Generator"
            __typeof__(__gen())>)

      for (__decltype(__n + 0) __niter = __n;
	   __niter > 0; --__niter, ++__first)
	*__first = __gen();
      return __first;
    }

  /**
   *  @brief Copy a sequence, removing consecutive duplicate values.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements that compare equal.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
   *  
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
   *  Assignable?
  */
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
		_OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_function_requires(_EqualityComparableConcept<
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return __result;
      return std::__unique_copy(__first, __last, __result,
				__gnu_cxx::__ops::__iter_equal_to_iter(),
				std::__iterator_category(__first),
				std::__iterator_category(__result));
    }

  /**
   *  @brief Copy a sequence, removing consecutive values using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        An input iterator.
   *  @param  __last         An input iterator.
   *  @param  __result       An output iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements for which @p __binary_pred returns
   *  true.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
  */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
		_OutputIterator __result,
		_BinaryPredicate __binary_pred)
    {
      // concept requirements -- predicates checked later
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return __result;
      return std::__unique_copy(__first, __last, __result,
			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
				std::__iterator_category(__first),
				std::__iterator_category(__result));
    }

  /**
   *  @brief Randomly shuffle the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  Nothing.
   *
   *  Reorder the elements in the range @p [__first,__last) using a random
   *  distribution, so that every possible ordering of the sequence is
   *  equally likely.
  */
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first != __last)
	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	  {
	    // XXX rand() % N is not uniformly distributed
	    _RandomAccessIterator __j = __first
					+ std::rand() % ((__i - __first) + 1);
	    if (__i != __j)
	      std::iter_swap(__i, __j);
	  }
    }

  /**
   *  @brief Shuffle the elements of a sequence using a random number
   *         generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __rand    The RNG functor or function.
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
   *  provide a random distribution. Calling @p __rand(N) for a positive
   *  integer @p N should return a randomly chosen integer from the
   *  range [0,N).
  */
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
#if __cplusplus >= 201103L
		   _RandomNumberGenerator&& __rand)
#else
# 4474 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
		   _RandomNumberGenerator& __rand)
#endif
# 4476 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      if (__first == __last)
	return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
	{
	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
	  if (__i != __j)
	    std::iter_swap(__i, __j);
	}
    }


  /**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [__first,middle) and false for each @p i
   *  in the range @p [middle,__last).
   *
   *  @p __pred must not modify its operand. @p partition() does not preserve
   *  the relative ordering of elements in each group, use
   *  @p stable_partition() if this is needed.
  */
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
	      _Predicate   __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return std::__partition(__first, __last, __pred,
			      std::__iterator_category(__first));
    }


  /**
   *  @brief Sort the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [first,last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
  */
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
		 _RandomAccessIterator __middle,
		 _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      std::__partial_sort(__first, __middle, __last,
			  __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort the smallest elements of a sequence using a predicate
   *         for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
   *  are both false.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
		 _RandomAccessIterator __middle,
		 _RandomAccessIterator __last,
		 _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __middle);
      __glibcxx_requires_valid_range(__middle, __last);

      std::__partial_sort(__first, __middle, __last,
			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief Sort a sequence just enough to find a particular position.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that *j < *i is false.
  */
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
		_RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __nth);
      __glibcxx_requires_valid_range(__nth, __last);

      if (__first == __last || __nth == __last)
	return;

      std::__introselect(__first, __nth, __last,
			 std::__lg(__last - __first) * 2,
			 __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort a sequence just enough to find a particular position
   *         using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that @p __comp(*j,*i) is false.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
		_RandomAccessIterator __last, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __nth);
      __glibcxx_requires_valid_range(__nth, __last);

      if (__first == __last || __nth == __last)
	return;

      std::__introselect(__first, __nth, __last,
			 std::__lg(__last - __first) * 2,
			 __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief Sort the elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @e i in the range @p [__first,__last-1),  
   *  *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  */
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
   *  range @p [__first,__last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
	 _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
	    _InputIterator2 __first2, _InputIterator2 __last2,
	    _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first2, __first1))
	    {
	      *__result = *__first2;
	      ++__first2;
	    }
	  else
	    {
	      *__result = *__first1;
	      ++__first1;
	    }
	  ++__result;
	}
      return std::copy(__first2, __last2,
		       std::copy(__first1, __last1, __result));
    }

  /**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @return         An iterator pointing to the first element <em>not less
   *                  than</em> @e val.
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
	  _InputIterator2 __first2, _InputIterator2 __last2,
	  _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)	
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__merge(__first1, __last1,
				     __first2, __last2, __result,
				     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @param  __comp    A functor to use for comparisons.
   *  @return         An iterator pointing to the first element "not less
   *                  than" @e val.
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
	  _InputIterator2 __first2, _InputIterator2 __last2,
	  _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__merge(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
		  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
	_ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
	_DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
	std::__inplace_stable_sort(__first, __last, __comp);
      else
	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
				    _DistanceType(__buf.size()), __comp);
    }

  /**
   *  @brief Sort the elements of a sequence, preserving the relative order
   *         of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p x<y is false and @p y<x is false will have the same relative
   *  ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      _GLIBCXX_STD_A::__stable_sort(__first, __last,
				    __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison,
   *         preserving the relative order of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p __comp(*(i+1),*i) is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
   *  relative ordering after calling @p stable_sort().
  */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
		_Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
	    _RandomAccessIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_RandomAccessIterator>::value_type,
	    typename iterator_traits<_RandomAccessIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      _GLIBCXX_STD_A::__stable_sort(__first, __last,
				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
		_InputIterator2 __first2, _InputIterator2 __last2,
		_OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first1, __first2))
	    {
	      *__result = *__first1;
	      ++__first1;
	    }
	  else if (__comp(__first2, __first1))
	    {
	      *__result = *__first2;
	      ++__first2;
	    }
	  else
	    {
	      *__result = *__first1;
	      ++__first1;
	      ++__first2;
	    }
	  ++__result;
	}
      return std::copy(__first2, __last2,
		       std::copy(__first1, __last1, __result));
    }

  /**
   *  @brief Return the union of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that element is copied and the iterator advanced.  If an element is
   *  contained in both ranges, the element from the first range is copied and
   *  both ranges advance.  The output range may not overlap either input
   *  range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
	      _InputIterator2 __first2, _InputIterator2 __last2,
	      _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Return the union of two sorted ranges using a comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that element is copied and the iterator advanced.
   *  If an equivalent element according to @p __comp is contained in both
   *  ranges, the element from the first range is copied and both ranges
   *  advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
	      _InputIterator2 __first2, _InputIterator2 __last2,
	      _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
		       _InputIterator2 __first2, _InputIterator2 __last2,
		       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first1, __first2))
	  ++__first1;
	else if (__comp(__first2, __first1))
	  ++__first2;
	else
	  {
	    *__result = *__first1;
	    ++__first1;
	    ++__first2;
	    ++__result;
	  }
      return __result;
    }

  /**
   *  @brief Return the intersection of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that iterator advances.  If an element is contained in both ranges, the
   *  element from the first range is copied and both ranges advance.  The
   *  output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
		     _InputIterator2 __first2, _InputIterator2 __last2,
		     _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
				     __first2, __last2, __result,
				     __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief Return the intersection of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that iterator advances.  If an element is
   *  contained in both ranges according to @p __comp, the element from the
   *  first range is copied and both ranges advance.  The output range may not
   *  overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
		     _InputIterator2 __first2, _InputIterator2 __last2,
		     _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
		     _InputIterator2 __first2, _InputIterator2 __last2,
		     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first1, __first2))
	  {
	    *__result = *__first1;
	    ++__first1;
	    ++__result;
	  }
	else if (__comp(__first2, __first1))
	  ++__first2;
	else
	  {
	    ++__first1;
	    ++__first2;
	  }
      return std::copy(__first1, __last1, __result);
    }

  /**
   *  @brief Return the difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second, that element is copied and the
   *  iterator advances.  If the current element of the second range is less,
   *  the iterator advances, but no element is copied.  If an element is
   *  contained in both ranges, no elements are copied and both ranges
   *  advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
		   _InputIterator2 __first2, _InputIterator2 __last2,
		   _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)	
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
				   __first2, __last2, __result,
				   __gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the difference of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second according to @p __comp, that element
   *  is copied and the iterator advances.  If the current element of the
   *  second range is less, no element is copied and the iterator advances.
   *  If an element is contained in both ranges according to @p __comp, no
   *  elements are copied and both ranges advance.  The output range may not
   *  overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
		   _InputIterator2 __first2, _InputIterator2 __last2,
		   _OutputIterator __result, _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
				   __first2, __last2, __result,
				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator,
	   typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
			       _InputIterator1 __last1,
			       _InputIterator2 __first2,
			       _InputIterator2 __last2,
			       _OutputIterator __result,
			       _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	if (__comp(__first1, __first2))
	  {
	    *__result = *__first1;
	    ++__first1;
	    ++__result;
	  }
	else if (__comp(__first2, __first1))
	  {
	    *__result = *__first2;
	    ++__first2;
	    ++__result;
	  }
	else
	  {
	    ++__first1;
	    ++__first2;
	  }
      return std::copy(__first2, __last2, 
		       std::copy(__first1, __last1, __result));
    }

  /**
   *  @brief  Return the symmetric difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other, that element is copied and the iterator advances.  If an
   *  element is contained in both ranges, no elements are copied and both
   *  ranges advance.  The output range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
			     _InputIterator2 __first2, _InputIterator2 __last2,
			     _OutputIterator __result)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_LessThanOpConcept<
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)	
      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
      __glibcxx_requires_sorted_set(__first2, __last2, __first1);

      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
					__first2, __last2, __result,
					__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the symmetric difference of two sorted ranges using
   *  comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other according to @p comp, that element is copied and the
   *  iterator advances.  If an element is contained in both ranges according
   *  to @p __comp, no elements are copied and both ranges advance.  The output
   *  range may not overlap either input range.
  */
  template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
			     _InputIterator2 __first2, _InputIterator2 __last2,
			     _OutputIterator __result,
			     _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator1>::value_type,
	    typename iterator_traits<_InputIterator2>::value_type>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_InputIterator2>::value_type,
	    typename iterator_traits<_InputIterator1>::value_type>)
      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);

      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
				__first2, __last2, __result,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
		  _Compare __comp)
    {
      if (__first == __last)
	return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
	if (__comp(__first, __result))
	  __result = __first;
      return __result;
    }

  /**
   *  @brief  Return the minimum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the smallest value.
  */
  template<typename _ForwardIterator>
    _GLIBCXX14_CONSTEXPR
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__min_element(__first, __last,
				__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the minimum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the smallest value
   *  according to __comp.
  */
  template<typename _ForwardIterator, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
		_Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__min_element(__first, __last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
		  _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
	if (__comp(__result, __first))
	  __result = __first;
      return __result;
    }

  /**
   *  @brief  Return the maximum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the largest value.
  */
  template<typename _ForwardIterator>
    _GLIBCXX14_CONSTEXPR
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanComparableConcept<
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__max_element(__first, __last,
				__gnu_cxx::__ops::__iter_less_iter());
    }

  /**
   *  @brief  Return the maximum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the largest value
   *  according to __comp.
  */
  template<typename _ForwardIterator, typename _Compare>
    _GLIBCXX14_CONSTEXPR
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
		_Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
	    typename iterator_traits<_ForwardIterator>::value_type,
	    typename iterator_traits<_ForwardIterator>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return _GLIBCXX_STD_A::__max_element(__first, __last,
				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

_GLIBCXX_END_NAMESPACE_ALGO
} // namespace std

#endif /* _STL_ALGO_H */
# 5547 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_algo.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 2 3

#ifdef _GLIBCXX_PARALLEL
#if 0 /* expanded by -frewrite-includes */
# include <parallel/algorithm>
#endif /* expanded by -frewrite-includes */
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3
#endif
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3

#endif /* _GLIBCXX_ALGORITHM */
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/algorithm" 3
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfBindChecker.hh" 2

NAMESPACE_UPFIR_BEGIN

/* The bindChecker is a serializable object created for bind_checker command
   The UPF command is
   bind_checker instance_name
-module checker_name
[-elements element_list]
[-bind_to module [-arch name]]
[-ports {{port_name net_name}*}]
[-parameters {{param_name param_value}*}]
[-prefix pref_string]
[-suffix suff_string]
   */
class BindChecker : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BindChecker);
    ///instance name / policy name of bind checker, it will be fully qualified name.
    virtual const char*         getFullName() const = 0;

    ///name of bind checker.
    virtual const char*         getName() const = 0;

    ///This will return list of elements given either through -elements option
    ///of bind_checker command
    virtual charLI        getElements() const =0;

    ///The module containing VIP
    virtual const char* getCheckerModuleName() const = 0;

    ///This will give the bind_to module/entity/policy name
    virtual const char*   getBindTo() const = 0;

    //This will store the current scope name
    virtual void        setScope(char *scope) = 0;
    virtual const char* getScope() const = 0;


    //add one hdl port
    virtual void addHdlPort(char* key, char* value, UpfObj* obj = NULL) = 0;

    //add parameter 
    virtual void addParameter(char* f, char* s) = 0;


    ///get the list of ports to bind_checker
    virtual NamePairLI getHdlPorts() const = 0;
    ///get the list of parameters to bind_checker
    virtual NamePairLI getParameters() const = 0;
    virtual const char* getParamVal(const char* key) const = 0;
    ///get the name prefix
    virtual const char* getNamePrefix() const = 0;
    ///get the name suffix
    virtual const char* getNameSuffix() const = 0;

    virtual void print() const = 0;

    ///if to be applied on pd scope
    virtual bool isOnPdScope() const = 0;

    ///if to be applied on pd scope
    virtual void applyOnPdScope(bool b) = 0;

    ///if to be applied on generic signals
    virtual bool isGenericPortParamsPresent() const = 0;
    virtual bool isGenericClockPresent() const = 0;
    virtual bool isGenericResetPresent() const = 0;
    virtual bool isGenericInputPresent() const = 0;
    virtual bool isGenericOutputPresent() const = 0;
    virtual bool isGenericFlopPresent() const = 0;
    virtual void setGenericPortParamsPresent(char b) = 0;
    virtual void setBindToElements(bool b) = 0;
    virtual bool isBindToElements() const = 0;
    virtual bool isLpaBind() const = 0;
    virtual unsigned int getBindCheckerId() const = 0;
    virtual ~BindChecker() {}
};

class UpfControllerObj : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfControllerObj);
    virtual void addController(void* m) = 0;
    virtual void* getController() = 0;
    virtual void addControllerName(const char* name) = 0;
    virtual const char* getControllerName() = 0;
    virtual void addBindChecker(BindChecker* bc) = 0;
    virtual bool hasBindChecker() = 0;
    virtual BindCheckerLI getBindCheckers() = 0;
    virtual void destroyNonGenericBindCheckers() = 0;

    /*Store referenced line number to enable trace objects based on line number*/
    void addReferencedLineNo(unsigned int lineNo) {
        std::vector<unsigned int>::iterator it = std::find(referencedLineNo_.begin(), referencedLineNo_.end(), lineNo);
        if( it == referencedLineNo_.end())
            referencedLineNo_.push_back(lineNo);
    }
    const std::vector<unsigned int>& getReferencedLineNo() { return referencedLineNo_; }
protected:
    std::vector<unsigned int> referencedLineNo_;
};

class NamePair : public virtual ser::Serializable
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(NamePair);
    virtual char* getKey() const  = 0;
    virtual char* getValue() const = 0;
    virtual UpfObj* getObject() const = 0;
    virtual void setKey(char* k) = 0;
    virtual void setValue(char* v)  = 0;
    virtual void setObject(UpfObj* o) = 0;
    virtual UpfObjLI getArrayPathLI() const = 0;
    virtual void addArrayPath(UpfObj*) = 0;
    virtual ~NamePair() {}
};

NamePair* createNamePair(char* k, char* v);
NAMESPACE_UPFIR_END

#endif
# 134 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfBindChecker.hh"
# 18 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "lp-src/runtime/include/nlp_sim_types.h"
#endif /* expanded by -frewrite-includes */
# 18 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 19 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
#if 0 /* expanded by -frewrite-includes */
#include "UpfTypeDef.hh"
#endif /* expanded by -frewrite-includes */
# 19 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 20 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
#if 0 /* expanded by -frewrite-includes */
#include <map>
#endif /* expanded by -frewrite-includes */
# 20 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 1 3
// <map> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/map
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_MAP
#define _GLIBCXX_MAP 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_tree.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 1 3
// RB tree implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 */

/** @file bits/stl_tree.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map,set}
 */

#ifndef _STL_TREE_H
#define _STL_TREE_H 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/allocator.h>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_function.h>
#endif /* expanded by -frewrite-includes */
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/cpp_type_traits.h>
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <ext/alloc_traits.h>
#endif /* expanded by -frewrite-includes */
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <ext/aligned_buffer.h>
#endif /* expanded by -frewrite-includes */
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
#endif
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Red-black tree class, designed for use in implementing STL
  // associative containers (set, multiset, map, and multimap). The
  // insertion and deletion algorithms are based on those in Cormen,
  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
  // 1990), except that
  //
  // (1) the header cell is maintained with links not only to the root
  // but also to the leftmost node of the tree, to enable constant
  // time begin(), and to the rightmost node of the tree, to enable
  // linear time performance when used with the generic set algorithms
  // (set_union, etc.)
  // 
  // (2) when a node being deleted has two children its successor node
  // is relinked into its place, rather than copied, so that the only
  // iterators invalidated are those referring to the deleted node.

  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color	_M_color;
    _Base_ptr		_M_parent;
    _Base_ptr		_M_left;
    _Base_ptr		_M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;

#if __cplusplus < 201103L
      _Val _M_value_field;

      _Val*
      _M_valptr()
      { return std::__addressof(_M_value_field); }

      const _Val*
      _M_valptr() const
      { return std::__addressof(_M_value_field); }
#else
# 149 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }
#endif
# 159 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    };

  _GLIBCXX_PURE _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  _GLIBCXX_PURE const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  _GLIBCXX_PURE _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  _GLIBCXX_PURE const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp  value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t                  difference_type;

      typedef _Rb_tree_iterator<_Tp>        _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>*           _Link_type;

      _Rb_tree_iterator() _GLIBCXX_NOEXCEPT
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      : _M_node(__x) { }

      reference
      operator*() const _GLIBCXX_NOEXCEPT
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const _GLIBCXX_NOEXCEPT
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() _GLIBCXX_NOEXCEPT
      {
	_M_node = _Rb_tree_increment(_M_node);
	return *this;
      }

      _Self
      operator++(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _Rb_tree_increment(_M_node);
	return __tmp;
      }

      _Self&
      operator--() _GLIBCXX_NOEXCEPT
      {
	_M_node = _Rb_tree_decrement(_M_node);
	return *this;
      }

      _Self
      operator--(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _Rb_tree_decrement(_M_node);
	return __tmp;
      }

      bool
      operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp        value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t                  difference_type;

      typedef _Rb_tree_const_iterator<_Tp>        _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>*           _Link_type;

      _Rb_tree_const_iterator() _GLIBCXX_NOEXCEPT
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) _GLIBCXX_NOEXCEPT
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const _GLIBCXX_NOEXCEPT
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const _GLIBCXX_NOEXCEPT
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const _GLIBCXX_NOEXCEPT
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() _GLIBCXX_NOEXCEPT
      {
	_M_node = _Rb_tree_increment(_M_node);
	return *this;
      }

      _Self
      operator++(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _Rb_tree_increment(_M_node);
	return __tmp;
      }

      _Self&
      operator--() _GLIBCXX_NOEXCEPT
      {
	_M_node = _Rb_tree_decrement(_M_node);
	return *this;
      }

      _Self
      operator--(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	_M_node = _Rb_tree_decrement(_M_node);
	return __tmp;
      }

      bool
      operator==(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const _GLIBCXX_NOEXCEPT
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
			       _Rb_tree_node_base& __header) throw ();


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;

    protected:
      typedef _Rb_tree_node_base* 		_Base_ptr;
      typedef const _Rb_tree_node_base* 	_Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* 		_Link_type;
      typedef const _Rb_tree_node<_Val>*	_Const_Link_type;

    private:
      // Functor recycling a pool of nodes and using allocation once the pool
      // is empty.
      struct _Reuse_or_alloc_node
      {
	_Reuse_or_alloc_node(_Rb_tree& __t)
	  : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
	{
	  if (_M_root)
	    {
	      _M_root->_M_parent = 0;

	      if (_M_nodes->_M_left)
		_M_nodes = _M_nodes->_M_left;
	    }
	  else
	    _M_nodes = 0;
	}

#if __cplusplus >= 201103L
	_Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;
#endif
# 382 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

	~_Reuse_or_alloc_node()
	{ _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

	template<typename _Arg>
	  _Link_type
#if __cplusplus < 201103L
	  operator()(const _Arg& __arg)
#else
# 391 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
	  operator()(_Arg&& __arg)
#endif
# 393 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
	  {
	    _Link_type __node = static_cast<_Link_type>(_M_extract());
	    if (__node)
	      {
		_M_t._M_destroy_node(__node);
		_M_t._M_construct_node(__node, _GLIBCXX_FORWARD(_Arg, __arg));
		return __node;
	      }

	    return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg));
	  }

      private:
	_Base_ptr
	_M_extract()
	{
	  if (!_M_nodes)
	    return _M_nodes;

	  _Base_ptr __node = _M_nodes;
	  _M_nodes = _M_nodes->_M_parent;
	  if (_M_nodes)
	    {
	      if (_M_nodes->_M_right == __node)
		{
		  _M_nodes->_M_right = 0;

		  if (_M_nodes->_M_left)
		    {
		      _M_nodes = _M_nodes->_M_left;

		      while (_M_nodes->_M_right)
			_M_nodes = _M_nodes->_M_right;

		      if (_M_nodes->_M_left)
			_M_nodes = _M_nodes->_M_left;
		    }
		}
	      else // __node is on the left.
		_M_nodes->_M_left = 0;
	    }
	  else
	    _M_root = 0;

	  return __node;
	}

	_Base_ptr _M_root;
	_Base_ptr _M_nodes;
	_Rb_tree& _M_t;
      };

      // Functor similar to the previous one but without any pool of nodes to
      // recycle.
      struct _Alloc_node
      {
	_Alloc_node(_Rb_tree& __t)
	  : _M_t(__t) { }

	template<typename _Arg>
	  _Link_type
#if __cplusplus < 201103L
	  operator()(const _Arg& __arg) const
#else
# 457 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
	  operator()(_Arg&& __arg) const
#endif
# 459 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
	  { return _M_t._M_create_node(_GLIBCXX_FORWARD(_Arg, __arg)); }

      private:
	_Rb_tree& _M_t;
      };

    public:
      typedef _Key 				key_type;
      typedef _Val 				value_type;
      typedef value_type* 			pointer;
      typedef const value_type* 		const_pointer;
      typedef value_type& 			reference;
      typedef const value_type& 		const_reference;
      typedef size_t 				size_type;
      typedef ptrdiff_t 			difference_type;
      typedef _Alloc 				allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }
      
      const _Node_allocator&
      _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) _GLIBCXX_NOEXCEPT
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }

#if __cplusplus < 201103L
      void
      _M_construct_node(_Link_type __node, const value_type& __x)
      {
	__try
	  { get_allocator().construct(__node->_M_valptr(), __x); }
	__catch(...)
	  {
	    _M_put_node(__node);
	    __throw_exception_again;
	  }
      }

      _Link_type
      _M_create_node(const value_type& __x)
      {
	_Link_type __tmp = _M_get_node();
	_M_construct_node(__tmp, __x);
	return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      { get_allocator().destroy(__p->_M_valptr()); }
#else
# 522 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      template<typename... _Args>
	void
	_M_construct_node(_Link_type __node, _Args&&... __args)
	{
	  __try
	    {
	      ::new(__node) _Rb_tree_node<_Val>;
	      _Alloc_traits::construct(_M_get_Node_allocator(),
				       __node->_M_valptr(),
				       std::forward<_Args>(__args)...);
	    }
	  __catch(...)
	    {
	      __node->~_Rb_tree_node<_Val>();
	      _M_put_node(__node);
	      __throw_exception_again;
	    }
	}

      template<typename... _Args>
        _Link_type
        _M_create_node(_Args&&... __args)
	{
	  _Link_type __tmp = _M_get_node();
	  _M_construct_node(__tmp, std::forward<_Args>(__args)...);
	  return __tmp;
	}

      void
      _M_destroy_node(_Link_type __p) noexcept
      {
	_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
	__p->~_Rb_tree_node<_Val>();
      }
#endif
# 557 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

      void
      _M_drop_node(_Link_type __p) _GLIBCXX_NOEXCEPT
      {
	_M_destroy_node(__p);
	_M_put_node(__p);
      }

      template<typename _NodeGen>
	_Link_type
	_M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
	{
	  _Link_type __tmp = __node_gen(*__x->_M_valptr());
	  __tmp->_M_color = __x->_M_color;
	  __tmp->_M_left = 0;
	  __tmp->_M_right = 0;
	  return __tmp;
	}

    protected:
      // Unused _Is_pod_comparator is kept as it is part of mangled name.
      template<typename _Key_compare,
	       bool /* _Is_pod_comparator */ = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
	  _Key_compare		_M_key_compare;
	  _Rb_tree_node_base 	_M_header;
	  size_type 		_M_node_count; // Keeps track of size of tree.

	  _Rb_tree_impl()
	  : _Node_allocator(), _M_key_compare(), _M_header(),
	    _M_node_count(0)
	  { _M_initialize(); }

	  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
	  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
	    _M_node_count(0)
	  { _M_initialize(); }

#if __cplusplus >= 201103L
	  _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
	  : _Node_allocator(std::move(__a)), _M_key_compare(__comp),
	    _M_header(), _M_node_count(0)
	  { _M_initialize(); }
#endif
# 602 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

	  void
	  _M_reset()
	  {
	    this->_M_header._M_parent = 0;
	    this->_M_header._M_left = &this->_M_header;
	    this->_M_header._M_right = &this->_M_header;
	    this->_M_node_count = 0;
	  }

	private:
	  void
	  _M_initialize()
	  {
	    this->_M_header._M_color = _S_red;
	    this->_M_header._M_parent = 0;
	    this->_M_header._M_left = &this->_M_header;
	    this->_M_header._M_right = &this->_M_header;
	  }	    
	};

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() _GLIBCXX_NOEXCEPT
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const _GLIBCXX_NOEXCEPT
      {
	return static_cast<_Const_Link_type>
	  (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end() _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const _GLIBCXX_NOEXCEPT
      { return reinterpret_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return *__x->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) _GLIBCXX_NOEXCEPT
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type>       iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator>       reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
				    const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
				   const key_type& __k);

#if __cplusplus >= 201103L
      template<typename _Arg, typename _NodeGen>
        iterator
	_M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
        iterator
        _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
        iterator
        _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
#else
# 761 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      template<typename _NodeGen>
	iterator
	_M_insert_(_Base_ptr __x, _Base_ptr __y,
		   const value_type& __v, _NodeGen&);

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 233. Insertion hints in associative containers.
      iterator
      _M_insert_lower(_Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);
#endif
# 774 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

      template<typename _NodeGen>
	_Link_type
	_M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen&);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p)
      {
	_Alloc_node __an(*this);
	return _M_copy(__x, __p, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
		     const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
		     const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
		     const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
		     const _Key& __k) const;

    public:
      // allocation/deallocation
      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
	       const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare,
	        _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator()))
      {
	if (__x._M_root() != 0)
	  {
	    _M_root() = _M_copy(__x._M_begin(), _M_end());
	    _M_leftmost() = _S_minimum(_M_root());
	    _M_rightmost() = _S_maximum(_M_root());
	    _M_impl._M_node_count = __x._M_impl._M_node_count;
	  }
      }

#if __cplusplus >= 201103L
      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Compare(), _Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
	if (__x._M_root() != nullptr)
	  {
	    _M_root() = _M_copy(__x._M_begin(), _M_end());
	    _M_leftmost() = _S_minimum(_M_root());
	    _M_rightmost() = _S_maximum(_M_root());
	    _M_impl._M_node_count = __x._M_impl._M_node_count;
	  }
      }

      _Rb_tree(_Rb_tree&& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
	if (__x._M_root() != 0)
	  _M_move_data(__x, std::true_type());
      }

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);
#endif
# 856 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

      ~_Rb_tree() _GLIBCXX_NOEXCEPT
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);

      // Accessors.
      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() _GLIBCXX_NOEXCEPT
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(begin()); }

      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const _GLIBCXX_NOEXCEPT 
      { return _M_impl._M_node_count; }

      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void
#if __cplusplus >= 201103L
      swap(_Rb_tree& __t) noexcept(_Alloc_traits::_S_nothrow_swap());
#else
# 916 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      swap(_Rb_tree& __t);
#endif
# 918 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

      // Insert/erase.
#if __cplusplus >= 201103L
      template<typename _Arg>
        pair<iterator, bool>
        _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
        iterator
        _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
        iterator
	_M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
	iterator
	_M_insert_unique_(const_iterator __pos, _Arg&& __x)
	{
	  _Alloc_node __an(*this);
	  return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
	}

      template<typename _Arg, typename _NodeGen>
	iterator
	_M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
	iterator
	_M_insert_equal_(const_iterator __pos, _Arg&& __x)
	{
	  _Alloc_node __an(*this);
	  return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
	}

      template<typename... _Args>
	pair<iterator, bool>
	_M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
	iterator
	_M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
	iterator
	_M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
	iterator
	_M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
#else
# 969 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      template<typename _NodeGen>
	iterator
	_M_insert_unique_(const_iterator __pos, const value_type& __x,
			  _NodeGen&);

      iterator
      _M_insert_unique_(const_iterator __pos, const value_type& __x)
      {
	_Alloc_node __an(*this);
	return _M_insert_unique_(__pos, __x, __an);
      }

      template<typename _NodeGen>
	iterator
	_M_insert_equal_(const_iterator __pos, const value_type& __x,
			 _NodeGen&);
      iterator
      _M_insert_equal_(const_iterator __pos, const value_type& __x)
      {
	_Alloc_node __an(*this);
	return _M_insert_equal_(__pos, __x, __an);
      }
#endif
# 998 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:
#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(const_iterator __position)
      {
	const_iterator __result = __position;
	++__result;
	_M_erase_aux(__position);
	return __result._M_const_cast();
      }

      // LWG 2059.
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(iterator __position)
      {
	iterator __result = __position;
	++__result;
	_M_erase_aux(__position);
	return __result;
      }
#else
# 1039 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      void
      erase(iterator __position)
      { _M_erase_aux(__position); }

      void
      erase(const_iterator __position)
      { _M_erase_aux(__position); }
#endif
# 1047 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
	_M_erase_aux(__first, __last);
	return __last._M_const_cast();
      }
#else
# 1061 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_erase_aux(__first, __last); }

      void
      erase(const_iterator __first, const_iterator __last)
      { _M_erase_aux(__first, __last); }
#endif
# 1069 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear() _GLIBCXX_NOEXCEPT
      {
        _M_erase(_M_begin());
	_M_impl._M_reset();
      }

      // Set operations.
      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

#if __cplusplus > 201103L
      template<typename _Cmp, typename _Kt, typename = __void_t<>>
	struct __is_transparent { };

      template<typename _Cmp, typename _Kt>
	struct
	__is_transparent<_Cmp, _Kt, __void_t<typename _Cmp::is_transparent>>
	{ typedef void type; };

      static auto _S_iter(_Link_type __x) { return iterator(__x); }

      static auto _S_iter(_Const_Link_type __x) { return const_iterator(__x); }

      template<typename _Cmp, typename _Link, typename _Kt>
	static auto
	_S_lower_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)
	{
	  while (__x != 0)
	    if (!__cmp(_S_key(__x), __k))
	      __y = __x, __x = _S_left(__x);
	    else
	      __x = _S_right(__x);
	  return _S_iter(__y);
	}

      template<typename _Cmp, typename _Link, typename _Kt>
	static auto
	_S_upper_bound_tr(_Cmp& __cmp, _Link __x, _Link __y, const _Kt& __k)
	{
	  while (__x != 0)
	    if (__cmp(__k, _S_key(__x)))
	      __y = __x, __x = _S_left(__x);
	    else
	      __x = _S_right(__x);
	  return _S_iter(__y);
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	iterator
	_M_find_tr(const _Kt& __k)
	{
	  auto& __cmp = _M_impl._M_key_compare;
	  auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
	  return (__j == end() || __cmp(__k, _S_key(__j._M_node)))
	    ? end() : __j;
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	const_iterator
	_M_find_tr(const _Kt& __k) const
	{
	  auto& __cmp = _M_impl._M_key_compare;
	  auto __j = _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
	  return (__j == end() || __cmp(__k, _S_key(__j._M_node)))
	    ? end() : __j;
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	size_type
	_M_count_tr(const _Kt& __k) const
	{
	  auto __p = _M_equal_range_tr(__k);
	  return std::distance(__p.first, __p.second);
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	iterator
	_M_lower_bound_tr(const _Kt& __k)
	{
	  auto& __cmp = _M_impl._M_key_compare;
	  return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	const_iterator
	_M_lower_bound_tr(const _Kt& __k) const
	{
	  auto& __cmp = _M_impl._M_key_compare;
	  return _S_lower_bound_tr(__cmp, _M_begin(), _M_end(), __k);
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	iterator
	_M_upper_bound_tr(const _Kt& __k)
	{
	  auto& __cmp = _M_impl._M_key_compare;
	  return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	const_iterator
	_M_upper_bound_tr(const _Kt& __k) const
	{
	  auto& __cmp = _M_impl._M_key_compare;
	  return _S_upper_bound_tr(__cmp, _M_begin(), _M_end(), __k);
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	pair<iterator, iterator>
	_M_equal_range_tr(const _Kt& __k)
	{
	  auto __low = _M_lower_bound_tr(__k);
	  auto __high = __low;
	  auto& __cmp = _M_impl._M_key_compare;
	  while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
	    ++__high;
	  return { __low, __high };
	}

      template<typename _Kt,
	       typename _Req = typename __is_transparent<_Compare, _Kt>::type>
	pair<const_iterator, const_iterator>
	_M_equal_range_tr(const _Kt& __k) const
	{
	  auto __low = _M_lower_bound_tr(__k);
	  auto __high = __low;
	  auto& __cmp = _M_impl._M_key_compare;
	  while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
	    ++__high;
	  return { __low, __high };
	}
#endif
# 1241 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

      // Debugging.
      bool
      __rb_verify() const;

#if __cplusplus >= 201103L
      _Rb_tree&
      operator=(_Rb_tree&&) noexcept(_Alloc_traits::_S_nothrow_move());

      template<typename _Iterator>
	void
	_M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
	void
	_M_assign_equal(_Iterator, _Iterator);

    private:
      // Move elements from container with equal allocator.
      void
      _M_move_data(_Rb_tree&, std::true_type);

      // Move elements from container with possibly non-equal allocator,
      // which might result in a copy not a move.
      void
      _M_move_data(_Rb_tree&, std::false_type);
#endif
# 1268 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
	     && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(), 
					  __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
	 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

#if __cplusplus >= 201103L
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
    {
      using __eq = integral_constant<bool, _Alloc_traits::_S_always_equal()>;
      if (__x._M_root() != nullptr)
	_M_move_data(__x, __eq());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::true_type)
    {
      _M_root() = __x._M_root();
      _M_leftmost() = __x._M_leftmost();
      _M_rightmost() = __x._M_rightmost();
      _M_root()->_M_parent = _M_end();

      __x._M_root() = 0;
      __x._M_leftmost() = __x._M_end();
      __x._M_rightmost() = __x._M_end();

      this->_M_impl._M_node_count = __x._M_impl._M_node_count;
      __x._M_impl._M_node_count = 0;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, std::false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
	  _M_move_data(__x, std::true_type());
      else
	{
	  _Alloc_node __an(*this);
	  auto __lbd =
	    [&__an](const value_type& __cval)
	    {
	      auto& __val = const_cast<value_type&>(__cval);
	      return __an(std::move_if_noexcept(__val));
	    };
	  _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
	  _M_leftmost() = _S_minimum(_M_root());
	  _M_rightmost() = _S_maximum(_M_root());
	  _M_impl._M_node_count = __x._M_impl._M_node_count;
	}
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move())
    {
      _M_impl._M_key_compare = __x._M_impl._M_key_compare;
      if (_Alloc_traits::_S_propagate_on_move_assign()
	  || _Alloc_traits::_S_always_equal()
	  || _M_get_Node_allocator() == __x._M_get_Node_allocator())
	{
	  clear();
	  if (__x._M_root() != nullptr)
	    _M_move_data(__x, std::true_type());
	  std::__alloc_on_move(_M_get_Node_allocator(),
			       __x._M_get_Node_allocator());
	  return *this;
	}

      // Try to move each node reusing existing nodes and copying __x nodes
      // structure.
      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
	{
	  auto __lbd =
	    [&__roan](const value_type& __cval)
	    {
	      auto& __val = const_cast<value_type&>(__cval);
	      return __roan(std::move_if_noexcept(__val));
	    };
	  _M_root() = _M_copy(__x._M_begin(), _M_end(), __lbd);
	  _M_leftmost() = _S_minimum(_M_root());
	  _M_rightmost() = _S_maximum(_M_root());
	  _M_impl._M_node_count = __x._M_impl._M_node_count;
	  __x.clear();
	}
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
	_Reuse_or_alloc_node __roan(*this);
	_M_impl._M_reset();
	for (; __first != __last; ++__first)
	  _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
	_Reuse_or_alloc_node __roan(*this);
	_M_impl._M_reset();
	for (; __first != __last; ++__first)
	  _M_insert_equal_(end(), *__first, __roan);
      }
#endif
# 1447 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
	{
	  // Note that _Key may be a constant type.
#if __cplusplus >= 201103L
	  if (_Alloc_traits::_S_propagate_on_copy_assign())
	    {
	      auto& __this_alloc = this->_M_get_Node_allocator();
	      auto& __that_alloc = __x._M_get_Node_allocator();
	      if (!_Alloc_traits::_S_always_equal()
		  && __this_alloc != __that_alloc)
		{
		  // Replacement allocator cannot free existing storage, we need
		  // to erase nodes first.
		  clear();
		  std::__alloc_on_copy(__this_alloc, __that_alloc);
		}
	    }
#endif
# 1472 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

	  _Reuse_or_alloc_node __roan(*this);
	  _M_impl._M_reset();
	  _M_impl._M_key_compare = __x._M_impl._M_key_compare;
	  if (__x._M_root() != 0)
	    {
	      _M_root() = _M_copy(__x._M_begin(), _M_end(), __roan);
	      _M_leftmost() = _S_minimum(_M_root());
	      _M_rightmost() = _S_maximum(_M_root());
	      _M_impl._M_node_count = __x._M_impl._M_node_count;
	    }
	}

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename _Arg, typename _NodeGen>
#else
# 1493 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    template<typename _NodeGen>
#endif
# 1495 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,
#if __cplusplus >= 201103L
		 _Arg&& __v,
#else
# 1501 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
		 const _Val& __v,
#endif
# 1503 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
		 _NodeGen& __node_gen)
      {
	bool __insert_left = (__x != 0 || __p == _M_end()
			      || _M_impl._M_key_compare(_KeyOfValue()(__v),
							_S_key(__p)));

	_Link_type __z = __node_gen(_GLIBCXX_FORWARD(_Arg, __v));

	_Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
				      this->_M_impl._M_header);
	++_M_impl._M_node_count;
	return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename _Arg>
#endif
# 1522 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
#if __cplusplus >= 201103L
    _M_insert_lower(_Base_ptr __p, _Arg&& __v)
#else
# 1527 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    _M_insert_lower(_Base_ptr __p, const _Val& __v)
#endif
# 1529 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    {
      bool __insert_left = (__p == _M_end()
			    || !_M_impl._M_key_compare(_S_key(__p),
						       _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
				    this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename _Arg>
#endif
# 1547 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
#if __cplusplus >= 201103L
    _M_insert_equal_lower(_Arg&& __v)
#else
# 1552 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    _M_insert_equal_lower(const _Val& __v)
#endif
# 1554 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
	{
	  __y = __x;
	  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
	        _S_left(__x) : _S_right(__x);
	}
      return _M_insert_lower(__y, _GLIBCXX_FORWARD(_Arg, __v));
    }

  template<typename _Key, typename _Val, typename _KoV,
	   typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Link_type __p, _NodeGen& __node_gen)
      {
	// Structural copy. __x and __p must be non-null.
	_Link_type __top = _M_clone_node(__x, __node_gen);
	__top->_M_parent = __p;

	__try
	  {
	    if (__x->_M_right)
	      __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
	    __p = __top;
	    __x = _S_left(__x);

	    while (__x != 0)
	      {
		_Link_type __y = _M_clone_node(__x, __node_gen);
		__p->_M_left = __y;
		__y->_M_parent = __p;
		if (__x->_M_right)
		  __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
		__p = __y;
		__x = _S_left(__x);
	      }
	  }
	__catch(...)
	  {
	    _M_erase(__top);
	    __throw_exception_again;
	  }
	return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {
      // Erase without rebalancing.
      while (__x != 0)
	{
	  _M_erase(_S_right(__x));
	  _Link_type __y = _S_left(__x);
	  _M_drop_node(__x);
	  __x = __y;
	}
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
	else
	  __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
		   const _Key& __k) const
    {
      while (__x != 0)
	if (!_M_impl._M_key_compare(_S_key(__x), __k))
	  __y = __x, __x = _S_left(__x);
	else
	  __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
		   const _Key& __k)
    {
      while (__x != 0)
	if (_M_impl._M_key_compare(__k, _S_key(__x)))
	  __y = __x, __x = _S_left(__x);
	else
	  __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
		   const _Key& __k) const
    {
      while (__x != 0)
	if (_M_impl._M_key_compare(__k, _S_key(__x)))
	  __y = __x, __x = _S_left(__x);
	else
	  __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::iterator,
	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
	{
	  if (_M_impl._M_key_compare(_S_key(__x), __k))
	    __x = _S_right(__x);
	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
	    __y = __x, __x = _S_left(__x);
	  else
	    {
	      _Link_type __xu(__x), __yu(__y);
	      __y = __x, __x = _S_left(__x);
	      __xu = _S_right(__xu);
	      return pair<iterator,
		          iterator>(_M_lower_bound(__x, __y, __k),
				    _M_upper_bound(__xu, __yu, __k));
	    }
	}
      return pair<iterator, iterator>(iterator(__y),
				      iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::const_iterator,
	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
	{
	  if (_M_impl._M_key_compare(_S_key(__x), __k))
	    __x = _S_right(__x);
	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
	    __y = __x, __x = _S_left(__x);
	  else
	    {
	      _Const_Link_type __xu(__x), __yu(__y);
	      __y = __x, __x = _S_left(__x);
	      __xu = _S_right(__xu);
	      return pair<const_iterator,
		          const_iterator>(_M_lower_bound(__x, __y, __k),
					  _M_upper_bound(__xu, __yu, __k));
	    }
	}
      return pair<const_iterator, const_iterator>(const_iterator(__y),
						  const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
#if __cplusplus >= 201103L
    noexcept(_Alloc_traits::_S_nothrow_swap())
#endif
# 1753 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    {
      if (_M_root() == 0)
	{
	  if (__t._M_root() != 0)
	    {
	      _M_root() = __t._M_root();
	      _M_leftmost() = __t._M_leftmost();
	      _M_rightmost() = __t._M_rightmost();
	      _M_root()->_M_parent = _M_end();
	      _M_impl._M_node_count = __t._M_impl._M_node_count;
	      
	      __t._M_impl._M_reset();
	    }
	}
      else if (__t._M_root() == 0)
	{
	  __t._M_root() = _M_root();
	  __t._M_leftmost() = _M_leftmost();
	  __t._M_rightmost() = _M_rightmost();
	  __t._M_root()->_M_parent = __t._M_end();
	  __t._M_impl._M_node_count = _M_impl._M_node_count;
	  
	  _M_impl._M_reset();
	}
      else
	{
	  std::swap(_M_root(),__t._M_root());
	  std::swap(_M_leftmost(),__t._M_leftmost());
	  std::swap(_M_rightmost(),__t._M_rightmost());
	  
	  _M_root()->_M_parent = _M_end();
	  __t._M_root()->_M_parent = __t._M_end();
	  std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
	}
      // No need to swap header's color as it does not change.
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
				__t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr,
	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
	{
	  __y = __x;
	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
	  __x = __comp ? _S_left(__x) : _S_right(__x);
	}
      iterator __j = iterator(__y);
      if (__comp)
	{
	  if (__j == begin())
	    return _Res(__x, __y);
	  else
	    --__j;
	}
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
	return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr,
	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
	{
	  __y = __x;
	  __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
	        _S_left(__x) : _S_right(__x);
	}
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename _Arg>
#endif
# 1852 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
#if __cplusplus >= 201103L
    _M_insert_unique(_Arg&& __v)
#else
# 1858 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    _M_insert_unique(const _Val& __v)
#endif
# 1860 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
	= _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
	{
	  _Alloc_node __an(*this);
	  return _Res(_M_insert_(__res.first, __res.second,
				 _GLIBCXX_FORWARD(_Arg, __v), __an),
		      true);
	}

      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename _Arg>
#endif
# 1881 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
#if __cplusplus >= 201103L
    _M_insert_equal(_Arg&& __v)
#else
# 1886 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    _M_insert_equal(const _Val& __v)
#endif
# 1888 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    {
      pair<_Base_ptr, _Base_ptr> __res
	= _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
			_GLIBCXX_FORWARD(_Arg, __v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
				  const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;

      // end()
      if (__pos._M_node == _M_end())
	{
	  if (size() > 0
	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
	    return _Res(0, _M_rightmost());
	  else
	    return _M_get_insert_unique_pos(__k);
	}
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
	{
	  // First, try before...
	  iterator __before = __pos;
	  if (__pos._M_node == _M_leftmost()) // begin()
	    return _Res(_M_leftmost(), _M_leftmost());
	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
	    {
	      if (_S_right(__before._M_node) == 0)
		return _Res(0, __before._M_node);
	      else
		return _Res(__pos._M_node, __pos._M_node);
	    }
	  else
	    return _M_get_insert_unique_pos(__k);
	}
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
	{
	  // ... then try after.
	  iterator __after = __pos;
	  if (__pos._M_node == _M_rightmost())
	    return _Res(0, _M_rightmost());
	  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
	    {
	      if (_S_right(__pos._M_node) == 0)
		return _Res(0, __pos._M_node);
	      else
		return _Res(__after._M_node, __after._M_node);
	    }
	  else
	    return _M_get_insert_unique_pos(__k);
	}
      else
	// Equivalent keys.
	return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename _Arg, typename _NodeGen>
#else
# 1960 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    template<typename _NodeGen>
#endif
# 1962 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,
#if __cplusplus >= 201103L
			_Arg&& __v,
#else
# 1968 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
			const _Val& __v,
#endif
# 1970 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
			_NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
	= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
	return _M_insert_(__res.first, __res.second,
			  _GLIBCXX_FORWARD(_Arg, __v),
			  __node_gen);
      return iterator(static_cast<_Link_type>(__res.first));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr,
         typename _Rb_tree<_Key, _Val, _KeyOfValue,
			   _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;

      // end()
      if (__pos._M_node == _M_end())
	{
	  if (size() > 0
	      && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
	    return _Res(0, _M_rightmost());
	  else
	    return _M_get_insert_equal_pos(__k);
	}
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
	{
	  // First, try before...
	  iterator __before = __pos;
	  if (__pos._M_node == _M_leftmost()) // begin()
	    return _Res(_M_leftmost(), _M_leftmost());
	  else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
	    {
	      if (_S_right(__before._M_node) == 0)
		return _Res(0, __before._M_node);
	      else
		return _Res(__pos._M_node, __pos._M_node);
	    }
	  else
	    return _M_get_insert_equal_pos(__k);
	}
      else
	{
	  // ... then try after.  
	  iterator __after = __pos;
	  if (__pos._M_node == _M_rightmost())
	    return _Res(0, _M_rightmost());
	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
	    {
	      if (_S_right(__pos._M_node) == 0)
		return _Res(0, __pos._M_node);
	      else
		return _Res(__after._M_node, __after._M_node);
	    }
	  else
	    return _Res(0, 0);
	}
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename _Arg, typename _NodeGen>
#else
# 2042 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
    template<typename _NodeGen>
#endif
# 2044 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,
#if __cplusplus >= 201103L
		       _Arg&& __v,
#else
# 2050 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
		       const _Val& __v,
#endif
# 2052 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
		       _NodeGen& __node_gen)
      {
	pair<_Base_ptr, _Base_ptr> __res
	  = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

	if (__res.second)
	  return _M_insert_(__res.first, __res.second,
			    _GLIBCXX_FORWARD(_Arg, __v),
			    __node_gen);

	return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));
      }

#if __cplusplus >= 201103L
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
			    || _M_impl._M_key_compare(_S_key(__z),
						      _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
				    this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
			    || !_M_impl._M_key_compare(_S_key(__p),
						       _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
				    this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
	{
	  __y = __x;
	  __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
	        _S_left(__x) : _S_right(__x);
	}
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
			     _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    typedef pair<iterator, bool> _Res;
	    auto __res = _M_get_insert_unique_pos(_S_key(__z));
	    if (__res.second)
	      return _Res(_M_insert_node(__res.first, __res.second, __z), true);
	
	    _M_drop_node(__z);
	    return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
	  }
	__catch(...)
	  {
	    _M_drop_node(__z);
	    __throw_exception_again;
	  }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_equal_pos(_S_key(__z));
	    return _M_insert_node(__res.first, __res.second, __z);
	  }
	__catch(...)
	  {
	    _M_drop_node(__z);
	    __throw_exception_again;
	  }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

	    if (__res.second)
	      return _M_insert_node(__res.first, __res.second, __z);

	    _M_drop_node(__z);
	    return iterator(static_cast<_Link_type>(__res.first));
	  }
	__catch(...)
	  {
	    _M_drop_node(__z);
	    __throw_exception_again;
	  }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

	__try
	  {
	    auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

	    if (__res.second)
	      return _M_insert_node(__res.first, __res.second, __z);

	    return _M_insert_equal_lower_node(__z);
	  }
	__catch(...)
	  {
	    _M_drop_node(__z);
	    __throw_exception_again;
	  }
      }
#endif
# 2214 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
	_Alloc_node __an(*this);
	for (; __first != __last; ++__first)
	  _M_insert_unique_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
	_Alloc_node __an(*this);
	for (; __first != __last; ++__first)
	  _M_insert_equal_(end(), *__first, __an);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
				(const_cast<_Base_ptr>(__position._M_node),
				 this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
	clear();
      else
	while (__first != __last)
	  erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
	erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
	      || _M_impl._M_key_compare(__k,
					_S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
		      _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
	      || _M_impl._M_key_compare(__k, 
					_S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  _GLIBCXX_PURE unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
	return _M_impl._M_node_count == 0 && begin() == end()
	       && this->_M_impl._M_header._M_left == _M_end()
	       && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
	{
	  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
	  _Const_Link_type __L = _S_left(__x);
	  _Const_Link_type __R = _S_right(__x);

	  if (__x->_M_color == _S_red)
	    if ((__L && __L->_M_color == _S_red)
		|| (__R && __R->_M_color == _S_red))
	      return false;

	  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
	    return false;
	  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
	    return false;

	  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
	    return false;
	}

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
	return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
	return false;
      return true;
    }

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif
# 2371 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_tree.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_map.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 1 3
// Map implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_map.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map}
 */

#ifndef _STL_MAP_H
#define _STL_MAP_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/functexcept.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <tuple>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
#endif
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /**
   *  @brief A standard container made up of (key,value) pairs, which can be
   *  retrieved based on a key, in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam  _Tp  Type of mapped objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to 
   *                  allocator<pair<const _Key, _Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using unique keys).
   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the
   *  value_type is std::pair<const Key,T>.
   *
   *  Maps support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for map and
   *  multimap; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  */
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key                                          key_type;
      typedef _Tp                                           mapped_type;
      typedef std::pair<const _Key, _Tp>                    value_type;
      typedef _Compare                                      key_compare;
      typedef _Alloc                                        allocator_type;

    private:
      // concept requirements
      typedef typename _Alloc::value_type                   _Alloc_value_type;
      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
				_BinaryFunctionConcept)
      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
	friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
	_Compare comp;

	value_compare(_Compare __c)
	: comp(__c) { }

      public:
	bool operator()(const value_type& __x, const value_type& __y) const
	{ return comp(__x.first, __y.first); }
      };

    private:
      /// This turns a red-black tree into a [multi]map. 
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
	rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
		       key_compare, _Pair_alloc_type> _Rep_type;

      /// The actual tree structure.
      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:
      // many of these are specified differently in ISO, but the following are
      // "functionally equivalent"
      typedef typename _Alloc_traits::pointer            pointer;
      typedef typename _Alloc_traits::const_pointer      const_pointer;
      typedef typename _Alloc_traits::reference          reference;
      typedef typename _Alloc_traits::const_reference    const_reference;
      typedef typename _Rep_type::iterator               iterator;
      typedef typename _Rep_type::const_iterator         const_iterator;
      typedef typename _Rep_type::size_type              size_type;
      typedef typename _Rep_type::difference_type        difference_type;
      typedef typename _Rep_type::reverse_iterator       reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;

      // [23.3.1.1] construct/copy/destroy
      // (get_allocator() is also listed in this section)

      /**
       *  @brief  Default constructor creates no elements.
       */
      map()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
#endif
# 166 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      : _M_t() { }

      /**
       *  @brief  Creates a %map with no elements.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       */
      explicit
      map(const _Compare& __comp,
	  const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }

      /**
       *  @brief  %Map copy constructor.
       *  @param  __x  A %map of identical element and allocator types.
       *
       *  The newly-created %map uses a copy of the allocation object
       *  used by @a __x.
       */
      map(const map& __x)
      : _M_t(__x._M_t) { }

#if __cplusplus >= 201103L
      /**
       *  @brief  %Map move constructor.
       *  @param  __x  A %map of identical element and allocator types.
       *
       *  The newly-created %map contains the exact contents of @a __x.
       *  The contents of @a __x are a valid, but unspecified %map.
       */
      map(map&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }

      /**
       *  @brief  Builds a %map from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       *
       *  Create a %map consisting of copies of the elements in the
       *  initializer_list @a __l.
       *  This is linear in N if the range is already sorted, and NlogN
       *  otherwise (where N is @a __l.size()).
       */
      map(initializer_list<value_type> __l,
	  const _Compare& __comp = _Compare(),
	  const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }

      /// Allocator-extended default constructor.
      explicit
      map(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }

      /// Allocator-extended copy constructor.
      map(const map& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }

      /// Allocator-extended move constructor.
      map(map&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
	       && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }

      /// Allocator-extended initialier-list constructor.
      map(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }

      /// Allocator-extended range constructor.
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
	    const allocator_type& __a)
	: _M_t(_Compare(), _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
#endif
# 244 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      /**
       *  @brief  Builds a %map from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %map consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       */
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
	: _M_t()
        { _M_t._M_insert_unique(__first, __last); }

      /**
       *  @brief  Builds a %map from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %map consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       */
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
	    const _Compare& __comp,
	    const allocator_type& __a = allocator_type())
	: _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }

      // FIXME There is no dtor declared, but we should have something
      // generated by Doxygen.  I don't know what tags to add to this
      // paragraph to make that happen:
      /**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       */

      /**
       *  @brief  %Map assignment operator.
       *  @param  __x  A %map of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but unlike the copy
       *  constructor, the allocator object is not copied.
       */
      map&
      operator=(const map& __x)
      {
	_M_t = __x._M_t;
	return *this;
      }

#if __cplusplus >= 201103L
      /// Move assignment operator.
      map&
      operator=(map&&) = default;

      /**
       *  @brief  %Map list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %map with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %map and
       *  that the resulting %map's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
      map&
      operator=(initializer_list<value_type> __l)
      {
	_M_t._M_assign_unique(__l.begin(), __l.end());
	return *this;
      }
#endif
# 325 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      /// Get a copy of the memory allocation object.
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_t.get_allocator()); }

      // iterators
      /**
       *  Returns a read/write iterator that points to the first pair in the
       *  %map.
       *  Iteration is done in ascending order according to the keys.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points to the first pair
       *  in the %map.  Iteration is done in ascending order according to the
       *  keys.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return _M_t.begin(); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  pair in the %map.  Iteration is done in ascending order
       *  according to the keys.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  pair in the %map.  Iteration is done in ascending order according to
       *  the keys.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return _M_t.end(); }

      /**
       *  Returns a read/write reverse iterator that points to the last pair in
       *  the %map.  Iteration is done in descending order according to the
       *  keys.
       */
      reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %map.  Iteration is done in descending order
       *  according to the keys.
       */
      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return _M_t.rbegin(); }

      /**
       *  Returns a read/write reverse iterator that points to one before the
       *  first pair in the %map.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return _M_t.rend(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first pair in the %map.  Iteration is done in descending
       *  order according to the keys.
       */
      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return _M_t.rend(); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the first pair
       *  in the %map.  Iteration is done in ascending order according to the
       *  keys.
       */
      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  pair in the %map.  Iteration is done in ascending order according to
       *  the keys.
       */
      const_iterator
      cend() const noexcept
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %map.  Iteration is done in descending order
       *  according to the keys.
       */
      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first pair in the %map.  Iteration is done in descending
       *  order according to the keys.
       */
      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }
#endif
# 441 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      // capacity
      /** Returns true if the %map is empty.  (Thus begin() would equal
       *  end().)
      */
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return _M_t.empty(); }

      /** Returns the size of the %map.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_t.size(); }

      /** Returns the maximum size of the %map.  */
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _M_t.max_size(); }

      // [23.3.1.2] element access
      /**
       *  @brief  Subscript ( @c [] ) access to %map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data of the (key,data) %pair.
       *
       *  Allows for easy lookup with the subscript ( @c [] )
       *  operator.  Returns data associated with the key specified in
       *  subscript.  If the key does not exist, a pair with that key
       *  is created using default values, which is then returned.
       *
       *  Lookup requires logarithmic time.
       */
      mapped_type&
      operator[](const key_type& __k)
      {
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
#if __cplusplus >= 201103L
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
					    std::tuple<const key_type&>(__k),
					    std::tuple<>());
#else
# 487 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
          __i = insert(__i, value_type(__k, mapped_type()));
#endif
# 489 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
	return (*__i).second;
      }

#if __cplusplus >= 201103L
      mapped_type&
      operator[](key_type&& __k)
      {
	// concept requirements
	__glibcxx_function_requires(_DefaultConstructibleConcept<mapped_type>)

	iterator __i = lower_bound(__k);
	// __i->first is greater than or equivalent to __k.
	if (__i == end() || key_comp()(__k, (*__i).first))
	  __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
					std::forward_as_tuple(std::move(__k)),
					std::tuple<>());
	return (*__i).second;
      }
#endif
# 508 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 464. Suggestion for new member functions in standard containers.
      /**
       *  @brief  Access to %map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data whose key is equivalent to @a __k, if
       *           such a data is present in the %map.
       *  @throw  std::out_of_range  If no such data is present.
       */
      mapped_type&
      at(const key_type& __k)
      {
	iterator __i = lower_bound(__k);
	if (__i == end() || key_comp()(__k, (*__i).first))
	  __throw_out_of_range(__N("map::at"));
	return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
	const_iterator __i = lower_bound(__k);
	if (__i == end() || key_comp()(__k, (*__i).first))
	  __throw_out_of_range(__N("map::at"));
	return (*__i).second;
      }

      // modifiers
#if __cplusplus >= 201103L
      /**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param __args  Arguments used to generate a new pair instance (see
       *	        std::piecewise_contruct for passing arguments to each
       *	        part of the pair constructor).
       *
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted pair, and the second is a bool that
       *           is true if the pair was actually inserted.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *
       *  Insertion requires logarithmic time.
       */
      template<typename... _Args>
	std::pair<iterator, bool>
	emplace(_Args&&... __args)
	{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }

      /**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param  __pos  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param  __args  Arguments used to generate a new pair instance (see
       *	         std::piecewise_contruct for passing arguments to each
       *	         part of the pair constructor).
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args (may or may not be that
       *          std::pair).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      template<typename... _Args>
	iterator
	emplace_hint(const_iterator __pos, _Args&&... __args)
	{
	  return _M_t._M_emplace_hint_unique(__pos,
					     std::forward<_Args>(__args)...);
	}
#endif
# 594 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      /**
       *  @brief Attempts to insert a std::pair into the %map.

       *  @param __x Pair to be inserted (see std::make_pair for easy
       *	     creation of pairs).
       *
       *  @return  A pair, of which the first element is an iterator that 
       *           points to the possibly inserted pair, and the second is 
       *           a bool that is true if the pair was actually inserted.
       *
       *  This function attempts to insert a (key, value) %pair into the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *
       *  Insertion requires logarithmic time.
       */
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }

#if __cplusplus >= 201103L
      template<typename _Pair, typename = typename
	       std::enable_if<std::is_constructible<value_type,
						    _Pair&&>::value>::type>
        std::pair<iterator, bool>
        insert(_Pair&& __x)
        { return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }
#endif
# 623 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief Attempts to insert a list of std::pairs into the %map.
       *  @param  __list  A std::initializer_list<value_type> of pairs to be
       *                  inserted.
       *
       *  Complexity similar to that of the range constructor.
       */
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
#endif
# 636 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      /**
       *  @brief Attempts to insert a std::pair into the %map.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                    pair should be inserted.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *               of pairs).
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *

       *  This function is not concerned about whether the insertion
       *  took place, and thus does not return a boolean like the
       *  single-argument insert() does.  Note that the first
       *  parameter is only a hint and can potentially improve the
       *  performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      iterator
#if __cplusplus >= 201103L
      insert(const_iterator __position, const value_type& __x)
#else
# 664 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      insert(iterator __position, const value_type& __x)
#endif
# 666 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      { return _M_t._M_insert_unique_(__position, __x); }

#if __cplusplus >= 201103L
      template<typename _Pair, typename = typename
	       std::enable_if<std::is_constructible<value_type,
						    _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_unique_(__position,
					std::forward<_Pair>(__x)); }
#endif
# 677 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      /**
       *  @brief Template function that attempts to insert a range of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       */
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases an element from a %map.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a position prior to the element being erased. If no such 
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given
       *  iterator, from a %map.  Note that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }

      // LWG 2059
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
#else
# 717 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      /**
       *  @brief Erases an element from a %map.
       *  @param  __position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given
       *  iterator, from a %map.  Note that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#endif
# 731 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      /**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases a [first,last) range of elements from a %map.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
#else
# 767 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      /**
       *  @brief Erases a [__first,__last) range of elements from a %map.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *
       *  This function erases a sequence of elements from a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#endif
# 783 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3

      /**
       *  @brief  Swaps data with another %map.
       *  @param  __x  A %map of the same element and allocator types.
       *
       *  This exchanges the elements between two maps in constant
       *  time.  (It is only swapping a pointer, an integer, and an
       *  instance of the @c Compare type (which itself is often
       *  stateless and empty), so it should be quite fast.)  Note
       *  that the global std::swap() function is specialized such
       *  that std::swap(m1,m2) will feed to this function.
       */
      void
      swap(map& __x)
#if __cplusplus >= 201103L
      noexcept(_Alloc_traits::_S_nothrow_swap())
#endif
# 800 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      { _M_t.swap(__x._M_t); }

      /**
       *  Erases all elements in a %map.  Note that this function only
       *  erases the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      { _M_t.clear(); }

      // observers
      /**
       *  Returns the key comparison object out of which the %map was
       *  constructed.
       */
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      /**
       *  Returns a value comparison object, built from the key comparison
       *  object out of which the %map was constructed.
       */
      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }

      // [23.3.1.3] map operations

      //@{
      /**
       *  @brief Tries to locate an element in a %map.
       *  @param  __x  Key of (key, value) %pair to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */

      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }
#endif
# 854 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief Tries to locate an element in a %map.
       *  @param  __x  Key of (key, value) %pair to be located.
       *  @return  Read-only (constant) iterator pointing to sought-after
       *           element, or end() if not found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns a constant
       *  iterator pointing to the sought after %pair. If unsuccessful it
       *  returns the past-the-end ( @c end() ) iterator.
       */

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }
#endif
# 879 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief  Finds the number of elements with given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for multimaps; for map the result will
       *  either be 0 (not present) or 1 (present).
       */
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
	{ return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }
#endif
# 900 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Iterator pointing to first element equal to or greater
       *           than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       */
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x)
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }
#endif
# 925 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first element
       *           equal to or greater than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       */
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x) const
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }
#endif
# 950 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return Iterator pointing to the first element
       *          greater than key, or end().
       */
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x)
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }
#endif
# 970 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first iterator
       *           greater than key, or end().
       */
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x) const
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }
#endif
# 990 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multimaps.
       */
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	equal_range(const _Kt& __x)
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }
#endif
# 1019 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      //@{
      /**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of read-only (constant) iterators that possibly points
       *           to the subsequence matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multimaps.
       */
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	equal_range(const _Kt& __x) const
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }
#endif
# 1048 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
      //@}

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
		   const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
		  const map<_K1, _T1, _C1, _A1>&);
    };

  /**
   *  @brief  Map equality comparison.
   *  @param  __x  A %map.
   *  @param  __y  A %map of the same type as @a x.
   *  @return  True iff the size and elements of the maps are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  maps.  Maps are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  */
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }

  /**
   *  @brief  Map ordering relation.
   *  @param  __x  A %map.
   *  @param  __y  A %map of the same type as @a x.
   *  @return  True iff @a x is lexicographically less than @a y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  maps.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }

  /// Based on operator==
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  /// Based on operator<
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }

  /// Based on operator<
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  /// Based on operator<
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  /// See std::map::swap().
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
	 map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif /* _STL_MAP_H */
# 1133 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_map.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_multimap.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 1 3
// Multimap implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_multimap.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map}
 */

#ifndef _STL_MULTIMAP_H
#define _STL_MULTIMAP_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
#endif
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /**
   *  @brief A standard container made up of (key,value) pairs, which can be
   *  retrieved based on a key, in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam  _Tp  Type of mapped objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to 
   *                  allocator<pair<const _Key, _Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using equivalent
   *  keys).  For a @c multimap<Key,T> the key_type is Key, the mapped_type
   *  is T, and the value_type is std::pair<const Key,T>.
   *
   *  Multimaps support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for map and
   *  multimap; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  */
  template <typename _Key, typename _Tp,
	    typename _Compare = std::less<_Key>,
	    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key                                          key_type;
      typedef _Tp                                           mapped_type;
      typedef std::pair<const _Key, _Tp>                    value_type;
      typedef _Compare                                      key_compare;
      typedef _Alloc                                        allocator_type;

    private:
      // concept requirements
      typedef typename _Alloc::value_type                   _Alloc_value_type;
      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
				_BinaryFunctionConcept)
      __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)

    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
	friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
	_Compare comp;

	value_compare(_Compare __c)
	: comp(__c) { }

      public:
	bool operator()(const value_type& __x, const value_type& __y) const
	{ return comp(__x.first, __y.first); }
      };

    private:
      /// This turns a red-black tree into a [multi]map.
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
	rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
		       key_compare, _Pair_alloc_type> _Rep_type;
      /// The actual tree structure.
      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:
      // many of these are specified differently in ISO, but the following are
      // "functionally equivalent"
      typedef typename _Alloc_traits::pointer            pointer;
      typedef typename _Alloc_traits::const_pointer      const_pointer;
      typedef typename _Alloc_traits::reference          reference;
      typedef typename _Alloc_traits::const_reference    const_reference;
      typedef typename _Rep_type::iterator               iterator;
      typedef typename _Rep_type::const_iterator         const_iterator;
      typedef typename _Rep_type::size_type              size_type;
      typedef typename _Rep_type::difference_type        difference_type;
      typedef typename _Rep_type::reverse_iterator       reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;

      // [23.3.2] construct/copy/destroy
      // (get_allocator() is also listed in this section)

      /**
       *  @brief  Default constructor creates no elements.
       */
      multimap()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
#endif
# 164 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      : _M_t() { }

      /**
       *  @brief  Creates a %multimap with no elements.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       */
      explicit
      multimap(const _Compare& __comp,
	       const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }

      /**
       *  @brief  %Multimap copy constructor.
       *  @param  __x  A %multimap of identical element and allocator types.
       *
       *  The newly-created %multimap uses a copy of the allocation object
       *  used by @a __x.
       */
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }

#if __cplusplus >= 201103L
      /**
       *  @brief  %Multimap move constructor.
       *  @param   __x  A %multimap of identical element and allocator types.
       *
       *  The newly-created %multimap contains the exact contents of @a __x.
       *  The contents of @a __x are a valid, but unspecified %multimap.
       */
      multimap(multimap&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }

      /**
       *  @brief  Builds a %multimap from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %multimap consisting of copies of the elements from
       *  the initializer_list.  This is linear in N if the list is already
       *  sorted, and NlogN otherwise (where N is @a __l.size()).
       */
      multimap(initializer_list<value_type> __l,
	       const _Compare& __comp = _Compare(),
	       const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }

      /// Allocator-extended default constructor.
      explicit
      multimap(const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }

      /// Allocator-extended copy constructor.
      multimap(const multimap& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }

      /// Allocator-extended move constructor.
      multimap(multimap&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
	       && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }

      /// Allocator-extended initialier-list constructor.
      multimap(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Pair_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }

      /// Allocator-extended range constructor.
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
		 const allocator_type& __a)
	: _M_t(_Compare(), _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
#endif
# 241 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      /**
       *  @brief  Builds a %multimap from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %multimap consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is already sorted,
       *  and NlogN otherwise (where N is distance(__first,__last)).
       */
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
	: _M_t()
        { _M_t._M_insert_equal(__first, __last); }

      /**
       *  @brief  Builds a %multimap from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %multimap consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is already sorted,
       *  and NlogN otherwise (where N is distance(__first,__last)).
       */
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
		 const _Compare& __comp,
		 const allocator_type& __a = allocator_type())
	: _M_t(__comp, _Pair_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }

      // FIXME There is no dtor declared, but we should have something generated
      // by Doxygen.  I don't know what tags to add to this paragraph to make
      // that happen:
      /**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       */

      /**
       *  @brief  %Multimap assignment operator.
       *  @param  __x  A %multimap of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but unlike the copy
       *  constructor, the allocator object is not copied.
       */
      multimap&
      operator=(const multimap& __x)
      {
	_M_t = __x._M_t;
	return *this;
      }

#if __cplusplus >= 201103L
      /// Move assignment operator.
      multimap&
      operator=(multimap&&) = default;

      /**
       *  @brief  %Multimap list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %multimap with copies of the elements
       *  in the initializer list @a __l.
       *
       *  Note that the assignment completely changes the %multimap and
       *  that the resulting %multimap's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
      multimap&
      operator=(initializer_list<value_type> __l)
      {
	_M_t._M_assign_equal(__l.begin(), __l.end());
	return *this;
      }
#endif
# 320 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      /// Get a copy of the memory allocation object.
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT 
      { return allocator_type(_M_t.get_allocator()); }

      // iterators
      /**
       *  Returns a read/write iterator that points to the first pair in the
       *  %multimap.  Iteration is done in ascending order according to the
       *  keys.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points to the first pair
       *  in the %multimap.  Iteration is done in ascending order according to
       *  the keys.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return _M_t.begin(); }

      /**
       *  Returns a read/write iterator that points one past the last pair in
       *  the %multimap.  Iteration is done in ascending order according to the
       *  keys.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  pair in the %multimap.  Iteration is done in ascending order according
       *  to the keys.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return _M_t.end(); }

      /**
       *  Returns a read/write reverse iterator that points to the last pair in
       *  the %multimap.  Iteration is done in descending order according to the
       *  keys.
       */
      reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %multimap.  Iteration is done in descending order
       *  according to the keys.
       */
      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return _M_t.rbegin(); }

      /**
       *  Returns a read/write reverse iterator that points to one before the
       *  first pair in the %multimap.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return _M_t.rend(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first pair in the %multimap.  Iteration is done in
       *  descending order according to the keys.
       */
      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return _M_t.rend(); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the first pair
       *  in the %multimap.  Iteration is done in ascending order according to
       *  the keys.
       */
      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  pair in the %multimap.  Iteration is done in ascending order according
       *  to the keys.
       */
      const_iterator
      cend() const noexcept
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %multimap.  Iteration is done in descending order
       *  according to the keys.
       */
      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first pair in the %multimap.  Iteration is done in
       *  descending order according to the keys.
       */
      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }
#endif
# 436 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      // capacity
      /** Returns true if the %multimap is empty.  */
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return _M_t.empty(); }

      /** Returns the size of the %multimap.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_t.size(); }

      /** Returns the maximum size of the %multimap.  */
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _M_t.max_size(); }

      // modifiers
#if __cplusplus >= 201103L
      /**
       *  @brief Build and insert a std::pair into the %multimap.
       *
       *  @param __args  Arguments used to generate a new pair instance (see
       *	        std::piecewise_contruct for passing arguments to each
       *	        part of the pair constructor).
       *
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function builds and inserts a (key, value) %pair into the
       *  %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *
       *  Insertion requires logarithmic time.
       */
      template<typename... _Args>
	iterator
	emplace(_Args&&... __args)
	{ return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }

      /**
       *  @brief Builds and inserts a std::pair into the %multimap.
       *
       *  @param  __pos  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param  __args  Arguments used to generate a new pair instance (see
       *	         std::piecewise_contruct for passing arguments to each
       *	         part of the pair constructor).
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function inserts a (key, value) pair into the %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      template<typename... _Args>
	iterator
	emplace_hint(const_iterator __pos, _Args&&... __args)
	{
	  return _M_t._M_emplace_hint_equal(__pos,
					    std::forward<_Args>(__args)...);
	}
#endif
# 506 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      /**
       *  @brief Inserts a std::pair into the %multimap.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *             of pairs).
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function inserts a (key, value) pair into the %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *
       *  Insertion requires logarithmic time.
       */
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }

#if __cplusplus >= 201103L
      template<typename _Pair, typename = typename
	       std::enable_if<std::is_constructible<value_type,
						    _Pair&&>::value>::type>
        iterator
        insert(_Pair&& __x)
        { return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }
#endif
# 531 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      /**
       *  @brief Inserts a std::pair into the %multimap.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                      pair should be inserted.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *               of pairs).
       *  @return An iterator that points to the inserted (key,value) pair.
       *
       *  This function inserts a (key, value) pair into the %multimap.
       *  Contrary to a std::map the %multimap does not rely on unique keys and
       *  thus multiple pairs with the same key can be inserted.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      iterator
#if __cplusplus >= 201103L
      insert(const_iterator __position, const value_type& __x)
#else
# 556 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      insert(iterator __position, const value_type& __x)
#endif
# 558 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      { return _M_t._M_insert_equal_(__position, __x); }

#if __cplusplus >= 201103L
      template<typename _Pair, typename = typename
	       std::enable_if<std::is_constructible<value_type,
						    _Pair&&>::value>::type>
        iterator
        insert(const_iterator __position, _Pair&& __x)
        { return _M_t._M_insert_equal_(__position,
				       std::forward<_Pair>(__x)); }
#endif
# 569 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      /**
       *  @brief A template function that attempts to insert a range
       *  of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       */
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }

#if __cplusplus >= 201103L
      /**
       *  @brief Attempts to insert a list of std::pairs into the %multimap.
       *  @param  __l  A std::initializer_list<value_type> of pairs to be
       *               inserted.
       *
       *  Complexity similar to that of the range constructor.
       */
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
#endif
# 596 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases an element from a %multimap.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a position prior to the element being erased. If no such 
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %multimap.  Note that this function only erases the element,
       *  and that if the element is itself a pointer, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }

      // LWG 2059.
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
#else
# 623 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      /**
       *  @brief Erases an element from a %multimap.
       *  @param  __position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %multimap.  Note that this function only erases the element,
       *  and that if the element is itself a pointer, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#endif
# 637 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      /**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all elements located by the given key from a
       *  %multimap.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases a [first,last) range of elements from a %multimap.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to be
       *                erased .
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from a %multimap.
       *  Note that this function only erases the elements, and that if
       *  the elements themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
#else
# 674 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases a [first,last) range of elements from a %multimap.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                 erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *
       *  This function erases a sequence of elements from a %multimap.
       *  Note that this function only erases the elements, and that if
       *  the elements themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#endif
# 693 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3

      /**
       *  @brief  Swaps data with another %multimap.
       *  @param  __x  A %multimap of the same element and allocator types.
       *
       *  This exchanges the elements between two multimaps in constant time.
       *  (It is only swapping a pointer, an integer, and an instance of
       *  the @c Compare type (which itself is often stateless and empty), so it
       *  should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(m1,m2) will feed to this function.
       */
      void
      swap(multimap& __x)
#if __cplusplus >= 201103L
      noexcept(_Alloc_traits::_S_nothrow_swap())
#endif
# 710 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      { _M_t.swap(__x._M_t); }

      /**
       *  Erases all elements in a %multimap.  Note that this function only
       *  erases the elements, and that if the elements themselves are pointers,
       *  the pointed-to memory is not touched in any way.  Managing the pointer
       *  is the user's responsibility.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      { _M_t.clear(); }

      // observers
      /**
       *  Returns the key comparison object out of which the %multimap
       *  was constructed.
       */
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      /**
       *  Returns a value comparison object, built from the key comparison
       *  object out of which the %multimap was constructed.
       */
      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }

      // multimap operations

      //@{
      /**
       *  @brief Tries to locate an element in a %multimap.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Iterator pointing to sought-after element,
       *           or end() if not found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }
#endif
# 763 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Tries to locate an element in a %multimap.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to sought-after
       *           element, or end() if not found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns a constant
       *  iterator pointing to the sought after %pair.  If unsuccessful it
       *  returns the past-the-end ( @c end() ) iterator.
       */
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }
#endif
# 787 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the number of elements with given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return Number of elements with specified key.
       */
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
	{ return _M_t._M_count_tr(__x); }
#endif
# 805 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Iterator pointing to first element equal to or greater
       *           than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       */
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x)
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }
#endif
# 830 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first element
       *           equal to or greater than key, or end().
       *
       *  This function returns the first element of a subsequence of
       *  elements that matches the given key.  If unsuccessful the
       *  iterator will point to the next greatest element or, if no
       *  such greater element exists, to end().
       */
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x) const
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }
#endif
# 855 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return Iterator pointing to the first element
       *          greater than key, or end().
       */
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x)
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }
#endif
# 875 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first iterator
       *           greater than key, or end().
       */
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x) const
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }
#endif
# 895 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       */
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	equal_range(const _Kt& __x)
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }
#endif
# 922 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      //@{
      /**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of read-only (constant) iterators that possibly points
       *           to the subsequence matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       */
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	equal_range(const _Kt& __x) const
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }
#endif
# 949 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
      //@}

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
		   const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
		  const multimap<_K1, _T1, _C1, _A1>&);
  };

  /**
   *  @brief  Multimap equality comparison.
   *  @param  __x  A %multimap.
   *  @param  __y  A %multimap of the same type as @a __x.
   *  @return  True iff the size and elements of the maps are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  multimaps.  Multimaps are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  */
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }

  /**
   *  @brief  Multimap ordering relation.
   *  @param  __x  A %multimap.
   *  @param  __y  A %multimap of the same type as @a __x.
   *  @return  True iff @a x is lexicographically less than @a y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  multimaps.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }

  /// Based on operator==
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  /// Based on operator<
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }

  /// Based on operator<
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  /// Based on operator<
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  /// See std::multimap::swap().
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif /* _STL_MULTIMAP_H */
# 1034 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multimap.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/range_access.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3

#ifdef _GLIBCXX_DEBUG
#if 0 /* expanded by -frewrite-includes */
# include <debug/map>
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
#endif
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3

#ifdef _GLIBCXX_PROFILE
#if 0 /* expanded by -frewrite-includes */
# include <profile/map>
#endif /* expanded by -frewrite-includes */
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
#endif
# 72 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3

#endif /* _GLIBCXX_MAP */
# 74 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/map" 3
# 21 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 21 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 22 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
#if 0 /* expanded by -frewrite-includes */
#include <list>
#endif /* expanded by -frewrite-includes */
# 22 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 23 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
#ifdef __cplusplus
extern "C" {
#endif
# 26 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"

void* makeOrGetUpfPowerNetwork(void);
void* makeOrGetUpfPowerNetworkForIp(void);
void* createDesignObjectByName(const char* name, UPFIR::DesignElementType d);
typedef void (*ExitFunctionCB)(int);
void initializeUpfReader(void *, ExitFunctionCB, void*, void*, int);
void cleanupUpfReader(void);
void cleanupCpfReader(void);


#ifdef __cplusplus
}
#endif
# 39 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"

///This will give singleton PowerNetwork object.
UPFIR::PowerNetwork*  makeOrGetUpfReaderPowerNetwork();
UPFIR::PowerNetwork*  makeOrGetPowerNetwork();
UPFIR::PowerNetwork*  makeOrGetPowerNetworkForIp();
UPFIR::DesignObject*  createDesignObjectByNameUpf(const char* n,  UPFIR::DesignElementType d);
//API to get PN for CPF/UPF flow
UPFIR::PowerNetwork*  makeOrGetPowerNetwork();


NAMESPACE_UPFIR_BEGIN
class SupplySetState;
class SupplySetHandle;
class SupplyNetFunction;
class SupplyNetHandle;
class SupplyPair;
class UpfDesignAdapter;
class UpfProductInfo;
class UpfReaderIf;
class BoolExpr;
class PowerSwitchState;
class CorrelatedSupplyGroup;
class PowerConfig;
class ContextResetGroup;
class LpSourceInfo;
class UpfGroup;
class UpfGroupState;
class RetentionMode;
class UpfFile;
class ControlSignalInfo;
typedef SlistL<SupplyState>     SupplyStateL;
typedef SlistL<ContextResetGroup> ContextResetGroupL;
typedef SlistLI<ContextResetGroup> ContextResetGroupLI;
typedef HashTableLI<UpfGroup> UpfGroupTableLI;

///This class is a singleton to represent all UPF's command information.
class PowerNetwork:public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerNetwork);
    ///This is responsible for reading upf command file.
    ///Before calling this, please set tool top using setToolDesignTop
    ///method
    ///Please register checkDesignElementByName function(see prototype in
    ///file UpfTypeDef.hh) using registerCallbackToCheckDesignElement.
    ///@param upfFileName name of upf command file.
    virtual bool isUfeFlow() const = 0;
    virtual bool isUcpFlow() = 0;
    virtual char* getModuleName(void* inst, bool isVlog) { return NULL;}
    virtual bool isUc15Flow() = 0;
    virtual bool isCurrentUpfFileEncrypted() {return false; }
    virtual void setCurrentUpfFileEncrypted(bool val) {}
    virtual void resetCurrentUpfFileEncrypted() {}
    virtual void setTestDecryption() {}
    virtual bool showEncryptedName() { return true; }
    virtual void hideEncryptedName(bool val) {}
    virtual void instantiateSourceService() {}
    virtual void addBBoxModel(const char* modname) {fassert(0, "addBBoxModel not expected for CPF");}
    virtual charLI getInsideBBoxModels() { fassert(0, "getInsideBBoxModels not expected for CPF"); charL dummy; return charLI(dummy); }
    virtual const char* getScopeResolvedNameFromFullName(const char* psFullName) { return NULL; }
    virtual std::string& getSNetResolvedNameFromFullName(SupplyNet* sNet) { static std::string dummy;  return dummy; }
    virtual std::string getSPortResolvedNameFromSPort(SupplyPort* sPort) { return NULL; }
    virtual std::string getDomainFullResolvedNameFromPD(PowerDomain* pd) { return NULL; }
    virtual std::string getPSNameFullToResolve(PowerScope* ps, std::string targetFullName) { return NULL; }
    virtual std::string getSSHandleFullNameFromSSHandle(SupplySetHandle* ssHandle) { return NULL; }
    virtual void saveResolvedName(PowerScope* ps) = 0;
    virtual const std::string& getSavedResolvedName(const std::string& psFullName) = 0;
    virtual bool readUpfFile(const char *upfFileName) = 0;
    virtual bool readTopLevelUpfFile(const char* upfFileName,
                                     bool isUpfFile = false) = 0;
    virtual void applySimstateBehaviors() = 0;
    virtual bool populateUPFIRfromPlatoSDM(void *, void *, void *, const char* reportsDir) = 0;

    //This is called only in Plato Upf to San flow
    virtual void setPlatoAnalysis() = 0;
    virtual void setUpfRead(bool isUpfRead) = 0;

    virtual UpfSupplySource* createSupplySource(unsigned id, unsigned corrGrpId, unsigned eqSuppId,
            UpfResolveType, bool isPwr, bool isGnd, bool hasEqSupps) = 0;

    virtual UpfRootSupplyDriver* createRootSupplyDriver(UpfSupplySource*, unsigned , SupplyNet*, UpfRootSupplyDriverType type) = 0;
    virtual UpfRootSupplyDriver* createRootSupplyDriver(UpfSupplySource*, unsigned , SupplyPort*, UpfRootSupplyDriverType type) = 0;

    //End : Called only in Plato Upf to San flow
    virtual bool readRuntimeConfig(const char *upfFileName) = 0;

    virtual const char *getHWTopName() = 0;
    virtual void setHWTopName(const char *hwTopName) = 0;
    virtual const char* getWrapperName() = 0;
    virtual void setWrapperName(const char *wrapperName) = 0;
    virtual IsolationStrategy* findIsolation(const char*) const = 0;

    // Name Database for Assertions
    virtual char* lookupNameDB(char* alias) = 0;
    virtual char* lookupXmrInNameDB(const char* alias, int& type) = 0;

    ///This is responsible for reading user provided power configuration file.
    virtual bool readPowerConfigFile(const char *configFileName) = 0;
    virtual PowerConfig* getPowerConfig() = 0;

    ///This is to set tool design top. User must set top module name as
    ///UPF file might not specify design top. All upf command have scope
    ///& scope again depends on top.
    virtual bool setToolDesignTop(const char *topModuleName, bool isVlog,
                                  void *topInst, const char* origTop) = 0;

    virtual void setUpfParsingMode(UpfParsingMode mode) = 0;

    //Messaging related
    virtual lpmsg::LpMsgController* getLpMsgController() = 0;
    virtual void setLpMsgController(lpmsg::LpMsgController* msgController) = 0;

    virtual ReInitInfoLI getReInitInfos() = 0;
    virtual ReInitInfoLI getDontReInitInfos() = 0;
    virtual bool checkReInitEnabledOnIp(void* ip, char* modelName) = 0;
    /// Design Wide Attributes
    /// Random Corruption
    virtual unsigned getRandomCorruptionSeed() = 0;
    virtual void setRandomCorruptionSeed(unsigned) = 0;
    virtual CorruptionType getRandomCorruptionType() = 0;
    virtual void setRandomCorruptionType(CorruptionType corType) = 0;
    virtual unsigned enableDesignRandomCorruption() = 0;
    virtual void setDesignRandomCorruption(unsigned corEn) = 0;
    /// Reinit
    virtual void setDesignReinit(bool reinit) = 0;
    virtual void setDesignDontReinit(bool reinit) = 0;
    virtual bool isDesignReinit() = 0;
    /// Disabling COA on whole design
    virtual void setDesignDisableCoa(bool b) = 0;
    virtual bool isDesignDisableCoa() = 0; 
    /// Assertion Control
    virtual void setAssertionControl(AssertControlType b) = 0;
    virtual AssertControlType getAssertionControl() const  = 0;
    virtual void setForceSemanticConfig(ForceSemanticType b) = 0;
    virtual ForceSemanticType getForceSemanticConfig() const = 0;
    virtual void setBuffersAsGates(unsigned) = 0;
    virtual unsigned buffersAsGates() = 0;
    virtual void setSequentialBuffersAsPassTrough(unsigned) = 0;
    virtual unsigned sequentialBuffersAsPassTrough() = 0;
    virtual void setConstantsInDomain(unsigned) = 0;
    virtual unsigned constantsInDomain() = 0;
    virtual void setZebuLpFlow(bool val) = 0;
    virtual unsigned getZebuLpFlow() = 0;
    virtual void dumpUpfForZebu(const char* fileName) = 0;
    virtual DesignObjectLI getAlwaysOnObjects() = 0;
    virtual void addDontTouchObject(DesignObject* dobj) = 0;
    virtual DesignObjectLI getResetWaiverObjects() = 0;
    virtual void addResetWaiverObject(DesignObject* dobj) = 0;
    virtual DesignObjectLI getIsoDisResetWaiverObjects() = 0;
    virtual void addIsoDisResetWaiverObjects(DesignObject* dobj) = 0;
    virtual DesignObjectLI getIsoDisClockWaiverObjects() = 0;
    virtual void addIsoDisClockWaiverObjects(DesignObject* dobj) = 0;
    virtual unsigned getClockCycleOnIsoDisable() = 0;
    virtual void setClockCycleOnIsoDisable(unsigned cycle) = 0;
    virtual bool isTreatUndrivenAsUndetermined() = 0;
    virtual bool isTreatUndrivenSupplyNetAsUndetermined() = 0;
    virtual bool isUnassociatedIsoOn() = 0;

    virtual void addBindCheckerStrategy(BindChecker* bc) =0;
    virtual BindChecker* createBindCheckerObject(char* checkerInstance, int line, char* checkerModule, charL &targetPolicies) =0;

    ///This directs the parser to understand level sensitive save/restore
    ///signals as edge sensitive signals
    virtual void treatLevelSaveRestoreAsEdge(unsigned int levelAsEdge) = 0;

    virtual bool isLevelSaveRestoreAsEdge() const = 0;

    virtual void registerDesignAdapter(UpfDesignAdapter *adapter) = 0;
    virtual void setUpfReader(UpfReaderIf *reader) = 0;

    virtual void setReportsDir(const char* reportsDir) = 0;
    virtual const char* getReportsDir() const = 0;
    ///Current top design used for upf specification. It could be set by
    ///set_design_top command or default design top set by tool if
    ///set_design_top has not been specified in upf file.
    virtual const char* getDesignTop() const = 0;
    virtual const char* getWorkDir() const = 0;
    virtual DesignObject*      getDTop() const = 0;
    virtual bool hasVlogPad() const = 0;
    virtual void setVlogPad(bool ) = 0;
    virtual void* getParentInstance(void* inst, UPFIR::DESIGN_TREE_TYPE designTreeType, bool& isVlog) = 0;
    virtual bool  isUnderDesignTop(void *inst, bool isInstVlog) = 0;
    virtual SupplyPortLI getSupplyPads() const = 0;
    ///This will give you all power domains defined(using creat_power_domain)
    ///in the UPF file(s)
    virtual PowerDomainLI getPowerDomains() const = 0;
    virtual RetentionLI    getRetentions() const = 0;
    virtual IsolationLI    getIsolations() const = 0;
    virtual PowerSwitchLI getPowerSwitches() const = 0;
    virtual LevelShifterLI getLevelShifters() const =0;
    virtual PowerDomain* isPowerBoundaryElement(void*) = 0;
    virtual PowerScopeTableLI getPowerScopes() = 0;
    ///This will give you all supply nets defined(using creat_supply_nets)
    ///in the UPF file(s)

    virtual void adjustRetentionStrategies() = 0;
    virtual bool doSupplyNetAnalysis() = 0;
    virtual SupplyNetAnalysis* getSupplyNetAnalysis() = 0;

    ///All power state table defined in UPF file(s) for a design. Power state
    ///table is defined using create_pst UPF command. It is unlikesly that there
    ///will be more than one pst.
    virtual PowerStateTableLI getPowerStateTables() const = 0;

    ///All value conversion(vct) defined  for converting HDL logic into
    ///net_state_type value in the UPF file using create_hdl2upf_vct
    virtual Hdl2UpfVctLI      getHdl2UpfVcts() const = 0;

    ///All value conversion table that can be used in converting UPF
    ///supply_net_type.state(1:0) values into HDL logic values using
    ///create_upf2hdl_vct
    virtual Upf2HdlVctLI      getUpf2HdlVcts() const = 0;

    ///All bind_checker commands specified in the upf file .
    virtual BindCheckerLI     getBindCheckers() const = 0;
    virtual void setAnyBCForIsoWithGenericPresent() = 0;
    virtual bool isAnyBCForIsoWithGenericPresent() = 0;

    virtual void findDesignModels(const char* name, DesignModelL &models, bool ignoreTop = true) = 0;
    virtual DesignModel* makeOrGetDesignModel(const char* module, void* hook, bool isGetOnly = false) = 0;
    virtual DesignModel* makeOrGetDesignModel(const char* canonicalName, const char *lib, const char *entity, const char *arch) = 0;
    virtual DesignModelTableLI getDesignModels() = 0;

    ///This will return last name_format upf command. Previous name_format upf
    ///command if any in the upf file will be overwritten.
    virtual NameFormat*       getNameFormat() const = 0;

    ///All save_upf commands  in the UPF file.
    virtual SaveUpfLI         getSaveUpfs() const = 0;

    ///All load_upf commands in the UPF file.
    virtual LoadUpfLI         getLoadUpfs() const = 0;

    virtual void setDbInfoPresent() =0;
    virtual bool getDbInfoPresent() const =0;
    virtual bool checkForNetTypeObj(DesignObject* dObj) = 0;
    virtual void checkForNetTypePorts(DesignObject* dir, ApplyDirectionType d) = 0;
    virtual void addDLForLpObj(const char* objName, const unsigned int lineNo, const char* fileName, const CharL* scopeL, const bool isVerilogHdl) = 0;
    virtual void addDLForLpObj(PowerScope* ps, const char* objName, const unsigned int lineNo, const char* fileName, const CharL* scopeL, const bool isVerilogHdl, bool& isDriverAdded) = 0;
    virtual LpSourceInfo* createLpSourceInfoObj(unsigned int file_line, void* obj) = 0;
    virtual void createScopeSrsn(PowerDomain* pd) = 0;
    virtual void setPgForBlackBox() = 0;
    virtual void setDesignDebugEnabled() = 0;
    virtual bool isDesignDebugEnabled() const = 0;
    virtual bool isMixedHdl() const = 0;
    virtual void setIsMixedHdl() = 0;
    virtual UpfParsingFileMode getUpfParsingFileMode() { fassert(0, "getUpfParsingFileMode() to be called only for UPF"); return ErrorC;}
    virtual int evalTclCmd(const char* cmd) {fassert(0,"Undefined function evalTclCmd in flow"); return 0;}
    virtual void setUpfParsingFileMode(UpfParsingFileMode mode) { fassert(0, "setUpfParsingFileMode can be called only for UPF"); }
    virtual void setRtlPGMode() {fassert(0,"Cannot set RTLPG mode") ; };
    virtual bool getRtlPGMode() const {fassert(0,"Cannot check RTLPG mode"); return false;};
    virtual void setSSDefaultON() = 0;
    virtual bool getSSDefaultON() const = 0;
    virtual void setModInline(void* inst) {}
    virtual bool isSpiceBlackBox() const { return false; }
    virtual bool hasAnyPowerBBox() const { 
        return false;
    }
    virtual void setHasAnyPowerBBox() { fassert(0, "setHasAnyPowerBBox to be called only for UPF");}
    virtual void setConfigValue(const std::string & , const std::string &) {fassert(0,"Cannot set mode") ; };
    virtual void setQueryLoggerValues(const char *, const char *, const char *) {fassert(0,"Can log only in UPF") ; };
    virtual void setDumpUPF(const char *) {fassert(0,"Can dump only in UPF") ; };
    virtual RetentionStrategy* findRetention(const char* retName) const {fassert(0, "findRetention with name only supported in UPF"); return 0;}
    ///Some utility function
    //Domain name should be fully qualified name
    virtual PowerDomain*      findPowerDomain(const char *domainName, bool isTcl = false) const = 0;
    virtual PowerDomain*      findPowerDomain(int) const = 0;
    virtual IsolationStrategy*      findIsolationStrategy(int) const = 0;
    virtual BindChecker*      findBindCheckerStrategy(int) const = 0;
    virtual SRSNStrategy*      findSRSNStrategy(int) const = 0;
    virtual RetentionStrategy*      findRetention(int) const = 0;
    virtual LevelShifterStrategy*   findLevelShifterStrategy(int) const = 0;

    virtual Hdl2UpfVct*       findHdl2UpfVct(const char *vctName) const = 0;

    virtual Upf2HdlVct*       findUpf2HdlVct(const char *vctName) const = 0;
    virtual SupplyNet*        findSupplyNet(const char *supplyNetName) const = 0;
    virtual SupplyNet*        findSupplyNet(int snid) const = 0;
    virtual SupplyPort*       findSupplyPort(const char *supplyPortName) const = 0;
    virtual SupplySetHandle*  findSupplySetHandle(const char* name) const = 0;
    virtual UpfObjLI            getSupplyPortsInScope(void* scopePtr) = 0;
    virtual void registerSupplyPortInScope(void* instPtr, SupplyPort *sport) = 0;
    virtual void addGoldenUpfTopLevelFile(const char* fileName) {  fassert(0,"Cannot add top level upf file");  }
    virtual void setGoldenUpfFlow() { fassert(0,"Cannot set golden upf flow");   }
    virtual bool isGoldenUpfFlow() const { fassert(0,"Cannot get golden upf flow"); return false;}
    virtual void  setUcpFlow() { fassert(0, "Cannot set UcpFlow for CPF"); }
    virtual bool              populateElementFromQueryObject() = 0;
    virtual void              markNoPinRetention() = 0;
    virtual DesignObject*     getVirtualPortInCurrentScope(const char *name) const = 0;
    virtual bool              isNlpGenericName(const char* name) const = 0;
    virtual void              setAnyRetCondPresent() = 0;
    virtual bool              isAnyRetCondPresent() const = 0;
    virtual const char*       getDesignTopName() const { fassert(0,"Cannot get design top name")                                                   ; return 0; } 
    virtual void              setDesignTopName(const char * topName) { fassert(0,"Cannot set design top name");}    

    ///This function performs semantic checking on entire power network
    virtual bool              doSemanticCheck() const = 0;
    virtual DesignObject*     checkDesignElement(const char *elem,
                                                 const char *scope, bool checkSignal = false,
                                                 char *file = NULL, int line = 0,
                                                 bool reportError = true,
                                                 QueryCmdType cType = UNKNOWN_CMD,
                                                 bool lookInSpice = false) = 0;
    virtual DesignObject*     queryDesignElement(const char *elem, bool bLookInSpice = false, DesignElementType* dType = NULL, bool giveError= true) = 0;
    virtual int findHierObjectsInScope (void * scope, const std::string & scopeName, bool vlogScope, const std::string & token, int type, charL & tokenList, UpfObjL& upfObjList, bool lookupClassRef=false) = 0;

    ///This function will set the reader whether it will print or stop
    ///upf reading progress message or not.
    virtual void              setVerboseMode(int mode) = 0;
    virtual void              dumpUpfInTclFormat(FILE *) const = 0;

    ///@todo other function(s) may be needed to write next application layer
    ///which will be provided based on requirement.
    virtual const char*       getBaseDir() const  { return NULL; }
    virtual void              setLpaBindTcl(const char* fileName) { }
    virtual const char*       getLpaBindTcl() const { return NULL;}
    virtual void              setLpaBindFileList(const char* fileName) { }
    virtual const char*       getLpaBindFileList() const { return NULL; }
    virtual const char*       getFileName(unsigned int fileId) const = 0;
    virtual unsigned int      getCurrentFileId() const = 0;
    virtual unsigned int      getCurrentLineNo() const = 0;
    virtual bool              getCoaDisabled () = 0;
    virtual void              setCoaDisabled (bool flag) = 0;
    ///This will set the language mode at which upf reader
    ///will work.
    virtual void              setLanguage(UpfHdlType) = 0;
    virtual void save(const char* file) = 0;
    virtual void restore(const char* file, bool isLoadingForIP =false) = 0;
    virtual void print() const = 0;
    virtual void cleanup();

    virtual char* getToolTop() = 0;

    ///This will return all power tops.
    virtual PowerScopeLI         getPowerTops() const = 0;

    /// Check if the ip has a power scope or not.
    virtual bool hasPowerScope(void* ip, char** psName) const { return false; }

    ///This will return all modules for which power properties are defined.
    virtual PowerScopeLI         getPowerModels() = 0;

    //This will return scope during UPF/CPF parsing
    virtual const char *getCurrentScope() const = 0;
    virtual DesignObject *getCScope() const = 0;

    //This will return the domain mapping manager object only for CPF
    virtual DomainMappingMgr* getMappingManager() const = 0;
    virtual bool noPowerModeValidation() const = 0;
    // Function to get the Verilog ScopeTable
    virtual ScopeTable* getScopeTable() = 0;
    virtual int registerScope(DesignObject* elem, const char* scope) = 0;
    virtual int registerScope(const char* scope, int ScopeId) = 0;
    virtual void unregisterScope(int id, DesignObject* dobj = 0) = 0;

    //DesignScope APIs
    virtual DesignScopeTablePI getDesignScopes() = 0;
    virtual DesignScope* makeOrGetDesignScope(DesignObject* dobj) = 0;
    virtual DesignScope* findDesignScope(int id) = 0;

    // DesignPorts
    virtual UpfDesignPort*  makeOrGetDesignPort(const char* name, const char* portName, const char* resolvedName, unsigned isVerilog, void* instance, int cellId, DesignScope* dscope, bool forSPA, ClampValueType clampVal = UpfClampUnspecifiedC) = 0;
    virtual UpfDesignPortTableLI  getDesignPorts() = 0;
    virtual UpfDesignPort*  findDesignPort(int id) = 0;


    ///All SRSNs defined in this domain using set_related_supply_net
    virtual SRSNStrategyLI getSRSNStrategies() const =0;
    virtual std::vector<UpfDesignPort*>::iterator getDesignPortsOrderBegin() = 0;
    virtual std::vector<UpfDesignPort*>::iterator getDesignPortsOrderEnd() = 0;

    virtual const char* getFileName() const { return NULL; }
    virtual unsigned getLineNo() const { return 0; }
    virtual unsigned getFileId(unsigned fileLineId) { return (fileLineId >> 20);}
    virtual unsigned getLineId(unsigned fileLineId) { return fileLineId & 0xFFFFF;}
    virtual unsigned int getLowVoltageLevel() { return 0;}
    virtual unsigned int getHighVoltageLevel() { return 0;}
    virtual int getActiveResetDuration() = 0;
    virtual int getInactiveResetDuration() = 0;
    ///-power=pbp_opt in command line will set this flag for PowerNetwork
    virtual void setPBPOptEnabled() = 0;
    virtual bool isPBPOptEnabled() = 0;
    ///-power=strict_db_match in command line will set this flag for PowerNetwork
    virtual void setStrictDbMatch() = 0;
    ///check whether -power=strict_db_match present in command line
    virtual bool isStrictDbMatch() = 0;
    ///-power=mv_assert in command line will set this flag for PowerNetwork
    virtual void setLpAssertEnabled() = 0;
    ///-power=ret_sup_corr in command line will set this flag for PowerNetwork
    virtual void setRetSupCorr() = 0;
    ///check whether -power=mv_assert present in command line
    virtual bool isLpAssertEnabled() = 0;
    ///-power=custom_assert in command line will set this flag for PowerNetwork
    virtual void setCustomAssertTcl(const char*) = 0;
    ///check whether -power=custom_assert present in command line
    virtual const char* getCustomAssertTcl() = 0;
    ///-power=srsn_outside_port in command line will set this flag for PowerNetwork
    virtual void setSrsnOutsidePortInstrumentation() = 0;
    virtual void setSrsnLocationSelfInstrumentation() = 0;
    ///check whether -power=srsn_outside_port present in command line
    virtual bool getSrsnOutsidePortInstrumentation() = 0;
    virtual bool getSrsnLocationSelfInstrumentation() = 0;
    ///-power=unconnected_bias_pins_ON in command line will set this flag for PowerNetwork
    virtual void setUnconnectedBiasPinsOn() = 0;
    ///check whether -power=unconnected_bias_pins_ON present in command line
    virtual bool getUnconnectedBiasPinsOn() = 0;
    virtual void setClampCheckOnEnable() = 0;
    virtual bool getClampCheckOnEnable() = 0;
    virtual void setClampCheckOnDisable() = 0;
    virtual bool getClampCheckOnDisable() = 0;
    ///-power=poweropt in command line will set this flag for PowerNetwork
    virtual void setPowerOptMode() = 0;
    ///check whether -power=poweropt present in command line
    virtual bool getPowerOptMode() = 0;
    virtual void setCheckPowerDownWrite() = 0;
    virtual bool  isCheckPowerDownWrite() = 0;

    virtual bool hasPolicyOnInterfModport() = 0;
    virtual void setHasPolicyOnInterfModport() = 0;

    virtual bool hasFanoutPolicy() = 0;
    virtual void setHasFanoutPolicy() = 0;
    virtual bool hasPathBasedPolicy() = 0;
    virtual void setHasPathBasedPolicy() = 0;
    virtual void setDiscretePortStates() {
        fassert(0,"Cannot use setDiscretePortStates");
    }
    virtual bool  isDiscretePortStates() {
        fassert(0,"Cannot use setDiscretePortStates"); return false;
    }
    /// BCID - DISABLE_INSTANCE_WITH_ELEM
    virtual bool isInstanceEnableIsolsElem() = 0;
    virtual void resetInstanceEnableIsolsElem() = 0;

    virtual bool hasUpfError() = 0;
    virtual void setUpfError() = 0;
    virtual bool isPartialOnFullOn() const = 0;

    ///A function to check whether power state tables are there
    virtual PowerStateTable*  findPowerStateTable(const char *tableName, bool isTcl = false)const =0;
    virtual PowerScope* findPowerScope(const char* fullName) const =0;
    virtual DesignObject* findDesignObject(const char* fullName) const =0;
    virtual PowerSwitch* findPowerSwitch (const char *switchName, bool isTcl = false) const = 0;
    virtual PowerSwitch* findPowerSwitch (int id) const = 0;

    virtual bool resolvePowerStates() { return false; }
    virtual void disableParsingNotice(bool disable) = 0;
    virtual bool isParsingNoticeDisabled() = 0;
    virtual void setPartcompFlow(int) = 0;
    virtual int  getPartcompFlow() = 0;
    virtual bool isMixadAmsFlow() = 0;
    virtual void setMixadAmsFlow(bool flag) = 0;
    virtual bool hasDummyDesignTop() const = 0;
    virtual void setPowerUpf2SvVct(Upf2SvInbuiltType vct) = 0;
    virtual Upf2SvInbuiltType getPowerUpf2SvVct() = 0;
    virtual void setGroundUpf2SvVct(Upf2SvInbuiltType vct) = 0;
    virtual Upf2SvInbuiltType getGroundUpf2SvVct() = 0;
    virtual void setPowerSv2UpfVct(Sv2UpfInbuiltType vct) = 0;
    virtual Sv2UpfInbuiltType getPowerSv2UpfVct() = 0;
    virtual void setGroundSv2UpfVct(Sv2UpfInbuiltType vct) = 0;
    virtual Sv2UpfInbuiltType getGroundSv2UpfVct() = 0;
    virtual void setPowerUpf2VhVct(Upf2VhInbuiltType vct) = 0;
    virtual Upf2VhInbuiltType getPowerUpf2VhVct()  = 0;
    virtual void setGroundUpf2VhVct(Upf2VhInbuiltType vct) = 0;
    virtual Upf2VhInbuiltType getGroundUpf2VhVct() = 0;
    virtual void setPowerVh2UpfVct(Vh2UpfInbuiltType vct) = 0;
    virtual Vh2UpfInbuiltType getPowerVh2UpfVct() = 0;
    virtual void setGroundVh2UpfVct(Vh2UpfInbuiltType vct) = 0;
    virtual Vh2UpfInbuiltType getGroundVh2UpfVct() = 0;
    virtual void setOverridePBPCorruption(int corrupt) = 0;
    virtual int getOverridePBPCorruption() = 0;
    virtual int getTotalSupplyNetCount() = 0;
    virtual int getTotalPowerDomainCount() = 0;
    virtual int getTotalPowerSwitchCount() = 0;
    virtual int getTotalIsolationsCount() = 0;
    virtual int getTotalRetentionCount() = 0;
    virtual const char* getScopeAtLineNo(const char* fileName, unsigned int lineNo, const char* fileTopScope = NULL) const = 0;
    virtual const UpfNamedObj* getUpfObjAtLineNo(const char* fileName, unsigned int lineNo, const char* identifier, const char* fileTopScope = NULL) const = 0;
    virtual bool isMonetFlow() = 0;
    virtual bool isHierModelConsistencyFlow() = 0;
    virtual bool ignoreBboxMsgs() = 0;
    virtual bool isHeteroFanoutEnabled() = 0;
    virtual bool isDefaultAppliesToDontFilter() = 0;
    virtual bool isMacroPerfMode() = 0;
    virtual bool isConservativeDiffSupplyEnabled() = 0;
    virtual bool ignoreCsnError() = 0;
    virtual void setInstSupportForIsoLsInMonetFlow(bool flag)= 0;
    virtual bool instanceSupportForIsoLsInMonetFlow() = 0;
    virtual bool allUpfError() = 0;
    virtual bool allUpfErrorProceed() = 0;
    virtual bool isUpfLRMExtensionAllowed() const = 0;
    virtual bool isEnableAppliesToDefaultOutputsOrBoth() const = 0;
    virtual void setMonetFlow(bool flag)  = 0;
    virtual void setHierModelConsistencyFlow(bool flag) = 0;
    virtual void ignoreBboxMsgs(bool flag) = 0;
    virtual void setIgnoreCsnError(bool flag)  = 0;
    virtual void setAllUpfError(bool flag) = 0;
    virtual void setAllUpfErrorProceed(bool flag) = 0;
    virtual void setAllowUpfLRMExtension(bool flag) = 0;
    virtual void setEnableAppliesToDefaultOutputsOrBoth(bool flag) = 0;
    virtual UpfHdlType getLanguage() = 0;
    virtual PowerFormatType getPowerFormat() = 0;
    virtual bool areSupplySetsEquivalent(SupplySetHandle* sH1, SupplySetHandle* sH2) = 0;
    virtual bool isApfCompat() = 0;
    virtual bool isNorIsolationEnabled() = 0;
    virtual bool isCdcCorruptionEnabled() { return false; }
    virtual void setVhdlIntegerCorruptMode(const char* flag) = 0;
    virtual int  getVhdlIntegerCorruptMode(void) = 0;
    virtual void setApfCompat(bool apf) = 0;
    virtual bool logicExprDrivesSupplyExpr() = 0;
    virtual void setLogicExprDrivesSupplyExpr(bool b) = 0;
    virtual bool voltageBasedSupplyOn() = 0;
    virtual void setVoltageBasedSupplyOn(bool b) = 0;
    virtual bool nameBasedSourceSink() = 0;
    virtual void setNameBasedSourceSink(bool b) = 0;
    virtual void setLogFile(FILE* logFile) = 0;
    virtual FILE* generateReportWithBanner(const char* title, const char* description, const char* fileName, const char* mode="w+") = 0;
    virtual void closeReport(FILE* fp) = 0;
    virtual UpfProductInfo* getProductInfo() = 0;
    virtual void setUpfProduct(UpfProductInfo* product) = 0;
    virtual bool getVoltageRangeForSupplyNet(SupplyNet* snet, float &min, float& max) = 0;
    virtual void addLSXoverGate(int id, int srcSSId, int destSSId, int strategyId, bool is3070)= 0;
    virtual XoverGateLI getLSXoverGates() = 0;
    virtual SimModeType getSimulationMode() = 0;
    virtual bool isCorrelatedGroupsDefined() {
        fassert(0,"Cannot use isCorrelatedGroupsDefined in CPF"); return false;
    }

    virtual void setCorrelatedGroupsDefined(bool b) {
        fassert(0,"Cannot use setCorrelatedGroupsDefined in CPF");
    }
    virtual bool isPgSim() const = 0;
    virtual void setPgSim(bool b) = 0;
    virtual bool isDisableSRSN() const = 0;
    virtual void setDisableSRSN() = 0;
    virtual bool isCovgEnableLpCg() const {
        fassert(0,"Cannot use isCovgEnableLpCg"); return false; }
    virtual bool isLpCoverageEnabled() const = 0;
    virtual bool isPowerStateTableCoverage() = 0;
    virtual bool isSupplySetCoverage() = 0;
    virtual bool isPowerSwitchCoverage() = 0;
    virtual bool isPowerDomainCoverage() = 0;
    virtual bool isPowerDomainSimStateCoverage() = 0;
    virtual bool isSupplyPortStateCoverage() = 0;
    virtual void setLpCoverageEnabled () = 0;
    virtual bool isIsoNotClampedAssertion() = 0;
    virtual void setIsoNotClampedAsertion(bool b) = 0;
    virtual void setSupplyPortStateCoverage () = 0;
    virtual void setSupplySetCoverage () = 0;
    virtual void setImplicitSupplySetPowerStateCoverage () = 0;
    virtual void setExplicitSupplySetPowerStateCoverage () = 0;
    virtual void setPowerSwitchCoverage () = 0;
    virtual void setPowerDomainCoverage () = 0;
    virtual void setPowerDomainSimStateCoverage () = 0;
    virtual void setPowerDomainPowerStateCoverage () = 0;
    virtual void setPowerStateTableCoverage () = 0;
    virtual void setPowerStateTableStateCoverage () = 0;
    virtual void setPowerStateTableTransitionCoverage () = 0;
    virtual void setSaveSignalCoverage () = 0;
    virtual void setRestoreSignalCoverage () = 0;
    virtual void setIsoEnableCoverage () = 0;
    virtual void setGroupStateCoverage () = 0;
    virtual bool isGroupStateCoverage() = 0;
    virtual bool isPartialDeselect() const = 0;

    virtual bool isHierPSTCheck() { fassert(0,"Cannot use isHierPSTCheck") ; return true ; }
    virtual void setHierPSTCheck(bool b) { fassert(0,"Cannot use setHierPSTCheck") ; }
    virtual bool isUpfLint() { fassert(0,"Cannot use isUpfLint") ; return true ; }
    virtual void setUpfLint(bool b) { fassert(0,"Cannot use setUpfLint") ; }
    virtual bool isPowerStateMerge() { fassert(0,"Cannot use isPowerStateMerge") ; return true ; }
    virtual void setPowerStateMerge(bool b) { fassert(0,"Cannot use setPowerStateMerge") ; }
    // do something when power scope is changed with command "set_scope"
    virtual void recordScopeStartLineNo() = 0;
    virtual void printCorrSupplyGroups() {
        fassert(0,"Cannot use printCorrSupplyGroups in CPF");
    }

    virtual void addBlackBoxModel (const char*, unsigned int, unsigned int) = 0;
    virtual void markAsBlackBoxModels () = 0;
    virtual void markAsXBashSynchronizers () = 0;

    virtual void markSpiceModulesAsBlackBox () = 0;

    //Populate Command Line options
    virtual void populatePowerOptions() = 0;
    virtual unsigned findPowerOption(const std::string & name) = 0;

    virtual void setRetGenericCheckerPresent() = 0;
    virtual bool isRetGenericCheckerPresent() const = 0;
    virtual const char* getDesignElementFullName(DesignElementTokenL* tokenL, bool getInstName, bool convertVhNameToUpper) = 0;
    virtual const char* getDesignElementFullResolvedName(DesignElementTokenL* tokenL, bool getInstName)  = 0;
    virtual const char* getDesignElementFullTclName(DesignElementTokenL* tokenL, bool getInstName) = 0;
    virtual const char* getDesignElementResidualName(DesignElementTokenL* tokenL) = 0;
    virtual const char* getDesignElementTargetName(DesignElementTokenL* tokenL) = 0;
    virtual const char* getDesignElementEncryptName(DesignElementTokenL* tokenL) = 0;

    virtual DesignElementToken* createDesignElementToken(UpfTokenProp prop) = 0;

    virtual UpfDesignAdapter* getPowerNetworkDesignAdapter() = 0;
    virtual bool getControlPortCoverage() = 0;
    virtual bool getAckPortCoverage() = 0;
    virtual bool getSaveSignalCoverage() = 0;
    virtual bool getRestoreSignalCoverage() = 0;
    virtual bool getIsoEnableCoverage() = 0;
    virtual bool resolveWildcardClassRefs() = 0;
    virtual bool expandWildcardClassRefs(DesignObjectLI& dli, DesignObjectL& dobjL, UPFIR::FindObjType type, UpfObj* obj) = 0;
    virtual bool hasPowerDomains() const = 0;
    virtual void clearDomainBoundaryMap() = 0;
    virtual void setLowerDomainBoundaryData(bool val=false, const char* scope=NULL) = 0;
    virtual LowerDomainBoundaryData* getLowerDomainBoundaryData() = 0;
    virtual bool isLowerDomainBoundaryEnabled() = 0;
    virtual CdcInstanceDb* getCdcInstanceDb() { return 0; }
    virtual void setEnableUpfPortabilityMsg(bool flag) = 0;
    virtual bool enableUpfPortabilityMsg() = 0;
    //virtual DesignScopeLI getLowerDomainTrueList() = 0;
    //virtual DesignScopeLI getLowerDomainFalseList() = 0;
    virtual DesignScopeLI getLowerDomainTrueList() = 0;
    virtual DesignScopeLI getLowerDomainFalseList() = 0;
    virtual DesignScopeLI getTerminalBoundaryList() = 0;
    virtual bool hasAnyPowerDomainsAtOrBelowScope(DesignObject* dobj) = 0;
    virtual void setCoverageOption(unsigned int i) = 0;
    virtual unsigned int getCoverageOption() = 0;
    virtual bool isPowerStateTableTransitionCoverage() = 0;
    virtual bool isPowerStateTableStateCoverage() = 0;
    virtual bool isAutoComplete() = 0;
    virtual void enableAutoComplete() = 0;
    virtual void setNewRetentionFlow(bool b) = 0;
    virtual bool getNewRetentionFlow() = 0;

    virtual void setBiasBoundary(void *in, bool b, int fileid, int lineno) = 0;
    virtual const char* getBiasBoundaryFileNameLineNo(void *instance, int &line) = 0;
    virtual bool IsBiasBoundary(void *in) = 0;
    virtual bool biasBlockExists() = 0;
    virtual bool isBiasEnabled(void *in) = 0;
    virtual void processMacroModelInfos() = 0;
    virtual DesignModelLI getMacroModels() = 0;
    virtual const char *getMacroUpfFileName(std::string &macroName,
                                            MacroCorruptionType &mtype) = 0;
    virtual void populateRetentionInfoToPidb() = 0;
    virtual void appendContextResetGroup(ContextResetGroup *grp) = 0;
    virtual bool populateTraceDownwardElements() = 0;
    virtual void populateContextResetExclusionModels() = 0;
    virtual void clearTraceDownwardElements() = 0;
    virtual ContextResetGroupLI getAllContextResetGroups() = 0;
    virtual DesignObjectLI getContextResetExclusionElements() = 0;
    virtual bool isContextResetFlowEnabled() = 0;
    virtual bool getDisableAppliestoWithElements() = 0;
    virtual bool isAppliestoDefaultOutput() = 0;
    virtual void setDisableAppliestoWithElements(bool val) = 0;
    virtual void setAppliestoDefaultOutput(bool val) = 0;
    virtual void setUndrivenSuppliesOff(bool val) = 0;
    virtual bool undrivenSuppliesOff() = 0;
    virtual void printRuntimeSDA(FILE *fp) = 0;
    virtual std::string upfResolveTypeToString(UpfResolveType type) const = 0;
    virtual bool isPartialSinglePinRetention() = 0;
    virtual void setPartialSinglePinRetention(bool val) = 0;
    virtual void setMacroPerfMode() = 0;
    virtual void escapeHierName(std::string* name, bool hasSupplyHandler) const = 0;
    virtual void unEscapeName(std::string & name) { fassert(0, "unEscapeName not implemented for CPF");}
    virtual std::string getFullDecompileName(UPFIR::DesignObject* dObj) const = 0;
    virtual std::string stripPowerNetworkModelPrefix(const std::string& name) const = 0;
    virtual void removeDuplicatedSpaces(std::string* name) const = 0;
    virtual bool hasEscapedNamesOrChars(const std::string& name) const = 0;
    virtual char* getStrFromHconName(char* hc) = 0;
    virtual const char* makeVolatileRTLDBName(const std::string& name,
        bool isImplicitName = false) const = 0;
    virtual double getRealCorruptionValue() = 0;
    virtual void setRealCorruptionValue(double realCorValue) = 0;
    virtual unsigned isDesignRealCorruptionEnabled() = 0;
    virtual void setDesignRealCorruption(unsigned corEn) = 0;
    virtual void setHeteroFanoutSupport(bool flag) = 0;
    virtual void setDefaultAppliesToDontFilter(bool flag) = 0;
    virtual void setNlp2Compat() = 0;
    virtual bool isNlp2Compat() = 0;
    virtual void setInitGlitchBc() = 0;
    virtual bool isInitGlitchBc() = 0;
    virtual bool isPlatoParser() = 0;
    virtual void setSdm2UpfirFlow() = 0;
    virtual bool isSdm2UpfirFlow() = 0;
    virtual void setDelaySemanticsBc() = 0;
    virtual bool isDelaySemanticsBc() = 0;
    virtual RetentionMode* getRetentionModeImpl() = 0;
    virtual void analyzeRetentionMode() = 0;
    virtual void applyRetentionMode() = 0;
    virtual void setHasCompProfiler(bool val)  {}
    virtual bool hasCompProfiler()  { return true; }
    virtual void setFastUpfObjLookup(bool val)  {}
    virtual bool fastUpfObjLookup()  { return false; }
    virtual void createXoverToggleStrategies() = 0;
    virtual void notifyNewUpfFileParsing(const char* upfFileName) = 0;
    virtual PowerDomain *getTopPowerDomain() = 0;
    virtual const char* getGVar(const char* gvarName) = 0;
    virtual BlackBoxModelLI getBlackBoxModels() = 0; 
    virtual UpfFile* getUpfFileFromConfig() = 0; 
    virtual void disableLpAssertEnabled() = 0;
    virtual void setVcsVerboseLevel(int level) = 0;
    virtual void setUseUpfQueryData() = 0; 
    virtual bool getUseUpfQueryData() = 0; 
    virtual void setMvAllowPgPinReconnection() = 0; 
    virtual bool getMvAllowPgPinReconnection() = 0; 

    virtual bool isPswControlPortCorruption() = 0;
    virtual void setPswControlPortCorruption() = 0;
    virtual void setPswRelatedSupplyPrimary() = 0;
    virtual bool isPswRelatedSupplyPrimary() =0;
    virtual void populatePswImplicitSupplySet() = 0;
    virtual void registerUninstantiatedModel(const char* modelName) = 0;
    virtual bool getUninstantiatedModelsIter(std::list<std::string>::const_iterator& begin,
            std::list<std::string>::const_iterator& end) = 0;
    virtual void setVhClkVlIsoCdcName(char* vlogClk,char *vlogPnmClk) = 0;
    virtual std::map<std::string,std::string>* getVhClkVlIsoCdcMap() = 0;
    virtual void setVlClkVhIsoCdcName(char* vlogClk,char *vlogPnmClk) = 0;
    virtual std::map<std::string,std::string>* getVlClkVhIsoCdcMap() = 0;
    virtual bool bcIsOldVhdlImplEnabled()  { return false; }
    virtual void setBcEnableOldVhdlImpl() {}   
    virtual bool applyBind(UPFIR::BindChecker *bc) = 0;
    virtual void setToggleReportEnabled() = 0;
    virtual bool isToggleReportEnabled() = 0;
    virtual void setAssertResetSequenceEnabled() = 0;
    virtual bool isAssertResetSequenceEnabled() = 0;
};

class PowerNetworkForIPPartition {
public:
};

class UpfPgSimDriverLoads : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfPgSimDriverLoads);
    virtual const char* getName() const = 0;
    virtual DesignObjectLI getLoads() = 0;
    virtual DesignObjectLI getDrivers() = 0;
    virtual SupplyNet* getSupplyNet() = 0;
    virtual void addLoad(DesignObject* dobj) = 0;
    virtual void addDriver(DesignObject* dobj) = 0;
    virtual void* getLoadNet() = 0;
    virtual void setLoadNet(void* loadNet) = 0;
    virtual void* getDriverNet() = 0;
    virtual void setDriverNet(void* driverNet) = 0;
    virtual unsigned getId() = 0;
    virtual ~UpfPgSimDriverLoads() {}
};

class UpfPgSimScope
{
public:
    virtual DesignObject* getScope() = 0;
    virtual const void* getInstance() = 0;
    virtual unsigned getScopeId()  = 0;
    virtual PgSimDriverLoadsTableLI getDriverLoads()  = 0;
    virtual UpfPgSimDriverLoads* findNetConnections(SupplyNet* snet) = 0;
    virtual void appendDriverLoad(UpfPgSimDriverLoads* dl) = 0;
    virtual ~UpfPgSimScope() {}
};

class SpiceConnect : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SpiceConnect);
    virtual unsigned getId() = 0;
    virtual void *   getHook() = 0;
    virtual SupplyPort *   getSupplyPort() = 0;
    virtual SupplyNet *   getSupplyNet() = 0;
    virtual unsigned getOffset() = 0;
    virtual SpiceConnectType getType() = 0;
    virtual void setHook(void * hook) = 0;
    virtual void setOffset(unsigned offset) = 0;
    virtual ~SpiceConnect() {}
};

class SupplyNetAnalysis : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplyNetAnalysis);
    virtual void doSupplyNetAnalysis() = 0;
    virtual SupplyNet* findSupplyNet(const char* name) = 0;
    virtual SupplyNet* findSupplyNet(int id) = 0;
    virtual SupplyPort* findSupplyPort(const char* name) = 0;
    virtual SupplyPort* findSupplyPort(int id) = 0;
    virtual void addSupplyNet(SupplyNet* snet) = 0;
    virtual SupplyNetTablePI getSupplyNets()  = 0;
    virtual SupplyNetTablePI getDummySupplyNets()  = 0;
    virtual SupplyPortTablePI getSupplyPorts()  = 0;
    virtual SupplyNet* makeOrGetSupplyNet(char* snetName, PowerScope* ps,
                                          UpfResolveType resType, DesignObject* dobj,
                                          DesignScope* scope,
                                          bool isDummyNet = false, bool isPowerNet = false, bool isGroundNet = false, char *resScheme = 0) = 0;
    virtual SupplyNetHandle* makeOrGetSupplyNetHandle(const char* snhName, PowerScope* ps) = 0;
    virtual bool createRtlPgPort(UPFIR::SupplyPort* &port, char* rtlPgFullName) = 0;
    virtual SupplySetHandle* makeOrGetSupplySet(const char* ssetName, PowerScope* ps) = 0;
    virtual SupplySetHandle* makeOrGetSupplySetHandle(const char* sshName,
                                                      PowerScope* ps, bool createSNH = true) = 0;
    virtual SupplyPort* makeOrGetSupplyPort(char* portName, UpfPortDirection dir, bool isVoltageAware) = 0;
    virtual void deleteSupplySetHandle(SupplySetHandle* ssh) = 0;
    virtual SupplyPort* makeOrGetDesignSupplyPort(char* portName, UpfPortDirection dir, DesignScope* scope, DesignObject* dobj, bool isVoltageAware, bool isPowerSwitchPin, bool isSpicePort, bool isWrealPort) = 0;
    virtual SupplyPortLI getSupplyPads()  = 0;
    virtual void addSupplyPad(SupplyPort* sport)  = 0;
    virtual void addSupplySetHandle (SupplySetHandle * ssh) = 0;
    virtual void addSupplyNetHandle (SupplyNetHandle *snh) = 0;
    virtual SupplySetHandle *lookUpSupplyHandle (const char *n) = 0;
    virtual SupplyNetHandle *lookUpSupplyNetHandle (const char *n) = 0;
    virtual int getSupplyNetCount() = 0;
    virtual int getTotalSupplySetCount() = 0;
    virtual int getTotalSupplySetHandleCount() = 0;
    virtual int getTotalSupplySourceCount() {
        /*fassert(0,"Cannot use getSupplySourceCount in CPF") ;*/ return 0; };
    virtual int getTotalSupplySetStatesCount()  = 0;
    virtual UpfSupplySourceLI getSupplySources() {
        /*fassert(0,"Cannot use getSupplySources in CPF") ;*/ return UpfSupplySourceLI(); };
    virtual UpfSupplySource* findSupplySource(int id) {
        /*fassert(0,"Cannot use findSupplySource in CPF") ;*/ return 0; }
    virtual int getRootSupplyDriverCount() {
        /*fassert(0,"Cannot use getRootSupplyDriverCount in CPF") ;*/ return 0; };
    virtual UpfRootSupplyDriverLI getRootSupplyDrivers() {
        /*fassert(0,"Cannot use getRootSupplyDrivers in CPF") ;*/ return UpfRootSupplyDriverLI(); };
    virtual SupplySetHandle* findSupplySet(int id) = 0;
    virtual SupplySetHandle* findSupplySetHandle(int id) = 0;
    virtual SupplySetHandle* findSupplySetHandle(const char* name) = 0;
    virtual SupplySetHandleTableLI getSupplySetHandles() = 0;
    virtual SupplyNetPair* makeOrGetSupplyNetPairForRelatedSupply(SupplyNet* power, SupplyNet* ground) = 0;
    virtual SupplyNetPair* makeOrGetSupplyNetPair(char* name, SupplyNet* power, SupplyNet* ground) = 0;
    virtual void doSupplyNetPairAnalysis() = 0;
    virtual StateMachine* createStateMachine(UpfObj* object, const char* name, const char* stateName, const char* groupName) = 0;
    virtual void addPgSim(SupplyNet* net, UPFIR::UpfPortDirection direction, DesignScope * parent, DesignObject* dobj) = 0;
    virtual PgSimScopeTablePI getPgsimScopes() = 0;
    virtual UpfPgSimDriverLoads* getPgSimDriverLoad(int id) = 0;
    virtual void cleanPgsimData() = 0;
    virtual SupplyNet * getSupplyNetForUpfPackage(const std::string & name) = 0;
    virtual SupplyPort * getSupplyPortForUpfPackage(const std::string & name) = 0;

    //SpiceConnect
    virtual SpiceConnect * getSpiceConnect(unsigned id) = 0;
    virtual unsigned makeSpiceConnect(SupplyPort * sp, char * name,
                                      SpiceConnectType type)= 0;
    virtual unsigned getTotalSpiceConnectCount() = 0;
    virtual void doSpiceConnectReporting() = 0;




};

// These are classes for CPF models. More to be added later //

class PowerDesign : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerDesign);
    virtual PowerScopeLI    getChildPowerScopes() const = 0;
    virtual PowerDomainTableLI    getPowerDomains() const = 0;
    virtual PowerSwitchTableLI getPowerSwitches() const = 0;
    virtual SupplyNetTableLI getSupplyNets() const = 0;
    virtual NominalCondTableLI getNominalConditions() const = 0;
    virtual RetentionStrategyTableLI getRetentionStrategies() const = 0;
    virtual IsolationTableLI getIsolationRules() const = 0;
    virtual PowerModeTableLI getPowerModes() const = 0;
    virtual bool hasPowerModes() const = 0;
    virtual PowerDomain * findPowerDomain(const char* simpleName) const = 0;
    virtual PowerSwitch * findPowerSwitch(const char* simpleName) const = 0;
    virtual SupplyNet   * findSupplyNet(const char* simpleName) const = 0;
    virtual RetentionStrategy* findRetentionStrategy(const char* simpleName) const = 0;
    virtual NominalCondition * findNominalCondition(const char* simpleName) const = 0;
    virtual PowerMode   * findPowerMode(const char *simpleName) const = 0;
    virtual IsolationStrategy *findIsolationRule(const char* simpleName) const = 0;
    virtual bool getDefaultDomainAlreadyPresent() const =0;
    virtual void     addPowerScope(PowerScope* dObj) = 0;
    virtual void     addPowerDomain(PowerDomain* pd) = 0;
    virtual void     addPowerSwitch(PowerSwitch* psr) = 0;
    virtual void    addSupplyNet(SupplyNet *sn) = 0;
    virtual void    addNominalCondition(NominalCondition *nc) = 0;
    virtual void    addRetentionStrategy(RetentionStrategy *nc) = 0;
    virtual void    addPowerMode(PowerMode *pm) = 0;
    virtual void    addIsolationRule(IsolationStrategy *pm) = 0;
    virtual void    setDefaultDomainAlreadyPresent() =0;
    virtual void    print() const = 0;
    virtual void    populateElementFromQueryObject() = 0;
    virtual PowerScope *getLastPowerScope() const = 0;
    virtual char getHierarchySeparator() const = 0;
    virtual void  setHierarchySeparator(char sep) = 0;
    virtual const PowerMode *getDefaultPowerMode() const = 0;
    virtual void  setDefaultPowerMode(PowerMode *pm) = 0;
    virtual bool isMacroModel() const = 0;
    virtual bool deepCopySingleInCurrentScope() = 0;
    virtual bool mergePowerModes(const char *scopeName) = 0;
    virtual void  addSetSimControl(SetSimControl *sc) = 0;
};

class NominalCondition : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(NominalCondition);
    virtual float                 getVoltage            () const =0;
    virtual float                 getGroundVoltage    () const =0;
    virtual NomCondStateCpf        getNominalState        () const =0;
    virtual void                print               () const = 0;
};

class ActiveStateCondition : public UpfObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(ActiveStateCondition);
    virtual NominalCondition*    getNominalCond    () const =0;
    virtual BoolExpr*            getExpression    () const =0;

    virtual void             setNominalCond     (NominalCondition* nc    )    =0;
    virtual void             setExpression    (BoolExpr*bs            )    =0;
};

class DomainCondition : public UpfObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(DomainCondition);
    virtual PowerDomain*        getPowerDomain () const = 0;
    virtual NominalCondition*    getNominalCondition () const = 0;
};

class PowerMode : public UpfNamedObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerMode);
    virtual DomainConditionLI    getDomainCondtions () const = 0;
    virtual void                print              () const = 0;
};

class DomainMappingMgr : public UpfObj
{
    // This is the main manager API for Domain Mapping
    // Here top level refers to the parent or the upper level domain
    // while block level refers to the lower level domain or the one in the child scope
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(DomainMappingMgr);
    virtual int     getTopLevelID   (int pid)  =0;
    virtual const std::vector<int>& getBlockLevelIDs(int pid)  =0;
    virtual PowerDomainLI   getTopLevelIDs  ()   =0;
    virtual bool makeEquivalent(int topPID,int blockPID)   =0;
    virtual bool isEquivalent(int pid1,int pid2)  =0;
    virtual  int getProcessedCount() =0;
};

class SetSimControl : public UpfObj
{
public :
    // VCS_DECL_SERIALIZABLE_ABSTRACT(SetSimControl);
    // No virtual methods required.
};


///This class is a place holder for all power domain related information.
///These information will come from
/// - create_power_domain
/// - create_power_switch
/// - add_domain_elements
/// - create_supply_net
/// - create_supply_port
/// - set_domain_supply_net
/// - set_level_shifter
/// - set_isolation
/// - set_retention
class PowerDomain : public UpfControllerObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerDomain);
    ///This will return list of elements given either through -elements option
    ///of create_power_domain or add_domain_elements or by both.
    virtual DesignObjectLI        getElements() const =0;
    virtual void getEffectiveElements(DesignObjectL &) const {
        fassert(0,"Cannot use getEffectiveElements in CPF") ; };
    virtual void setIsBlackBox() {
        fassert(0,"Cannot use setIsBlackBox in CPF");
    }
    virtual bool isBlackBox() const {
        fassert(0,"Cannot use isBlackBox in CPF");
        return false;
    }
    virtual void setAsBlackBox() {
        fassert(0,"Cannot use setIsBlackBox in CPF");
    }
    virtual void setAsAutoBlackBox() {
        fassert(0,"Cannot use setAsAutoBlackBox in CPF");
    }
    virtual bool isAutoBlackBox() {
        fassert(0,"Cannot use isAutoBlackBox in CPF");
        return false;
    }
    virtual bool isEmpty() const = 0;
    virtual int getId() = 0;
    virtual void setId(int) = 0;
    virtual lpmsg::LpMsgSeverity getMsgSeverity() = 0;
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev)  = 0;
    virtual bool getMsgEnabled() = 0;
    virtual void setMsgEnabled(bool en) = 0;
    virtual void updateSimState(power_state_simstate simstate) = 0;
    virtual void updatePrimaryPowerNet(supply_net_type power) = 0;
    virtual void updatePrimaryGroundNet(supply_net_type ground) = 0;
    virtual power_state_simstate getSimState() = 0;
    virtual supply_net_type getPrimaryPowerNet() = 0;
    virtual supply_net_type getPrimaryGroundNet() = 0;
    virtual unsigned getRandomCorruptionSeed() = 0;
    virtual void setRandomCorruptionSeed(unsigned) = 0;
    virtual CorruptionType getRandomCorruptionType() = 0;
    virtual void setRandomCorruptionType(CorruptionType corType) = 0;
    virtual void setOffState() = 0;
    virtual bool hasOffState() const = 0;
    virtual void setBiasEnabled(bool b) = 0;
    virtual bool isBiasEnabled() = 0;
    virtual void setBiasState(BiasState b) = 0;
    virtual BiasState getBiasState() = 0;
    virtual SupplyNet* getPwellNet() = 0;
    virtual SupplyNet* getNwellNet() = 0;
    virtual SupplyNet* getDeepPwellNet() = 0;
    virtual SupplyNet* getDeepNwellNet() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual bool getIsControlledFromUpperLevelEquivDomain() const  =0;

    ///This will return list of elements which are not to be isolated
    virtual DesignObjectLI        getDontIsolateElements() const =0;

    ///This will add an element to the dont isolate list
    virtual void        appendDontIsolateElement(DesignObject* elem) =0;

    ///This will return list of elements which are not to be level shifted
    virtual DesignObjectLI        getDontLevelShiftElements() const =0;

    ///This will add an element to the dont level shift list
    virtual void        appendDontLevelShiftElement(DesignObject* elem) =0;

    ///This will give scope of the power domain elements
    virtual const char*          getPdElementScope() const =0;

    ///This will give scope of the power domain logic scope made by instrumentation
    virtual const char*          getRealLogicScope() const = 0;

    ///This will tell at which logic scope this power domain need to be created.
    ///This scope either set by -scope option of create_power_domain
    ///or by set_scope command
    ///-scope of create_power_domain has highest priority.
    virtual const char*         getPdLogicScope() const =0;

    ///All supply nets(power or ground) defined within a power domain.
    virtual SupplyNetLI   getSupplyNets() const =0;

    ///All supply ports defined for a power domain.
    virtual SupplyPortLI  getSupplyPorts() const =0;

    ///Will return primary power supply net, set either by -primary_power_net
    ///option of set_domain_supply_net or by -rail_connection(for older
    ///libraries)/-pg_type option of connect_supply_net
    virtual SupplyNet*    getPowerNet() const =0;

    // Get SupplySetHandle for Primary
    virtual SupplySetHandle* getPrimarySupply() = 0;
    virtual SupplySetHandle* getDefaultIsoSupply() = 0;
    virtual SupplySetHandle* getDefaultRetSupply() = 0;
    virtual SupplySetHandleTableLI getCustomSupplies() = 0;

    virtual void markAllImplicitSuppliesBlackBox() = 0;

    //
    virtual bool hasSetDomainPriSupply() = 0;
    ///Will return primary ground supply net,set either by -primary_ground_net
    ///option of set_domain_supply_net or by -rail_connection(for older
    ///libraries)/-pg_type option of connect_supply_net
    virtual SupplyNet*    getGroundNet() const=0;

    virtual SupplyNet*    getImmediatePowerNet() const=0;
    virtual SupplyNet*    getImmediateGroundNet() const=0;

    ///All switches created within this domain using create_power_switch
    virtual PowerSwitchLI getSwitches() const =0;

    ///All level shifter strategy defined in this domain using set_level_shifter
    virtual LevelShifterLI getLevelShifters() const =0;

    ///All isolation strategy defined in this domain using set_isolation
    virtual IsolationLI getIsolations() const =0;

    ///All retention registers defined in this domain.
    virtual RetentionLI getRetentions() const =0;

    virtual bool hasRetentions() const =0;

    virtual void deleteRetention(RetentionStrategy *ret) = 0;

    ///returns logic scope is included in the power domain or not
    ///This is set by -include_scope command
    virtual bool isIncludeScope() const = 0;

    ///This function will find in the PD scope, if there is any supply
    ///port with @param name
    virtual SupplyPort* findSupplyPort(const char* name) const = 0;
    ///@todo add utility function on demand of next application layer
    virtual LevelShifterStrategy* createDefaultLevelShifterStrategy() = 0;

    ///returns true for domains with scope as verilog
    virtual bool isVerilogScope() const = 0;

    ///This function will be used to add implicit VL elements found
    ///during partition analysis for domain scope verilog.
    virtual DesignObject* addImplicitVL(char *name, void *instP) = 0;

    ///Returning all verilog implicit elements starting with verilog
    ///power domain scope.
    virtual DesignObjectLI getImplicitVLElements() const = 0;

    ///Will set to true if verilog pd found any vh elements during analysis.
    virtual void setHasVhElements(bool b)  = 0;
    virtual bool hasVhElements()  const = 0;
    virtual void* getTargetScope() const = 0;
    virtual void print() const = 0;
    virtual bool populateElementFromQueryObject() = 0;

    //The following two functions give information about a power domain being the domain at the transition of LDB value from TRUE to FALSE
    virtual bool isLDBTransition() = 0;
    virtual void setLDBTransition(bool val) = 0;
    virtual bool getLDBVal() = 0;

    virtual bool hasCorruptOnActivityState() = 0;
    virtual bool hasCorruptOnChangeState() = 0;
    virtual bool hasCorruptOnSequentialActivityState() = 0;
    virtual bool hasCorruptOnSequentialChangeState() = 0;
    virtual unsigned isRandomCorruptionEnabled() = 0;
    virtual void setRandomCorruption(unsigned) = 0;
    virtual unsigned isDomainDisableCoa() = 0;
    virtual void setDomainDisableCoa() = 0;
    virtual ReinitType getReinit() = 0;
    virtual void setReinit(bool) = 0;
    virtual void setDontReinit(bool) = 0;
    virtual void addControlSignalInfo(const char *signalName, DesignElementTokenL *tokl, FlopCtrlSigType sigType, bool sense,
            int flatindex, const char *fileName, unsigned int lineNo, bool isVhdl = false) = 0 ;
    virtual std::list<ControlSignalInfo *>* getControlSignalInfo() = 0;
    virtual std::list<ControlSignalInfo *>* getVhdlControlSignalInfo() = 0;

        ////search for an isolation within power domain
    virtual IsolationStrategy* findIsolation(const char*) const = 0;
    ////search for a retention power domain
    virtual RetentionStrategy* findRetention(const char*) = 0;
    ////search for a supply-net power domain
    virtual SupplyNet* findSupplyNet(const char*) const = 0;
    virtual bool isSimulationOnly() const  = 0;
    virtual void createDefultSupplySets () = 0;
    virtual UpfSimstate* getSimstate() const = 0;
    virtual void setAssertionControl(AssertControlType b) = 0;
    virtual AssertControlType getAssertionControl() const  = 0;
    virtual PowerScope* getPowerScope() const = 0;
    virtual void setPowerScope(PowerScope* ps) = 0;
    virtual void setUpfCorruptForMrm(void*) = 0;
    virtual void* getUpfCorruptForMrm() = 0;
    // For Functional Coverage
    virtual void createStateMachine() = 0;
    virtual StateMachine* getStateMachine() = 0;
    virtual void dumpUpfPowerDomainCmd(std::ofstream& ofs) const = 0;

    virtual double getRealCorruptionValue() = 0;
    virtual void setRealCorruptionValue(double realCorValue) = 0;
    virtual unsigned isRealCorruptionEnabled() = 0;
    virtual void setRealCorruption(unsigned) = 0;
    virtual IsolationStrategy  *getDefaultInputIso() const = 0;
    virtual IsolationStrategy  *getDefaultOutputIso() const = 0;

    /* This is where the classes for CPF power domain begins
    All these functions should be concretized in CpfImpl class and crash asserted in
    UPF class. The reverse is true for UPF class*/

public:
    virtual PowerDomainLI          getBaseDomains       () const =0;
    virtual UpfDesignPortLI          getBoundaryPorts     () const =0;
    virtual ActiveStateCondLI     getActiveStateConds () const =0;

    virtual SupplyNetLI         getEquivPwrNets       () const  =0;
    virtual SupplyNetLI         getEquivGndNets       () const =0;

    virtual bool              getIsDefault            ( ) const =0;
    virtual BoolExpr*         getShutoffCondition    ( ) const =0;
    virtual bool             getIsExternalShutoff   ( ) const =0;
    virtual BoolExpr*          getDefaultIsoCondition ( ) const =0;
    virtual BoolExpr*          getDefaultRestoreEdge  ( ) const =0;
    virtual BoolExpr*          getDefaultSaveEdge     ( ) const =0;
    virtual BoolExpr*          getDefaultRestoreLevel ( ) const =0;
    virtual BoolExpr*          getDefaultSaveLevel    ( ) const =0;
    virtual PowerUpStatesCpf getPowerUpState        ( ) const =0;

    // Create consturctor for Active State Conditions here

    virtual void setIsDefault           (bool isDefault            ) =0;
    virtual void setShutoffCondition    (BoolExpr* expr            ) =0;
    virtual void setIsExternalShutoff   (bool isExternalShutoff    ) =0;
    virtual void setDefaultIsoCondition (BoolExpr* expr            ) =0;
    virtual void setDefaultSaveEdge     (BoolExpr* expr            ) =0;
    virtual void setDefaultRestoreLevel (BoolExpr* expr            ) =0;
    virtual void setDefaultSaveLevel    (BoolExpr* expr            ) =0;
    virtual void setPowerUpState        (PowerUpStatesCpf pUpState ) =0;
    virtual void setDefaultRestoreEdge  (BoolExpr* expr            ) =0;

    virtual void addBaseDomain           (PowerDomain* baseDomainName       ) =0;
    virtual void addBoundaryPort         (UpfDesignPort* port           ) =0;

    virtual void addEqPwrNet             (SupplyNet* pwrNet           ) =0;
    virtual void addEqGndNet             (SupplyNet* gndNet           ) =0;
    virtual void setPdSupplyPwrFile(const char* fileName)            =0;
    virtual void setPdSupplyGndFile(const char* fileName)            =0;
    virtual void setPdSupplyPwrLine(unsigned int lineNo)             =0;
    virtual void setPdSupplyGndLine(unsigned int lineNo)             =0;
    virtual const char* getPdSupplyPwrFile()                         =0;
    virtual unsigned int getPdSupplyPwrLine()                                =0;
    virtual const char* getPdSupplyGndFile()                                 =0;
    virtual unsigned int getPdSupplyGndLine()                                =0;
    virtual bool hasTimingChecks() = 0;
    virtual void setHasTimingChecks() = 0;
};


class UpfSimstate: public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfSimstate);
    virtual PowerDomain* getDomain() const = 0;
    virtual PowerStateTable* getPST() const = 0;
    virtual UpfGroup* getUpfGroup() const = 0;
    bool isEncrypted() const { return false; }
};

class ScopeTable: public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(ScopeTable);
    virtual void* getScope(int id) = 0;
    virtual void setScope(int id, void* scope) = 0;
    virtual int registerScope(DesignObject* upfElement) = 0;
    virtual void unregisterScope (int id,DesignObject* dobj = 0) = 0;
    virtual void resetScopes() = 0;
    virtual int getNumOfScopes() const = 0;
    virtual DesignObject* getElement(int id) = 0;
};


class PowerScope : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerScope);
    virtual DesignScope* getDesignScope() const = 0;
    virtual void addSupplyPort(SupplyPort* sport) = 0;
    virtual void addSupplyNet(SupplyNet* sport) = 0;
    virtual void addSupplySet(SupplySetHandle* sset) = 0;
    virtual void addPowerSwitch(PowerSwitch* psw) = 0;
    virtual void addPowerStateTableInScope(PowerStateTable* pst) = 0;
    virtual void addPowerDomain(PowerDomain* pd) = 0;
    virtual void addSRSN(SRSNStrategy* srsn) = 0;
    virtual PowerDomain* findPowerDomain(const char* simpleName) = 0;
    virtual PowerSwitch* findPowerSwitch(const char* simpleName) = 0;
    virtual SupplyNet* findSupplyNet(const char* simpleName) = 0;
    virtual SupplySetHandle* findSupplySetByFullName(const char* fullName) = 0;
    virtual SupplyNetHandle* findSupplyNetHandle(const char* simpleName) = 0;
    virtual SupplyPort* findSupplyPort(const char* simpleName) = 0;
    virtual void createAndSaveMangledName(const char* pnmModName, const char* powerScopeName) = 0;
    virtual const char* getMangledName() const = 0;
    virtual PowerDomainTableLI getPowerDomains() = 0;
    virtual PowerSwitchTableLI getPowerSwitches() = 0;
    virtual PSTTableLI getPowerStateTablesFromScope() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual SupplyPortTableLI getSupplyPorts() = 0;
    virtual SupplyNetTableLI getSupplyNets() = 0;
    virtual SupplySetTableLI getSupplySets() = 0;
    virtual SRSNStrategyLI getSRSNStrategies() = 0;
    virtual PowerScopeLI getChildPowerScopes() = 0;
    virtual PowerScopeLI getImmediateChildPowerScopes() = 0;
    virtual bool isAnyParentPowerScope(PowerScope* parentPs) = 0;
    virtual PowerScope* getImmediateParentPowerScope() = 0;
    virtual void makeImplicitConnections() = 0;
    virtual bool isPowerTopScope() const= 0;
    virtual bool isModuleScope() const= 0;
    virtual bool isInvalidScopeforSNA()=0;
    virtual UpfLogicPortTableLI getLogicPorts() = 0;
    virtual UpfLogicNetTableLI getLogicNets() = 0;
    virtual DesignModel* getDesignModel() const = 0;
    virtual DesignObject* getDesignObject() = 0;
    virtual PowerDesign* getPowerDesign() =0;
    virtual void setPowerDesign(PowerDesign* powD) =0;
    virtual void print() const = 0;
    virtual void populateElementFromQueryObject() = 0;
    virtual void createStateMachines() = 0;
    virtual bool isInsideBBox() = 0;
    virtual const char* getResolvedName() const = 0;
    virtual const char* getResolvedNameRT() const = 0;
    virtual bool hasAnyPowerDomainsAtOrBelowScope() = 0;
    virtual bool isBboxScope() = 0;
    virtual void setLDBVal(bool val) = 0;
    virtual bool getLDBVal() = 0;
    virtual UpfGroupTableLI getUpfGroups() = 0 ;
};

class DesignObject : public UpfNamedObj, public UpfNamedVhObj
{
public:

    VCS_DECL_SERIALIZABLE_ABSTRACT(DesignObject);
    virtual char *getSimpleName (
        bool isResolved=true,
        bool stripEscape=false)  const = 0;
    bool isEncrypted() const { return false; }
    virtual int getPrefixPathLen ()  const = 0;
    virtual bool isInstance() const = 0;
    virtual void* getTargetInstance() const = 0;
    virtual ApplyDirectionType getApplyDirectionType() const  = 0;
    virtual bool isVerilog () const  = 0;
    virtual  void * getInstance() const = 0;
    virtual  void * getElabInstance() const = 0;
    virtual DesignElementType getElementType() const = 0;
    virtual UpfClassType getUpfClassType() const = 0;
    virtual unsigned getScopeId() const = 0;
    virtual void setScopeId(unsigned id) = 0;
    virtual void updateScopePointer(void* scope) = 0;
    virtual char* getMangledName() const = 0;
    virtual bool isAutoBlackBox() = 0;
    virtual void setMangledName(const char* name) = 0;
    virtual bool isInsideBBox() = 0;
    virtual std::string getInstanceNameTcl(bool checkInstance=true) = 0;
    virtual DesignObject* getInstanceDesignObject() = 0;
    virtual DesignObject* getParentDesignObject() = 0;
    virtual const char* getResolvedName() const = 0;
    virtual const char* getResolvedNameRT() const = 0;
    virtual const char* getTargetName(bool resolved=false) = 0;
    virtual unsigned int getDobjId() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual bool isUserSpecified() { return false; }
    virtual void setUserSpecified(bool b) {}
};

class DesignScope : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(DesignScope);
    virtual DesignObject* getDesignObject() = 0;
    virtual void setDesignObject(DesignObject* dobj) = 0;
    virtual unsigned isVerilog() = 0;
    virtual const void* getInstance() const= 0;
    virtual void* getHook() = 0;
    virtual void setHook(void* hook) = 0;
    virtual unsigned int getId() = 0;
    virtual const char* getMasterModName() = 0;
    virtual SRSNStrategy* getSrsnStrategy() = 0;
    virtual SupplyNet* getRelatedPowerNet() = 0;
    virtual SupplyNet* getRelatedGroundNet() = 0;
    virtual SupplySetHandle*  getRelatedSupplyInputs() = 0;
    virtual SupplySetHandle*  getRelatedSupplyOutputs() = 0;
    virtual SupplySetHandle*  getDriverSupplyInputs() = 0;
    virtual SupplySetHandle*  getDriverSupplyOutputs() = 0;
    virtual SupplySetHandle*  getReceiverSupplyInputs() = 0;
    virtual SupplySetHandle*  getReceiverSupplyOutputs() = 0;
    virtual SupplySetHandle*  getSrcSupply() = 0;
    virtual SupplySetHandle*  getSinkSupply() = 0;
    virtual SupplySetHandle*  getRepeaterSupply() = 0;
    virtual UpfDesignDirection getRepeaterAppliesTo() = 0;
    virtual bool getRelatedSupplyDefaultPrimaryInputs() = 0;
    virtual bool getRelatedSupplyDefaultPrimaryOutputs() = 0;
    virtual bool isIsoTerminalBoundary() = 0;
    virtual bool isTerminalBoundary() = 0;
    virtual void setRelatedPowerNet(SRSNStrategy* srsn) = 0;
    virtual void setRelatedGroundNet(SRSNStrategy* srsn) = 0;
    virtual void setRepeaterAppliesTo(UpfDesignDirection dir) = 0;
    virtual void setDesignTop() = 0;
    virtual unsigned isDesignTop() = 0;
    virtual unsigned isRandomCorruptionEnabled() = 0;
    virtual void setRandomCorruption(unsigned) = 0;
    virtual unsigned isAlwaysOn() = 0;
    virtual void setReinit(bool b, bool transitive) = 0;
    virtual void setDontReinit(bool b, bool transitive) = 0;
    virtual ReinitType getReinit() = 0;
    virtual bool isRuntimeConfigurationEnabled() = 0;
    virtual void setDontTouch() = 0;
    virtual int getCellId() = 0;
    virtual int getSrsnStrategyIndex() = 0;
    virtual void setSrsnStrategyIndex(int idx) = 0;
    virtual int getSpaStrategyIndex() = 0;
    virtual void setSpaStrategyIndex(int idx) = 0;
    virtual unsigned int getFileLineForSRSNSPA() const = 0;

    // Interface for Vhdl Xover Gate
    virtual void addVhdlXoverGate(int gateId) = 0;
    virtual void addVhdlXoverGateInputs(int gateId) = 0;
    virtual void addVhdlXoverGateOutputs(int gateId) = 0;
    virtual XoverGateLI getVhdlXoverGates() = 0;
    virtual XoverGateLI getVhdlXoverGatesInputs() = 0;
    virtual XoverGateLI getVhdlXoverGatesOutputs() = 0;
    virtual SupplyNetPair* getSupplyNetPair() = 0;
    virtual void setSupplyNetPair(SupplyNetPair* pair) = 0;
    virtual SupplyNetPair* getRepeaterSupplyNetPair() = 0;
    virtual void setRepeaterSupplyNetPair(SupplyNetPair* pair) = 0;
    virtual bool setLowerDomainBoundary(bool val) = 0;
    virtual bool setLowerDomainBoundaryOnDesignScope(bool val) = 0;
    virtual int getLowerDomainBoundaryAttribute() = 0;
    virtual bool isLowerDomainBoundarySet() = 0;
    virtual const char* getRelatedPowerFile() = 0;
    virtual int getRelatedPowerLine() = 0;
    virtual const char* getRelatedGroundFile() = 0;
    virtual int getRelatedGroundLine() = 0;
    virtual const char* getRelatedSupplyInputsFile() = 0;
    virtual int getRelatedSupplyInputsLine() = 0;
    virtual const char* getRelatedSupplyOutputsFile() = 0;
    virtual int getRelatedSupplyOutputsLine() = 0;
    virtual const char* getDriverSupplyInputsFile() = 0;
    virtual int getDriverSupplyInputsLine() = 0;
    virtual const char* getDriverSupplyOutputsFile() = 0;
    virtual int getDriverSupplyOutputsLine() = 0;
    virtual const char* getReceiverSupplyInputsFile() = 0;
    virtual int getReceiverSupplyInputsLine() = 0;
    virtual const char* getReceiverSupplyOutputsFile() = 0;
    virtual int getReceiverSupplyOutputsLine() = 0;
    virtual const char* getSrcSupplyFile() = 0;
    virtual const char* getSinkSupplyFile() = 0;
    virtual int getSrcSupplyLine() = 0;
    virtual int getSinkSupplyLine() = 0;
    virtual const char* getRepeaterSupplyFile() = 0;
    virtual int getRepeaterSupplyLine() = 0;
    virtual LowerDomainBoundaryData* getScopeLDBData() = 0;
};

class UpfDesignPort : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfDesignPort);
    virtual const char* getName() const = 0;
    virtual const char* getResolvedName() = 0;
    virtual const char* getPortName() = 0;
    virtual void* getHook() = 0;
    virtual void setHook(void* hook) = 0;
    virtual DesignScope* getDesignScope() = 0;
    virtual void setDesignScope( DesignScope* ds) = 0;
    virtual SRSNStrategy* getSrsnStrategy() = 0;
    virtual SupplyNet*  getRelatedPowerNet() = 0;
    virtual SupplyNet*  getRelatedGroundNet() = 0;
    virtual SupplySetHandle*  getRelatedSupply() = 0;
    virtual SupplySetHandle*  getReceiverSupply() = 0;
    virtual SupplySetHandle*  getDriverSupply() = 0;
    virtual SupplySetHandle*  getSrcSinkSupply() = 0;
    virtual SupplySetHandle*  getRepeaterSupply() = 0;
    virtual bool getRelatedSupplyDefaultPrimary() = 0;
    virtual UpfDesignDirection getDirection() = 0;
    virtual void setDirection(UpfDesignDirection dir) = 0;
    virtual ClampValueType getClampValue() const = 0;
    virtual void setClampValue(ClampValueType v) = 0;
    virtual void setRelatedPowerNet(SRSNStrategy* srsn) = 0;
    virtual void setRelatedGroundNet(SRSNStrategy* srsn) = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    //Should the set functions be in interface class?
    virtual unsigned isVerilog() = 0;
    virtual int getId()  = 0;
    virtual int getCellId()  = 0;
    virtual void* getInstance()  = 0;
    virtual void markChipBoundaryPort()  = 0;
    virtual void markSvInterfaceModportPort() = 0;
    virtual void markHasIsoSourceAttribute() = 0;
    virtual void markHasIsoSinkAttribute() = 0;
    virtual void markBBPort()  = 0;
    virtual void markDontTouchPort()  = 0;
    virtual void markDomainBoundaryPort()  = 0;
    virtual void markCellBoundaryPort()  = 0;
    virtual unsigned isChipBoundaryPort()  = 0;
    virtual unsigned isDomainBoundaryPort()  = 0;
    virtual unsigned isCellBoundaryPort()  = 0;
    virtual unsigned isBlackBoxPort()  = 0;
    virtual unsigned isSvInterfaceModportPort() = 0;
    virtual unsigned hasIsoSourceAttribute() = 0;
    virtual unsigned hasIsoSinkAttribute() = 0;
    virtual std::string getBBAttribute (std::string & attributeName) = 0;
    virtual void populateBBAttribute (std::map<std::string, std::string> &attrMap) = 0;
    virtual void populateIsoBBAttribute (std::map<std::string, std::vector <std::string> > &attrMap) = 0;
    virtual unsigned isDontTouchPort()  = 0;
    virtual int getSrsnStrategyIndex() = 0;
    virtual void setSrsnStrategyIndex(int idx) = 0;
    virtual int getSpaStrategyIndex() = 0;
    virtual void setSpaStrategyIndex(int idx) = 0;
    virtual void setSrcSinkSupply(SupplySetHandle* ssh) = 0;

    // Interface for Vhdl Xover Gate
    virtual void addVhdlXoverGate(int gateId) = 0;
    virtual XoverGateLI getVhdlXoverGates() = 0;
    virtual SupplyNetPair* getSupplyNetPair() = 0;
    virtual void setSupplyNetPair(SupplyNetPair* pair) = 0;
    virtual SupplyNetPair* getRepeaterSupplyNetPair() = 0;
    virtual void setRepeaterSupplyNetPair(SupplyNetPair* pair) = 0;

    // Interface fpr SRSN/SPA driver loads
    virtual unsigned int getFileLineForSRSNSPA() const = 0;
    virtual LpSourceInfoLI getDriverList() const = 0;
    virtual unsigned int relatedPwrLineNo()const = 0;
    virtual unsigned int relatedGndLineNo() const = 0;
    virtual const char* relatedPwrFileName() const = 0;
    virtual const char* relatedGndFileName() const = 0;
    virtual const char* driverSupplyFileName() const = 0;
    virtual const char* receiverSupplyFileName() const = 0;
    virtual const char* srcSinkSupplyFileName() const = 0;
    virtual const char* repeaterSupplyFileName() const = 0;
    virtual unsigned int driverSupplyLineNo() const = 0;
    virtual unsigned int receiverSupplyLineNo() const = 0;
    virtual unsigned int srcSinkSupplyLineNo() const = 0;
    virtual unsigned int repeaterSupplyLineNo() const = 0;

};

class DesignModel  : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(DesignModel);
    virtual const char* getName() const = 0;
    virtual const char* getLibraryName() = 0;
    virtual const char* getEntityName() = 0;
    virtual const char* getArchName() = 0;
    virtual void* getHook() = 0;
    virtual void setHook(void* hook) = 0;
    virtual unsigned  getSimStateBehavior() = 0;
    virtual void  setSimStateBehavior(const char* lib, bool behavior) = 0;
    virtual void  setLeafCell() = 0;
    virtual unsigned  isLeafCell() = 0;
    virtual void  setMacroCell() = 0;
    virtual unsigned  isMacroCell() = 0;
    virtual void setDontTouchNode(const char* node) = 0;
    virtual void replaceDontTouchNode(charL& resolvedDontTouchNode) = 0;
    virtual charLI getDontTouchNodes() = 0;
    virtual void setReinitNamedBlock(const char* nb) = 0;
    virtual void setOrigReinitNamedBlock(const char* nb) = 0;
    virtual charLI getReinitNamedBlocks() = 0;
    virtual charLI getOrigReinitNamedBlocks() = 0;
    virtual void setDontReinitNamedBlock(const char* nb) = 0;
    virtual charLI getDontReinitNamedBlocks() = 0;
    virtual bool hasReinitNamedBlocks() = 0;
    virtual bool hasOrigReinitNamedBlocks() = 0;
    virtual bool hasDontReinitNamedBlocks() = 0;
    virtual unsigned isVerilog() = 0;
    virtual void setModelDontTouch() = 0;
    virtual unsigned hasDontTouchNodes() = 0;
    virtual unsigned isModelDontTouch() = 0;
    virtual void setModelDisableCoa() = 0;
    virtual unsigned isModelDisableCoa() = 0;
    virtual ReinitType getModelReinit() = 0;
    virtual void setModelReinit(bool reinit, bool transitive) = 0;
    virtual void setModelDontReinit(bool reinit, bool transitive) = 0;
    virtual bool isRuntimeConfigurationEnabled() = 0;
    virtual unsigned isRandomCorruptionEnabled() = 0;
    virtual void setRandomCorruption(unsigned) = 0;
    virtual unsigned hasSRPGSequentialElement() = 0;
    virtual unsigned isSimStateBehaviorDefined() = 0;
    virtual void setPowerUpf2SvVct(Upf2SvInbuiltType vct) = 0;
    virtual Upf2SvInbuiltType getPowerUpf2SvVct() = 0;
    virtual void setGroundUpf2SvVct(Upf2SvInbuiltType vct) = 0;
    virtual Upf2SvInbuiltType getGroundUpf2SvVct() = 0;
    virtual void setPowerSv2UpfVct(Sv2UpfInbuiltType vct) = 0;
    virtual Sv2UpfInbuiltType getPowerSv2UpfVct() = 0;
    virtual void setGroundSv2UpfVct(Sv2UpfInbuiltType vct) = 0;
    virtual Sv2UpfInbuiltType getGroundSv2UpfVct() = 0;
    virtual void setVoltageAwareCheckerMod(bool b) = 0;
    virtual bool isVoltageAwareCheckerMod() = 0;
    virtual void setAsBlackBox() = 0;
    virtual bool isBlackBox() = 0;
    virtual void setAsInsideBlackBox() = 0;
    virtual bool isInsideBlackBox() = 0;
    virtual const char* getDbLibrary() = 0;
    virtual void setIsVerilog (bool b) = 0;
    virtual ~DesignModel() {}
};

class DesignElementToken : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(DesignElementToken);
    virtual ~DesignElementToken() { }; 
    virtual void printToken() = 0;
    virtual char* getName() = 0;
    virtual bool isVlogToken() = 0;
    virtual bool isGenerateToken() = 0;
    virtual bool isStructToken() = 0;
    virtual bool isEscapedToken() = 0;
    virtual bool isTargetToken() = 0;
    virtual bool isResidualNameToken() = 0;
    virtual bool isInstance() = 0;
    virtual int getSelectPosition() = 0;
    virtual bool isEncrypted() = 0;
    virtual void setTargetToken(bool val) = 0;

};

class PortMap
{
public:
    virtual ~PortMap() {};
    virtual const char *getFormalName() = 0;
    virtual UpfObj *getActual() = 0;
    virtual UpfPortDirection getDirection() = 0;
    virtual unsigned int getIndex() = 0;
    virtual bool isSupplyPort() = 0;
};

class ParameterMap
{
public:
    virtual ~ParameterMap() {};
    virtual const char *getFormalName() = 0;
    virtual BoolExpr *getActual() = 0;
};

class MetaInstance : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(MetaInstance);
    virtual DesignModel *getDesignModel() = 0;
    virtual PortMapLI getPortMaps() = 0;
    virtual ParameterMapLI getParameterMaps() = 0;
    virtual DesignObjectLI getElements() = 0;
    virtual charLI getLibCellNameList() = 0;
    virtual const char * getLibCellType() = 0;
    virtual UpfObj *getPolicy() = 0;
    virtual bool    doSemanticCheck() const = 0;
};

///This class will capture all information specified through create_pst
///add_pst_state will create new power state(PowerState) in PST.
class PowerStateTable: public UpfControllerObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerStateTable);

    ///list of supply nets or ports to include to each power state of the
    ///design.
    virtual UpfNamedObj* getSupplyNamedObj(int index) const  = 0;
    virtual UpfSupplySource* getUpfSupplySource(int index) const  = 0;
    virtual const char* getLocalSupplyName(int index) const  = 0;
    virtual UpfObj* getLocalSupply(int index) const  = 0;
    virtual PowerScope* getPowerScope() = 0;

    virtual PstStateTableLI getStates() =0;
    virtual UpfSimstate* getSimstate() const = 0;
    virtual bool resolveStates() = 0;
    virtual int getId() = 0;

    //getNumberOf Supplies
    virtual int getNumSupplies() =0;

    //get number of states
    virtual int getNumStates() =0;

    //find a power state
    virtual PstState*  findPstState(const char *stateName) const = 0;

    // For Functional Coverage
    virtual void createStateMachine() = 0;
    virtual StateMachine* getStateMachine() = 0;

    virtual bool isResolved() = 0;
    virtual unsigned getObjectFileLine() = 0;

    //zebu UC1.5 flow Auto BlackBox check
    virtual bool hasSuppliesInAutoBlackBoxScope() = 0;
};

class PstEntry : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PstEntry);
    virtual int getIndex() = 0;
    virtual bool isDontCare() = 0;
    virtual bool isOffState() = 0;
    virtual const char* getStateName() = 0;
    virtual SupplyState* getResolvedState() = 0;
    virtual unsigned getObjectFileLine() = 0;
    virtual UpfSupplySource* getSupplySource() = 0;
};

///Information in command add_pst_state is stored in this class.
class PstState:public UpfNamedObj
{
public:
    ///Power state name
    VCS_DECL_SERIALIZABLE_ABSTRACT(PstState);

    ///list of states specified through -state option
    virtual PstEntry* getState(int indx) =0;
    virtual bool resolveSupplyStates() = 0;
    virtual int getNumOfSupplies() = 0;
    virtual unsigned getObjectFileLine() = 0;
    virtual void setEnumValue(int value) = 0;
    virtual int getEnumValue() = 0;
    virtual PowerStateTable* getPst() = 0;
    virtual bool getInvalidPstState() = 0;
};

///Base class for all kind of UPF port
///                     UpfPort
///       _________________|_______________
///       |                                |
///    SupplyPort                  FunctionalPort
///                        _______________|____________
///                        |                           |
///                   ControlPort                   AckPort
class UpfPort:public UpfNamedObj
{
public:
    ///give you UPF port name
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfPort);

    ///give you UPF port direction
    virtual UpfPortDirection getDirection() const =0;
    virtual void setScope(UpfObj* scope) = 0;

    // This is for DVE Driver/Loads Support
    virtual LpSourceInfoL& getDrList() = 0;
    virtual LpSourceInfoL& getLdList() = 0;
    virtual LpSourceInfoLI getLoadList() const = 0;
    virtual LpSourceInfoLI getDriverList() const = 0;
    void addToLoadList();
    void addToDriverList(UpfObj* obj = NULL);
    void detachDriverLoads();

};
///Information coming from create_supply_port are stored in this class.
///For each new add_port_state command, a new state is added to the given port.
class SupplyPort:public UpfPort
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplyPort);

    virtual unsigned getObjectFileLine() = 0;
    ///Connected supply net with this supply port in the same scope
    ///For switch input & output supply there will be no inside net.
    ///Only outside net.
    virtual SupplyNet* getInsideNet() const =0;
    virtual void setInsideNet(SupplyNet * sNet)  = 0;

    virtual void setHook(void* hook) = 0;
    virtual void* getHook() = 0;
    ///Connected supply net with this supply port above the same scope
    virtual SupplyNet* getOutsideNet() const =0;
    virtual void setOutsideNet(SupplyNet * sNet) = 0;

    virtual UpfRootSupplyDriver* getRootSupplyDriver() const = 0;
    virtual UpfPortDirection getDirection() const = 0;
    virtual void setDirection(UpfPortDirection dir) = 0;

    virtual const char* getFullName() const = 0;
    virtual const char* getFileName()  const = 0;
    virtual  unsigned int getLineNo()  const = 0;

    virtual int getId() = 0;

    virtual void setModulePortId(int id) = 0;
    virtual int getModulePortId() = 0;

    virtual bool isSwitchInPort() = 0;
    virtual void markSwitchInPort() = 0;

    virtual void markSwitchPort() = 0;
    virtual bool isSwitchPort() const = 0;
    virtual PowerSwitch* getPowerSwitch() const = 0;
    virtual void setPowerSwitch(PowerSwitch *pSwitch) = 0;
    virtual void print() const = 0;
    virtual bool isDesignSupplyPort() const = 0;
    virtual bool isDesignSupplyPGPin() const = 0;
    virtual bool isSpicePort() const = 0;
    virtual bool isSpicePgPin() const = 0;
    virtual bool isWrealPort() const = 0;
    virtual SupplyPort* getRtlPgPort() const = 0;
    virtual bool isSwitchCellPort() const = 0;
    virtual bool isVisited() const = 0;
    virtual void markVisited() = 0;
    virtual void unmarkVisited() = 0;
    virtual void setHdl2UpfVCT(Sv2UpfInbuiltType vct) = 0;
    virtual void setUpf2HdlVCT(Upf2SvInbuiltType vct) = 0;
    virtual Sv2UpfInbuiltType getHdl2UpfVCT() = 0;
    virtual Upf2SvInbuiltType getUpf2HdlVCT() = 0;
    virtual void setVh2UpfVCT(Vh2UpfInbuiltType vct) = 0;
    virtual void setUpf2VhVCT(Upf2VhInbuiltType vct) = 0;
    virtual Vh2UpfInbuiltType getVh2UpfVCT() = 0;
    virtual Upf2VhInbuiltType getUpf2VhVCT() = 0;
    virtual bool isBboxPort()  = 0;
    virtual void setBboxPort()  = 0;
    virtual bool isSupplyPad() = 0;
    virtual void markSupplyPad()  = 0;
    virtual DesignScope* getDesignScope() = 0;
    virtual PowerScope* getPowerScope() const = 0;
    virtual DesignObject* getDesignObject() = 0;
    virtual void setIsVoltageAware(bool b) = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual bool getIsVoltageAware() const = 0;
    virtual void setDesignSupplyPortProperties(int cellId, bool isSpicePort, bool isPowerSwitchPin, bool isWrealPort) = 0;
    virtual void setIsWrealPort() = 0;
    virtual bool isPowerSwitchPin() const = 0;
    virtual supply_net_type getDefaultSupplyStateValue() = 0;
    virtual UpfSupplySource* getSupplySource() = 0;
    virtual UpfRootSupplyDriver* getRootSupplyDriver() = 0;
    virtual UpfRootSupplyDriver* getUndrivenRootSupplyDriver() = 0;
    virtual UpfRootSupplyDriver* getUniqueRootSupplyDriver() = 0;
    virtual UpfRootSupplyDriverType isRootSupply() = 0;

    //PlatoUpfToUpfirSan
    virtual bool setSupplySource(UpfSupplySource* stateSource, bool platoToUpfir) = 0; 
};

class UpfLogicPort : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfLogicPort);
    virtual const char* getPortName() const = 0;
    virtual const char* getResolvedName() const = 0;
    virtual UpfPortDirection getDirection() const = 0;
    virtual UpfLogicNet* getInsideNet()= 0;
    virtual UpfLogicNet* getOutsideNet()= 0;
    virtual void setInsideLogicNet(UpfLogicNet * net)= 0;
    virtual void setInsideDesignNet(DesignObject * net)= 0;
    virtual void setOutsideLogicNet(UpfLogicNet * net)= 0;
    virtual void setOutsideDesignNet(DesignObject * net) = 0;
    virtual PowerScope* getPowerScope() = 0;
    virtual bool isImplemented() = 0;
    virtual bool needReconnect() const = 0;
    virtual unsigned getConnectionFileLineId() const { return 0; }
    virtual void  setConnectionFileLineId(unsigned id) {}
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual const char* getTargetModName() const = 0;
    virtual void setTargetModName(std::string name) = 0;
};

class UpfLogicNet : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfLogicNet);
    virtual const char* getNetName() const = 0;
    virtual const char* getResolvedName() const = 0;
    virtual void addConnectedLogicPort(UpfLogicPort * port)= 0;
    virtual void removeConnectedLogicPort(const UpfLogicPort * port)= 0;
    virtual void addConnectedDesignPort(DesignObject * port)= 0;
    virtual UpfLogicPortLI getConnectedLogicPorts() = 0;
    virtual DesignObjectLI getConnectedDesignPorts() = 0;
    virtual PowerScope* getPowerScope() = 0;
    virtual bool isImplemented() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    // This is for DVE Driver/Loads Support
    virtual LpSourceInfoLI getLoadList() const = 0;
    virtual LpSourceInfoLI getDriverList() const = 0;
    virtual const char* getOwnerModName() const = 0;
    virtual void setOwnerModName(std::string name) = 0;
};

///For create_supply_net
class SupplyNet:public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplyNet);
    virtual UpfResolveType getResolveType() const =0;
    virtual const char * getScopeName() = 0;
    virtual SupplyPort* getDriverSupplyPort() = 0;
    virtual int getDriverCount() = 0;
    virtual bool hasMultiDriver() = 0;
    virtual unsigned isDriven() = 0;
    virtual unsigned isDummyNet() = 0;
    virtual bool isImplicitUnused()  const= 0;
    virtual SupplyNet* getMasterNet() = 0;
    virtual UpfSupplySource* getSupplySource() = 0;
    virtual UpfRootSupplyDriver* getRootSupplyDriver() = 0;
    virtual UpfRootSupplyDriver* getUndrivenRootSupplyDriver() = 0;
    virtual UpfRootSupplyDriver* getUniqueRootSupplyDriver() = 0;
    virtual unsigned getObjectFileLine() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual unsigned getSupplySourceId() = 0;

    //This is for messaging infra
    virtual lpmsg::LpMsgSeverity getMsgSeverity() = 0;
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev)  = 0;
    virtual bool getMsgEnabled() = 0;
    virtual void setMsgEnabled(bool en) = 0;

    //THese 2 APIs for hdl nets only
    virtual void setModulePortId(int id) = 0;
    virtual int getModulePortId() = 0;

    virtual UpfRootSupplyDriver* getRootSupplyDriver() const = 0;

    ///The value conversion table (VCT) to be used specified through-vct option
    ///of connect_supply_net upf command.
    virtual const char* getVCT() const =0;

    ///@note following two functions might not be required.
    virtual bool isPowerNet()const =0;
    virtual bool isGroundNet()const=0;
    virtual int getId() = 0;
    virtual void setId(int id) = 0;

    ///Connected supply ports defined in the same scope as this supply nets
    virtual SupplyPortLI getUpperPortConns() const = 0;
    virtual void setHook(void* hook) = 0;
    virtual void* getHook() = 0;

    ///Connected supply ports defined in the scope below the scope of this supply net
    virtual SupplyPortLI getLowerPortConns() const = 0;

    /// Find one SupplyNetFunctions attached to this supplyNet
    /// TODO: In case multiple net fnctions are semantically allowed this will
    /// get extended to a list.
    virtual SupplyNetFunctionT getSupplyNetFunctionType() const = 0;

    ///Visitor marking.
    virtual bool isVisited() const = 0;
    virtual void markVisited() = 0;
    virtual void unmarkVisited() = 0;
    virtual void print() const = 0;
    virtual void addRelatedDesignPort(UpfDesignPort* dport) = 0;
    virtual UpfDesignPortLI getRelatedPorts() = 0;
    virtual DesignScope* getDesignScope() = 0;
    virtual DesignObject* getDesignObject() = 0;
    virtual PowerScope* getPowerScope() = 0;
    virtual unsigned isHdlNet() = 0;
    virtual unsigned isRtlPgNet() = 0;
    virtual unsigned isVerilog() = 0;
    virtual unsigned isDomainDependent() = 0;
    virtual void markDomainDependent(unsigned b) = 0;
    virtual void addPowerDomain(PowerDomain* pd) = 0;
    virtual PowerDomainLI getDomainsExtent() = 0;
    virtual supply_net_type getDefaultSupplyStateValue() = 0;

    virtual void setIsImplicitUnused(bool val) = 0;

    // This is for DVE Driver/Loads Support
    virtual LpSourceInfoLI getLoadList() const = 0;
    virtual LpSourceInfoLI getDriverList() const = 0;

    //This is for CPF implementation of PowerNets and Groundnets
    virtual bool getIsInternalInfo() const=0;

    virtual BoolExpr* getExternalShutoffCond() const=0;
    virtual bool isReferred() const = 0;

    //PlatoUpfToUpfirSan
    virtual bool setSupplySource(UpfSupplySource* stateSource, bool platoToUpfir) = 0; 
};

/// LpSourceInfo class to be used for drivers/loads
/// for the selected LowPower Object

class LpSourceInfo: public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(LpSourceInfo);
    virtual unsigned int isHDL() const = 0;
    virtual void* getUpfObjHandle() = 0;
    virtual CharLI getScopeNames() = 0;
    virtual unsigned int getFileLineId() const = 0;
};

/// ReInitInfo class to store data when user specifies
/// SNPS_reinit attribute on a instance of a Named Initial Block
class ReInitInfo: public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(ReInitInfo);
    virtual void addReInitNB(char* nbName) = 0;
    virtual DesignScope* getDesignScope() = 0;
    virtual charLI getBlockNameList() = 0;
};


// Abstract Class for  correlated Supply Groups Info
class CorrelatedSupplyGroup : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(CorrelatedSupplyGroup);
    virtual void addSupply(SupplyNet* sn) = 0;
    virtual SupplyNet* findSupply(SupplyNet* sn) = 0;
    virtual SupplyNetTablePI getSupplyNets() = 0;
    virtual unsigned int getCorrelatedGroupId() const  = 0;
    virtual void setCorrelatedGroupId(unsigned int corr_group_id) = 0;
};

class SupplyNetPair :  public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplyNetPair);
    virtual SupplyNet* getPowerNet()           = 0;
    virtual SupplyNet* getGroundNet()           = 0;
    virtual SupplySetHandle* getHandle()     = 0;
    virtual void setHandle(SupplySetHandle*) = 0;
};

///@note Hdl2Upf & Upf2Hdl this two VCT class can be merged into a single class
///as these two class is holding similer kind of information.Right now I am
///keeping these information seperately.

///create_hdl2upf_vct command information holder
class Hdl2Upf
{
public:
    ///return VCT name.
    virtual char* getName() const;

    ///-hdl_type option
    virtual HdlType getHdlType() const;

    ///typename specified when hdl type is other than vlog.
    virtual char*   getTypeName() const;

    ///-table options valuse are represented as pair of HDL logic value &
    ///corresponding upf value.
    virtual ValuePairLI getTable() const;
};
///create_upf2hdl_vct command information holder
class Upf2Hdl
{
public:
    ///@todo add same function interface as in class Hdl2Upf.
};

///This class will store save_upf command information
class SaveUpf
{
public:
    ///The UPF file to write
    virtual char* getName() const;

    ///-scope option;The scope relative to which the UPF commands are written.
    virtual char* getScope() const;

    ///-version option;The UPF version
    virtual char* getVersion() const;
};

///This class will store load_upf command information
class LoadUpf
{
public:
    ///@todo add same function interface as in class SaveUpf.
};



///class to represent name_format command information.
class NameFormat:public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(NameFormat);
    ///-isolation_prefix;default is empty string "" or NULL
    virtual const char* getIsolationPrefix() const = 0;

    ///-isolation_suffix;default is _UPF_ISO
    virtual const char* getIsolationSuffix() const = 0;

    ///-level_shift_prefix;default is empty string "" or NULL.
    virtual const char* getLevelShiftPrefix() const = 0;

    ///-level_shift_suffix;default is _UPF_LS
    virtual const char* getLevelShiftSuffix() const = 0;
};

///This class will represent information given through upf command
/// - create_power_switch
///
class PowerSwitch : public UpfControllerObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerSwitch);
    virtual int getId() = 0;
    virtual void setId(int id) = 0;
    virtual int getOnDelay() = 0;
    virtual int getSwitchDelay() = 0;
    virtual int getDelayUnit() { return 0; }

    ///-output_supply_port ;SupplyPort has pointer of corresponding SupplyNet
    virtual SupplyPort* getOutputPort()const =0;

    ///All input ports defined through -input_supply_port
    virtual SupplyPortLI getInputPorts()const =0;

    ///All control ports defined through -control_port
    ///@todo This will be design port not Supply port, please change it later.
    virtual ControlPortLI getControlPorts() const =0;

    //This is for messaging infra
    virtual lpmsg::LpMsgSeverity getMsgSeverity() = 0;
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev)  = 0;
    virtual bool getMsgEnabled() = 0;
    virtual void setMsgEnabled(bool en) = 0;
    ///All -on_state options
    virtual OnPortStateLI getOnStates() const =0;

    ///All -on_partial_states
    virtual OnPortStateLI getOnPartialStates() const =0;

    ///all -ack_port options
    virtual AckPortLI getAckPorts() const =0;

    ///all -off_state options
    virtual SwitchStateLI getOffStates() const =0;

    ///all -error_state options
    virtual SwitchStateLI getErrorStates() const =0;

    ///This will give all kinds of switch port(input/output/control/ack)
    virtual UpfPortLI getAllSwitchPorts() const = 0;

    ///Scope of the switch signals.
    virtual const char* getScope() const = 0;

    //Get total number of partial on states
    unsigned int getNumPartialOnStates() const { return 0; }
    ///Get total number of states
    virtual unsigned int getNumStates() const = 0;
    ///Get total number of input supplies
    virtual unsigned int getNumInputs() const = 0;
    ///Get total number of control signals
    virtual unsigned int getNumControls() const = 0;
    ///Get total number of ack signals
    virtual unsigned int getNumAcks() const = 0;
    virtual void setDomain(PowerDomain *) = 0;
    virtual PowerDomain* getDomain() const = 0;
    virtual SupplyNet* getInputSupplyNet() const = 0;
    virtual SupplySetHandle* getSupplySet() = 0;
    virtual void setSupplySet(SupplySetHandle* ssh) = 0;
    virtual bool isSupplySetSpecified() const = 0; 
    virtual void setSupplySetSpecified() = 0;

    virtual void print() const = 0;

    // For Functional Coverage
    virtual void createStateMachine() = 0;
    virtual StateMachine* getStateMachine() = 0;

    virtual DesignScopeLI getInstances() = 0;
    virtual  MetaInstanceLI getMetaInstances() {
        fassert(false,"Illegal function called");
        MetaInstanceL dummy;
        return MetaInstanceLI(dummy);
    }

    virtual PowerSwitchState* getPowerSwitchState() const = 0;
    virtual void createAndSetPowerSwitchState() = 0;

    virtual DesignElementTokenL* getScopeTokenL() = 0;
    virtual DesignElementTokenLI getScopeTokenLI() = 0;

    //Add a CPF specific header footer switch.
    virtual bool isHeader() const = 0;
    virtual BoolExpr* getEnable1() const = 0;
    virtual AckPort* findAckPort(const char *ackName) const = 0;
    virtual bool isCoverageDisabled() const
    { fassert(false,"Illegal function isCoverageDisabled called"); return false; }
};

///This is required to represent boolean expression used in some switch option.
///Base class for all kind of UPF expression
///                     BoolExpr
///    ____________________|__________________
///    |                   |                 |
/// BoolExprId        BoolExprUnary    BoolExprBinary
///
///Expressions are stotred as boolean expression syntax tree.
class BoolExpr:public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BoolExpr);
    ///This function returns the expression tree in string format
    virtual const char* getBooleanString() const =0;
    virtual void        accept(UpfExprVisitor *) const =0;

    virtual void        setOriginalExprString(const char* strOrgExpr) = 0;
    virtual const char* getOriginalExprString() = 0;
};

///This class store simple constant expression like 1'b0, 1'b1
class BoolConst:public BoolExpr
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BoolConst);
    ///This function returns the corresponding port
    virtual int getValue() const = 0;
    virtual bool isSupplyValue() const = 0;
    virtual bool isStateExpression() const = 0;
    virtual UpfSupplyNetState getSupplyState() const = 0;
    virtual UpfSupplyVoltageType getSupplyVoltageType() const = 0;
    virtual double getMinVoltage() const = 0;
    virtual double getNomVoltage() const = 0;
    virtual double getMaxVoltage() const = 0;
};

class BoolSupplyExpr : public BoolExpr
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BoolSupplyExpr);
    ///This function returns the corresponding port
    virtual const char* getSupply() const = 0;
    virtual unsigned isStateExpression() const = 0;
    virtual UpfSupplyNetState getSupplyState() const = 0;
    virtual UpfSupplyVoltageType getSupplyVoltageType() const = 0;
    virtual int getMinVoltage() const = 0;
    virtual int getNomVoltage() const = 0;
    virtual int getMaxVoltage() const = 0;
    virtual UpfOpType getOperator() const = 0;
};

///This class store simple name expressions
class BoolExprId:public BoolExpr
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BoolExprId);
    ///This function returns the corresponding port
    virtual bool isSupplyPort() const = 0;
    virtual bool isSupplyNet() const = 0;
    virtual bool isSupplyFunction() const = 0;
    virtual bool isDomain() const = 0;
    virtual bool isSupplySet() const = 0;
    virtual bool isPowerStateSimstate() const = 0;
    virtual bool isLogicNet() const = 0;

    virtual UpfObj* getTarget() const = 0;
};

///This class store unary expressions
class BoolExprUnary:public BoolExpr
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BoolExprUnary);
    ///This function returns the binary operator
    virtual UpfOpType getOperator() const = 0;

    ///This function returns the operand expression
    virtual BoolExpr* getOperand() const = 0;
};

///This class store binary expressions
class BoolExprBinary:public BoolExpr
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BoolExprBinary);
    ///This function returns the binary operator
    virtual UpfOpType getOperator() const = 0;

    ///This function returns the left hand side expression
    virtual BoolExpr* getLeftOperand() const = 0;

    ///This function returns the right hand side expression
    virtual BoolExpr* getRightOperand() const = 0;
};

///This is to represent normal verilog concat expression.
///This is simple concat expression. Can be extented for multi-concat.
class BoolExprConcat:public BoolExpr
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BoolExprConcat);

    ///List of expression constituting the concat.
    virtual BoolExprLI getExprLI() const = 0;
};

///This class will represent -on_state/on_partial_state option of
///create_power_switch
class OnPortState:public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(OnPortState);
    ///-on_state/on_partial_state information
    //virtual State* getPortState() const;
    virtual const char*  getStateName() const =0;

    ///input supply port for which above state is defined.
    virtual SupplyPort*    getInputSupplyPort() const =0;

    ///boolean function specified at -on_state/on_partial_state option
    ///BoolExpr must be System verilog boolean expression
    virtual BoolExpr* getBooleanFunction()const =0;

    virtual int getOutputVoltage() const =0;

    virtual bool isOutputVoltageDefined() const =0;
};

///Intermediate class for Switch control & ack port
class FunctionalPort:public UpfPort
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(FunctionalPort);
    ///Following returns full hierarchical name.
    virtual const char* getConnectedLogicNet() const = 0;
    ///Following returns simple logic net name.
    virtual const char* getLogicNetName() = 0;
    virtual const char* getLogicNetType() const = 0;
    bool isEncrypted() const { return false; }
};

///This class will represent -control_port
class ControlPort:public FunctionalPort, public UpfNamedVhObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(ControlPort);
    virtual void *getTargetInstance() const = 0;
    virtual bool isVerilog () const = 0;
    virtual void setDesignType (DesignElementType d) = 0;
    virtual bool isInternallyCreated() = 0;
    virtual void setLogicNetName (char *x) = 0;
    virtual void setInternallyCreated (bool b) = 0;
    virtual char* getMangledName() const = 0;
    virtual void setMangledName(const char* name) = 0;
    virtual UpfLogicNet* getUpfLogicNet() const = 0;
    virtual const char* getResolvedNetName() const = 0;
};
///This class will represent -ack_port option of create_power_switch
class AckPort:public FunctionalPort, public UpfNamedVhObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(AckPort);
    ///this for -ack_delay value
    virtual int   getDelay() const  = 0;
    virtual BoolExpr*  getBooleanFunction() const =0;
    virtual void setDesignType (DesignElementType d) = 0;
    virtual void *getTargetInstance() const = 0;
    virtual const char* getResolvedNetName() const = 0;
    virtual char* getMangledName() const = 0;
    virtual void setMangledName(const char* name) = 0;
    virtual bool isVerilog () const = 0;
    virtual DesignObject* getDesignObject() = 0;
    virtual void setDesignSignalToDrive(const char *) = 0;
    virtual const char *getDesignSignalToDrive() = 0;
    virtual  bool isDesignSignalToDriveInVerilog() = 0;
    virtual void setDesignSignalToDriveInVerilog(bool b) = 0;
    virtual bool isErrorneous () = 0;
    virtual void setErrorneous() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual char* getTempNetName() = 0;
    virtual void  setTempNetName(const char *) = 0;
    virtual char* getInstPath() = 0;
    virtual void  setInstPath(const char*) = 0;
};

/// Class to Store variable power_switch_state
class PowerSwitchState:public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PowerSwitchState);
};

///This class will represent -off_state/-error_state of create_power_switch
class SwitchState:public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SwitchState);
    virtual const char* getStateName()const =0;
    virtual BoolExpr* getBooleanFunction() const =0;
};
///This class will capture isolation cell functions a policy is defining
///It will have enable signal, sense, clamp value
class IsolationCellFunc:public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(IsolationCellFunc);
    virtual UpfObj* getIsoEnable() const = 0;
    virtual const char* getIsoEnableName() const = 0;
    virtual const char* getIsoEnableSimpleName() const = 0;
    virtual IsolationSenseType getIsolationSense() const =0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    ///-clamp_value(0/1/Z/latch)
    virtual ClampValueType getClampValue() const =0;
    virtual LpSourceInfoLI getLoadList() const = 0;
};

class IsolationCellSupply :public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(IsolationCellSupply);
    ///-isolation_power_net
    virtual SupplyNet* getPowerNet() const =0;

    ///-isolation_ground_net
    virtual SupplyNet* getGroundNet() const =0;

    virtual SupplySetHandle *getSupplySetHandle() const = 0;
    virtual SupplyNet * getPwellNet() const = 0;
    virtual SupplyNet * getNwellNet() const = 0;
    virtual SupplyNet * getDeepNwellNet() const = 0;
    virtual SupplyNet * getDeepPwellNet() const = 0;

    virtual const char* getFullName() const = 0;
    virtual void markAllSuppliesAutoBlackBox() = 0;
    virtual void setIsImplicitSuppliesUnused(bool val) = 0; 

};

class IsoSinkDomainsDB : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(IsoSinkDomainsDB);
    virtual char* getParentInst() = 0;
    virtual char* getNodeName() = 0;
    virtual void addToSinkDomainList(int p) = 0;;
    virtual std::vector<int>& getSinkDomainsList() = 0;
};

class XoverGate : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(XoverGate);
    virtual int getGateId() = 0;
    virtual int getSrcPdId() = 0;
    virtual int getDestPdId() = 0;
};

class XoverLSGate : public XoverGate
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(XoverLSGate);
    virtual int getGateId() = 0;
    virtual int getSrcSSId() = 0;
    virtual int getDestSSId() = 0;
    virtual int getStrategyId() = 0;
    virtual bool is3070() = 0;
};

///Information from following commands are stored in this class
/// - set_isolation
/// - set_isolation_control
class IsolationStrategy: public UpfControllerObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(IsolationStrategy);

    /// -applies_to has been specified or not.
    virtual void setAppliesToSpecified(bool b) = 0;
    virtual bool getAppliesToSpecifed() = 0;

    /// Domain Name
    virtual const char *getDomain() const =0;

    ///-source and -sink
    virtual SupplySetHandle * getSourceSupplySet() const =0;
    virtual SupplySetHandle * getSinkSupplySet() const =0;
    //This is for messaging infra
    virtual lpmsg::LpMsgSeverity getMsgSeverity() = 0;
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev)  = 0;
    virtual bool getMsgEnabled() = 0;
    virtual void setMsgEnabled(bool en) = 0;

    virtual ClampValueType getClampValue() const = 0;

    ///-no_isolation
    virtual bool isNoIsolation() const =0;

    virtual bool isInsideBbox() const = 0;
    
    virtual bool isAutoBbox() const = 0;

    ///-elements
    virtual DesignObjectLI getElements() const =0;
    virtual DesignObjectLI getExcludeElements() const =0;

    ///-applies_to(inputs/outputs/both)
    virtual ApplyDirectionType getDirection() const =0;

    virtual IsolationCellFuncLI getCellFunctions() const = 0;

    virtual unsigned int getSignalCount() const = 0;

    virtual IsolationCellSupplyLI getCellSupplies() const = 0;

    virtual unsigned int getSupplyCount() const = 0;

    ///-location of set_isolation_control cmd.
    virtual LocationType getLocation() const =0;
    virtual void getLocationStr(char* policyLocation) = 0;

    ///Scope of the strategy where isolation cell will be created.
    virtual const char* getScope() const = 0;

    ///Will return the name format to be applied to the isolation gates output
    ///signal name.It will return NULL to indicate that, default name format
    ///semantics need to be used.
    virtual NameFormat* getNameFormat() const = 0;
    virtual bool isAutoPower() = 0;
    virtual bool isMappedIso() = 0;
    virtual bool isIsolationTargetTo() const
    { fassert(false,"Illegal function isIsolationTargetTo called"); return false; }
    virtual void setAutoPower(void)
    { fassert(false, "setAutoPower function should not be called for base class"); }
    virtual const char* getFileName() const  = 0;
    virtual unsigned int getLineNo() const = 0;
    virtual bool hasVHDLComponents () = 0;
    virtual void appendElement(DesignObject *e) = 0;
    virtual bool isVerilogScope() = 0;
    virtual void setTargetScope (void *) = 0;
    virtual void * getTargetScope () = 0;
    virtual void setGenericCheckerInstName (char *) = 0;
    virtual char * getGenericCheckerInstName () = 0;
    virtual     void setAllDone(bool b) = 0;
    virtual     bool getAllDone() = 0;
    virtual void setAlreadyImplementedPolicy(unsigned b) = 0;
    virtual  MetaInstanceLI getMetaInstances() {
        fassert(false,"Illegal function called");
        MetaInstanceL dummy;
        return MetaInstanceLI(dummy);
    }
    virtual unsigned int getFileLine() const {
        fassert(0,"getFileLine not defined for CPF");
        return 0;
    }

    virtual const char* getIsoPrefix() const = 0;
    virtual const char* getIsoSuffix() const = 0;
    virtual unsigned isAlreadyImplemented() = 0;
    virtual unsigned int getId() = 0;
//    virtual unsigned int getScopeId() = 0;
//    virtual void setId (unsigned int i) = 0;
//    virtual void setScopeId (unsigned int i) = 0;
    virtual unsigned isDiffSupplyOnly() = 0;
    virtual void setDiffSupplyOnly(unsigned) = 0;
    virtual bool isNorIsolationEnabled() const = 0;
    virtual bool isCdcCorruptionEnabled() const {
        fassert(0,"isCdcCorruptionEnabled not defined for CPF");
        return false;
    }
    virtual bool isIsoSupplySpecified() const {
        fassert(0,"isIsoSupplySpecified not defined for CPF");
        return false;
    }
    virtual void print() const = 0;

    virtual bool isEmptyIsoSupplySet() const {
        fassert(0,"isEmptyIsoSupplySet not defined for CPF");
        return false;
    }

    // Interface for Vhdl Xover Gate
    virtual void addVhdlXoverGate(int ,int, int) = 0;
    virtual XoverGateLI getVhdlXoverGates() = 0;

    //added for CPF.
    virtual BoolExpr* getIsolationCondition() const = 0;
    virtual PowerDomainLI getFromPowerDomainList() const  = 0;
    virtual PowerDomainLI getToPowerDomainList() const = 0;
    virtual void replaceElementList(DesignObjectL& dobjL) = 0;
    virtual void replaceExcludeElementList(DesignObjectL& dobjL) = 0;
    virtual UPFIR::PowerDomain * getSecondaryDomain() const = 0;
    virtual void setSecondaryDomain(UPFIR::PowerDomain * domain) = 0;

    virtual const char *getEnableSignalName() = 0;
    virtual void addToIsoSinkDomain(char* parentInst,const char* nodeName,std::vector<int> sinkDomains) = 0;
    virtual IsoSinkDomainsDBLI getIsoSinkDOmains() = 0;
    virtual std::vector<char*> &getIsoDBCells() = 0;
    virtual void addIsoDBCell(char* inst) = 0;
    virtual bool isXoverTogglePolicy() = 0;
    virtual void markAllCellSuppliesAutoBlackBox() = 0;
    virtual void setIsImplicitSuppliesUnused(bool val) = 0;

};

class SRSNStrategy : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SRSNStrategy);
    virtual SupplyNet* getPowerNet() const = 0;
    virtual SupplyNet* getGroundNet() const = 0;
    virtual PowerScope* getPowerScope() = 0;
    virtual UpfDesignPortLI getDesignPortLI() = 0;
    virtual DesignScopeLI getDesignScopeLI() = 0;
    virtual unsigned int getLineNo() const = 0;
    virtual const char* getFileName() const = 0;
    virtual int getId() = 0;
    virtual unsigned int getFileLine() const = 0;
    virtual std::pair<int,int> getPnetGnetIdPair() = 0;
};

///Information from following commands are stored here
/// - set_level_shifter
/// - map_level_shifter(For VCS Checker in future).
class LevelShifterStrategy: public UpfControllerObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(LevelShifterStrategy);

    ///domain
    virtual const char *getDomain() const =0;

    ///scope
    virtual const char *getScope() const =0;

    ///-elements
    virtual DesignObjectLI getElements()  const =0;
    //This is for messaging infra
    virtual lpmsg::LpMsgSeverity getMsgSeverity() = 0;
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev)  = 0;
    virtual bool getMsgEnabled() = 0;
    virtual void setMsgEnabled(bool en) = 0;
    ///-applies_to(inputs/outputs/both)
    virtual ApplyDirectionType getDirection()  const =0;

    ///-threshold
    virtual float getThresholdVoltage()  const =0;

    ///-rule(low_to_high/high_to_low/both)
    virtual LevelShifterRuleType getRuleType()  const =0;

    ///-location
    virtual LocationType getLocation()  const =0;

    ///-no_shift
    virtual bool isNoShift()  const =0;

    virtual  bool isInternalVR() const = 0;

    virtual NameFormat* getNameFormat() const = 0;
    virtual  MetaInstanceLI getMetaInstances() {
        fassert(false,"Illegal function called");
        MetaInstanceL dummy;
        return MetaInstanceLI(dummy);
    }

    virtual int getId() = 0;
    virtual void replaceElementList(DesignObjectL& dobjL) = 0;
};

///This class stores retention signals
class RetentionSignal:public UpfNamedObj, public UpfNamedVhObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(RetentionSignal);
    ///name of retention signal, it will be fully qualified name.
    virtual const char* getResolvedName () const = 0;
    ///retention signal trigger level(low/high/posedge/negedge)
    virtual SignalLevel getSignalLevel() const = 0;
    virtual RetentionSignalType getSignalType() const = 0;
    virtual void setSignalLevel (SignalLevel s) = 0;
    /// retention signal assert mutex corruption
    virtual void setAssertCorruptType (AssertCorruptType t) = 0;

    virtual AssertCorruptType getAssertCorruptType () = 0;
    virtual void setDesignScope(void*) = 0;
    virtual void setIsVerilog(bool b) = 0;
    virtual void* getDesignScope() const = 0;
    virtual bool isVerilog() const = 0;
    virtual char* getMangledName() const = 0;
    virtual void setMangledName(const char* name) = 0;
    virtual void* getTargetInstance() const = 0;
    virtual UpfLogicNet* getUpfLogicNet() const = 0;
    virtual DesignElementTokenLI getTokenLI() = 0;
    virtual DesignElementTokenL* getTokenL() = 0;
    virtual LpSourceInfoLI getLoadList() const = 0;
    virtual DesignObject* getDesignObject() = 0;
};

///This class represents information coming from
/// - set_retention
/// - set_retention_control
class RetentionStrategy: public UpfControllerObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(RetentionStrategy);
    /// Retention strategy domain
    virtual const char * getDomain() const =0;
    /// Retention Strategy Instance
    virtual const char* getInstance() const = 0;

    virtual SupplySetHandle* getRetentionSupplySet()  = 0;
    virtual void setRetentionSupplySet(SupplySetHandle* ssh) = 0;

    /// Retention Strategy Instance
    virtual void setInstance(char* inst) = 0;

    /// Get file/line info
    virtual unsigned int getFileLine() const {
        fassert(0,"getFileLine not defined for CPF");
        return 0;
    }

    /// Retention Strategy dows not require shadow flops
    virtual bool isNoShadowPolicy() const = 0;

    virtual bool isZeroPinEdgeCorruptRetention() = 0;

    /// Retention Strategy dows not require shadow flops
    virtual void setNoShadowPolicy(bool noShadow) = 0;
    ///-retention_power_net option
    virtual SupplyNet* getPowerNet() const =0;

    ///-retention_ground_net option
    virtual SupplyNet* getGroundNet() const =0;
    //This is for messaging infra
    virtual lpmsg::LpMsgSeverity getMsgSeverity() = 0;
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev)  = 0;
    virtual bool getMsgEnabled() = 0;
    virtual void setMsgEnabled(bool en) = 0;
    ///-elements option
    virtual DesignObjectLI getElements() const =0;

    ///-exclude_elements option
    virtual DesignObjectLI getExcludeElements() const =0;

    ///DesignScopes of all elements.
    virtual DesignScopeTablePI getElementScopes() const = 0;

    ///-no_retention
    virtual void setNoRetention (bool b) = 0;
    virtual bool isNoRetention() const = 0;

    ///-save_signal of set_retention_control cmd
    virtual RetentionSignal*  getSaveSignal() const =0;

    ///-restore_signal of set_retention_control cmd.
    virtual RetentionSignal* getRestoreSignal() const =0;

    ///assertion save signal for -assert_s_mutex of set_retention_control cmd.
    virtual RetentionSignalLI getSaveAssertSignals() const =0;

    ///assertion restore signal for -assert_r_mutex of set_retention_control cmd.
    virtual RetentionSignalLI getRestoreAssertSignals() const =0;

    ///assertion save restote signal for -assert_rs_mutex of set_retention_control
    ///cmd.
    virtual RetentionSignalLI getSaveRestoreAssertSignals() const =0;

    virtual bool isSaveRestoreAssert() const = 0;

    virtual DesignElementTokenLI getDomainTokenLI() = 0;
    virtual DesignElementTokenL* getDomainTokenL() = 0;

    ///@note For VCS checker map_retention_cell related infomation may be
    ///required to store here.
    virtual const char* getFileName() const = 0;
    virtual unsigned int getLineNo() const = 0;

    //set and getblackbox status
    virtual void setRetAsAutoBB(bool isAutoBB) = 0;
    virtual bool isRetAutoBB() = 0;
    

    virtual void addElements( DesignObject*s) = 0;
    virtual void addExcludeElements(DesignObject *s) = 0;
    virtual void appendMapRetention(MapRtnElement *mapRtn) = 0;

    virtual void setTransitive (bool b) = 0;
    virtual bool getUseAsPrim () = 0;
    virtual void setSaveSpecified (bool) = 0;
    virtual void setRestoreSpecified (bool) = 0;
    virtual bool getSaveSpecified() = 0;
    virtual bool getRestoreSpecified() = 0;
    virtual bool isRetSupplySpecified() const {
        fassert(0,"isRetSupplySpecified not defined for CPF");
        return false;
    }
    virtual bool isSinglePinSaveRestore() = 0;
    virtual BoolExpr *getRtnCond () = 0;
    virtual BoolExpr *getRestoreCond () const = 0;
    virtual BoolExpr *getSaveCond () const = 0;
    virtual void * getTargetScope() = 0;
    virtual  MetaInstanceLI getMetaInstances() {
        fassert(false,"Illegal function called");
        MetaInstanceL dummy;
        return MetaInstanceLI(dummy);
    }

    virtual void setTargetScope (void *v) = 0;
    virtual bool isTransitive () = 0;
    virtual bool isExcludeElement(void *inst) = 0;
    virtual bool getNoRetention() = 0;
    virtual bool hasAnyExcludeElement () = 0;
    virtual bool isRetSupplyCorrupt() = 0;
    virtual bool isSaveRestoreCorrupt ()= 0;
    virtual bool isSaveRestoreLevelToEdge ()= 0;
    virtual void setRetSupplyCorrupt(bool b)= 0;
    virtual void setSaveRestoreCorrupt (bool b)= 0;
    virtual void setAssertCorruptType (AssertCorruptType t) = 0;
    virtual AssertCorruptType getAssertCorruptType () = 0;
    virtual void setAlreadyImplementedPolicy(unsigned b) = 0;
    virtual unsigned isAlreadyImplemented() = 0;
    virtual int getId () const = 0;
    virtual bool getIsVerilogScope() = 0;
    virtual void setControllerInstanceName(const char *s) = 0;
    virtual const char * getControllerInstanceName() = 0;
    virtual void setGenNameInCond (bool b) = 0;
    virtual bool isGenNameInCond () const = 0;
    virtual void setGenClkUsed (bool b) = 0;
    virtual bool isGenClkUsed () const = 0;
    virtual void setGenRstUsed (bool b) = 0;
    virtual bool isGenRstUsed () const = 0;
    virtual void setWarnForGeneric () = 0;
    virtual bool isWarnForGeneric () const = 0;

    //Exclusive functions for CPF
    virtual void print() const =0;
    virtual bool populateElementFromQueryObject() =0;
    virtual UPFIR::PowerDomain* getAssocPowerDomain() const =0;
    virtual UPFIR::BoolExpr *getRestoreLevelCond () const =0;
    virtual UPFIR::BoolExpr *getSaveLevelCond () const =0;
    virtual UPFIR::BoolExpr *getRestorePreCond () const =0;
    virtual UPFIR::BoolExpr *getSavePreCond () const =0;
    virtual UPFIR::CpfRetTarget getRetentionTargetType() const =0;

    //Retention generic bind checker api's
    virtual void addRetGenericCheckerInstName (const char *instName) = 0;
    virtual charLI getRetGenericCheckerInstNameList() = 0;
    virtual void replaceElementList(DesignObjectL& dobjL, bool isExclude=false) = 0;
    virtual void setRetElemFullySkipped (const bool& b) = 0;
    virtual bool isRetElemFullySkipped () = 0;
    ///Scope of the retention strategy
    virtual const char* getScope() const = 0;
    virtual SupplyNet * getPwellNet() const = 0;
    virtual SupplyNet * getNwellNet() const = 0;
    virtual SupplyNet * getDeepNwellNet() const = 0;
    virtual SupplyNet * getDeepPwellNet() const = 0;
    virtual char* getContextResetGroupName() = 0;
    virtual bool isRetenModePessimistic() = 0;
    virtual bool isRetenModeAccurate() = 0;
    virtual void addRetentionModeReportElement(const char* str) = 0;
    virtual charLI getRetentionModeReportElements() = 0;
    virtual void deleteRetentionModeReportElements() { return; }
    virtual void setIsImplicitSuppliesUnused(bool val) = 0;
};

class RetentionMode
{
public:
    virtual RetentionModeType findRetentionMode(void* targetInst) = 0;
    virtual bool isTransitive(void* targetInst) = 0;
    virtual RetentionStrategy* getRetentionStrategy(void* el) = 0;
    virtual void addRetentionAccurateElInstance(void* el) = 0;
    virtual void addRetentionPessimisticElInstance(void* el) = 0;
    virtual void addRetentionBoundaryThruTraversal(const char* elName, RetentionStrategy* ret) = 0;
    virtual bool analyze() = 0;
    virtual ~RetentionMode() {}
};


///This class stores error messages
class MessageStorer
{
public:
    ///This function returns the type / id of the error message
    virtual const char* getMessageId() const = 0;

    ///Return actual message string
    virtual const char* getMessageString() const = 0;

    ///This function returns the file name where the error got generated
    virtual const char* getFileName() const = 0;

    ///This function returns the line number where the error got generated
    virtual unsigned int getLineNo() const = 0;
};
class RetentionElements:public UpfNamedObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(RetentionElements);
    virtual void setTransitive(bool trans)  = 0 ;
    virtual void setPurpose(RtnPurposeType p)  = 0 ;
    virtual void setappliesTo(RtnAppilesToType app)  = 0 ;
    virtual bool getTransitive ()  = 0 ;
    virtual RtnPurposeType getPurpose ()  = 0 ;
    virtual RtnAppilesToType getAppilesTo ()  = 0 ;
    //virtual void addElements( DesignObject*s)  = 0 ;
    //virtual void addExcludeElements(DesignObject *s)  = 0 ;
    //virtual void addExcludeElementsToRetentionStategy(RetentionStrategy *ret) = 0;
    //virtual void addElementsToRetentionStategy(RetentionStrategy *ret) = 0;
};
class RtnPortMap:public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(RtnPortMap);
};

class MapRtnElement:public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(MapRtnElement);
};

class AttributeValue : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(AttributeValue);
    virtual const char* getName() = 0;
    virtual const char* getValue() = 0;
};

class PortBBAttribute : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PortBBAttribute);
    //virtual char* getStoredAttributeVal (std::string & attributeName) = 0;
};

class PortAttribute : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(PortAttribute);
    virtual AttributeValueLI getValues() = 0;
    virtual ClampValueType getClampValue() = 0;
    virtual ClampValueType getSinkOffClampValue() = 0;
    virtual ClampValueType getSourceOffClampValue() = 0;
    virtual char*          getReceiverSupplySet() = 0;
    virtual char*          getDriverSupplySet() = 0;
    virtual char*          getPowertPort() = 0;
    virtual char*          getGroundPort() = 0;
};

class SupplyNetHandle :public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplyNetHandle);
    virtual void setMaster (SupplyNet *) = 0;
    virtual void setMasterHandle (SupplyNetHandle *) = 0;
    virtual SupplyNet * getMaster () = 0;
};

class SupplyNetFunction :public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplyNetFunction);
    virtual void setSupplyNetHandle (SupplyNetHandle *n) = 0;
    virtual SupplyNetHandle * getSupplyNetHandle () = 0;
    virtual SupplyNet * getSupplyNet () = 0;
};

class SupplySetHandle :public UpfNamedObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplySetHandle);
    virtual int getId() = 0;
    virtual SupplySetHandle* getAssociatedMasterHandle() = 0;
    virtual SupplyNetFunctionLI getSupplyNetFunctions() = 0;
    virtual bool isExplicitSupplyFunctionsSet() const = 0;
    virtual void addSupplyNetFunction (SupplyNetFunction *) = 0;
    virtual UpfSimstate* getSimstate() = 0;
    virtual UpfSimstate* getActiveState() = 0;
    virtual void setAutoBlackBox() = 0;
    virtual bool isAutoBlackBox() = 0;
    virtual void addSimstate(SupplySetState *pss) = 0;
    virtual SupplySetState* lookupState(const char* name) = 0;
    virtual SupplySetStateLI getStates() = 0;
    virtual SupplySetState* getDefaultState() = 0;
    virtual const char *getHandleName() = 0;
    virtual const char *getSimpleName() = 0;
    virtual bool hasTheGivenState(UpfPowerStateSimstate sim) = 0;
    virtual bool hasCorruptOnActivityState() = 0;
    virtual bool hasCorruptOnChangeState() = 0;
    virtual bool hasCorruptOnSequentialActivityState() = 0;
    virtual bool hasCorruptOnSequentialChangeState() = 0;
    virtual SupplyNetFunction * lookupSupplyNetFunction(const char *n) = 0;
    virtual bool isExplicit() = 0;
    virtual SupplySetHandle* getAssociatedRootHandle() = 0;
    virtual void setEquivalentHandle(SupplySetHandle* ssh) = 0;
    virtual SupplySetHandle* getEquivalentHandle() = 0;
    virtual bool isInternalSupplySet() = 0;
    virtual PowerScope *getPowerScope() = 0;
    virtual void setIsImplicitUnused(bool val) = 0;
    // For Functional Coverage
    virtual void createStateMachine() = 0;
    virtual StateMachine* getStateMachine() = 0;

    //This is for messaging infra
    virtual lpmsg::LpMsgSeverity getMsgSeverity() = 0;
    virtual void setMsgSeverity(lpmsg::LpMsgSeverity sev)  = 0;
    virtual bool getMsgEnabled() = 0;
    virtual void setMsgEnabled(bool en) = 0;

};

class SupplySetState : public UpfNamedObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplySetState);
    virtual PowerScope *getPowerScope() = 0;
    virtual BoolExpr* getSupplyExpr() = 0;
    virtual void checkSupplyExprForIllegalUpdates(BoolExpr*, SupplySetHandle*) {
        fassert(0, "checkSupplyExprForIllegalUpdates not expected for CPF"); }
    virtual void addPortStateFromSupplyExpr(BoolExpr*, SupplySetHandle*, const char* simstate) {
        fassert(0, "addPortStateFromSupplyExpr not expected for CPF"); }
    virtual void setSupplyExpr(BoolExpr* be, SupplySetHandle * ssh, const char* simstate) = 0;
    virtual void update(SupplySetState* ss, SupplySetHandle* sh) = 0;
    virtual BoolExpr* getLogicExpr() = 0;
    virtual void setLogicExpr(BoolExpr* be) = 0;
    virtual UpfPowerStateSimstate getSimstate() = 0;
    virtual void setSimstateType(UpfPowerStateSimstate t) = 0;
    virtual bool isLegal() = 0;
    virtual void setLegal() = 0;
    virtual bool isIllegal() = 0;
    virtual void setIllegal() = 0;
    virtual SupplyNetFunction* getSupplyFunction() = 0;
    virtual bool doSemanticCheck(const PowerDomain *pd) = 0;
    virtual void setEnumValue(int value) = 0;
    virtual int getEnumValue() = 0;
    virtual unsigned getObjectFileLine() = 0;
};

class SupplyState : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(SupplyState);
    virtual int getMinVoltage() const =0;
    virtual int getNomVoltage() const =0;
    virtual int getMaxVoltage() const =0;
    virtual UpfSupplyVoltageType getSupplyVoltageType() const = 0;
    virtual UpfSupplyNetState getSupplyState() const = 0;
    virtual bool isOffState() const =0;
    virtual void setEnumValue(int value) = 0;
    virtual int getEnumValue() = 0;
    virtual unsigned getObjectFileLine() = 0;
    virtual bool isDontCare() const= 0;
};

class UpfGroup : public UpfControllerObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfGroup);

    virtual PowerScope* getPowerScope() const = 0;
    virtual UpfGroupState* findState(const char* name) = 0;
    virtual UpfGroupStateTableLI getStates() = 0; 
    virtual int getNumStates() = 0;
    virtual UpfSimstate* getSimstate() const = 0;
    // For Functional Coverage
    virtual void createStateMachine() = 0;
    virtual StateMachine* getStateMachine() = 0;
};


class UpfGroupState : public UpfNamedObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfGroupState);
    virtual PowerScope *getPowerScope() = 0;
    virtual BoolExpr* getLogicExpr() = 0;
    virtual void setEnumValue(int value) = 0;
    virtual int getEnumValue() = 0;
    virtual bool isLegal() = 0;
    virtual unsigned getObjectFileLine() = 0;
};

class UpfSupplySource : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfSupplySource);
    //virtual StateMachine* getStateMachine() = 0;
    virtual SupplyState* findState(const char* name) = 0;
    virtual SupplyState* scopedFindState(PowerScope * ps, const char* name) = 0;
    virtual bool isUndriven() = 0;
    virtual UpfRootSupplyDriverLI getRootSupplyDrivers() = 0;
    virtual SupplyStateTableLI getStates() = 0;
    virtual unsigned getNumOfRootSupplyDrivers() = 0;
    virtual SupplyNetLI getConnectedNets() = 0;
    virtual SupplyPortLI getConnectedPorts() = 0;
    virtual PgSimDriverLoadsLI getPgSimDrivers() = 0;
    virtual PgSimDriverLoadsLI getPgSimLoads() = 0;
    virtual unsigned getNumOfPgSimDrivers() = 0;
    virtual unsigned getNumOfPgSimLoads() = 0;
    virtual UpfResolveType getResolutionType() = 0;
    virtual bool isGround() = 0;
    virtual bool isPower() = 0;
    virtual unsigned getId() = 0;
    virtual const char *getResolutionScheme() = 0;
    virtual unsigned getCorrelatedGroupId() const = 0;
    virtual StateMachine* getStateMachine() = 0;
    virtual bool getVoltageRangeFromAllPST(float& min, float &max) = 0;
    virtual SupplyState* getDefaultState() = 0;
    virtual void setDefaultState(SupplyState* st) = 0;
    virtual void setCorrelatedGroupId(unsigned corr_group_id) = 0;
    virtual bool addState(PowerScope * ps, SupplyState* state) = 0;
    virtual supply_net_type getDefaultSupplyStateValue() = 0;
    virtual UpfRootSupplyDriver* getUniqueRootSupplyDriver() = 0;
    virtual UpfRootSupplyDriver* getUndrivenRootSupplyDriver() = 0;
    virtual SupplyNet* getRootNet() = 0;
    virtual bool hasUpfContribution() = 0;
    virtual void setHasUpfContribution() = 0;

    //PlatoUpfToUpfirSan
    virtual void addNet(SupplyNet * net) = 0;
    virtual void addPort(SupplyPort * port) = 0;

};

class UpfRootSupplyDriver : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfRootSupplyDriver);
    virtual const char* getFullName() const = 0;
    virtual bool isSupplyNet() = 0;
    virtual bool isSupplyPort() = 0;
    virtual bool isPgSimDriver() = 0;
    virtual SupplyNet* getSupplyNet() = 0;
    virtual SupplyPort* getSupplyPort() = 0;
    virtual UpfPgSimDriverLoads* getPgSimDriver() = 0;
    virtual UpfSupplySource* getSupplySource() = 0;
    virtual UpfRootSupplyDriverType getDriverType() = 0;
    virtual void setDriverType(UpfRootSupplyDriverType dt) = 0;
    virtual unsigned getId() = 0;
};

class UnresolvedEquivalentSupply : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UnresolvedEquivalentSupply);
    virtual bool isFunctionOnly() = 0;
};

class UpfEquivalentSupplySources : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfEquivalentSupplySources);
};

class UpfSupplyPortState : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(UpfSupplyPortState);
    virtual SupplyStateLI getSupplyStates() = 0;
    virtual bool isSupplyNet() = 0;
    virtual bool isSupplyPort() = 0;
    virtual SupplyNet* getSupplyNet() = 0;
    virtual SupplyPort* getSupplyPort() = 0;
};

class State : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(State);
    virtual int getEnumId() = 0;
    virtual void setEnumId(int id) = 0;
    virtual void* getHook() = 0;
    virtual void setHook(void* hook) = 0;
    virtual LegalityType getLegality() = 0;
    virtual void setLegality(LegalityType legal) = 0;
    virtual bool isUnusedState() = 0;
    virtual bool isUserDefined() = 0;

};

class StateEntry : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(StateEntry);
    virtual State* getState() = 0;
    virtual bool isResolved() = 0;
    virtual bool resolve(StateMachine* sm) = 0;
    virtual void setState(State *s) = 0;
};

class StateEntryPair : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(StateEntryPair);
    virtual StateEntry* getFrom() = 0;
    virtual StateEntry* getTo() = 0;
};

class TransitionGroup : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(TransitionGroup);
    virtual bool isResolved() = 0;
    virtual LegalityType getLegality() = 0;
    virtual StateEntryLI getThrough() = 0;
    virtual StateEntryLI getFrom() = 0;
    virtual StateEntryLI getTo() = 0;
    virtual StateEntryPairLI getPaired() = 0;
    virtual bool isSimstateTransitionGroup() = 0;
    virtual UpfObj* getObject() = 0;
    virtual TransitionTableLI getTransitions() = 0;
    virtual bool resolveTransitions() = 0;
    virtual void report() = 0;
    virtual void setHasLegalTransition(bool b) = 0;
    virtual bool hasLegalTransition() = 0;
};

class Transition : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(Transition);
    virtual StateLI getSequence() = 0;
    virtual LegalityType getLegality() = 0;
    virtual void append(State* entry) = 0;
    virtual void insert(State* entry) = 0;
    virtual void createName() = 0;
    virtual void report() = 0;
    virtual bool isAutoTransition() = 0;

};

class StateMachine : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(StateMachine);
    virtual const char* getStateName() const = 0;
    virtual const char* getGroupName() const = 0;
    virtual StateTableLI getStates() = 0;
    virtual TransitionGroupTableLI getTransitions() = 0;
    virtual UpfObj* getObject() = 0;
    virtual void setObject(UpfObj* obj) = 0;
    virtual void populateAutoTransitions() = 0;
    virtual void report() = 0;
    virtual void addState(const char* name, unsigned fileline, LegalityType legal, bool isUserDefined, bool isUsed) = 0;
    virtual State* findState(const char* name) = 0;
    virtual bool addTransitionGroup(TransitionGroup* grp) = 0;
    virtual TransitionLI getAutoTransitions() = 0;
    virtual bool hasTransitions() = 0;
    virtual void setStateMachineType(StateMachineType) = 0;
    virtual StateMachineType getStateMachineType() = 0;
    virtual void setSimpleName(const char* nm) {}
    virtual const char* getSimpleName() const { return NULL; }
};

class PowerConfig
{

public:
    virtual void applyNoClockInfer() = 0;
    virtual void registerDesignAdapter(UpfDesignAdapter *adapter) = 0;
    virtual ~PowerConfig() {}
};

class ContextResetGroup: public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(ContextResetGroup);
    virtual ~ContextResetGroup()  {}
    virtual const char *getName() const = 0;
    virtual void appendTraceDownwardElement(DesignObject *obj) = 0;
    virtual void appendTraceDownwardElementasString (const char *s) = 0;
    virtual DesignObjectLI getAllTraceDownwardElement()  = 0;
    bool isEncrypted() const { return false; }
};

class CdcClock : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(CdcClock);

    virtual int getId() = 0; 

    virtual DesignObject* getDesignObject() const = 0;
    virtual void setVhName(const char *vhName) = 0;
    virtual std::string &getVhName() = 0;
};

class CdcInstance : public UpfNamedObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(CdcInstance);

    virtual int getId() = 0; 
    virtual DesignObject* getDesignObject() const = 0;
    virtual CdcClock* getClock() const = 0;
    virtual unsigned int  getEdgeCount() const = 0;
    virtual unsigned int  getDelay() const = 0;
    virtual bool isTransitive() const = 0;
};

class CdcInstanceDb : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(CdcInstanceDb);
    virtual ~CdcInstanceDb() {}

    virtual bool isCdcCorruptionEnabled() const = 0;
    virtual CdcClockTableLI getClockTable() const = 0;
    virtual CdcClock*  findClock(int id) const = 0;

    virtual CdcInstanceTableLI getInstanceTable() const = 0;
    virtual CdcInstance*  findInstance(int id) const = 0;
    virtual int getTotalClockCount() = 0;

    virtual bool resolveDesignRef() = 0;
    virtual void print() const  = 0;
};

class BlackBoxModel : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE_ABSTRACT(BlackBoxModel);
    virtual ~BlackBoxModel() {}
    virtual const char* getName() = 0;
};

class ControlSignalInfo : public UpfObj
{
public :
    VCS_DECL_SERIALIZABLE_ABSTRACT(ControlSignalInfo);
    virtual ~ControlSignalInfo() { }
    virtual const char* getControlSignalName() = 0;
    virtual FlopCtrlSigType getControlSignalType() = 0;
    virtual bool getControlSignalSense() = 0;
    virtual int getControlSignalFlatIndex() = 0;
    virtual DesignElementTokenL * getControlSignalTokenL() = 0;
};


class UpfFile 
{
public:
    virtual ~UpfFile() {}
    virtual const char* getFileName() = 0;
    virtual const char* getSupplementalFileName() = 0;
    virtual const char* getScope() = 0;
    virtual const char* getTarget() = 0;
    virtual bool strictChecks() = 0;
};


// Function for Equivalence of Supplies for Isolation
bool areSuppliesEquivalentForIsolation(SupplySetHandle* ssh1, SupplySetHandle* ssh2);
bool areSuppliesEquivalentForIsolation(SupplyNet* power, SupplyNet* ground, SupplySetHandle* ssh2);
bool areSuppliesEquivalentForIsolation(SupplyNet* power1, SupplyNet* ground1, SupplyNet* power2, SupplyNet* ground2);

// Function for Equivalence of Supplies for Level Shifting
bool areSuppliesEquivalentForLevelShifting(SupplySetHandle* ssh1, SupplySetHandle* ssh2);
bool areSuppliesEquivalentForLevelShifting(SupplyNet* power, SupplyNet* ground, SupplySetHandle* ssh2);
bool areSuppliesEquivalentForLevelShifting(SupplyNet* power1, SupplyNet* ground1, SupplyNet* power2, SupplyNet* ground2);

bool areSupplySetsEquivalent(SupplySetHandle* s1, SupplySetHandle* s2);
NAMESPACE_UPFIR_END
UPFIR::UpfReaderIf*  makeOrGetUpfParser(bool runtime = false);

#endif //__UpfCommandInterface_hh__
# 3360 "/remote/vgrnd13/bpham/VCS/lp-src/upf/include/UpfCommandInterface.hh"
# 12 "./CpfRetentionStrategy.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "UpfTypeDefImpl.hh"
#endif /* expanded by -frewrite-includes */
# 12 "./CpfRetentionStrategy.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

#ifndef __UpfTypeDefImpl_hh__
#define __UpfTypeDefImpl_hh__
#if 0 /* expanded by -frewrite-includes */
#include "list.hh"
#endif /* expanded by -frewrite-includes */
# 9 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
#if 0 /* expanded by -frewrite-includes */
#include "hash.hh"
#endif /* expanded by -frewrite-includes */
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
#if 0 /* expanded by -frewrite-includes */
#include "stack.hh"
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

// Copyright (C) 1995-1997 Radiant Design Tools.  All Rights Reserved.
// This program is an unpublished work fully protected by the
// United States copyright laws and is considered a trade secret
// belonging to Radiant Design Tools.

#ifndef _STACK_HH_
#define _STACK_HH_

/// @file
/// This file contains the interface to a Stack template
/// class. Because of templates it also contains the implementation :(

// This is needed because we use placement new.
#if 0 /* expanded by -frewrite-includes */
#include <new>
#endif /* expanded by -frewrite-includes */
# 20 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh"
# 21 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh"

#if 0 /* expanded by -frewrite-includes */
#include "util.hh"
#endif /* expanded by -frewrite-includes */
# 22 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh"
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh"
#if 0 /* expanded by -frewrite-includes */
#include "pool.hh"
#endif /* expanded by -frewrite-includes */
# 23 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh"
# 24 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh"

/// Stack traits parameterize behavioral details:
/// (1) Control whether warning about large stacks.

template<typename T> struct StackTraitsWarn
{
    enum { warnLargeSize = 1 };
};

template<typename T> struct StackTraitsNowarn
{
    enum { warnLargeSize = 0 };
};

template<typename T> struct StackTraitsDefault : public StackTraitsWarn<T>
{
};

// Forward declarations.
template<class T, class Traits_ = StackTraitsDefault<T> > class Stack;
template<class T, class Traits_ = StackTraitsDefault<T> > class StackI;

/// This is a template for extensible stacks. The stack is implemented
/// as an array, which is initialized with some small number of
/// entries, and grow as required. If they grow past a certain size
/// they will notify, unless you use the StackN template defined below.
///
/// @note This template is appropriate for small items, since it
/// copies the item itself.
template<class T, class Traits_> class Stack
{
    // These methods are needed to make Stack<T> behave according to
    // C++ object semantics - stack slots have to have the constructor
    // and destructor called on push/pop. This is not necessary for
    // "POD" types (scalars, constructorless structs), and the C++
    // standard has provided for this. These operations should become
    // nops and optimized out for types T that don't need them.

    static inline void init(T* p, int i)
    {
        // It is important to use 'T' and not 'T()' here; this is
        // because the former does not do default initialization
        // for POD types like int. Otherwise int will be initialized
        // to 0, which is redundant, as this will be immediately
        // followed by assignment in push/copy.
        ::new (p+i) T;
    }

    static inline void deinit(T *p, int i)
    {
        (p+i)->~T();
    }

public:
    typedef Traits_ Traits;
    Stack(const char* name)
        : name_(name)
        , top_(0)
        , size_(InitSize)
    {
        array_ = (T*)getCurrentLifeGuard()->createArray(
                     sizeof(T), size_);
    }

    ~Stack() {
        purge();
        getCurrentLifeGuard()->destroyArray(array_, sizeof(T), size_);
    }

    /// Removes all items from the stack. Does *not* delete them.
    /// (Will call destructor on slot objects if applicable, but
    /// not delete pointers.)
    /// @todo +++RFE+++ This method could be extended to trim array_ if it's
    /// too large.
    void            purge() {
        for (int i = top_-1; i >= 0; i--) {
            deinit(array_, i);
        }
        top_ = 0;
    }

    /// This pushes a new item on the stack, growing the array if needed.
    void        push(T item) {
        if (top_ == size_) {
            // The stack has to grow.
            T* newArray;
            int newSize = size_ << 1;
            fassert(newSize >= 0 && newSize > size_,
                    "stack size overflow");
            newArray = (T*)getCurrentLifeGuard()->
                       createArray(sizeof(T), newSize);
            fassert(newArray,
                    msg("%s can't grow to %d.\n",
                        name_, newSize));
            for (int i = 0; i < size_; i++) {
                init(newArray, i);
                newArray[i] = array_[i];
                deinit(array_, i);
            }
            getCurrentLifeGuard()->destroyArray(
                array_, sizeof(T), size_);
            array_ = newArray;
            size_ = newSize;
            if (Traits::warnLargeSize) {
                wassert(size_ < RatherLargeSize,
                        msg("%s grew to size %d",
                            name_, size_));
            }
        }
        init(array_, top_);
        array_[top_++] = item;
    }

    /// This pops and returns the item on top.
    /// @pre It is fatal to pop from an empty stack.
    T       pop() {
        fassert(top_ > 0, msg("%s underflow.\n", name_));
        // For class type T, this will lead to an extra copy,
        // first from array_ to t, then from t in return,
        // but this seems unavoidable due to C++ copy semantics.
        T t = array_[--top_];
        deinit(array_, top_);
        return t;
    }

    /// This discards the item on top.
    /// @pre It is fatal to pop from an empty stack.
    void        discardTop() {
        fassert(top_ > 0, msg("%s underflow.\n", name_));
        --top_;
        deinit(array_, top_);
    }

    /// This gets the item on top of the stack, or NULL if empty.
    T       tos() const {
        return (top_ > 0) ? array_[top_ - 1] : T();
    }

    /// This returns a reference to the item on top of the stack.
    /// @pre It is fatal to call this method on an empty stack.
    T&      tosReference() {
        fassert(top_ > 0, msg("%s underflow.\n", name_));
        return array_[top_ - 1];
    }

    /// This gets the stack depth.
    uint            getDepth() const        { return top_; }

    /// This retrieves the item at the given depth in the
    /// stack. The top item is at index 0. If the index is past
    /// the bottom of the stack we return NULL.
    /// @pre It is fatal to pass a negative index.
    T       operator[](int ix) const {
        fassert(ix >= 0, msg("%s index cannot be negative", name_));
        return (ix < top_) ? array_[top_ - ix - 1] : T();
    }

    /// This replaces the item at the given index.
    /// @pre The index must be within bounds.
    void        replaceAt(T item, int ix) {
        fassert((ix >= 0) && (ix < top_), msg("Illegal stack index"));
        array_[top_ - ix - 1] = item;
    }

    /// This returns true if the stack is empty.
    bool        isEmpty() const     { return top_ == 0; }

private:
    // Block copy and assignment operators
    Stack(Stack<T>&);
    Stack<T>& operator=(Stack<T>&);

private:
    friend class    StackI<T, Traits>;

    enum {      InitSize = 8 };
    enum {      RatherLargeSize = 16384 };

    T*      array_;         //< This array holds the items.
    const char* name_;          //< This is the name of the stack
    int     top_;           //< This is the next available entry,
    //< and also the number of entries
    int     size_;          //< This is the size of the
    //< array, unrelated to the
    //< number of entries
};

/// This is an iterator on the items in a stack. They are traversed
/// from top to bottom.
template<class T, class Traits_> class StackI
{
public:
    typedef Traits_ Traits;

    StackI(const Stack<T, Traits>& st)
        : st_(st)
        , current_(0) {}

    /// The current item.
    T       operator()() const  { return st_[current_]; }

    /// Post increment.
    T       operator++(int) {
        return ((current_ >= st_.getDepth()) ? NULL : st_[current_++]);
    }

private:
    const Stack<T>& st_;
    uint        current_;
};

/// StackN/StackNI: Raw Stack without large size warning

template<class T> class StackN : public Stack<T, StackTraitsNowarn<T> >
{
public:
    StackN(const char* name)
        : Stack<T, StackTraitsNowarn<T> >(name)
    {}
};

template<class T> class StackNI : public StackI<T, typename StackN<T>::Traits>
{
public:
    StackNI(const StackN<T>& st)
        : StackI<T, typename StackN<T>::Traits>(st)
    {}
};

//*--------------------------------------------------------------------------
//* This is an attempt to create a lightweight version of class Stack for
//* stacks of pointers. As they are widely used in iterators, they deserve
//* a special treatment ;) Furthermore, an analysis of over 90 benchmarks
//* ran with +rad shows that:
//* - 73.39% of all stacks are never used
//* - 90.83% of all stacks have at most 1 element
//* - almost 100% of all stacks have less than 9 elements.
//*
//* My initial approach was to put stack array along with 'size' and 'top'
//* in a contiguous memory block and keep only a pointer to this block in
//* class StackP. Additionally, 1-element stacks were initially created
//* without this block, and the pointer pointed directly to the element
//* (the least significant bit of the pointer was set to 1 in such case).
//* However, this implementation turned out to be _slower_ than the original
//* Stack class, even after multiple changes. It seems that it's necessary
//* to keep 'top' along with array pointer to avoid pointer dereferencing
//* in isEmpty() and atIndex() methods, which are heavily used in all code
//* processing stacks.
//*
//* Stack_base and derived classes have the same interface as Stack<T>.
//*--------------------------------------------------------------------------

class Stack_base
{
public:
    Stack_base() : array_(NULL), size_(0), top_(0)  { }
    Stack_base(unsigned estimatedSize) :
        array_(estimatedSize ? allocateArray(estimatedSize) : NULL),
        size_(estimatedSize),
        top_(0)         { }
    ~Stack_base()                   { if(array_) freeArray(); }

    /// Removes all items from the stack. Does *not* delete them.
    /// @todo +++RFE+++ This method could be extended to trim array_ if it's
    /// too large.
    void            purge() {
        top_ = 0;
    }

    bool        isEmpty() const         { return (top_ == 0); }
    bool        inStack(unsigned ix) const  { return (ix < top_); }

    void        push(void* p) {
        if (isFull()) {
            growArray();
        }
        array_[top_++] = p;
    }

    void*       pop() {
        fassert(top_ > 0U, msg("stack underflow"));
        return array_[--top_];
    }

    void*       tos() const {
        return (top_ > 0) ? array_[top_ - 1] : NULL;
    }

    void        replaceAt(void* p, int ix) {
        fassert((ix >= 0) && (static_cast<uint>(ix) < top_),
                msg("Illegal stack index"));
        array_[top_ - ix - 1] = p;
    }

    void*       atIndex(int ix) const {
        fassert(ix >= 0, msg("stack index cannot be negative"));
        return (inStack(unsigned(ix)) ? array_[top_ - ix - 1] : NULL);
    }

    void*       atIndex_1(unsigned ix1) const {
        // This method works as atIndex(ix1 - 1), but assumes
        //   that (1 <= ix1 <= top_)
        fassert((ix1 >= 1U) && (ix1 <= top_),
                msg("atIndex_1: stack index out of bounds"));
        return array_[top_ - ix1];
    }

    /// Returns the current depth of the stack.
    uint        getDepth() const        { return top_; }

private:
    bool        isFull() const  { return (top_ >= size_); }

    static unsigned elm2B(unsigned sz) {
        return(sz * sizeof(void*));
    }

    static void**   allocateArray(unsigned sz) {
        // Allocates memory for sz-element stack. Assumes sz >= 1
        return((void**)getCurrentLifeGuard()->create(elm2B(sz)));
        // No memcheck() here on purpose - I want the allocation to be
        //   as fast as possible, and dereferencing NULL will be caught
        //   anyway. And I don't want to use createArray() as it would
        //   split large stacks into pieces of sizeof(void*) when they
        //   are freed
    }

    void        freeArray() const {
        // Releases memory occupied by stack array
        getCurrentLifeGuard()->destroy(array_, elm2B(size_));
    }

    void        growArray(void);

private:
    // Block copy and assignment operators
    Stack_base(Stack_base&);
    Stack_base& operator=(Stack_base&);

    // The following constants were shamelessly copied from Stack<T>
    enum {      InitSize = 8 };
    enum {      RatherLargeSize = 16384 };

private:
    // array==NULL in the case of an empty stack which has never been used
    void**      array_;
    uint        size_;
    uint        top_;
};


template<class T> class StackP : public Stack_base {
public:
    StackP() : Stack_base() { }
    StackP(const char *) : Stack_base() { }
    // ^ This constructor is provided only to maintain compatibility
    //   with Stack<T>

    StackP(unsigned estimatedSize) : Stack_base(estimatedSize) { }

    void        push(T* item)   { Stack_base::push((void *)item); }
    T*      pop()       { return (T*)Stack_base::pop(); }
    T*      tos() const { return (T*)Stack_base::tos(); }
    void        replaceAt(T* item, int ix)
    { Stack_base::replaceAt((void *)item, ix); }
    T*      operator[](int ix) const
    { return (T*)Stack_base::atIndex(ix); }
    T*      atIndex_1(unsigned ix1) const
    { return (T*)Stack_base::atIndex_1(ix1); }
};


template<class T> class StackPI
{
public:
    StackPI(const StackP<T>& p_st) : st(p_st), current(0) {}

    T*      operator()() const  { return st[current]; }

    T*      operator++(int) {
        return (st.inStack(current) ? st.atIndex_1(++current) : NULL);
    }

private:
    const StackP<T>& st;
    unsigned    current;
};

#endif // _STACK_HH_
# 413 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/stack.hh"
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "buffer.hh"
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
#if 0 /* expanded by -frewrite-includes */
#include "map.hh"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

#ifndef _MAP_HH_
#define _MAP_HH_

#ifndef _LIST_HH_
#if 0 /* expanded by -frewrite-includes */
#  include "list.hh"
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"
#endif
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"
#ifndef _HASH_HH_
#if 0 /* expanded by -frewrite-includes */
#  include "hash.hh"
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"
#endif
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"
#ifndef _VOLATILESTR_HH
#if 0 /* expanded by -frewrite-includes */
#  include "volatilestr.hh"
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"
# 1 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

#ifndef _VOLATILESTR_HH
#define _VOLATILESTR_HH

#if 0 /* expanded by -frewrite-includes */
#include <string.h>
#endif /* expanded by -frewrite-includes */
# 10 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
# 11 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
#ifndef _UTIL_HH_
#if 0 /* expanded by -frewrite-includes */
#  include "util.hh"    // For memcheck.
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
# 13 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
#endif
# 14 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
#ifndef _POOL_HH_
#if 0 /* expanded by -frewrite-includes */
#  include "pool.hh"    // For memory management.
#endif /* expanded by -frewrite-includes */
# 15 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
# 16 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
#endif
# 17 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"

// This defines the a volatile string. It is mainly to store these things in
// the symbol table.
class VolatileStr
{
public:
    explicit VolatileStr(const char* p_name)
        : name(getCurrentLifeGuard()->strdupVolatileStr(p_name)) { }
    VolatileStr(const char* p_name, size_t nChars) {
        if (p_name) {
            name = getCurrentLifeGuard()->createVolatileStr(nChars + 1);
            memcpy(name, p_name, nChars);
            name[nChars] = '\0';
        }
        else {
            name = NULL;
        }
    }
    ~VolatileStr() { purge(); }

    const char* getName() const {
        return name;
    }
    void        stealFrom(VolatileStr& vs) {
        purge();
        name = vs.name;
        vs.name = NULL;
    }

private:
    VolatileStr(const VolatileStr&);
    void operator=(const VolatileStr&);

    void        purge() {
        if (name) {
            getCurrentLifeGuard()->destroyVolatileStr(name);
        }
    }

private:
    char*   name;
};

#endif // _VOLATILESTR_HH
# 61 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/volatilestr.hh"
# 18 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh" 2
#endif
# 19 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"

// This file has declarations for two types of maps, which are tables
// associating keys to values. The two variants correspond to how the
// key works: in MapL the key must support a getName() member
// function, in Mapper the key is a const char*.

template<class KEY,class VALUE> class MapL;
template<class T> class Mapper;

//----------------------------------------------------------------------
//  Intrusively linked pairs.  These are not exported from the maps,
//  but only internally managed.

template<class FST,class SND>
struct MapPair : SlinkB
{
    FST first;
    SND second;

public:
    MapPair(const FST &first_)
        : first(first_)
        , second()
    {
    }

    lifeGuardNewAndDeleteMacro
};

//----------------------------------------------------------------------
//  Pairs supporting getName(), deferring to their first member.

template<class FST,class SND>
struct NameMapPair : public MapPair<FST,SND>
{
public:
    NameMapPair(const FST &first_)
        : MapPair<FST,SND>(first_)
    {
    }

    lifeGuardNewAndDeleteMacro

    const char *getName()
    {
        return this->first->getName();
    }
};

//----------------------------------------------------------------------
//  getName() based maps.  KEY must support application of ->getName().

template<class KEY,class VALUE>
class MapL
{
    typedef KEY                             KeyT;
    typedef VALUE                           ValT;
    typedef NameMapPair<KEY,VALUE>          PairT;
    typedef HashTableM<PairT>               HashTab;

    HashTab     htab;

public:
    lifeGuardNewAndDeleteMacro

    void clear()
    {
        htab.deleteItems();
    }

    ValT &operator[](KeyT &key)
    {
        int index = 0;
        PairT *p = htab.lookup(key->getName(),index);

        if (p == NULL)
        {
            p = new PairT(key);
            nullcheck(p);
            htab.append(p,index);
        }

        return p->second;
    }
};


template<class KEY, class VALUE> class PtrMapI;

/// PtrMap is a pointer-to-pointer map.
/// It hashes the pointer value of KEY rather than the name of KEY.
/// If there is a more efficient way to implement this, feel free.
template<class KEY,class VALUE>
class PtrMap
{
    typedef KEY                             KeyT;
    typedef VALUE                           ValT;
public:
    typedef MapPair<KEY,VALUE>              PairT;
    typedef typename HashTableX<PairT>::LinkedQ      HashTab;
    typedef typename HashTableX<PairT>::LinkedQI     HashTabI;
    typedef HashTabI iterator;
private:

    HashTab     htab;

    static uint hash(const PairT* p) {
        return HashTableBase::hash(p->first);
    }

    static bool eq(const PairT* p, const PairT* q) {
        return p->first == q->first;
    }

public:
    lifeGuardNewAndDeleteMacro

    PtrMap() : htab(PtrMap::hash, PtrMap::eq) { }
    explicit PtrMap(unsigned size) : htab(PtrMap::hash, PtrMap::eq, size) { }

    iterator getIterator() { return iterator(htab); }

    void detachItems()
    {
        htab.deleteItems();
    }

    void detachItemsAndDeleteValues()
    {
        HashTabI hti(htab);
        do {
            while (PairT *item = htab.detachAt(hti)) {
                VALUE ret = item->second;
                delete item;
                delete ret;
            }
        } while (0);
    }

    VALUE deleteFirstAndDetachValue()
    {
        HashTabI hti(htab);
        do {
            if (PairT *item = htab.detachAt(hti)) {
                VALUE ret = item->second;
                delete item;
                return ret;
            }
        } while (0);
        return NULL;
    }

    bool isEmpty() const
    {
        return htab.isEmpty();
    }

    void clear()
    {
        htab.deleteItems();
    }
    /// Key present, or not?
    bool exists(const KeyT &key) const
    {
        PairT k(key);
        PairT *p = htab.lookup(&k);
        //mprintf("find %p, %p, %s\n", this, key, p != NULL ? "yes" : "no");
        return p != NULL;
    }

    /// Finds and also alerts if key exists or not. Usefull especially
    /// when storing NULL as values (avoids one lookup)
    ValT lookup(const KeyT &key, bool &exists) const
    {
        PairT k(key);
        PairT *p = htab.lookup(&k);
        //mprintf("find %p, %p, %s\n", this, key, p != NULL ? "yes" : "no");

        if (p == NULL)
        {
            exists = false;
            return NULL;
        }
        exists = true;
        return p->second;
    }

    /// Finds key, returns NULL if key does not exists
    ValT lookup(const KeyT &key) const
    {
        PairT k(key);
        PairT *p = htab.lookup(&k);
        //mprintf("find %p, %p, %s\n", this, key, p != NULL ? "yes" : "no");

        if (p == NULL)
        {
            return 0;
        }
        return p->second;
    }

    PairT *find(const KeyT &key) const {
        PairT k(key);
        return htab.lookup(&k);
    }

    ValT detach(const KeyT &key) {
        ValT ret = 0;
        PairT k(key);
        PairT *p = htab.lookup(&k);
        if (p) {
            ret = p->second;
            htab.detach(p);
            delete p;
        }
        return ret;
    }

    /// Find only, NULL indistingushable from "not-present"
    /// Should not be used on LHS.  (how to enforce this?)
    ValT operator()(const KeyT &key) const
    {
        PairT k(key);
        PairT *p = htab.lookup(&k);
        //mprintf("find %p, %p, %s\n", this, key, p != NULL ? "yes" : "no");

        if (p == NULL)
        {
            return NULL;
        }

        return p->second;
    }

    /// FindOrAdd
    ValT& operator[](const KeyT& key)
    {
        int index = 0;
        PairT k(key);
        PairT *p = htab.lookup(&k,index);
        //mprintf("find or add %p, %p, %s\n", this, key, p != NULL ? "found" : "added");

        if (p == NULL)
        {
            p = new PairT(key);
            nullcheck(p);
            htab.append(p,index);
        }

        return p->second;
    }

    const HashTab& getHashTable() const { return htab; }
    HashTab& getHashTable() { return htab; }

    // assuming no null key
    KeyT detachFirstKey(ValT &val) {
        PairT* p = detachFirst();
        if (p) {
            KeyT key = p->first;
            val = p->second;
            delete p;
            return key;
        }
        val = NULL;
        return NULL;
    }

private:
    friend class PtrMapI<KEY, VALUE>;

    // keep calling until returns NULL to empty it
    PairT* detachFirst() {
        HashTabI hti(htab);
        return htab.detachAt(hti);
    }
};


// Mapper was initially meant for hashing a set of module's
// with a name other than their module names.

template <class T> class Mapper : public SlinkB
{
public:
    lifeGuardNewAndDeleteMacro

    Mapper(const char* n, T* m) :
        name(n),
        item(m) { }
    const char* getName(void) const { return name.getName(); }
    T*      getMapItem(void) const  { return item; }
    void        changeMapItem(T* t) { item = t; }

private:
    VolatileStr name;
    T*      item;
};


template <class KEY, class VALUE>
class PtrMapI
{
    typedef PtrMap<KEY, VALUE>          PM;
    typedef typename PM::PairT          PairT;
    typedef typename PM::HashTabI       HashTabI;

public:
    PtrMapI(const PM& ptrmap)
        : hti(ptrmap.htab)
    {}

    PtrMapI(const PM* ptrmap)
        : hti(ptrmap->htab)
    {}

    //post-increment
    PairT* operator++(int)
    {
        return hti++;
    }

    PairT* operator++()
    {
        return ++hti;
    }

    PairT* operator()() const
    {
        return hti();
    }

private:
    HashTabI hti;
};

#endif /* _MAP_HH_ */
# 356 "/remote/vgrnd13/bpham/VCS/vgcommon/generic/container/include/map.hh"

# 14 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "UpfObj.hh"
#endif /* expanded by -frewrite-includes */
# 14 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 15 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 15 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 16 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 16 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 17 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
#if 0 /* expanded by -frewrite-includes */
#include <list>
#endif /* expanded by -frewrite-includes */
# 17 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 18 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
#if 0 /* expanded by -frewrite-includes */
#include <map>
#endif /* expanded by -frewrite-includes */
# 18 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 19 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"

///All required list
NAMESPACE_UPFIR_BEGIN
class DesignQueryImpl;
class UpfEquivalentSupplySourcesImpl;
class SupplyNetFunction;
class SupplyNetHandle;
class SupplySetHandle;
class CorrelatedSupplyGroup;
typedef HashTableL<PowerDomain>    PowerDomainTableL;
typedef HashTableL<PowerScope>     PowerScopeTableL;
typedef HashTableL<PowerSwitch>    PowerSwitchTableL;
typedef HashTableL<SupplyPort>     SupplyPortTableL;
typedef HashTableL<SupplyNet>      SupplyNetTableL;
typedef HashTableL<SupplyNetPair>      SupplyNetPairL;

typedef HashTableL<RetentionStrategy>    RetentionTableL;
typedef HashTableL<IsolationStrategy>    IsolationTableL;
typedef HashTableL<SRSNStrategy>    SRSNTableL;
typedef HashTableL<LevelShifterStrategy> LevelShifterTableL;

typedef HashTableP<DesignScope>      DesignScopeTableP;

typedef SlistL<IsolationCellFunc> IsolationCellFuncL;
typedef SlistL<IsolationCellSupply> IsolationCellSupplyL;
typedef SlistL<AttributeValue> AttributeValueL;
typedef HashTableL<DesignModel> DesignModelTableL;
typedef SlistL<UpfDesignPort> UpfDesignPortL;
typedef HashTableL<UpfDesignPort> UpfDesignPortTableL;
typedef HashTableL<SupplyNetFunction> SupplyNetFunctionL;
typedef HashTableL<SupplyNetFunctionT> SupplyNetFunctionTL;
typedef HashTableL <SupplyNetHandle> SupplyNetHandleL;
typedef SlistL<SupplyNetHandle> SupplyNetHandleSL;
typedef SlistL<SupplySetHandle>     SupplySetL;
typedef HashTableL<SupplySetHandle> SupplySetTableL;
typedef HashTableP<SupplySetHandle> SupplySetTableP;
typedef SlistL<SupplySetState> SupplySetStateL;
typedef HashTableL<SupplySetState> SupplySetStateH;
typedef SlistL<SupplySetHandle>  SupplySetHandleL;
typedef HashTableL <SupplySetHandle>  SupplySetHandleTableL;
typedef SlistL<char>            charL;
typedef SlistL<PowerDomain>     PowerDomainL;
typedef SlistL<LpSourceInfo> LpSourceInfoL;
typedef SlistL<ReInitInfo> ReInitInfoL;
typedef SlistL<LevelShifterStrategy> LevelShifterL;
typedef SlistL<XoverGate> XoverGateL;
typedef SlistL<IsolationStrategy> IsolationL;
typedef SlistL<SRSNStrategy> SRSNStrategyL;
typedef SlistL<RetentionStrategy> RetentionL;
typedef SlistL<RetentionElements> RetentionElementsL;
typedef SlistL<RtnPortMap> RtnPortMapL;
typedef SlistL<MapRtnElement> MapRtnElementL;
typedef SlistL<PowerStateTable> PowerStateTableL;
typedef HashTableL<PowerStateTable> PSTTableL;
typedef SlistL<Hdl2UpfVct>      Hdl2UpfVctL;
typedef SlistL<Upf2HdlVct>      Upf2HdlVctL;
typedef SlistL<BindChecker>     BindCheckerL;
typedef SlistL<SaveUpf>         SaveUpfL;
typedef SlistL<LoadUpf>         LoadUpfL;
typedef SlistL<SupplyNet >      SupplyNetL;
typedef SlistL<PowerSwitch >    PowerSwitchL;
typedef SlistL<SwitchState >    SwitchStateL;
typedef SlistL<AckPort >        AckPortL;
typedef SlistL<OnPortState >    OnPortStateL;
typedef SlistL<ControlPort >    ControlPortL;
typedef SlistL<UpfPort >        UpfPortL;
typedef SlistL<RetentionSignal> RetentionSignalL;
typedef SlistL<PstState>        PstStateTableL;
typedef SlistL<BoolExpr>        BoolExprL;
typedef SlistL<DesignObject>    DesignObjectL;
typedef SlistL<DesignQueryImpl>  DesignQueryImplL;
typedef SlistLI<DesignQueryImpl> DesignQueryImplLI;
typedef SlistL<UpfEquivalentSupplySourcesImpl>  UpfEquivalentSupplySourcesL;
typedef SlistLI<UpfEquivalentSupplySourcesImpl> UpfEquivalentSupplySourcesLI;

typedef HashTableL<SupplyState>     SupplyStateTableL;
typedef SlistL<SupplyState>         SupplyStateL;
typedef SlistL<CorrelatedSupplyGroup> CorrSupplyGroupL;
typedef SlistLI<CorrelatedSupplyGroup> CorrSupplyGroupLI;
typedef std::map<std::string, std::string> VhVlCdcClkNameMap;

typedef enum {
    WILDCARD_NO_ERROR,              //OK.
    WILDCARD_NO_MATCH,              //Warn in this case
    WILDCARD_STRUCT_MEMBERS,        //supported only for few commands.. can result in error
    WILDCARD_MULTI_BIT_SEL_PRESENT, //Unsupported item.. must-error
    WILDCARD_PART_SELECT            //Unsupported item.. must-error
} WcFlatteningErrorType;

typedef SlistL<State>               StateL;
typedef HashTableL<State>           StateTableL;
typedef SlistL<StateEntry>          StateEntryL;
typedef SlistL<StateEntryPair>      StateEntryPairL;
typedef SlistL<Transition>          TransitionL;
typedef HashTableL<Transition>          TransitionTableL;
typedef HashTableL<Transition>       TransitionTableL;
typedef HashTableL<TransitionGroup> TransitionGroupTableL;
typedef SlistL<TransitionGroup>     TransitionGroupL;
typedef SlistL<StateMachine>     StateMachineL;
extern const char* ppiKindP[cUpfClassType+1];
///Function to extract port from given UpfObj
typedef UpfPort* (*getUpfPortByName)(const char*, UpfObj*, const char*);

class UpfEncryptedObj : virtual public UpfEncryptedObjAbstract {
public:
    VCS_DECL_SERIALIZABLE(UpfEncryptedObj);
    void serialize(ser::Archive& ar);
    UpfEncryptedObj();
    void setEncrypted(bool val) {_encrypted = val; }
    virtual bool isEncrypted() const { return _encrypted; }
    const char* getEncryptedName() const { return encryptedName_; }
    const char* encryptName(const char*) const;
    static const char* encryptedName_;
private:
    bool _encrypted;
};

NAMESPACE_UPFIR_END
#endif //__UpfTypeDefImpl_hh__
# 138 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfTypeDefImpl.hh"
# 13 "./CpfRetentionStrategy.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "UpfTypeDef.hh"
#endif /* expanded by -frewrite-includes */
# 13 "./CpfRetentionStrategy.hh"
# 14 "./CpfRetentionStrategy.hh"

NAMESPACE_CPFIR_BEGIN

class CpfRetentionStrategyImpl : public UPFIR::RetentionStrategy
{
public :
    //Constructors
    CpfRetentionStrategyImpl(
        const std::string & name,
        const std::string & assocDomain,
        const std::string & saveLevel,
        const std::string & restoreLevel,
        const std::string & saveEdge,
        const std::string & restoreEdge,
        const std::string & savePreCond,
        const std::string & restorePreCond,
        const std::string & retTargetType,
        const std::list<std::string> & instanceList,
        const std::list<std::string> & excludeInstanceList,
        const char                        * fileName,
        unsigned                            lineNo);
    CpfRetentionStrategyImpl();
    ~CpfRetentionStrategyImpl();

    //Serialization related
    bool isEncrypted() const { return false; }
    VCS_DECL_SERIALIZABLE(CpfRetentionStrategyImpl);
    void serialize(UPFIR::ser::Archive&);

    //Fucntions that will be only defined in concrete implementations in CC Files
    UPFIR::CpfRetTarget convertStringToRetTargetTypeEnum(std::string strType);
    bool resolveCrossRefsInCurrentScope();
    bool elaborateInCurrentScope();
    bool populateElementFromQueryObject();
    bool deepCopySingleInCurrentScope();
    void print() const;

    // These are functions common to both UPF and CPF retention libraries
    // Somewhere the intended usages for CPF has been altered
    // In such cases they are marked with special comments
    void addElements(UPFIR::DesignObject* s) { instanceList_.append(s); }
    void addExcludeElements(UPFIR::DesignObject *s) {excludeInstanceList_.append(s);}
    UPFIR::BoolExpr *getRestoreCond () const { return restoreEdge_;} //This will return save edge condition
    UPFIR::BoolExpr *getSaveCond () const { return saveEdge_;}       //This will return restore edge condition
    bool hasAnyExcludeElement () { return !excludeInstanceList_.isEmpty();}
    UPFIR::DesignObjectLI getElements() const { return UPFIR::DesignObjectLI(instanceList_);}
    UPFIR::DesignObjectLI getExcludeElements() const { return UPFIR::DesignObjectLI(excludeInstanceList_) ;}
    int getId () const {return id_;}
    virtual bool isZeroPinEdgeCorruptRetention() { return false;}
    bool isTransitive () {return true;}
    bool getUseAsPrim () {return false;}
    bool isNoShadowPolicy() const { return false; }
    bool getNoRetention() {return false;}
    void setGenNameInCond (bool b) {;}
    bool isGenNameInCond () const { return false; }
    void setGenClkUsed (bool b) {;}
    bool isGenClkUsed () const { return false; }
    void setGenRstUsed (bool b) {;}
    bool isGenRstUsed () const { return false; }
    void setWarnForGeneric () {;}
    bool isWarnForGeneric () const { return false; }


    //Compulsory functions that are required for UPFNamedObj Class
    const char *getName() const {return retName_;}
    const char *getFullName() const {return retName_;}
    UPFIR::UpfClassType getUpfClassType() const {return UPFIR::RetentionC;}
    const char*   getKindStr() const {return 0;}
    unsigned int getLineNo() const {return lineNo_;}
    const char* getFileName() const {return fileName_;}

    //Common functions from the base class defined in CC files
    bool isExcludeElement(void *inst) ;

    //These are UPF functions that has been crash asserted
    const char* getScope() const {fassert(0,"Undefined Function getScope for CPF"); return 0; }
    lpmsg::LpMsgSeverity getMsgSeverity() {fassert(0,"Undefined Function getMsgSeverity()"); return lpmsg::InfoC;}
    void setMsgSeverity(lpmsg::LpMsgSeverity sev) {fassert(0,"Undefined Function setMsgSeverity()"); }
    bool getMsgEnabled() {fassert(0,"Undefined Function getMsgEnabled()"); return false;}
    void setMsgEnabled(bool en) {fassert(0,"Undefined Function setMsgEnabled()"); }
    const char * getDomain() const { 
        return getAssocPowerDomain()? getAssocPowerDomain()->getName() : 0;
    }
    const char* getInstance() const {fassert(0,"Undefined Function getInstance()"); return 0; }
    UPFIR::SupplySetHandle* getRetentionSupplySet() {fassert(0,"Undefined Function getRetentionSupplySet()"); return 0;}
    void setRetentionSupplySet(UPFIR::SupplySetHandle* ssh) {fassert(0,"Undefined Function setRetentionSupplySet()"); }
    void setInstance(char* inst) {fassert(0,"Undefined Function setInstance()"); }
    void setNoShadowPolicy(bool noShadow)  {fassert(0,"Undefined Function setNoShadowPolicy()"); }
    UPFIR::SupplyNet* getPowerNet() const {fassert(0,"Undefined Function getPowerNet()"); return 0;}
    UPFIR::SupplyNet* getGroundNet() const {fassert(0,"Undefined Function getGroundNet()"); return 0;}
    bool isNoRetention() const {return false;}
    void setNoRetention (bool b) {;}
    UPFIR::RetentionSignal*  getSaveSignal() const {fassert(0,"Undefined Function getSaveSignal()"); return 0;}
    UPFIR::RetentionSignal* getRestoreSignal() const {fassert(0,"Undefined Function getRestoreSignal()"); return 0;}
    UPFIR::RetentionSignalLI getSaveAssertSignals() const {fassert(0,"Undefined Function getSaveAssertSignals()"); return 0; }
    UPFIR::RetentionSignalLI getRestoreAssertSignals() const {fassert(0,"Undefined Function getRestoreAssertSignals()"); return 0; }
    UPFIR::RetentionSignalLI getSaveRestoreAssertSignals() const {fassert(0,"Undefined Function getSaveRestoreAssertSignals()"); return 0;}
    bool isSaveRestoreAssert() const {fassert(0,"Undefined Function isSaveRestoreAssert()"); return false;}
    void appendMapRetention(UPFIR::MapRtnElement *mapRtn) {fassert(0,"Undefined Function appendMapRetention()"); }
    void setTransitive (bool b) {fassert(0,"Undefined Function setTransitive()"); }
    UPFIR::BoolExpr *getRtnCond () {fassert(0,"Undefined Function getRtnCond()"); return 0; }
    void * getTargetScope() {fassert(0,"Undefined Function getTargetScope()"); return 0;  }
    void setTargetScope (void *v) {fassert(0,"Undefined Function setTargetScope()"); }
    bool isRetSupplyCorrupt() {fassert(0,"Undefined Function isRetSupplyCorrupt()"); return false;}
    bool isSaveRestoreCorrupt () {fassert(0,"Undefined Function isSaveRestoreCorrupt()"); return false; }
    void setRetSupplyCorrupt(bool b) {fassert(0,"Undefined Function setRetSupplyCorrupt()"); }
    void setSaveRestoreCorrupt (bool b) {fassert(0,"Undefined Function setSaveRestoreCorrupt()"); }
    void setAssertCorruptType (UPFIR::AssertCorruptType t) {fassert(0,"Undefined Function setAssertCorruptType()"); }
    UPFIR::AssertCorruptType getAssertCorruptType () {fassert(0,"Undefined Function getAssertCorruptType()"); return UPFIR::COR_NONE;}
    void setAlreadyImplementedPolicy(unsigned b) {fassert(0,"Undefined Function setAlreadyImplementedPolicy()"); }
    unsigned isAlreadyImplemented() {fassert(0,"Undefined Function isAlreadyImplemented()"); return 0;}
    bool getIsVerilogScope() {fassert(0,"Undefined Function getIsVerilogScope()"); return false;}
    void setControllerInstanceName(const char *s) {fassert(0,"Undefined Function setControllerInstanceName()"); }
    const char * getControllerInstanceName() {fassert(0,"Undefined Function getControllerInstanceName()"); return 0; }
    UPFIR::DesignElementTokenLI getDomainTokenLI() { fassert(0, "Undefined function getDomainTokenLI()"); return 0; }
    UPFIR:: DesignElementTokenL* getDomainTokenL() { fassert(0, "Undefined function getDomainTokenL()"); return NULL; }
    void setRetAsAutoBB(bool isAutoBB) { fassert(0, "Undefined function setRetAsAutoBB()"); }
    void setIsImplicitSuppliesUnused(bool val) { fassert(0, "Unidefined function setIsImplicitSuppliesUnused()");}
    bool isRetAutoBB() { return false; }
    void addController(void*) {assert(0);}
    void* getController() {assert(0); return 0;}
    void addControllerName(const char*) {assert(0);}
    const char* getControllerName() {assert(0); return 0;}
    void addBindChecker(upfir::BindChecker*) {assert(0);}
    bool hasBindChecker() {assert(0); return false;}
    upfir::BindCheckerLI getBindCheckers() {assert(0); return 0;}
    void destroyNonGenericBindCheckers() {assert(0);}
    void setSaveSpecified (bool b) { assert(0); }
    bool getSaveSpecified () { assert(0); return false; }
    void setRestoreSpecified (bool b) { assert(0); }
    bool getRestoreSpecified () { assert(0); return false; }
    bool isSinglePinSaveRestore() { assert(0); return false; }
    bool isSaveRestoreLevelToEdge() { assert(0); return false; }
    UPFIR::DesignScopeTablePI getElementScopes() const {assert(0); return UPFIR::DesignScopeTablePI(0);}
    void replaceElementList(UPFIR::DesignObjectL& dobjL, bool isExclude=false) {assert(0);};


    //Exclusive CPF only functions that will be defined in the base class and crash asserted in UPF impls
    UPFIR::PowerDomain* getAssocPowerDomain() const { return powerDomain_;}
    UPFIR::BoolExpr *getRestoreLevelCond () const { return restoreLevel_;}
    UPFIR::BoolExpr *getSaveLevelCond () const { return saveLevel_;}
    UPFIR::BoolExpr *getRestorePreCond () const { return restorePreCond_;}
    UPFIR::BoolExpr *getSavePreCond () const { return savePreCond_;}
    UPFIR::CpfRetTarget getRetentionTargetType() const { return retTargetType_;}


    //Functions defined here that wont be abstracted in base class
    void addElements(UPFIR::DesignQueryImpl* s) { wcInstances_.append(s); }
    void addExcludeElements(UPFIR::DesignQueryImpl* s) { wcExclInstances_.append(s); }
    void setAssocPowerDomain(UPFIR::PowerDomain* pd)    { powerDomain_=pd;}
    void setId(int id)  { id_ =id;}
    void setSaveEdge(UPFIR::BoolExpr* saveE) { saveEdge_ = saveE; }
    void setRestoreEdge(UPFIR::BoolExpr* restE) {restoreEdge_ = restE; }
    void setSaveLevel(UPFIR::BoolExpr* saveL) { saveLevel_ = saveL; }
    void setRestoreLevel(UPFIR::BoolExpr* restL) {restoreLevel_ = restL; }
    void setSavePreCond(UPFIR::BoolExpr* savePC) {savePreCond_ = savePC; }
    void setRestorePreCond(UPFIR::BoolExpr* restPC) {restorePreCond_ = restPC; }
    void setRetentionTargetType(UPFIR::CpfRetTarget target) {retTargetType_ = target; }

    //Retention generic bind checker api's
    void addRetGenericCheckerInstName (const char *instName) { return; }
    SlistLI<char> getRetGenericCheckerInstNameList() { 
        SlistL<char> none;
        return SlistLI<char>(none);
    }

    void setRetElemFullySkipped (const bool &b) {return ;}
    bool isRetElemFullySkipped () { return false; }
    UPFIR::SupplyNet * getPwellNet() const {return 0;} 
    UPFIR::SupplyNet * getNwellNet() const {return 0;}
    UPFIR::SupplyNet * getDeepNwellNet() const {return 0;}
    UPFIR::SupplyNet * getDeepPwellNet() const {return 0;}
    char* getContextResetGroupName() { return NULL;}
    bool isRetenModePessimistic() { return false; }
    bool isRetenModeAccurate() { return false; }
    void addRetentionModeReportElement(const char* str) { return; }
    SlistLI<char> getRetentionModeReportElements() { 
        SlistL<char> none;
        return SlistLI<char>(none);
    }
    void deleteRetentionModeReportElements() { return; }

private :
    class ParseOnlyDesignInfo
    {
    public:
        ParseOnlyDesignInfo(const std::string & saveLevel,const std::string & restoreLevel,const std::string & saveEdge,const std::string & restoreEdge,const std::string & savePreCond,const std::string & restorePreCond,const std::list<std::string> & instances,const std::list<std::string> & exclInstances) :
            saveLevel_(saveLevel),restoreLevel_(restoreLevel),saveEdge_(saveEdge),restoreEdge_(restoreEdge),savePreCond_(savePreCond),restorePreCond_(restorePreCond),instanceList_(instances),excludeInstanceList_(exclInstances) {}
        const std::string & getSaveLevel() const
        {return saveLevel_;}
        const std::string & getRestoreLevel() const
        {return restoreLevel_;}
        const std::string & getRestoreEdge() const
        {return restoreEdge_;}
        const std::string & getSaveEdge() const
        {return saveEdge_;}
        const std::string & getSavePreCond() const
        {return savePreCond_;}
        const std::string & getRestorePreCond() const
        {return restorePreCond_;}
        const std::list<std::string> & getInstances() const
        {return instanceList_;}
        const std::list<std::string> & getExclusionInstances() const
        {return excludeInstanceList_;}
    private:
        ParseOnlyDesignInfo();//undefined
        std::string             saveLevel_;
        std::string             restoreLevel_;
        std::string             saveEdge_;
        std::string             restoreEdge_;
        std::string             savePreCond_;
        std::string             restorePreCond_;
        std::list<std::string>  instanceList_;
        std::list<std::string>  excludeInstanceList_;
    };
    class ParseOnlyPowerInfo
    {
    public:
        ParseOnlyPowerInfo(const std::string & assocDomain) :
            assocDomain_(assocDomain) {}
        const std::string & getAssocPowerDomain() const
        {return assocDomain_;}
    private:
        ParseOnlyPowerInfo();//undefined
        std::string assocDomain_;
    };

private :
    char*                       retName_;
    UPFIR::PowerDomain*         powerDomain_;
    UPFIR::BoolExpr*            saveLevel_;
    UPFIR::BoolExpr*            restoreLevel_;
    UPFIR::BoolExpr*            saveEdge_;
    UPFIR::BoolExpr*            restoreEdge_;
    UPFIR::BoolExpr*            savePreCond_;
    UPFIR::BoolExpr*            restorePreCond_;
    UPFIR::DesignObjectL        instanceList_;
    UPFIR::DesignObjectL        excludeInstanceList_;
    //Temp list for Wildcards
    UPFIR::DesignQueryImplL     wcInstances_;
    UPFIR::DesignQueryImplL     wcExclInstances_;
    UPFIR::CpfRetTarget         retTargetType_;
    int                         id_;
    char *                      fileName_;
    unsigned                    lineNo_;
    ParseOnlyDesignInfo*        parseInfo_;
    ParseOnlyPowerInfo*         parsePowerInfo_;

};
NAMESPACE_CPFIR_END

#endif
# 266 "./CpfRetentionStrategy.hh"
# 12 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "nlp_sim_types.h"
#endif /* expanded by -frewrite-includes */
# 12 "CpfRetentionStrategy.cc"
# 13 "CpfRetentionStrategy.cc"
#if 0 /* expanded by -frewrite-includes */
#include "CpfPowerNetwork.hh"
#endif /* expanded by -frewrite-includes */
# 13 "CpfRetentionStrategy.cc"
# 1 "./CpfPowerNetwork.hh" 1
#ifndef _CPF_POWERNETWORK_HH_
#define _CPF_POWERNETWORK_HH_

#if 0 /* expanded by -frewrite-includes */
#include "hash.hh"
#endif /* expanded by -frewrite-includes */
# 4 "./CpfPowerNetwork.hh"
# 5 "./CpfPowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include "comerror.h"
#endif /* expanded by -frewrite-includes */
# 5 "./CpfPowerNetwork.hh"
# 1 "../../../include/comerror.h" 1
/* SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
 * of Synopsys, Inc., and is fully protected under copyright and trade
 * secret laws. You may not view, use, disclose, copy, or distribute
 * this file or any information contained herein except pursuant to a
 * valid written license from Synopsys.
 */

#ifndef _COMMON_ERROR_H
#define _COMMON_ERROR_H

#if 0 /* expanded by -frewrite-includes */
#include <stdio.h>
#endif /* expanded by -frewrite-includes */
# 11 "../../../include/comerror.h"
# 12 "../../../include/comerror.h"
#if 0 /* expanded by -frewrite-includes */
#include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# 12 "../../../include/comerror.h"
# 13 "../../../include/comerror.h"
#if 0 /* expanded by -frewrite-includes */
#include <sys/time.h>
#endif /* expanded by -frewrite-includes */
# 13 "../../../include/comerror.h"
# 1 "/usr/include/sys/time.h" 1 3 4
/* Copyright (C) 1991-1994,1996-2003,2005,2006,2009
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _SYS_TIME_H
#define _SYS_TIME_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 23 "/usr/include/sys/time.h" 3 4
# 24 "/usr/include/sys/time.h" 3 4

#if 0 /* expanded by -frewrite-includes */
#include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 25 "/usr/include/sys/time.h" 3 4
# 26 "/usr/include/sys/time.h" 3 4
#define __need_time_t
#if 0 /* expanded by -frewrite-includes */
#include <time.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/sys/time.h" 3 4
# 28 "/usr/include/sys/time.h" 3 4
#define __need_timeval
#if 0 /* expanded by -frewrite-includes */
#include <bits/time.h>
#endif /* expanded by -frewrite-includes */
# 29 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
/* System-dependent timing definitions.  Generic version.
   Copyright (C) 1996,1997,1999-2002,2003,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <time.h> instead.
 */

#ifndef __need_timeval
# ifndef _BITS_TIME_H
#  define _BITS_TIME_H	1

/* ISO/IEC 9899:1990 7.12.1: <time.h>
   The macro `CLOCKS_PER_SEC' is the number per second of the value
   returned by the `clock' function. */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
#  define CLOCKS_PER_SEC  1000000l

#  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
   presents the real value for clock ticks per second for the system.  */
#if 0 /* expanded by -frewrite-includes */
#   include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/bits/time.h" 3 4
# 40 "/usr/include/bits/time.h" 3 4
extern long int __sysconf (int);
#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
#  endif
# 43 "/usr/include/bits/time.h" 3 4

#  ifdef __USE_POSIX199309
/* Identifier for system-wide realtime clock.  */
#   define CLOCK_REALTIME		0
/* Monotonic system-wide clock.  */
#   define CLOCK_MONOTONIC		1
/* High-resolution timer from the CPU.  */
#   define CLOCK_PROCESS_CPUTIME_ID	2
/* Thread-specific CPU-time clock.  */
#   define CLOCK_THREAD_CPUTIME_ID	3
/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
#   define CLOCK_MONOTONIC_RAW		4
/* Identifier for system-wide realtime clock, updated only on ticks.  */
#   define CLOCK_REALTIME_COARSE	5
/* Monotonic system-wide clock, updated only on ticks.  */
#   define CLOCK_MONOTONIC_COARSE	6

/* Flag to indicate time is absolute.  */
#   define TIMER_ABSTIME		1
#  endif
# 63 "/usr/include/bits/time.h" 3 4

# endif	/* bits/time.h */
# 65 "/usr/include/bits/time.h" 3 4
#endif
# 66 "/usr/include/bits/time.h" 3 4

#ifdef __need_timeval
# undef __need_timeval
# ifndef _STRUCT_TIMEVAL
#  define _STRUCT_TIMEVAL	1
#if 0 /* expanded by -frewrite-includes */
#  include <bits/types.h>
#endif /* expanded by -frewrite-includes */
# 71 "/usr/include/bits/time.h" 3 4
# 72 "/usr/include/bits/time.h" 3 4

/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec;		/* Seconds.  */
    __suseconds_t tv_usec;	/* Microseconds.  */
  };
# endif	/* struct timeval */
# 81 "/usr/include/bits/time.h" 3 4
#endif	/* need timeval */
# 82 "/usr/include/bits/time.h" 3 4
# 30 "/usr/include/sys/time.h" 2 3 4

#if 0 /* expanded by -frewrite-includes */
#include <sys/select.h>
#endif /* expanded by -frewrite-includes */
# 31 "/usr/include/sys/time.h" 3 4
# 32 "/usr/include/sys/time.h" 3 4

#ifndef __suseconds_t_defined
typedef __suseconds_t suseconds_t;
# define __suseconds_t_defined
#endif
# 37 "/usr/include/sys/time.h" 3 4


__BEGIN_DECLS

#ifdef __USE_GNU
/* Macros for converting between `struct timeval' and `struct timespec'.  */
# define TIMEVAL_TO_TIMESPEC(tv, ts) {                                   \
        (ts)->tv_sec = (tv)->tv_sec;                                    \
        (ts)->tv_nsec = (tv)->tv_usec * 1000;                           \
}
# define TIMESPEC_TO_TIMEVAL(tv, ts) {                                   \
        (tv)->tv_sec = (ts)->tv_sec;                                    \
        (tv)->tv_usec = (ts)->tv_nsec / 1000;                           \
}
#endif
# 52 "/usr/include/sys/time.h" 3 4


#ifdef __USE_BSD
/* Structure crudely representing a timezone.
   This is obsolete and should never be used.  */
struct timezone
  {
    int tz_minuteswest;		/* Minutes west of GMT.  */
    int tz_dsttime;		/* Nonzero if DST is ever in effect.  */
  };

typedef struct timezone *__restrict __timezone_ptr_t;
#else
# 65 "/usr/include/sys/time.h" 3 4
typedef void *__restrict __timezone_ptr_t;
#endif
# 67 "/usr/include/sys/time.h" 3 4

/* Get the current time of day and timezone information,
   putting it into *TV and *TZ.  If TZ is NULL, *TZ is not filled.
   Returns 0 on success, -1 on errors.
   NOTE: This form of timezone information is obsolete.
   Use the functions and variables declared in <time.h> instead.  */
extern int gettimeofday (struct timeval *__restrict __tv,
			 __timezone_ptr_t __tz) __THROW __nonnull ((1));

#ifdef __USE_BSD
/* Set the current time of day and timezone information.
   This call is restricted to the super-user.  */
extern int settimeofday (__const struct timeval *__tv,
			 __const struct timezone *__tz)
     __THROW __nonnull ((1));

/* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  */
extern int adjtime (__const struct timeval *__delta,
		    struct timeval *__olddelta) __THROW;
#endif
# 90 "/usr/include/sys/time.h" 3 4


/* Values for the first argument to `getitimer' and `setitimer'.  */
enum __itimer_which
  {
    /* Timers run in real time.  */
    ITIMER_REAL = 0,
#define ITIMER_REAL ITIMER_REAL
    /* Timers run only when the process is executing.  */
    ITIMER_VIRTUAL = 1,
#define ITIMER_VIRTUAL ITIMER_VIRTUAL
    /* Timers run when the process is executing and when
       the system is executing on behalf of the process.  */
    ITIMER_PROF = 2
#define ITIMER_PROF ITIMER_PROF
  };

/* Type of the second argument to `getitimer' and
   the second and third arguments `setitimer'.  */
struct itimerval
  {
    /* Value to put into `it_value' when the timer expires.  */
    struct timeval it_interval;
    /* Time to the next timer expiration.  */
    struct timeval it_value;
  };

#if defined __USE_GNU && !defined __cplusplus
/* Use the nicer parameter type only in GNU mode and not for C++ since the
   strict C++ rules prevent the automatic promotion.  */
typedef enum __itimer_which __itimer_which_t;
#else
# 122 "/usr/include/sys/time.h" 3 4
typedef int __itimer_which_t;
#endif
# 124 "/usr/include/sys/time.h" 3 4

/* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  */
extern int getitimer (__itimer_which_t __which,
		      struct itimerval *__value) __THROW;

/* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  */
extern int setitimer (__itimer_which_t __which,
		      __const struct itimerval *__restrict __new,
		      struct itimerval *__restrict __old) __THROW;

/* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  */
extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     __THROW __nonnull ((1));

#ifdef __USE_BSD
/* Same as `utimes', but does not follow symbolic links.  */
extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     __THROW __nonnull ((1));

/* Same as `utimes', but takes an open file descriptor instead of a name.  */
extern int futimes (int __fd, __const struct timeval __tvp[2]) __THROW;
#endif
# 151 "/usr/include/sys/time.h" 3 4

#ifdef __USE_GNU
/* Change the access time of FILE relative to FD to TVP[0] and the
   modification time of FILE to TVP[1].  If TVP is a null pointer, use
   the current time instead.  Returns 0 on success, -1 on errors.  */
extern int futimesat (int __fd, __const char *__file,
		      __const struct timeval __tvp[2]) __THROW;
#endif
# 159 "/usr/include/sys/time.h" 3 4


#ifdef __USE_BSD
/* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  */
# define timerisset(tvp)	((tvp)->tv_sec || (tvp)->tv_usec)
# define timerclear(tvp)	((tvp)->tv_sec = (tvp)->tv_usec = 0)
# define timercmp(a, b, CMP) 						      \
  (((a)->tv_sec == (b)->tv_sec) ? 					      \
   ((a)->tv_usec CMP (b)->tv_usec) : 					      \
   ((a)->tv_sec CMP (b)->tv_sec))
# define timeradd(a, b, result)						      \
  do {									      \
    (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;			      \
    (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;			      \
    if ((result)->tv_usec >= 1000000)					      \
      {									      \
	++(result)->tv_sec;						      \
	(result)->tv_usec -= 1000000;					      \
      }									      \
  } while (0)
# define timersub(a, b, result)						      \
  do {									      \
    (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;			      \
    (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;			      \
    if ((result)->tv_usec < 0) {					      \
      --(result)->tv_sec;						      \
      (result)->tv_usec += 1000000;					      \
    }									      \
  } while (0)
#endif	/* BSD */
# 190 "/usr/include/sys/time.h" 3 4

__END_DECLS

#endif /* sys/time.h */
# 194 "/usr/include/sys/time.h" 3 4
# 14 "../../../include/comerror.h" 2
#ifdef __cplusplus

extern "C" {

#endif
# 19 "../../../include/comerror.h"

/**
 * This function registers the given FILE pointer as an output to which
 * all messages should be sent
 */
int vcsMsgRegisterOutputFile(FILE *, const char* fileName);

/**
 * This function must be called with the path to the directory containing
 * the message dynamic libraries (e.g., for VCS this is psTOOL_HOME).
 * The vcsMsg library will add "/lib" onto the end of the specified dirpath.
 * The dirpath argument is not copied by the function - the application is
 * responsible for providing the memory.
 *
 * If this function is not called, the library will search for the
 * message libraries in LD_LIBRARY_PATH.  Thus applications can set
 * LD_LIBRARY_PATH instead of calling vcsMsgInitialize
 *
 * Returns 0 on success and non-zero on failure.
 */
unsigned vcsMsgInitialize(const char *dirpath);

/**
 * This function clears *all* registered outputs and callbacks
 */
void vcsMsgDeregisterOutputs(void);

/**
 * This function clears *all* registered outputs only
 */
void vcsMsgDeregisterOutputsOnly(void);

/**
 * This function clears the designated file from the registered output
 * file list.  Returns 0 on success and non-zero if the file pointer
 * was not found in the list.
 */
int vcsMsgDeregisterOutputFile(FILE *fp);

/**
 * This function upgrade/downgrade warning/error codes
 */
void vcsMsgDowngradeErrorFlag(const char* argStr);
void vcsMsgUpgradeWarnFlag(const char* argStr);


void vcsMsgCloseSmartLogFile(FILE *fp);

void vcsMsgCloseSmartLog(int code);

/**
 * This is a C wrapper around the C++ error-reporting functionality
 * Note that comerror.hh includes this file for some enum typedefs
 */

/**
 * Error severity levels
 * Please keep in sync with lib/vcs_int_api.h
 */
typedef enum {
    vcsMsgFatal = 0,               /** error, no more processing is possible */
    vcsMsgError,                   /** error, invocation will not succeed */
    vcsMsgWarning,                 /** warning */
    vcsMsgLint,                    /** for lint errors during compilation */
    vcsMsgNote,                    /** information only */
    vcsMsgInfo,                    /** DEPRECATED, use vcsMsgNote instead */
    vcsMsgNumSeverities
} vcsMsgSeverity;


/*
 * Use these alternate severities for messages that have not yet been
 * improved.
 */
#define vcsMsgFatalUnimproved vcsMsgFatal
#define vcsMsgErrorUnimproved vcsMsgError
#define vcsMsgWarningUnimproved vcsMsgWarning
#define vcsMsgLintUnimproved vcsMsgLint
#define vcsMsgNoteUnimproved vcsMsgNote
#define vcsMsgInfoUnimproved vcsMsgInfo

/**
 * Error types.
 * The type assigned to an error code is used in the automatic checking
 * to make sure all required arguments are passed when this code is used
 */
typedef enum {
    vcsMsgNormal,                  /** source file, line number, scope name,
                                    * and object name are required */
    vcsMsgNoSource                 /** only scope name is required */
} vcsMsgCodeType;



/**
 * Error tables
 * Selecting one of these pulls in the appropriate error table from
 * its dynamic library
 */
typedef enum {
    vcsMsgVcsCompileTable,
    vcsMsgVcsRuntimeTable,
    vcsMsgVcsCommonTable,
    vcsMsgPostProcTable,
    vcsMsgDVETable,
    vcsMsgVeraTable,
    vcsMsgSystemCTable,
    vcsMsgVcsCheckerTable,
    vcsMsgPowerTable,
    vcsMsgUtfTranTable,
    vcsMsgSimonTable,
    vcsMsgAccovTable,
    vcsMsgVcsSolverTable,
    vcsMsgVsiTable,
    vcsMsgLastTable
} vcsMsgTableType;


typedef enum {
    vcsMsgSuccess,
    vcsMsgCodeNotFound,
    vcsMsgBadSeverity,
    vcsMsgCannotChange,
    vcsMsgFunctionMismatch
} vcsMsgResult;


/**
 * Message types for diagnostics.
 */
typedef enum {
    vcsMsgExternal,         /*!< Message is always printed and
                       visible to the customer. */
    vcsMsgInternal,         /*!< Only for internal use. Not to
                       be printed to the customer. (or
                       printed in encrypted form). */
    vcsMsgNumTypes
} vcsMessageType;


/**
 * Types for diagnostics.  These can be enabled using the -diag switch,
 * except for vcsDiagCrashContext, which is always on.
 */
typedef enum {
    vcsDiagTimeScale                /*!< Timescale diagnostics */
    ,vcsDiagLib                      /*!< Library handling diagnostics */
    ,vcsDiagXprop                    /*!< Xprop diagnostics */
    ,vcsDiagVpi                      /*!< VPI diagnostics */
    ,vcsDiagVhpi                     /*!< VHPI diagnostics */
    ,vcsDiagActiveRgn               /*!< Active region diagnostics */
    ,vcsDiagCrashContext             /*!< crash context diagnostics */
    ,vcsDiagOnExit                   /*!< dump context on any exit */
    ,vcsDiagHsoptMx                  /*!< HSOPT_MX diagnostics */
    ,vcsDiagRegTunnel                /*!< SV-SPICE Reg-tunnel diagnostics */
    ,vcsDiagNoConst                  /*!< -cm_noconst user diagnostics */
    ,vcsDiagNoConstInternal          /*!< -cm_noconst internal diagnostics */
    ,vcsDiagDisableFork              /*!< disable fork user diagnostics*/
    ,vcsDiagSrcStack                 /*!< source stack user diagnostics */
    ,vcsDiagBcConfig                 /*!< synopsys_bc.setup diagnostics*/
    ,vcsDiagMhConfig                 /*!< synopsys_mh.setup diagnostics*/
    ,vcsDiagFsmCov                   /*!< FSM cov user diagnostics */
    ,vcsDiagFsmCovInternal           /*!< FSM cov internal diagnostics */
    ,vcsDiagSkipTranslateBody        /*!< skip_translate_body diagnostics*/
    ,vcsDiagRWMem                    /*!< extra info during system memory read/write*/
    ,vcsDiagEnv                   /*!< dump env variables before compilation*/
    ,vcsTglMergeReport    /*!<urg:dump mismatch report for toggle reference merging*/
    ,vcsDummy
} vcsDiagType;

/************
 * Applications can register a callback function to which
 * all messages will be routed when an error occurs, instead of sending
 * the message text to the registered output files/streams.  Only the
 * callback function on the top of the stack is called.
 *
 * The callback functions themselves can use the vcsMsgPassThrough
 * function to hand the error on as if the callback had not caught it.
 * This will invoke the next oldest callback (if any) or emit the message
 * to the register output files/streams.
 *
 * The data field is passed to any registered callback function.  It is not
 * otherwise used and can be NULL.  Note that you should not cast non-pointers
 * (e.g., integers) to void* in your code as it will not work on 64-bit
 * platforms.
 *
 * When pushing a regular callback function, the mask value should be:
 *
 *  0         - catch any message that has no special flag on it
 *  F1[|F2|F3...] - catch only messages that have flag F1 (or F2 or F3 if
 *          specified) set on them
 *
 * To push a callback function that will be called for all messages, use
 * the function vcsMsgPushCatchallCallback.  "Catchall" callback
 * functions are always called last, after any non-catchall functions that
 * were explicitly sensitive to the message are called.  If there are
 * multiple catchall functions they will be called in the reverse order
 * in which they were pushed.
 ************/
typedef void
(*vcsMsgCallbackFn)(vcsMsgSeverity, const unsigned mask,
                    const char *code, const char *msg, void *data);

int vcsMsgPushCallback(vcsMsgCallbackFn fn);
int vcsMsgPushMaskedCallback(vcsMsgCallbackFn fn, const unsigned mask);
int vcsMsgPopCallback(vcsMsgCallbackFn fn);

int vcsMsgPushCatchallCallback(vcsMsgCallbackFn fn);
int vcsMsgPopCatchallCallback(vcsMsgCallbackFn fn);

void vcsMsgPassThrough(vcsMsgSeverity, const unsigned mask, const char *code,
                       const char *msg, void *data);
vcsMsgResult vcsMsgCallbackExitCleanup(vcsMsgCallbackFn fn);

/********
 * These are the supported 'mask' flags for messages and for use with
 * vcsMsgPushCallback.  These can be or'd together using bitwise or (|)
 * when calling vcsMsgPushCallback if the function is sensitive to
 * multiple types of messages.  These flags are also used in the message
 * tables on specific messages.
 ********/

/* right now there is a max of 10 flags since the field is 10 bits wide */
#define VCSMSG_UCLI_FLAG    (1 << 0)
#define VCSMSG_UCAPI_FLAG       (1 << 1)
#define VCSMSG_CNST_FLAG        (1 << 2)
#define VCSMSG_PLI_FLAG     (1 << 3)
#define VCSMSG_VHPI_FLAG    (1 << 4)
#define VCSMSG_UCLI_NOICL_FLAG  (1 << 5)
#define VCSMSG_NO_EXIT_FLAG     (1 << 6)
#define VCSMSG_DVE_FLAG         (1 << 7)
#define VCSMSG_CONTEXT_FLAG     (1 << 8)
#define VCSMSG_MAX_FLAG     VCSMSG_NO_EXIT_FLAG


/************
 * Convenience functions to convert int or double to string.
 * The message system handles the memory - callers should not free it.
 ************/

const char *vcsMsgDblToStr(const double d, const int width, const int prec);
const char *vcsMsgIntToStr(const int i);
const char *vcsMsgLongIntToStr(const long int i);
const char *vcsMsgLongLongIntToStr(const long long int i);
const char *vcsMsgShortIntToStr(const short int it);
const char *vcsMsgUintToStr(const unsigned int i);
const char *vcsMsgLongUintToStr(const unsigned long int i);
const char *vcsMsgLongLongUintToStr(const unsigned long long int i);
const char *vcsMsgShortUintToStr(const unsigned short int it);
const char *vcsMsgCharToStr(const char c);


/************
 * This function creates two lines of text, with a ^ in the second
 * line pointing to column #colno of the 'text' argument.  In inserts
 * a newline before 'text' and after the second line, so the result
 * looks like:
 *
 *  "\ntext\n<colno-1 spaces>^\n"
 *
 * This should be used for messages that want to quote some text from
 * the user's source or input and indicate a particular column, like
 * an unexpected character.
 ************/
const char *vcsMsgQuotedText(const char *text, unsigned colno);

/************
 * Basic family of reporting functions that take source location info
 ************/

void vcsMsgReport(const char *code,
                  const char *srcfile, const int line,
                  const char *region, const char *object);

void vcsMsgReport1(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0);

void vcsMsgReport2(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1);

void vcsMsgReport3(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1, const char *arg2);

void vcsMsgReport4(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1, const char *arg2,
                   const char *arg3);

void vcsMsgReport5(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1, const char *arg2,
                   const char *arg3, const char *arg4);

void vcsMsgReport6(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1, const char *arg2,
                   const char *arg3, const char *arg4, const char *arg5);

void vcsMsgReport7(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1, const char *arg2,
                   const char *arg3, const char *arg4, const char *arg5,
                   const char *arg6);

void vcsMsgReport8(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1, const char *arg2,
                   const char *arg3, const char *arg4, const char *arg5,
                   const char *arg6, const char *arg7);

void vcsMsgReport9(const char *code,
                   const char *srcfile, const int line,
                   const char *region, const char *object,
                   const char *arg0, const char *arg1, const char *arg2,
                   const char *arg3, const char *arg4, const char *arg5,
                   const char *arg6, const char *arg7, const char *arg8);

void vcsMsgReport10(const char *code,
                    const char *srcfile, const int line,
                    const char *region, const char *object,
                    const char *arg0, const char *arg1, const char *arg2,
                    const char *arg3, const char *arg4, const char *arg5,
                    const char *arg6, const char *arg7, const char *arg8,
                    const char *arg9);

void vcsMsgReport11(const char *code,
                    const char *srcfile, const int line,
                    const char *region, const char *object,
                    const char *arg0, const char *arg1, const char *arg2,
                    const char *arg3, const char *arg4, const char *arg5,
                    const char *arg6, const char *arg7, const char *arg8,
                    const char *arg9, const char *arg10);

void vcsMsgReport12(const char *code,
                    const char *srcfile, const int line,
                    const char *region, const char *object,
                    const char *arg0, const char *arg1, const char *arg2,
                    const char *arg3, const char *arg4, const char *arg5,
                    const char *arg6, const char *arg7, const char *arg8,
                    const char *arg9, const char *arg10, const char *arg11);

/************
 * "No source" family of functions
 ************/

void vcsMsgReportNoSource(const char *code);

void vcsMsgReportNoSource1(const char *code,
                           const char *arg0);

void vcsMsgReportNoSource2(const char *code,
                           const char *arg0, const char *arg1);

void vcsMsgReportNoSource3(const char *code,
                           const char *arg0, const char *arg1, const char *arg2);

void vcsMsgReportNoSource4(const char *code,
                           const char *arg0, const char *arg1, const char *arg2,
                           const char *arg3);

void vcsMsgReportNoSource5(const char *code,
                           const char *arg0, const char *arg1, const char *arg2,
                           const char *arg3, const char *arg4);

void vcsMsgReportNoSource6(const char *code,
                           const char *arg0, const char *arg1, const char *arg2,
                           const char *arg3, const char *arg4, const char *arg5);

void vcsMsgReportNoSource7(const char *code,
                           const char *arg0, const char *arg1, const char *arg2,
                           const char *arg3, const char *arg4, const char *arg5,
                           const char *arg6);

void vcsMsgReportNoSource8(const char *code,
                           const char *arg0, const char *arg1, const char *arg2,
                           const char *arg3, const char *arg4, const char *arg5,
                           const char *arg6, const char *arg7);

void vcsMsgReportNoSource9(const char *code,
                           const char *arg0, const char *arg1, const char *arg2,
                           const char *arg3, const char *arg4, const char *arg5,
                           const char *arg6, const char *arg7, const char *arg8);

void vcsMsgReportNoSource10(const char *code,
                            const char *arg0, const char *arg1, const char *arg2,
                            const char *arg3, const char *arg4, const char *arg5,
                            const char *arg6, const char *arg7, const char *arg8,
                            const char *arg9);

void vcsMsgReportNoSource11(
    const char *code,
    const char *arg0, const char *arg1, const char *arg2,
    const char *arg3, const char *arg4, const char *arg5,
    const char *arg6, const char *arg7, const char *arg8,
    const char *arg9, const char *arg10);

void vcsMsgReportNoSource12(
    const char *code,
    const char *arg0, const char *arg1, const char *arg2,
    const char *arg3, const char *arg4, const char *arg5,
    const char *arg6, const char *arg7, const char *arg8,
    const char *arg9, const char *arg10, const char *arg11);

/************
 * Expanded reporting functions.  These all take source info as well as
 * a generic flag that can be used for special behavior (like brief reporting)
 * The flags are combined using bitwise or.
 *
 * For example:
 *  vcsMsgReportFlags2("MYCODE", VCSMSG_BRIEF|VCSMSG_TEMPWARNING, data,
 *             srcfile, lineno, regname, obj, argstr0, argstr1);
 *
 * If called with no flags (flags == 0) then the functions behave just like
 * the vcsMsgReport* functions.
 *
 * The 'data' field is a void * that is passed on to any registered, sensitive
 * callback functions.  This can be used to pass context to your callback
 * function so it can take further actions.  It is legal to pass it as NULL.
 ************/

/** If VCSMSG_BRIEF is given, only the code, srcfile and line are reported.
 * The region/object, error title, description, and what next text are
 * suppressed.  You can use this flag for errors in encrypted/protected source
 */
#define VCSMSG_BRIEF        0x00000001

/* You can use ONE of these flags to temporarily change the severity of
 * the code you are reporting.  This takes effect for this report only and
 * does not raise or lower the severity of the code in the tables.
 *
 * It is an error to give more than one of these flags.  If more than one
 * is given, the flag for the highest severity is used.
 */
#define VCSMSG_TEMPFATAL    0x00000002
#define VCSMSG_TEMPERROR    0x00000004
#define VCSMSG_TEMPWARNING  0x00000008
#define VCSMSG_TEMPLINT     0x00000010
#define VCSMSG_TEMPNOTE     0x00000020
#define VCSMSG_TEMPINFO     0x00000040

/*
 * Flags for the internal use of the library only
 */
#define VCSMSG_INTERNALFSRC     0x00000080

/**
 * Flag to tell error library message is coming from vcsMsgReport1
 * standalone executable
 */
#define VCSMSG_INTERNALSCRPTERR   0x00000200

/*
 * If this wrap is given, the description/what next text will not
 * be formatted to fit/have long lines wrapped
 */
#define VCSMSG_NOWRAP           0x00000100


void vcsMsgReportFlags(const char *code,
                       const unsigned flags, void *data,
                       const char *srcfile, const int line,
                       const char *region, const char *object);

void vcsMsgReportFlags1(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0);

void vcsMsgReportFlags2(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1);

void vcsMsgReportFlags3(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1, const char *arg2);

void vcsMsgReportFlags4(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1, const char *arg2,
                        const char *arg3);

void vcsMsgReportFlags5(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1, const char *arg2,
                        const char *arg3, const char *arg4);

void vcsMsgReportFlags6(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1, const char *arg2,
                        const char *arg3, const char *arg4, const char *arg5);

void vcsMsgReportFlags7(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1, const char *arg2,
                        const char *arg3, const char *arg4, const char *arg5,
                        const char *arg6);

void vcsMsgReportFlags8(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1, const char *arg2,
                        const char *arg3, const char *arg4, const char *arg5,
                        const char *arg6, const char *arg7);

void vcsMsgReportFlags9(const char *code,
                        const unsigned flags, void *data,
                        const char *srcfile, const int line,
                        const char *region, const char *object,
                        const char *arg0, const char *arg1, const char *arg2,
                        const char *arg3, const char *arg4, const char *arg5,
                        const char *arg6, const char *arg7, const char *arg8);

void vcsMsgReportFlags10(const char *code,
                         const unsigned flags, void *data,
                         const char *srcfile, const int line,
                         const char *region, const char *object,
                         const char *arg0, const char *arg1, const char *arg2,
                         const char *arg3, const char *arg4, const char *arg5,
                         const char *arg6, const char *arg7, const char *arg8,
                         const char *arg9);

void vcsMsgReportFlags11(const char *code,
                         const unsigned flags, void *data,
                         const char *srcfile, const int line,
                         const char *region, const char *object,
                         const char *arg0, const char *arg1, const char *arg2,
                         const char *arg3, const char *arg4, const char *arg5,
                         const char *arg6, const char *arg7, const char *arg8,
                         const char *arg9, const char *arg10);

void vcsMsgReportFlags12(const char *code,
                         const unsigned flags, void *data,
                         const char *srcfile, const int line,
                         const char *region, const char *object,
                         const char *arg0, const char *arg1, const char *arg2,
                         const char *arg3, const char *arg4, const char *arg5,
                         const char *arg6, const char *arg7, const char *arg8,
                         const char *arg9, const char *arg10, const char *arg11);

void vcsMsgReportNoSourceFlags(const char *code,
                               const unsigned flags, void *data);

void vcsMsgReportNoSourceFlags1(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0);

void vcsMsgReportNoSourceFlags2(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1);

void vcsMsgReportNoSourceFlags3(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1, const char *arg2);

void vcsMsgReportNoSourceFlags4(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1, const char *arg2,
                                const char *arg3);

void vcsMsgReportNoSourceFlags5(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1, const char *arg2,
                                const char *arg3, const char *arg4);

void vcsMsgReportNoSourceFlags6(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1, const char *arg2,
                                const char *arg3, const char *arg4, const char *arg5);

void vcsMsgReportNoSourceFlags7(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1, const char *arg2,
                                const char *arg3, const char *arg4, const char *arg5,
                                const char *arg6);

void vcsMsgReportNoSourceFlags8(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1, const char *arg2,
                                const char *arg3, const char *arg4, const char *arg5,
                                const char *arg6, const char *arg7);

void vcsMsgReportNoSourceFlags9(const char *code,
                                const unsigned flags, void *data,
                                const char *arg0, const char *arg1, const char *arg2,
                                const char *arg3, const char *arg4, const char *arg5,
                                const char *arg6, const char *arg7, const char *arg8);

void vcsMsgReportNoSourceFlags10(const char *code,
                                 const unsigned flags, void *data,
                                 const char *arg0, const char *arg1, const char *arg2,
                                 const char *arg3, const char *arg4, const char *arg5,
                                 const char *arg6, const char *arg7, const char *arg8,
                                 const char *arg9);

void vcsMsgReportNoSourceFlags11(const char *code,
                                 const unsigned flags, void *data,
                                 const char *arg0, const char *arg1, const char *arg2,
                                 const char *arg3, const char *arg4, const char *arg5,
                                 const char *arg6, const char *arg7, const char *arg8,
                                 const char *arg9, const char *arg10);

void vcsMsgReportNoSourceFlags12(const char *code,
                                 const unsigned flags, void *data,
                                 const char *arg0, const char *arg1, const char *arg2,
                                 const char *arg3, const char *arg4, const char *arg5,
                                 const char *arg6, const char *arg7, const char *arg8,
                                 const char *arg9, const char *arg10, const char *arg11);


/** sets *sev to severity of the given code */
vcsMsgResult vcsMsgGetCodeSeverity(const char *code, vcsMsgSeverity *sev);
/** sets *sev to original severity of the given code */
vcsMsgResult vcsMsgGetCodeOrigSeverity(const char *code, vcsMsgSeverity *sev);

/**
 * enable smartlog
 */
void vcsMsgSetSmartLogEnabled(int fGui);
void vcsMsgSetSmartLogDisabled();
int vcsMsgIsSmartLogEnabled(int fGui);

/**
 * get name of the log file Smartlog is writing to... null if no smartlog.
 */
const char* vcsMsgGetSmartLogFile();

/**
 * set name and log file pointer for smartlog.
 */
void vcsMsgSetSmartLogFile(const char* fileName, FILE* fp);

/**
 * Open diagnostic output file and return fileNo.
 * If diagnostic output should print to the standard log, there is no need to call this.
 */
int  vcsMsgOpenDiagFile(const char* fileName);

/**
 * Close the diagnostic file.
 */
void vcsMsgCloseDiagFile(int fileNo);

/**
 * Public function to return enable/disable status of a given diag type.
 */
int vcsMsgLogIsDiagEnabled(vcsDiagType diagType);

/**
 * Single Call Diagnostic Output Functions without source location
 * Description: Prints the message to the given fileNo.
 * The usage is just like printf, with a format string and parameters for '%' format tags.
 */
void vcsMsgLogDiag(int fileNo, vcsDiagType diagType, int verbosity, const char* format, ...);
void vvcsMsgLogDiag(int fileNo, vcsDiagType diagType, int verbosity, const char* format, va_list args);

/**
 * Single Call Diagnostic Output Functions with source location
 */
void vcsMsgLogDiagSource(int fileNo, vcsDiagType diagType, int verbosity, const char* srcFile, int line, const char* format, ...);

/**
 * Begin Diagnostic Output Functions
 * Description: This function must be called to start message processing.
 */
void vcsMsgLogDiagBegin(int fileNo, vcsDiagType diagType, int verbosity, vcsMessageType msgType);

/**
 * Output the diagnostic message text.
 */
void vcsMsgLogDiagAttrText(const char* format, ...);
void vvcsMsgLogDiagAttrText(const char* format, va_list args);

/**
 * Define attributes in current diagnostic message.
 */
void vcsMsgLogDiagAttrSource(const char* srcFile, int line);
void vcsMsgLogDiagAttrTime(const char* simTime);
void vcsMsgLogDiagAttrCode(const char* messageCode);
void vcsMsgLogDiagAttrScope(const char* scope);
void vcsMsgLogDiagAttrSeverity(const vcsMsgSeverity messageSeverity);
void vcsMsgLogDiagAttrVpiSeverity(const char* vpiSeverity);

/**
 * End Diagnostic Output Functions
 */
void vcsMsgLogDiagEnd();

/**
 * Create Smartlog Infor for Runtime Log Message
 */
void vcsMsgLogRTMessage(const char* srcfile, int line,
                        const char* simtime, const char* msg,
                        const char* instance, const char* stack);

/**
 * Print out Smartlog Infor for Runtime Log Message in stdout for DVE
 */
void vcsMsgLogRTMessagePrintSmlInfo();

/**
 * Create Smartlog Infor for VCS IWE Messages
 */
void vcsMsgLogIEWMessage(const char* srcfile, int line,
                         const char* simtime, const char* msg,
                         vcsMsgSeverity severity, const char* code,
                         const char* instance, const char* stack);

/**
 * Get the vcsMessage's source file/line
 */
const char* vcsMsgGetSrcFile();
int vcsMsgGetSrcLine();

unsigned vcsMsgNumReported(vcsMsgSeverity sev);

int lockMutexWrap();

void unlockMutexWrap();

/** suppresses all codes of the given severity */
vcsMsgResult vcsMsgSuppressSeverity(vcsMsgSeverity sev);

/** To know if a msg severity suppressed */
int vcsIsMsgSuppressSeverity(vcsMsgSeverity sev);

/** suppresses all codes up to the given severity */
vcsMsgResult vcsMsgSuppressUpToSeverity(vcsMsgSeverity sev);

/** changes the severity of the given code to 'sev' */
vcsMsgResult vcsMsgChangeSeverity(const char *code, vcsMsgSeverity sev);

/** suppresses the given code - no message will be reported and no
 * callback functions will be invoked
 */
vcsMsgResult vcsMsgSuppressCode(const char *code);

/* Set specified message count limit to the given code */
vcsMsgResult vcsMsgSetCntLimitForCode(const char *code, int cnt);

/** returns given code to unsuppressed state.  It is OK if the code wasn't
 * suppressed - no action is taken
 */
vcsMsgResult vcsMsgEnableCode(const char *code);

/** returns non-zero iff the given code can be suppressed */
unsigned int vcsMsgCodeCanBeSuppressed(const char *code);

/** returns non-zero iff the given code is currently suppressed */
unsigned int vcsMsgIsCodeSuppressed(const char *code);

vcsMsgResult vcsMsgChangeCompileSeverityToError(void);

vcsMsgResult vcsMsgEnableSeverity(vcsMsgSeverity sev, int severityOnly);

unsigned vcsMsgGetCurrentErrorCount(void);
unsigned vcsMsgGetCurrentWarningCount(void);

int vcsMsgGetMaxErrorCount(void);
void vcsMsgSetMaxErrorCount(int maxErrorCount);

void vcsMsgDoWrap(unsigned dowrap);

void vcsMsgReleaseInfo(void);

void vcsMsgReleaseInfo1(int code);  /** for use with vcs_atexit */

/*
 * These functions are used to manage separate, independent instances
 * of the error message global state such as callback function stacks.
 */
void vcsMsgPushContext(void);
void vcsMsgPopContext(void);

/* Just pass this string to all registered output handle & return.
 * Skip any registered callback
 */
void vcsPrintStrToAllOutput(const char *str);

/*
 * Function prototype for DoFinish and MustExit functions (see below).
 */
typedef void (*fnDoFinishPtr)(int);
/* If the doFinish function is set, it will be called when the next
 * message is reported regardless of severity, count, etc.  It is
 * always passed '1' as the argument.
 */
void vcsMsgSetDoFinishPtr(fnDoFinishPtr fn);
/* If the must exit function is set, it will be called if any code
 * with severity vcsMsgError or vcsMsgFatal is reported.n
 * The value '1' is always passed as the argument to the fn.
 */
void vcsMsgSetMustExit();
void vcsMsgSetMustExitPtr(fnDoFinishPtr fn);

typedef void (*fnSetSimExitStatusPtr)(unsigned int);
void vcsMsgSetSimExitStatusPtr(fnSetSimExitStatusPtr fn);
/* Returns true iff a must-exit function is set */
int vcsMsgIsMustExit(void);

typedef int (*fnCheckMsgConfigPtr)(const char* id,
                                   const char *fn, const int ln, const char* region,
                                   int* suppressed, vcsMsgSeverity* sev);
/* If the MsgConfig function is set, it will be called by
 *  vcsMsgIsCodeSuppressed and isSuppressed
 */
void vcsMsgSetCheckMsgConfigPtr(fnCheckMsgConfigPtr fn);

/**
 * Tell the error library that it's ok to exit regardless of
 * whether an error message has been issued.
 */
extern void vcsMsgSetOkToExit(void);

/**
 * Use vcsMsgExit instead of a libc exit() to suppress the error
 * issued when a process exits with a non-zero status.  The preferred
 * exit path is through verilog's VCS_EXIT or vhdl's pexit routine
 * (which run cleanup routines) but you can use this routine if
 * cleanup is not needed or those routines create linker dependency
 * issues.
 */
extern void vcsMsgExit(int status)
#if defined(__GNUC__) && defined(__linux__)
__attribute__ ((__noreturn__))
#endif
# 869 "../../../include/comerror.h"
;

/**
 * Returns the array of diagnostics options which were removed from
 * the cmd line.  The return value is NULL if no diag flags were used.
 * If the return value is non-NULL, then the array will be of variable
 * length.  A NULL pointer will mark the end of the array.
 */
extern char** vcsMsgGetDiagArgArray(void);

/**
 * Returns a pointer to a string of diagnostics options that were
 * removed from the command line.  Returns an empty string ("") if no
 * options were used.  Otherwise text in the string will be padded on
 * the left and right with a space.  CAUTION: returns a pointer to a
 * static buffer ... make a copy if not using it immediately.
 */
extern char*  vcsMsgGetDiagArgString(void);

/**
 * Returns <platform> subdirectory name.
 * Equivalent to "vcs -platform [-mode64]".
 * @param mode
 *   - 32   - for regular 32bit build
 *   - 64   - for mode64 build
 *
 * Returns NULL if the specified mode is not supported.
 */
extern const char* vcsHomePlatform(int mode);

/**
 * Returns the time vcsMinInitialized was called in the timeval argument.
 * @return 0 on success, non-zero on failure
 */
extern int vcsMsgGetInitTime(struct timeval* tv);

/**
 * Returns the original command line that was passed to trackerParseCmdLine
 * in pargv.  Returns argc value.
 */
extern int vcsMsgGetCmdLine(char*** pargv);

/**
 * Returns <build-or-install-dir>[/release-structure/vcs-mx][/<platform>].
 *
 * @param bindir
 *   - 1 to find the <platform>/bin directory
 *   - 0 to find the <platform>/lib directory
 *
 * The return value (if non-null) will point to the directory containing
 * platform specific binary files, eg:
 * @code
 *    char* home = vcsHomeFullPath(1); // locate bin directory
 *    if (home) {
 *       char path[FILENAME_MAX];
 *       sprintf(path, "%s/bin/vcs1", path);
 *       ...
 *       free(home);
 *    }
 * @endcode
 * The calling routine is responsible for freeing the return value.
 */
extern char* vcsHomeFullPath(int bindir);

extern int fFromDumpports;

int run_sysfault_callbacks(vcsMsgSeverity sev, const char* code);

void vcsMsgSetVSILogFile(const char* logName);
int  isVsiSession();
void vcsMsgSetRecordRtlTransform();
void vcsMsgSetEnableSpyglassUcFlow();
int  recordRtlTransform();
#ifdef __cplusplus
}
#endif
# 945 "../../../include/comerror.h"

#endif /* _COMMON_ERROR_H */
# 947 "../../../include/comerror.h"
# 6 "./CpfPowerNetwork.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "UpfCommandInterface.hh"
#endif /* expanded by -frewrite-includes */
# 6 "./CpfPowerNetwork.hh"
# 7 "./CpfPowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include "UpfTypeDefImpl.hh"
#endif /* expanded by -frewrite-includes */
# 7 "./CpfPowerNetwork.hh"
# 8 "./CpfPowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include <assert.h>
#endif /* expanded by -frewrite-includes */
# 8 "./CpfPowerNetwork.hh"
# 1 "/usr/include/assert.h" 1 3 4
/* Copyright (C) 1991,1992,1994-2001,2003,2004,2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>
 */

#ifdef	_ASSERT_H

# undef	_ASSERT_H
# undef	assert
# undef __ASSERT_VOID_CAST

# ifdef	__USE_GNU
#  undef assert_perror
# endif
# 33 "/usr/include/assert.h" 3 4

#endif /* assert.h	*/
# 35 "/usr/include/assert.h" 3 4

#define	_ASSERT_H	1
#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 37 "/usr/include/assert.h" 3 4
# 38 "/usr/include/assert.h" 3 4

#if defined __cplusplus && __GNUC_PREREQ (2,95)
# define __ASSERT_VOID_CAST static_cast<void>
#else
# 42 "/usr/include/assert.h" 3 4
# define __ASSERT_VOID_CAST (void)
#endif
# 44 "/usr/include/assert.h" 3 4

/* void assert (int expression);

   If NDEBUG is defined, do nothing.
   If not, and EXPRESSION is zero, print an error message and abort.  */

#ifdef	NDEBUG

# define assert(expr)		(__ASSERT_VOID_CAST (0))

/* void assert_perror (int errnum);

   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an
   error message with the error text for ERRNUM and abort.
   (This is a GNU extension.) */

# ifdef	__USE_GNU
#  define assert_perror(errnum)	(__ASSERT_VOID_CAST (0))
# endif
# 63 "/usr/include/assert.h" 3 4

#else /* Not NDEBUG.  */
# 65 "/usr/include/assert.h" 3 4

__BEGIN_DECLS

/* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (__const char *__assertion, __const char *__file,
			   unsigned int __line, __const char *__function)
     __THROW __attribute__ ((__noreturn__));

/* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, __const char *__file,
				  unsigned int __line,
				  __const char *__function)
     __THROW __attribute__ ((__noreturn__));


/* The following is not at all used here but needed for standard
   compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)
     __THROW __attribute__ ((__noreturn__));


__END_DECLS

# define assert(expr)							\
  ((expr)								\
   ? __ASSERT_VOID_CAST (0)						\
   : __assert_fail (__STRING(expr), __FILE__, __LINE__, __ASSERT_FUNCTION))

# ifdef	__USE_GNU
#  define assert_perror(errnum)						\
  (!(errnum)								\
   ? __ASSERT_VOID_CAST (0)						\
   : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))
# endif
# 99 "/usr/include/assert.h" 3 4

/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
   which contains the name of the function currently being defined.
   This is broken in G++ before version 2.6.
   C9x has a similar variable called __func__, but prefer the GCC one since
   it demangles C++ function names.  */
# if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
#   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
# else
# 108 "/usr/include/assert.h" 3 4
#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#   define __ASSERT_FUNCTION	__func__
#  else
# 111 "/usr/include/assert.h" 3 4
#   define __ASSERT_FUNCTION	((__const char *) 0)
#  endif
# 113 "/usr/include/assert.h" 3 4
# endif
# 114 "/usr/include/assert.h" 3 4

#endif /* NDEBUG.  */
# 116 "/usr/include/assert.h" 3 4
# 9 "./CpfPowerNetwork.hh" 2

#if 0 /* expanded by -frewrite-includes */
#include "CpfanPowerNetwork.hh"
#endif /* expanded by -frewrite-includes */
# 10 "./CpfPowerNetwork.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

//=====================================================================
// Copyright (C) 2014 Synopsys Inc. All Rights Reserved.
//
// Author : Muktipada Behera.
// Date: 10th July 2014
// Description:
//
//=====================================================================

#ifndef _CPFAN_POWERNETWORK_HH_
#define _CPFAN_POWERNETWORK_HH_

#if 0 /* expanded by -frewrite-includes */
#include <list>
#endif /* expanded by -frewrite-includes */
# 19 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh"
# 20 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include <map>
#endif /* expanded by -frewrite-includes */
# 20 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh"
# 21 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include "lp_namespace.hh"
#endif /* expanded by -frewrite-includes */
# 21 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/lp_namespace.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
//
//////////////////////////////////////////////////////////////////////////////
// To be used
// 1. to avoid extra indentation due to namespace.
// 2. And it documents all the namespace used in lp-src code.
//

// File : lp-src/verilog/lp_namespace.hh
// Link is created at (1) lp-src/runtime/include/lp_namespace.hh
//////////////////////////////////////////////////////////////////////////////

#ifndef __LP_NAMESPACE_HH__
#define __LP_NAMESPACE_HH__

#define NAMESPACE_UPFIR_BEGIN namespace upfir {
#define NAMESPACE_UPFIR_END } // upfir

#define NAMESPACE_CPFIR_BEGIN namespace cpfir {
#define NAMESPACE_CPFIR_END } // cpfir

#define NAMESPACE_LP_BEGIN namespace lp {
#define NAMESPACE_LP_END } // lp

#define NAMESPACE_XOVER_BEGIN namespace xover {
#define NAMESPACE_XOVER_END } // xover

#define NAMESPACE_MVDB_BEGIN namespace mvdb {
#define NAMESPACE_MVDB_END } // mvdb

#define NAMESPACE_LPRT_BEGIN namespace lprt {
#define NAMESPACE_LPRT_END } // lprt

#define NAMESPACE_PLATO_NLP_BEGIN namespace platonlp {
#define NAMESPACE_PLATO_NLP_END } // platonlp 

#endif // __LP_NAMESPACE_HH__
# 42 "/remote/vgrnd13/bpham/VCS/lp-src/runtime/include/lp_namespace.hh"
# 22 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh" 2

NAMESPACE_CPFIR_BEGIN

class CpfanPowerDesign;

enum CpfanCommandContext {
    SET_INSTANCE_FOUND,
    SET_DESIGN_FOUND,
    END_DESIGN_FOUND,
    SET_MACRO_FOUND,
    END_MACRO_FOUND,
    UNDEFINED_CONTEXT
};

class CpfanPowerNetwork
{
public:
    CpfanPowerNetwork();

    static CpfanPowerNetwork *getInstance();

    virtual ~CpfanPowerNetwork();

    void setCpfCommandContext(CpfanCommandContext ctxt) {cmdCtxt_ = ctxt;}
    CpfanCommandContext getCpfCommandContext() {return cmdCtxt_;}

    CpfanPowerDesign *findPowerDesign(const std::string &designName);
    void addPowerDesign(CpfanPowerDesign *pd);

    void pushUnresolvedDesign(CpfanPowerDesign *pd);
    void popUnresolvedDesign();
    CpfanPowerDesign *getCurrentUnresolvedDesign() const;

    void addAllowUpdatesOnly() {allowUpdatesOnly_ = 1;}
    void removeAllowUpdatesOnly() {allowUpdatesOnly_ = 0;}
    int  allowUpdatesOnly() {return allowUpdatesOnly_;}

    void setNoPowerModeValidation() {noPowerMode_ = true;}
    bool noPowerModeValidation() const {return noPowerMode_;}

    char getHierarchySeparator() const {return hierarchySep_;}
    void  setHierarchySeparator(char sep) {hierarchySep_ = sep;}

    CpfanPowerDesign *getTopPowerDesign();

    void cleanup();

private:
    static CpfanPowerNetwork                       *powerNetwork_;

    CpfanCommandContext                             cmdCtxt_;

    char                                            hierarchySep_;

    std::list<CpfanPowerDesign*>                    powerDesignList_;
    std::map<std::string, CpfanPowerDesign*>        powerDesignMap_;

    unsigned                                        noPowerMode_:1;
    unsigned                                        allowUpdatesOnly_:1;
};

NAMESPACE_CPFIR_END

#endif
# 86 "/remote/vgrnd13/bpham/VCS/lp-src/cpf/cpfan/CpfanPowerNetwork.hh"
# 11 "./CpfPowerNetwork.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "PowerNetwork.hh"
#endif /* expanded by -frewrite-includes */
# 11 "./CpfPowerNetwork.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh" 1
#ifndef _POWERNETWORK_HH_
#define _POWERNETWORK_HH_

#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 4 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 5 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 5 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 6 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include <map>
#endif /* expanded by -frewrite-includes */
# 6 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 7 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include <limits.h>
#endif /* expanded by -frewrite-includes */
# 7 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 1 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 1 3
/*===---- limits.h - Standard header for integer sizes --------------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/

#ifndef __CLANG_LIMITS_H
#define __CLANG_LIMITS_H

/* The system's limits.h may, in turn, try to #include_next GCC's limits.h.
   Avert this #include_next madness. */
#if defined __GNUC__ && !defined _GCC_LIMITS_H_
#define _GCC_LIMITS_H_
#endif
# 33 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3

/* System headers include a number of constants from POSIX in <limits.h>.
   Include it if we're hosted. */
#if __STDC_HOSTED__ && (1)/*__has_include_next(<limits.h>)*/
#if 0 /* expanded by -frewrite-includes */
#include_next <limits.h>
#endif /* expanded by -frewrite-includes */
# 37 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
/* Copyright (C) 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2005
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 */

#ifndef _LIBC_LIMITS_H_
#define _LIBC_LIMITS_H_	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */
# 27 "/usr/include/limits.h" 3 4
# 28 "/usr/include/limits.h" 3 4


/* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  */
#define MB_LEN_MAX	16


/* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  */
#if !defined __GNUC__ || __GNUC__ < 2

/* We only protect from multiple inclusion here, because all the other
   #include's protect themselves, and in GCC 2 we may #include_next through
   multiple copies of this file before we get to GCC's.  */
# ifndef _LIMITS_H
#  define _LIMITS_H	1

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 46 "/usr/include/limits.h" 3 4
# 47 "/usr/include/limits.h" 3 4

/* We don't have #include_next.
   Define ANSI <limits.h> for standard 32-bit words.  */

/* These assume 8-bit `char's, 16-bit `short int's,
   and 32-bit `int's and `long int's.  */

/* Number of bits in a `char'.	*/
#  define CHAR_BIT	8

/* Minimum and maximum values a `signed char' can hold.  */
#  define SCHAR_MIN	(-128)
#  define SCHAR_MAX	127

/* Maximum value an `unsigned char' can hold.  (Minimum is 0.)  */
#  define UCHAR_MAX	255

/* Minimum and maximum values a `char' can hold.  */
#  ifdef __CHAR_UNSIGNED__
#   define CHAR_MIN	0
#   define CHAR_MAX	UCHAR_MAX
#  else
# 69 "/usr/include/limits.h" 3 4
#   define CHAR_MIN	SCHAR_MIN
#   define CHAR_MAX	SCHAR_MAX
#  endif
# 72 "/usr/include/limits.h" 3 4

/* Minimum and maximum values a `signed short int' can hold.  */
#  define SHRT_MIN	(-32768)
#  define SHRT_MAX	32767

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0.)  */
#  define USHRT_MAX	65535

/* Minimum and maximum values a `signed int' can hold.  */
#  define INT_MIN	(-INT_MAX - 1)
#  define INT_MAX	2147483647

/* Maximum value an `unsigned int' can hold.  (Minimum is 0.)  */
#  define UINT_MAX	4294967295U

/* Minimum and maximum values a `signed long int' can hold.  */
#  if __WORDSIZE == 64
#   define LONG_MAX	9223372036854775807L
#  else
# 91 "/usr/include/limits.h" 3 4
#   define LONG_MAX	2147483647L
#  endif
# 93 "/usr/include/limits.h" 3 4
#  define LONG_MIN	(-LONG_MAX - 1L)

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0.)  */
#  if __WORDSIZE == 64
#   define ULONG_MAX	18446744073709551615UL
#  else
# 99 "/usr/include/limits.h" 3 4
#   define ULONG_MAX	4294967295UL
#  endif
# 101 "/usr/include/limits.h" 3 4

#  ifdef __USE_ISOC99

/* Minimum and maximum values a `signed long long int' can hold.  */
#   define LLONG_MAX	9223372036854775807LL
#   define LLONG_MIN	(-LLONG_MAX - 1LL)

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
#   define ULLONG_MAX	18446744073709551615ULL

#  endif /* ISO C99 */
# 112 "/usr/include/limits.h" 3 4

# endif	/* limits.h  */
# 114 "/usr/include/limits.h" 3 4
#endif	/* GCC 2.  */
# 115 "/usr/include/limits.h" 3 4

#endif	/* !_LIBC_LIMITS_H_ */
# 117 "/usr/include/limits.h" 3 4

 /* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  */
#if defined __GNUC__ && !defined _GCC_LIMITS_H_
/* `_GCC_LIMITS_H_' is what GCC's file defines.  */
#if 0 /* expanded by -frewrite-includes */
# include_next <limits.h>
#endif /* expanded by -frewrite-includes */
# 125 "/usr/include/limits.h" 3 4
# 126 "/usr/include/limits.h" 3 4
#endif
# 127 "/usr/include/limits.h" 3 4

/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  */
#if defined __USE_ISOC99 && defined __GNUC__
# ifndef LLONG_MIN
#  define LLONG_MIN	(-LLONG_MAX-1)
# endif
# 135 "/usr/include/limits.h" 3 4
# ifndef LLONG_MAX
#  define LLONG_MAX	__LONG_LONG_MAX__
# endif
# 138 "/usr/include/limits.h" 3 4
# ifndef ULLONG_MAX
#  define ULLONG_MAX	(LLONG_MAX * 2ULL + 1)
# endif
# 141 "/usr/include/limits.h" 3 4
#endif
# 142 "/usr/include/limits.h" 3 4

#ifdef	__USE_POSIX
/* POSIX adds things to <limits.h>.  */
#if 0 /* expanded by -frewrite-includes */
# include <bits/posix1_lim.h>
#endif /* expanded by -frewrite-includes */
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
/* Copyright (C) 1991-1993,96,98,2000-2003,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */

#ifndef	_BITS_POSIX1_LIM_H
#define	_BITS_POSIX1_LIM_H	1


/* These are the standard-mandated minimum values.  */

/* Minimum number of operations in one list I/O call.  */
#define _POSIX_AIO_LISTIO_MAX	2

/* Minimal number of outstanding asynchronous I/O operations.  */
#define _POSIX_AIO_MAX		1

/* Maximum length of arguments to `execve', including environment.  */
#define	_POSIX_ARG_MAX		4096

/* Maximum simultaneous processes per real user ID.  */
#ifdef __USE_XOPEN2K
# define _POSIX_CHILD_MAX	25
#else
# 44 "/usr/include/bits/posix1_lim.h" 3 4
# define _POSIX_CHILD_MAX	6
#endif
# 46 "/usr/include/bits/posix1_lim.h" 3 4

/* Minimal number of timer expiration overruns.  */
#define _POSIX_DELAYTIMER_MAX	32

/* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  */
#define _POSIX_HOST_NAME_MAX	255

/* Maximum link count of a file.  */
#define	_POSIX_LINK_MAX		8

/* Maximum length of login name.  */
#define	_POSIX_LOGIN_NAME_MAX	9

/* Number of bytes in a terminal canonical input queue.  */
#define	_POSIX_MAX_CANON	255

/* Number of bytes for which space will be
   available in a terminal input queue.  */
#define	_POSIX_MAX_INPUT	255

/* Maximum number of message queues open for a process.  */
#define _POSIX_MQ_OPEN_MAX	8

/* Maximum number of supported message priorities.  */
#define _POSIX_MQ_PRIO_MAX	32

/* Number of bytes in a filename.  */
#define	_POSIX_NAME_MAX		14

/* Number of simultaneous supplementary group IDs per process.  */
#ifdef __USE_XOPEN2K
# define _POSIX_NGROUPS_MAX	8
#else
# 80 "/usr/include/bits/posix1_lim.h" 3 4
# define _POSIX_NGROUPS_MAX	0
#endif
# 82 "/usr/include/bits/posix1_lim.h" 3 4

/* Number of files one process can have open at once.  */
#ifdef __USE_XOPEN2K
# define _POSIX_OPEN_MAX	20
#else
# 87 "/usr/include/bits/posix1_lim.h" 3 4
# define _POSIX_OPEN_MAX	16
#endif
# 89 "/usr/include/bits/posix1_lim.h" 3 4

#if !defined __USE_XOPEN2K || defined __USE_GNU
/* Number of descriptors that a process may examine with `pselect' or
   `select'.  */
# define _POSIX_FD_SETSIZE	_POSIX_OPEN_MAX
#endif
# 95 "/usr/include/bits/posix1_lim.h" 3 4

/* Number of bytes in a pathname.  */
#define	_POSIX_PATH_MAX		256

/* Number of bytes than can be written atomically to a pipe.  */
#define	_POSIX_PIPE_BUF		512

/* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  */
#define _POSIX_RE_DUP_MAX	255

/* Minimal number of realtime signals reserved for the application.  */
#define _POSIX_RTSIG_MAX	8

/* Number of semaphores a process can have.  */
#define _POSIX_SEM_NSEMS_MAX	256

/* Maximal value of a semaphore.  */
#define _POSIX_SEM_VALUE_MAX	32767

/* Number of pending realtime signals.  */
#define _POSIX_SIGQUEUE_MAX	32

/* Largest value of a `ssize_t'.  */
#define	_POSIX_SSIZE_MAX	32767

/* Number of streams a process can have open at once.  */
#define	_POSIX_STREAM_MAX	8

/* The number of bytes in a symbolic link.  */
#define _POSIX_SYMLINK_MAX	255

/* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  */
#define _POSIX_SYMLOOP_MAX	8

/* Number of timer for a process.  */
#define _POSIX_TIMER_MAX	32

/* Maximum number of characters in a tty name.  */
#define	_POSIX_TTY_NAME_MAX	9

/* Maximum length of a timezone name (element of `tzname').  */
#define	_POSIX_TZNAME_MAX	6

#if !defined __USE_XOPEN2K || defined __USE_GNU
/* Maximum number of connections that can be queued on a socket.  */
# define _POSIX_QLIMIT		1

/* Maximum number of bytes that can be buffered on a socket for send
   or receive.  */
# define _POSIX_HIWAT		_POSIX_PIPE_BUF

/* Maximum number of elements in an `iovec' array.  */
# define _POSIX_UIO_MAXIOV	16
#endif
# 151 "/usr/include/bits/posix1_lim.h" 3 4

/* Maximum clock resolution in nanoseconds.  */
#define _POSIX_CLOCKRES_MIN	20000000


/* Get the implementation-specific values for the above.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/local_lim.h>
#endif /* expanded by -frewrite-includes */
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
/* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-1998,2000,2002-2004,2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  */
#ifndef NR_OPEN
# define __undef_NR_OPEN
#endif
# 28 "/usr/include/bits/local_lim.h" 3 4
#ifndef LINK_MAX
# define __undef_LINK_MAX
#endif
# 31 "/usr/include/bits/local_lim.h" 3 4
#ifndef OPEN_MAX
# define __undef_OPEN_MAX
#endif
# 34 "/usr/include/bits/local_lim.h" 3 4
#ifndef ARG_MAX
# define __undef_ARG_MAX
#endif
# 37 "/usr/include/bits/local_lim.h" 3 4

/* The kernel sources contain a file with all the needed information.  */
#if 0 /* expanded by -frewrite-includes */
#include <linux/limits.h>
#endif /* expanded by -frewrite-includes */
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
#ifndef _LINUX_LIMITS_H
#define _LINUX_LIMITS_H

#define NR_OPEN	        1024

#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
#define ARG_MAX       131072	/* # bytes of args + environ for exec() */
#define LINK_MAX         127	/* # links a file may have */
#define MAX_CANON        255	/* size of the canonical input queue */
#define MAX_INPUT        255	/* size of the type-ahead buffer */
#define NAME_MAX         255	/* # chars in a file name */
#define PATH_MAX        4096	/* # chars in a path name including nul */
#define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
#define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
#define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */

#define RTSIG_MAX	  32

#endif
# 21 "/usr/include/linux/limits.h" 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4

/* Have to remove NR_OPEN?  */
#ifdef __undef_NR_OPEN
# undef NR_OPEN
# undef __undef_NR_OPEN
#endif
# 46 "/usr/include/bits/local_lim.h" 3 4
/* Have to remove LINK_MAX?  */
#ifdef __undef_LINK_MAX
# undef LINK_MAX
# undef __undef_LINK_MAX
#endif
# 51 "/usr/include/bits/local_lim.h" 3 4
/* Have to remove OPEN_MAX?  */
#ifdef __undef_OPEN_MAX
# undef OPEN_MAX
# undef __undef_OPEN_MAX
#endif
# 56 "/usr/include/bits/local_lim.h" 3 4
/* Have to remove ARG_MAX?  */
#ifdef __undef_ARG_MAX
# undef ARG_MAX
# undef __undef_ARG_MAX
#endif
# 61 "/usr/include/bits/local_lim.h" 3 4

/* The number of data keys per process.  */
#define _POSIX_THREAD_KEYS_MAX	128
/* This is the value this implementation supports.  */
#define PTHREAD_KEYS_MAX	1024

/* Controlling the iterations of destructors for thread-specific data.  */
#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
/* Number of iterations this implementation does.  */
#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS

/* The number of threads per process.  */
#define _POSIX_THREAD_THREADS_MAX	64
/* We have no predefined limit on the number of threads.  */
#undef PTHREAD_THREADS_MAX

/* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  */
#define AIO_PRIO_DELTA_MAX	20

/* Minimum size for a thread.  We are free to choose a reasonable value.  */
#define PTHREAD_STACK_MIN	16384

/* Maximum number of timer expiration overruns.  */
#define DELAYTIMER_MAX	2147483647

/* Maximum tty name length.  */
#define TTY_NAME_MAX		32

/* Maximum login name length.  This is arbitrary.  */
#define LOGIN_NAME_MAX		256

/* Maximum host name length.  */
#define HOST_NAME_MAX		64

/* Maximum message queue priority level.  */
#define MQ_PRIO_MAX		32768

/* Maximum value the semaphore can have.  */
#define SEM_VALUE_MAX   (2147483647)
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4


#ifndef	SSIZE_MAX
# define SSIZE_MAX	LONG_MAX
#endif
# 163 "/usr/include/bits/posix1_lim.h" 3 4


/* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  */

#ifndef	NGROUPS_MAX
# define NGROUPS_MAX	8
#endif
# 171 "/usr/include/bits/posix1_lim.h" 3 4

#endif	/* bits/posix1_lim.h  */
# 173 "/usr/include/bits/posix1_lim.h" 3 4
# 146 "/usr/include/limits.h" 2 3 4
#endif
# 147 "/usr/include/limits.h" 3 4

#ifdef	__USE_POSIX2
#if 0 /* expanded by -frewrite-includes */
# include <bits/posix2_lim.h>
#endif /* expanded by -frewrite-includes */
# 149 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
/* Copyright (C) 1991, 1996, 1999, 2000, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; include <limits.h> instead.
 */

#ifndef	_BITS_POSIX2_LIM_H
#define	_BITS_POSIX2_LIM_H	1


/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */
#define	_POSIX2_BC_BASE_MAX		99

/* The maximum number of elements allowed in an array by the `bc' utility.  */
#define	_POSIX2_BC_DIM_MAX		2048

/* The maximum `scale' value allowed by the `bc' utility.  */
#define	_POSIX2_BC_SCALE_MAX		99

/* The maximum length of a string constant accepted by the `bc' utility.  */
#define	_POSIX2_BC_STRING_MAX		1000

/* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  */
#define	_POSIX2_COLL_WEIGHTS_MAX	2

/* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  */
#define	_POSIX2_EXPR_NEST_MAX		32

/* The maximum length, in bytes, of an input line.  */
#define	_POSIX2_LINE_MAX		2048

/* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  */
#define	_POSIX2_RE_DUP_MAX		255

/* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  */
#define	_POSIX2_CHARCLASS_NAME_MAX	14


/* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  */

#ifndef	BC_BASE_MAX
#define	BC_BASE_MAX		_POSIX2_BC_BASE_MAX
#endif
# 66 "/usr/include/bits/posix2_lim.h" 3 4
#ifndef	BC_DIM_MAX
#define	BC_DIM_MAX		_POSIX2_BC_DIM_MAX
#endif
# 69 "/usr/include/bits/posix2_lim.h" 3 4
#ifndef	BC_SCALE_MAX
#define	BC_SCALE_MAX		_POSIX2_BC_SCALE_MAX
#endif
# 72 "/usr/include/bits/posix2_lim.h" 3 4
#ifndef	BC_STRING_MAX
#define	BC_STRING_MAX		_POSIX2_BC_STRING_MAX
#endif
# 75 "/usr/include/bits/posix2_lim.h" 3 4
#ifndef	COLL_WEIGHTS_MAX
#define	COLL_WEIGHTS_MAX	255
#endif
# 78 "/usr/include/bits/posix2_lim.h" 3 4
#ifndef	EXPR_NEST_MAX
#define	EXPR_NEST_MAX		_POSIX2_EXPR_NEST_MAX
#endif
# 81 "/usr/include/bits/posix2_lim.h" 3 4
#ifndef	LINE_MAX
#define	LINE_MAX		_POSIX2_LINE_MAX
#endif
# 84 "/usr/include/bits/posix2_lim.h" 3 4
#ifndef	CHARCLASS_NAME_MAX
#define	CHARCLASS_NAME_MAX	2048
#endif
# 87 "/usr/include/bits/posix2_lim.h" 3 4

/* This value is defined like this in regex.h.  */
#define	RE_DUP_MAX (0x7fff)

#endif	/* bits/posix2_lim.h */
# 92 "/usr/include/bits/posix2_lim.h" 3 4
# 150 "/usr/include/limits.h" 2 3 4
#endif
# 151 "/usr/include/limits.h" 3 4

#ifdef	__USE_XOPEN
#if 0 /* expanded by -frewrite-includes */
# include <bits/xopen_lim.h>
#endif /* expanded by -frewrite-includes */
# 153 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <limits.h> instead.
 */

/* Additional definitions from X/Open Portability Guide, Issue 4, Version 2
   System Interfaces and Headers, 4.16 <limits.h>

   Please note only the values which are not greater than the minimum
   stated in the standard document are listed.  The `sysconf' functions
   should be used to obtain the actual value.  */

#ifndef _XOPEN_LIM_H
#define _XOPEN_LIM_H	1

#define __need_IOV_MAX
#if 0 /* expanded by -frewrite-includes */
#include <bits/stdio_lim.h>
#endif /* expanded by -frewrite-includes */
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
/* Copyright (C) 1994, 1997, 1998, 1999, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#if !defined _STDIO_H && !defined __need_FOPEN_MAX && !defined __need_IOV_MAX
# error "Never include <bits/stdio_lim.h> directly; use <stdio.h> instead."
#endif
# 22 "/usr/include/bits/stdio_lim.h" 3 4

#ifdef _STDIO_H
# define L_tmpnam 20
# define TMP_MAX 238328
# define FILENAME_MAX 4096

# ifdef __USE_POSIX
#  define L_ctermid 9
#  if !defined __USE_XOPEN2K || defined __USE_GNU
#   define L_cuserid 9
#  endif
# 33 "/usr/include/bits/stdio_lim.h" 3 4
# endif
# 34 "/usr/include/bits/stdio_lim.h" 3 4
#endif
# 35 "/usr/include/bits/stdio_lim.h" 3 4

#if defined __need_FOPEN_MAX || defined _STDIO_H
# undef  FOPEN_MAX
# define FOPEN_MAX 16
#endif
# 40 "/usr/include/bits/stdio_lim.h" 3 4

#if defined __need_IOV_MAX && !defined IOV_MAX
# define IOV_MAX 1024
#endif
# 44 "/usr/include/bits/stdio_lim.h" 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4

/* We do not provide fixed values for

   ARG_MAX	Maximum length of argument to the `exec' function
		including environment data.

   ATEXIT_MAX	Maximum number of functions that may be registered
		with `atexit'.

   CHILD_MAX	Maximum number of simultaneous processes per real
		user ID.

   OPEN_MAX	Maximum number of files that one process can have open
		at anyone time.

   PAGESIZE
   PAGE_SIZE	Size of bytes of a page.

   PASS_MAX	Maximum number of significant bytes in a password.

   We only provide a fixed limit for

   IOV_MAX	Maximum number of `iovec' structures that one process has
		available for use with `readv' or writev'.

   if this is indeed fixed by the underlying system.
*/


/* Maximum number of `iovec' structures that one process has available
   for use with `readv' or writev'.  */
#define	_XOPEN_IOV_MAX	_POSIX_UIO_MAXIOV


/* Maximum value of `digit' in calls to the `printf' and `scanf'
   functions.  We have no limit, so return a reasonable value.  */
#define NL_ARGMAX	_POSIX_ARG_MAX

/* Maximum number of bytes in a `LANG' name.  We have no limit.  */
#define NL_LANGMAX	_POSIX2_LINE_MAX

/* Maximum message number.  We have no limit.  */
#define NL_MSGMAX	INT_MAX

/* Maximum number of bytes in N-to-1 collation mapping.  We have no
   limit.  */
#define NL_NMAX		INT_MAX

/* Maximum set number.  We have no limit.  */
#define NL_SETMAX	INT_MAX

/* Maximum number of bytes in a message.  We have no limit.  */
#define NL_TEXTMAX	INT_MAX

/* Default process priority.  */
#define NZERO		20


/* Number of bits in a word of type `int'.  */
#ifdef INT_MAX
# if INT_MAX == 32767
#  define WORD_BIT	16
# else
# 98 "/usr/include/bits/xopen_lim.h" 3 4
#  if INT_MAX == 2147483647
#   define WORD_BIT	32
#  else
# 101 "/usr/include/bits/xopen_lim.h" 3 4
/* Safe assumption.  */
#   define WORD_BIT	64
#  endif
# 104 "/usr/include/bits/xopen_lim.h" 3 4
# endif
# 105 "/usr/include/bits/xopen_lim.h" 3 4
#elif defined __INT_MAX__
# 106 "/usr/include/bits/xopen_lim.h" 3 4
# if __INT_MAX__ == 32767
#  define WORD_BIT	16
# else
# 109 "/usr/include/bits/xopen_lim.h" 3 4
#  if __INT_MAX__ == 2147483647
#   define WORD_BIT	32
#  else
# 112 "/usr/include/bits/xopen_lim.h" 3 4
/* Safe assumption.  */
#   define WORD_BIT	64
#  endif
# 115 "/usr/include/bits/xopen_lim.h" 3 4
# endif
# 116 "/usr/include/bits/xopen_lim.h" 3 4
#else
# 117 "/usr/include/bits/xopen_lim.h" 3 4
# define WORD_BIT	32
#endif
# 119 "/usr/include/bits/xopen_lim.h" 3 4

/* Number of bits in a word of type `long int'.  */
#ifdef LONG_MAX
# if LONG_MAX == 2147483647
#  define LONG_BIT	32
# else
# 125 "/usr/include/bits/xopen_lim.h" 3 4
/* Safe assumption.  */
#  define LONG_BIT	64
# endif
# 128 "/usr/include/bits/xopen_lim.h" 3 4
#elif defined __LONG_MAX__
# 129 "/usr/include/bits/xopen_lim.h" 3 4
# if __LONG_MAX__ == 2147483647
#  define LONG_BIT	32
# else
# 132 "/usr/include/bits/xopen_lim.h" 3 4
/* Safe assumption.  */
#  define LONG_BIT	64
# endif
# 135 "/usr/include/bits/xopen_lim.h" 3 4
#else
# 136 "/usr/include/bits/xopen_lim.h" 3 4
#if 0 /* expanded by -frewrite-includes */
# include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# 136 "/usr/include/bits/xopen_lim.h" 3 4
# 137 "/usr/include/bits/xopen_lim.h" 3 4
# if __WORDSIZE == 64
#  define LONG_BIT	64
# else
# 140 "/usr/include/bits/xopen_lim.h" 3 4
#  define LONG_BIT	32
# endif
# 142 "/usr/include/bits/xopen_lim.h" 3 4
#endif
# 143 "/usr/include/bits/xopen_lim.h" 3 4

#endif /* bits/xopen_lim.h */
# 145 "/usr/include/bits/xopen_lim.h" 3 4
# 154 "/usr/include/limits.h" 2 3 4
#endif
# 155 "/usr/include/limits.h" 3 4
# 38 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 2 3
#endif
# 39 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3

/* Many system headers try to "help us out" by defining these.  No really, we
   know how big each datatype is. */
#undef  SCHAR_MIN
#undef  SCHAR_MAX
#undef  UCHAR_MAX
#undef  SHRT_MIN
#undef  SHRT_MAX
#undef  USHRT_MAX
#undef  INT_MIN
#undef  INT_MAX
#undef  UINT_MAX
#undef  LONG_MIN
#undef  LONG_MAX
#undef  ULONG_MAX

#undef  CHAR_BIT
#undef  CHAR_MIN
#undef  CHAR_MAX

/* C90/99 5.2.4.2.1 */
#define SCHAR_MAX __SCHAR_MAX__
#define SHRT_MAX  __SHRT_MAX__
#define INT_MAX   __INT_MAX__
#define LONG_MAX  __LONG_MAX__

#define SCHAR_MIN (-__SCHAR_MAX__-1)
#define SHRT_MIN  (-__SHRT_MAX__ -1)
#define INT_MIN   (-__INT_MAX__  -1)
#define LONG_MIN  (-__LONG_MAX__ -1L)

#define UCHAR_MAX (__SCHAR_MAX__*2  +1)
#define USHRT_MAX (__SHRT_MAX__ *2  +1)
#define UINT_MAX  (__INT_MAX__  *2U +1U)
#define ULONG_MAX (__LONG_MAX__ *2UL+1UL)

#ifndef MB_LEN_MAX
#define MB_LEN_MAX 1
#endif
# 78 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3

#define CHAR_BIT  __CHAR_BIT__

#ifdef __CHAR_UNSIGNED__  /* -funsigned-char */
#define CHAR_MIN 0
#define CHAR_MAX UCHAR_MAX
#else
# 85 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3
#define CHAR_MIN SCHAR_MIN
#define CHAR_MAX __SCHAR_MAX__
#endif
# 88 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3

/* C99 5.2.4.2.1: Added long long.
   C++11 18.3.3.2: same contents as the Standard C Library header <limits.h>.
 */
#if __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L

#undef  LLONG_MIN
#undef  LLONG_MAX
#undef  ULLONG_MAX

#define LLONG_MAX  __LONG_LONG_MAX__
#define LLONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULLONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif
# 102 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3

/* LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad
   that we don't have something like #pragma poison that could be used to
   deprecate a macro - the code should just use LLONG_MAX and friends.
 */
#if defined(__GNU_LIBRARY__) ? defined(__USE_GNU) : !defined(__STRICT_ANSI__)

#undef   LONG_LONG_MIN
#undef   LONG_LONG_MAX
#undef   ULONG_LONG_MAX

#define LONG_LONG_MAX  __LONG_LONG_MAX__
#define LONG_LONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULONG_LONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif
# 117 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3

#endif /* __CLANG_LIMITS_H */
# 119 "/fs/src/interfaces/LLVM_Project/QSCM/opt/llvm-3.9.1/linux64/bin/../lib64/clang/3.9.1/include/limits.h" 3
# 8 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include <set>
#endif /* expanded by -frewrite-includes */
# 8 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 1 3
// <set> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/set
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_SET
#define _GLIBCXX_SET 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_tree.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_set.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 1 3
// Set implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_set.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{set}
 */

#ifndef _STL_SET_H
#define _STL_SET_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
#endif
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /**
   *  @brief A standard container made up of unique keys, which can be
   *  retrieved in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using unique keys).
   *
   *  Sets support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for set and
   *  multiset; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  */
  template<typename _Key, typename _Compare = std::less<_Key>,
	   typename _Alloc = std::allocator<_Key> >
    class set
    {
      // concept requirements
      typedef typename _Alloc::value_type                   _Alloc_value_type;
      __glibcxx_class_requires(_Key, _SGIAssignableConcept)
      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
				_BinaryFunctionConcept)
      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)

    public:
      // typedefs:
      //@{
      /// Public typedefs.
      typedef _Key     key_type;
      typedef _Key     value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc   allocator_type;
      //@}

    private:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
	rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
		       key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;  // Red-black tree representing set.

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:
      //@{
      ///  Iterator-related typedefs.
      typedef typename _Alloc_traits::pointer		    pointer;
      typedef typename _Alloc_traits::const_pointer	    const_pointer;
      typedef typename _Alloc_traits::reference		    reference;
      typedef typename _Alloc_traits::const_reference	    const_reference;
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 103. set::iterator is required to be modifiable,
      // but this allows modification of keys.
      typedef typename _Rep_type::const_iterator            iterator;
      typedef typename _Rep_type::const_iterator            const_iterator;
      typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type                 size_type;
      typedef typename _Rep_type::difference_type           difference_type;
      //@}

      // allocation/deallocation
      /**
       *  @brief  Default constructor creates no elements.
       */
      set()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
#endif
# 146 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      : _M_t() { }

      /**
       *  @brief  Creates a %set with no elements.
       *  @param  __comp  Comparator to use.
       *  @param  __a  An allocator object.
       */
      explicit
      set(const _Compare& __comp,
	  const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }

      /**
       *  @brief  Builds a %set from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %set consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       */
      template<typename _InputIterator>
	set(_InputIterator __first, _InputIterator __last)
	: _M_t()
	{ _M_t._M_insert_unique(__first, __last); }

      /**
       *  @brief  Builds a %set from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %set consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       */
      template<typename _InputIterator>
	set(_InputIterator __first, _InputIterator __last,
	    const _Compare& __comp,
	    const allocator_type& __a = allocator_type())
	: _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }

      /**
       *  @brief  %Set copy constructor.
       *  @param  __x  A %set of identical element and allocator types.
       *
       *  The newly-created %set uses a copy of the allocation object used
       *  by @a __x.
       */
      set(const set& __x)
      : _M_t(__x._M_t) { }

#if __cplusplus >= 201103L
     /**
       *  @brief %Set move constructor
       *  @param __x  A %set of identical element and allocator types.
       *
       *  The newly-created %set contains the exact contents of @a x.
       *  The contents of @a x are a valid, but unspecified %set.
       */
      set(set&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }

      /**
       *  @brief  Builds a %set from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %set consisting of copies of the elements in the list.
       *  This is linear in N if the list is already sorted, and NlogN
       *  otherwise (where N is @a __l.size()).
       */
      set(initializer_list<value_type> __l,
	  const _Compare& __comp = _Compare(),
	  const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }

      /// Allocator-extended default constructor.
      explicit
      set(const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a)) { }

      /// Allocator-extended copy constructor.
      set(const set& __x, const allocator_type& __a)
      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }

      /// Allocator-extended move constructor.
      set(set&& __x, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
	       && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }

      /// Allocator-extended initialier-list constructor.
      set(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a))
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }

      /// Allocator-extended range constructor.
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
	    const allocator_type& __a)
	: _M_t(_Compare(), _Key_alloc_type(__a))
        { _M_t._M_insert_unique(__first, __last); }
#endif
# 257 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      /**
       *  @brief  %Set assignment operator.
       *  @param  __x  A %set of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but unlike the copy
       *  constructor, the allocator object is not copied.
       */
      set&
      operator=(const set& __x)
      {
	_M_t = __x._M_t;
	return *this;
      }

#if __cplusplus >= 201103L
      /// Move assignment operator.
      set&
      operator=(set&&) = default;

      /**
       *  @brief  %Set list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %set with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %set and
       *  that the resulting %set's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
      set&
      operator=(initializer_list<value_type> __l)
      {
	_M_t._M_assign_unique(__l.begin(), __l.end());
	return *this;
      }
#endif
# 295 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      // accessors:

      ///  Returns the comparison object with which the %set was constructed.
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      ///  Returns the comparison object with which the %set was constructed.
      value_compare
      value_comp() const
      { return _M_t.key_comp(); }
      ///  Returns the allocator object with which the %set was constructed.
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_t.get_allocator()); }

      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %set.  Iteration is done in ascending order according
       *  to the keys.
       */
      iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %set.  Iteration is done in ascending order according
       *  to the keys.
       */
      iterator
      end() const _GLIBCXX_NOEXCEPT
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) iterator that points to the last
       *  element in the %set.  Iteration is done in descending order according
       *  to the keys.
       */
      reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %set.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return _M_t.rend(); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %set.  Iteration is done in ascending order according
       *  to the keys.
       */
      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %set.  Iteration is done in ascending order according
       *  to the keys.
       */
      iterator
      cend() const noexcept
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) iterator that points to the last
       *  element in the %set.  Iteration is done in descending order according
       *  to the keys.
       */
      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %set.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }
#endif
# 384 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      ///  Returns true if the %set is empty.
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return _M_t.empty(); }

      ///  Returns the size of the %set.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_t.size(); }

      ///  Returns the maximum size of the %set.
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _M_t.max_size(); }

      /**
       *  @brief  Swaps data with another %set.
       *  @param  __x  A %set of the same element and allocator types.
       *
       *  This exchanges the elements between two sets in constant
       *  time.  (It is only swapping a pointer, an integer, and an
       *  instance of the @c Compare type (which itself is often
       *  stateless and empty), so it should be quite fast.)  Note
       *  that the global std::swap() function is specialized such
       *  that std::swap(s1,s2) will feed to this function.
       */
      void
      swap(set& __x)
#if __cplusplus >= 201103L
      noexcept(_Alloc_traits::_S_nothrow_swap())
#endif
# 416 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      { _M_t.swap(__x._M_t); }

      // insert/erase
#if __cplusplus >= 201103L
      /**
       *  @brief Attempts to build and insert an element into the %set.
       *  @param __args  Arguments used to generate an element.
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted element, and the second is a bool
       *           that is true if the element was actually inserted.
       *
       *  This function attempts to build and insert an element into the %set.
       *  A %set relies on unique keys and thus an element is only inserted if
       *  it is not already present in the %set.
       *
       *  Insertion requires logarithmic time.
       */
      template<typename... _Args>
	std::pair<iterator, bool>
	emplace(_Args&&... __args)
	{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }

      /**
       *  @brief Attempts to insert an element into the %set.
       *  @param  __pos  An iterator that serves as a hint as to where the
       *                element should be inserted.
       *  @param  __args  Arguments used to generate the element to be
       *                 inserted.
       *  @return An iterator that points to the element with key equivalent to
       *          the one generated from @a __args (may or may not be the
       *          element itself).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does.  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      template<typename... _Args>
	iterator
	emplace_hint(const_iterator __pos, _Args&&... __args)
	{
	  return _M_t._M_emplace_hint_unique(__pos,
					     std::forward<_Args>(__args)...);
	}
#endif
# 467 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      /**
       *  @brief Attempts to insert an element into the %set.
       *  @param  __x  Element to be inserted.
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted element, and the second is a bool
       *           that is true if the element was actually inserted.
       *
       *  This function attempts to insert an element into the %set.  A %set
       *  relies on unique keys and thus an element is only inserted if it is
       *  not already present in the %set.
       *
       *  Insertion requires logarithmic time.
       */
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
	std::pair<typename _Rep_type::iterator, bool> __p =
	  _M_t._M_insert_unique(__x);
	return std::pair<iterator, bool>(__p.first, __p.second);
      }

#if __cplusplus >= 201103L
      std::pair<iterator, bool>
      insert(value_type&& __x)
      {
	std::pair<typename _Rep_type::iterator, bool> __p =
	  _M_t._M_insert_unique(std::move(__x));
	return std::pair<iterator, bool>(__p.first, __p.second);
      }
#endif
# 498 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      /**
       *  @brief Attempts to insert an element into the %set.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                    element should be inserted.
       *  @param  __x  Element to be inserted.
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the element passed in).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument insert()
       *  does.  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }

#if __cplusplus >= 201103L
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
#endif
# 527 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      /**
       *  @brief A template function that attempts to insert a range
       *  of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       */
      template<typename _InputIterator>
	void
	insert(_InputIterator __first, _InputIterator __last)
	{ _M_t._M_insert_unique(__first, __last); }

#if __cplusplus >= 201103L
      /**
       *  @brief Attempts to insert a list of elements into the %set.
       *  @param  __l  A std::initializer_list<value_type> of elements
       *               to be inserted.
       *
       *  Complexity similar to that of the range constructor.
       */
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
#endif
# 554 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases an element from a %set.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a __position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %set.  Note that this function only erases the element, and
       *  that if the element is itself a pointer, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
#else
# 576 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      /**
       *  @brief Erases an element from a %set.
       *  @param  position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %set.  Note that this function only erases the element, and
       *  that if the element is itself a pointer, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#endif
# 590 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      /**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  a %set.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases a [__first,__last) range of elements from a %set.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                 erased.

       *  @param __last Iterator pointing to the end of the range to
       *  be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from a %set.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
#else
# 628 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      /**
       *  @brief Erases a [first,last) range of elements from a %set.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                 erased.
       *  @param __last Iterator pointing to the end of the range to
       *  be erased.
       *
       *  This function erases a sequence of elements from a %set.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#endif
# 644 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3

      /**
       *  Erases all elements in a %set.  Note that this function only erases
       *  the elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      { _M_t.clear(); }

      // set operations:

      //@{
      /**
       *  @brief  Finds the number of elements.
       *  @param  __x  Element to located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for multisets; for set the result will
       *  either be 0 (not present) or 1 (present).
       */
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	count(const _Kt& __x) const
	-> decltype(_M_t._M_count_tr(__x))
	{ return _M_t._M_find_tr(__x) == _M_t.end() ? 0 : 1; }
#endif
# 677 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      //@}

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 214.  set::find() missing const overload
      //@{
      /**
       *  @brief Tries to locate an element in a %set.
       *  @param  __x  Element to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }

      template<typename _Kt>
	auto
	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }
#endif
# 712 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Iterator pointing to first element equal to or greater
       *           than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       */
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x)
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }

      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x) const
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }
#endif
# 747 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return Iterator pointing to the first element
       *          greater than key, or end().
       */
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x)
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }

      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x) const
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }
#endif
# 777 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      //@}

      //@{
      /**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multisets.
       */
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	equal_range(const _Kt& __x)
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }

      template<typename _Kt>
	auto
	equal_range(const _Kt& __x) const
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }
#endif
# 816 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
      //@}

      template<typename _K1, typename _C1, typename _A1>
	friend bool
	operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
	friend bool
	operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };


  /**
   *  @brief  Set equality comparison.
   *  @param  __x  A %set.
   *  @param  __y  A %set of the same type as @a x.
   *  @return  True iff the size and elements of the sets are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the sets.
   *  Sets are considered equivalent if their sizes are equal, and if
   *  corresponding elements compare equal.
  */
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
	       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }

  /**
   *  @brief  Set ordering relation.
   *  @param  __x  A %set.
   *  @param  __y  A %set of the same type as @a x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  sets.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
	      const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }

  ///  Returns !(x == y).
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
	       const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  ///  Returns y < x.
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
	      const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }

  ///  Returns !(y < x)
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
	       const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  ///  Returns !(x < y)
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
	       const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  /// See std::set::swap().
  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

_GLIBCXX_END_NAMESPACE_CONTAINER
} //namespace std
#endif /* _STL_SET_H */
# 898 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_set.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_multiset.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 1 3
// Multiset implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_multiset.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{set}
 */

#ifndef _STL_MULTISET_H
#define _STL_MULTISET_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
#endif
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /**
   *  @brief A standard container made up of elements, which can be retrieved
   *  in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using equivalent
   *  keys).  For a @c multiset<Key> the key_type and value_type are Key.
   *
   *  Multisets support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for set and
   *  multiset; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  */
  template <typename _Key, typename _Compare = std::less<_Key>,
	    typename _Alloc = std::allocator<_Key> >
    class multiset
    {
      // concept requirements
      typedef typename _Alloc::value_type                   _Alloc_value_type;
      __glibcxx_class_requires(_Key, _SGIAssignableConcept)
      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
				_BinaryFunctionConcept)
      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)	

    public:
      // typedefs:
      typedef _Key     key_type;
      typedef _Key     value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc   allocator_type;

    private:
      /// This turns a red-black tree into a [multi]set.
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
	rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
		       key_compare, _Key_alloc_type> _Rep_type;
      /// The actual tree structure.
      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:
      typedef typename _Alloc_traits::pointer		    pointer;
      typedef typename _Alloc_traits::const_pointer	    const_pointer;
      typedef typename _Alloc_traits::reference		    reference;
      typedef typename _Alloc_traits::const_reference	    const_reference;
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 103. set::iterator is required to be modifiable,
      // but this allows modification of keys.
      typedef typename _Rep_type::const_iterator            iterator;
      typedef typename _Rep_type::const_iterator            const_iterator;
      typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type                 size_type;
      typedef typename _Rep_type::difference_type           difference_type;

      // allocation/deallocation
      /**
       *  @brief  Default constructor creates no elements.
       */
      multiset()
#if __cplusplus >= 201103L
      noexcept(is_nothrow_default_constructible<allocator_type>::value)
#endif
# 144 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      : _M_t() { }

      /**
       *  @brief  Creates a %multiset with no elements.
       *  @param  __comp  Comparator to use.
       *  @param  __a  An allocator object.
       */
      explicit
      multiset(const _Compare& __comp,
	       const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }

      /**
       *  @brief  Builds a %multiset from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %multiset consisting of copies of the elements from
       *  [first,last).  This is linear in N if the range is already sorted,
       *  and NlogN otherwise (where N is distance(__first,__last)).
       */
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
	: _M_t()
        { _M_t._M_insert_equal(__first, __last); }

      /**
       *  @brief  Builds a %multiset from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %multiset consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is already sorted,
       *  and NlogN otherwise (where N is distance(__first,__last)).
       */
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
		 const _Compare& __comp,
		 const allocator_type& __a = allocator_type())
	: _M_t(__comp, _Key_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }

      /**
       *  @brief  %Multiset copy constructor.
       *  @param  __x  A %multiset of identical element and allocator types.
       *
       *  The newly-created %multiset uses a copy of the allocation object used
       *  by @a __x.
       */
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }

#if __cplusplus >= 201103L
     /**
       *  @brief  %Multiset move constructor.
       *  @param  __x  A %multiset of identical element and allocator types.
       *
       *  The newly-created %multiset contains the exact contents of @a __x.
       *  The contents of @a __x are a valid, but unspecified %multiset.
       */
      multiset(multiset&& __x)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _M_t(std::move(__x._M_t)) { }

      /**
       *  @brief  Builds a %multiset from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %multiset consisting of copies of the elements from
       *  the list.  This is linear in N if the list is already sorted,
       *  and NlogN otherwise (where N is @a __l.size()).
       */
      multiset(initializer_list<value_type> __l,
	       const _Compare& __comp = _Compare(),
	       const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }

      /// Allocator-extended default constructor.
      explicit
      multiset(const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a)) { }

      /// Allocator-extended copy constructor.
      multiset(const multiset& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Key_alloc_type(__a)) { }

      /// Allocator-extended move constructor.
      multiset(multiset&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
	       && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Key_alloc_type(__a)) { }

      /// Allocator-extended initialier-list constructor.
      multiset(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Compare(), _Key_alloc_type(__a))
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }

      /// Allocator-extended range constructor.
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
		 const allocator_type& __a)
	: _M_t(_Compare(), _Key_alloc_type(__a))
        { _M_t._M_insert_equal(__first, __last); }
#endif
# 253 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      /**
       *  @brief  %Multiset assignment operator.
       *  @param  __x  A %multiset of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but unlike the copy
       *  constructor, the allocator object is not copied.
       */
      multiset&
      operator=(const multiset& __x)
      {
	_M_t = __x._M_t;
	return *this;
      }

#if __cplusplus >= 201103L
      /// Move assignment operator.
      multiset&
      operator=(multiset&&) = default;

      /**
       *  @brief  %Multiset list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %multiset with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %multiset and
       *  that the resulting %multiset's size is the same as the number
       *  of elements assigned.  Old data may be lost.
       */
      multiset&
      operator=(initializer_list<value_type> __l)
      {
	_M_t._M_assign_equal(__l.begin(), __l.end());
	return *this;
      }
#endif
# 291 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      // accessors:

      ///  Returns the comparison object.
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      ///  Returns the comparison object.
      value_compare
      value_comp() const
      { return _M_t.key_comp(); }
      ///  Returns the memory allocation object.
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_t.get_allocator()); }

      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %multiset.  Iteration is done in ascending order
       *  according to the keys.
       */
      iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %multiset.  Iteration is done in ascending order
       *  according to the keys.
       */
      iterator
      end() const _GLIBCXX_NOEXCEPT
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last element in the %multiset.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last element in the %multiset.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return _M_t.rend(); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %multiset.  Iteration is done in ascending order
       *  according to the keys.
       */
      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }

      /**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %multiset.  Iteration is done in ascending order
       *  according to the keys.
       */
      iterator
      cend() const noexcept
      { return _M_t.end(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last element in the %multiset.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }

      /**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last element in the %multiset.  Iteration is done in descending order
       *  according to the keys.
       */
      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }
#endif
# 380 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      ///  Returns true if the %set is empty.
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return _M_t.empty(); }

      ///  Returns the size of the %set.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_t.size(); }

      ///  Returns the maximum size of the %set.
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _M_t.max_size(); }

      /**
       *  @brief  Swaps data with another %multiset.
       *  @param  __x  A %multiset of the same element and allocator types.
       *
       *  This exchanges the elements between two multisets in constant time.
       *  (It is only swapping a pointer, an integer, and an instance of the @c
       *  Compare type (which itself is often stateless and empty), so it should
       *  be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(s1,s2) will feed to this function.
       */
      void
      swap(multiset& __x)
#if __cplusplus >= 201103L
      noexcept(_Alloc_traits::_S_nothrow_swap())
#endif
# 412 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      { _M_t.swap(__x._M_t); }

      // insert/erase
#if __cplusplus >= 201103L
      /**
       *  @brief Builds and inserts an element into the %multiset.
       *  @param  __args  Arguments used to generate the element instance to be
       *                 inserted.
       *  @return An iterator that points to the inserted element.
       *
       *  This function inserts an element into the %multiset.  Contrary
       *  to a std::set the %multiset does not rely on unique keys and thus
       *  multiple copies of the same element can be inserted.
       *
       *  Insertion requires logarithmic time.
       */
      template<typename... _Args>
	iterator
	emplace(_Args&&... __args)
	{ return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }

      /**
       *  @brief Builds and inserts an element into the %multiset.
       *  @param  __pos  An iterator that serves as a hint as to where the
       *                element should be inserted.
       *  @param  __args  Arguments used to generate the element instance to be
       *                 inserted.
       *  @return An iterator that points to the inserted element.
       *
       *  This function inserts an element into the %multiset.  Contrary
       *  to a std::set the %multiset does not rely on unique keys and thus
       *  multiple copies of the same element can be inserted.
       *
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      template<typename... _Args>
	iterator
	emplace_hint(const_iterator __pos, _Args&&... __args)
	{
	  return _M_t._M_emplace_hint_equal(__pos,
					    std::forward<_Args>(__args)...);
	}
#endif
# 462 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      /**
       *  @brief Inserts an element into the %multiset.
       *  @param  __x  Element to be inserted.
       *  @return An iterator that points to the inserted element.
       *
       *  This function inserts an element into the %multiset.  Contrary
       *  to a std::set the %multiset does not rely on unique keys and thus
       *  multiple copies of the same element can be inserted.
       *
       *  Insertion requires logarithmic time.
       */
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }

#if __cplusplus >= 201103L
      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }
#endif
# 483 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      /**
       *  @brief Inserts an element into the %multiset.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                    element should be inserted.
       *  @param  __x  Element to be inserted.
       *  @return An iterator that points to the inserted element.
       *
       *  This function inserts an element into the %multiset.  Contrary
       *  to a std::set the %multiset does not rely on unique keys and thus
       *  multiple copies of the same element can be inserted.
       *
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       */
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }

#if __cplusplus >= 201103L
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
#endif
# 513 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      /**
       *  @brief A template function that tries to insert a range of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       */
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }

#if __cplusplus >= 201103L
      /**
       *  @brief Attempts to insert a list of elements into the %multiset.
       *  @param  __l  A std::initializer_list<value_type> of elements
       *               to be inserted.
       *
       *  Complexity similar to that of the range constructor.
       */
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
#endif
# 539 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases an element from a %multiset.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a position prior to the element being erased. If no such 
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %multiset.  Note that this function only erases the element,
       *  and that if the element is itself a pointer, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
#else
# 561 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      /**
       *  @brief Erases an element from a %multiset.
       *  @param  __position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %multiset.  Note that this function only erases the element,
       *  and that if the element is itself a pointer, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
#endif
# 575 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      /**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all elements located by the given key from a
       *  %multiset.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       */
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }

#if __cplusplus >= 201103L
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // DR 130. Associative erase should return an iterator.
      /**
       *  @brief Erases a [first,last) range of elements from a %multiset.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a last.
       *
       *  This function erases a sequence of elements from a %multiset.
       *  Note that this function only erases the elements, and that if
       *  the elements themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      _GLIBCXX_ABI_TAG_CXX11
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
#else
# 613 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      /**
       *  @brief Erases a [first,last) range of elements from a %multiset.
       *  @param  first  Iterator pointing to the start of the range to be
       *                 erased.
       *  @param  last  Iterator pointing to the end of the range to be erased.
       *
       *  This function erases a sequence of elements from a %multiset.
       *  Note that this function only erases the elements, and that if
       *  the elements themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
#endif
# 629 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3

      /**
       *  Erases all elements in a %multiset.  Note that this function only
       *  erases the elements, and that if the elements themselves are pointers,
       *  the pointed-to memory is not touched in any way.  Managing the pointer
       *  is the user's responsibility.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      { _M_t.clear(); }

      // multiset operations:

      //@{
      /**
       *  @brief Finds the number of elements with given key.
       *  @param  __x  Key of elements to be located.
       *  @return Number of elements with specified key.
       */
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
	{ return _M_t._M_count_tr(__x); }
#endif
# 658 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      //@}

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 214.  set::find() missing const overload
      //@{
      /**
       *  @brief Tries to locate an element in a %set.
       *  @param  __x  Element to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	find(const _Kt& __x) -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }

      template<typename _Kt>
	auto
	find(const _Kt& __x) const -> decltype(_M_t._M_find_tr(__x))
	{ return _M_t._M_find_tr(__x); }
#endif
# 693 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Iterator pointing to first element equal to or greater
       *           than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       */
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x)
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }

      template<typename _Kt>
	auto
	lower_bound(const _Kt& __x) const
	-> decltype(_M_t._M_lower_bound_tr(__x))
	{ return _M_t._M_lower_bound_tr(__x); }
#endif
# 728 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      //@}

      //@{
      /**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return Iterator pointing to the first element
       *          greater than key, or end().
       */
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x)
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }

      template<typename _Kt>
	auto
	upper_bound(const _Kt& __x) const
	-> decltype(_M_t._M_upper_bound_tr(__x))
	{ return _M_t._M_upper_bound_tr(__x); }
#endif
# 758 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      //@}

      //@{
      /**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multisets.
       */
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

#if __cplusplus > 201103L
      template<typename _Kt>
	auto
	equal_range(const _Kt& __x)
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }

      template<typename _Kt>
	auto
	equal_range(const _Kt& __x) const
	-> decltype(_M_t._M_equal_range_tr(__x))
	{ return _M_t._M_equal_range_tr(__x); }
#endif
# 797 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
      //@}

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
		   const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
		   const multiset<_K1, _C1, _A1>&);
    };

  /**
   *  @brief  Multiset equality comparison.
   *  @param  __x  A %multiset.
   *  @param  __y  A %multiset of the same type as @a __x.
   *  @return  True iff the size and elements of the multisets are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  multisets.
   *  Multisets are considered equivalent if their sizes are equal, and if
   *  corresponding elements compare equal.
  */
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
	       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }

  /**
   *  @brief  Multiset ordering relation.
   *  @param  __x  A %multiset.
   *  @param  __y  A %multiset of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  sets.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
	      const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }

  ///  Returns !(x == y).
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
	       const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  ///  Returns y < x.
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
	      const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }

  ///  Returns !(y < x)
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
	       const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  ///  Returns !(x < y)
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
	       const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  /// See std::multiset::swap().
  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
	 multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif /* _STL_MULTISET_H */
# 883 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_multiset.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/range_access.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3

#ifdef _GLIBCXX_DEBUG
#if 0 /* expanded by -frewrite-includes */
# include <debug/set>
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
#endif
# 68 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3

#ifdef _GLIBCXX_PROFILE
#if 0 /* expanded by -frewrite-includes */
# include <profile/set>
#endif /* expanded by -frewrite-includes */
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
#endif
# 72 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3

#endif /* _GLIBCXX_SET */
# 74 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/set" 3
# 9 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include <stack>
#endif /* expanded by -frewrite-includes */
# 9 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stack" 1 3
// <stack> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/stack
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_STACK
#define _GLIBCXX_STACK 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stack" 3

#if 0 /* expanded by -frewrite-includes */
#include <deque>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stack" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 1 3
// <deque> -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/deque
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_DEQUE
#define _GLIBCXX_DEQUE 1

#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3

#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_algobase.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/allocator.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_construct.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_uninitialized.h>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_deque.h>
#endif /* expanded by -frewrite-includes */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 1 3
// Deque implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_deque.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{deque}
 */

#ifndef _STL_DEQUE_H
#define _STL_DEQUE_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_types.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_iterator_base_funcs.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include <initializer_list>
#endif /* expanded by -frewrite-includes */
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
#endif
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

  /**
   *  @brief This function controls the size of memory nodes.
   *  @param  __size  The size of an element.
   *  @return   The number (not byte size) of elements per node.
   *
   *  This function started off as a compiler kludge from SGI, but
   *  seems to be a useful wrapper around a repeated constant
   *  expression.  The @b 512 is tunable (and no other code needs to
   *  change), but no investigation has been done since inheriting the
   *  SGI code.  Touch _GLIBCXX_DEQUE_BUF_SIZE only if you know what
   *  you are doing, however: changing it breaks the binary
   *  compatibility!!
  */

#ifndef _GLIBCXX_DEQUE_BUF_SIZE
#define _GLIBCXX_DEQUE_BUF_SIZE 512
#endif
# 87 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

  _GLIBCXX_CONSTEXPR inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }


  /**
   *  @brief A deque::iterator.
   *
   *  Quite a bit of intelligence here.  Much of the functionality of
   *  deque is actually passed off to this class.  A deque holds two
   *  of these internally, marking its valid range.  Access to
   *  elements is done as offsets of either of those two, relying on
   *  operator overloading in this class.
   *
   *  All the functions are op overloads except for _M_set_node.
  */
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
#if __cplusplus < 201103L
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
      typedef _Tp*                                         _Elt_pointer;
      typedef _Tp**                                        _Map_pointer;
#else
# 114 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
    private:
      template<typename _Up>
	using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
      template<typename _CvTp>
	using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
    public:
      typedef __iter<_Tp>		iterator;
      typedef __iter<const _Tp>		const_iterator;
      typedef __ptr_to<_Tp>		_Elt_pointer;
      typedef __ptr_to<_Elt_pointer>	_Map_pointer;
#endif
# 125 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp                             value_type;
      typedef _Ptr                            pointer;
      typedef _Ref                            reference;
      typedef size_t                          size_type;
      typedef ptrdiff_t                       difference_type;
      typedef _Deque_iterator                 _Self;

      _Elt_pointer _M_cur;
      _Elt_pointer _M_first;
      _Elt_pointer _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() _GLIBCXX_NOEXCEPT
      : _M_cur(), _M_first(), _M_last(), _M_node() { }

      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const _GLIBCXX_NOEXCEPT
      { return iterator(_M_cur, _M_node); }

      reference
      operator*() const _GLIBCXX_NOEXCEPT
      { return *_M_cur; }

      pointer
      operator->() const _GLIBCXX_NOEXCEPT
      { return _M_cur; }

      _Self&
      operator++() _GLIBCXX_NOEXCEPT
      {
	++_M_cur;
	if (_M_cur == _M_last)
	  {
	    _M_set_node(_M_node + 1);
	    _M_cur = _M_first;
	  }
	return *this;
      }

      _Self
      operator++(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	++*this;
	return __tmp;
      }

      _Self&
      operator--() _GLIBCXX_NOEXCEPT
      {
	if (_M_cur == _M_first)
	  {
	    _M_set_node(_M_node - 1);
	    _M_cur = _M_last;
	  }
	--_M_cur;
	return *this;
      }

      _Self
      operator--(int) _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	--*this;
	return __tmp;
      }

      _Self&
      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
      {
	const difference_type __offset = __n + (_M_cur - _M_first);
	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
	  _M_cur += __n;
	else
	  {
	    const difference_type __node_offset =
	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
	                   : -difference_type((-__offset - 1)
					      / _S_buffer_size()) - 1;
	    _M_set_node(_M_node + __node_offset);
	    _M_cur = _M_first + (__offset - __node_offset
				 * difference_type(_S_buffer_size()));
	  }
	return *this;
      }

      _Self
      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
      {
	_Self __tmp = *this;
	return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
      { return *(*this + __n); }

      /** 
       *  Prepares to traverse new_node.  Sets everything except
       *  _M_cur, which should therefore be set by the caller
       *  immediately afterwards, based on _M_first and _M_last.
       */
      void
      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
      {
	_M_node = __new_node;
	_M_first = *__new_node;
	_M_last = _M_first + difference_type(_S_buffer_size());
      }
    };

  // Note: we also provide overloads whose operands are of the same type in
  // order to avoid ambiguous overload resolution when std::rel_ops operators
  // are in scope (for additional details, see libstdc++/3628)
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
	   typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
	   typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
	   typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
	                                  : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
	   typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
	   typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
	   typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
    { return !(__x < __y); }

  // _GLIBCXX_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
	+ (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
	   typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
	(_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
	+ (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    _GLIBCXX_NOEXCEPT
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
	 const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
	 _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
		       __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
		  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
				const _Tp&, const _Tp*>(__first),
				_Deque_iterator<_Tp,
				const _Tp&, const _Tp*>(__last),
				__result); }

#if __cplusplus >= 201103L
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
	 _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
		       __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
		  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move_backward(_Deque_iterator<_Tp,
				const _Tp&, const _Tp*>(__first),
				_Deque_iterator<_Tp,
				const _Tp&, const _Tp*>(__last),
				__result); }
#endif
# 446 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

  /**
   *  Deque base class.  This class provides the unified face for %deque's
   *  allocation.  This class's constructor and destructor allocate and
   *  deallocate (but do not initialize) storage.  This makes %exception
   *  safety easier.
   *
   *  Nothing in this class ever constructs or destroys an actual Tp element.
   *  (Deque handles that itself.)  Only/All memory management is performed
   *  here.
  */
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
	rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	 _Alloc_traits;

#if __cplusplus < 201103L
      typedef _Tp*					_Ptr;
      typedef const _Tp*				_Ptr_const;
#else
# 469 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      typedef typename _Alloc_traits::pointer		_Ptr;
      typedef typename _Alloc_traits::const_pointer	_Ptr_const;
#endif
# 472 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      typedef typename _Alloc_traits::template rebind<_Ptr>::other
	_Map_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;

    public:
      typedef _Alloc                  allocator_type;
      typedef typename _Alloc_traits::size_type size_type;

      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Ptr>          iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { /* Caller must initialize map. */ }

#if __cplusplus >= 201103L
      _Deque_base(_Deque_base&& __x, false_type)
      : _M_impl(__x._M_move_impl())
      { }

      _Deque_base(_Deque_base&& __x, true_type)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
	_M_initialize_map(0);
	if (__x._M_impl._M_map)
	  this->_M_impl._M_swap_data(__x._M_impl);
      }

      _Deque_base(_Deque_base&& __x)
      : _Deque_base(std::move(__x),
		    __gnu_cxx::__allocator_always_compares_equal<_Alloc>{})
      { }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
      : _M_impl(__a)
      {
	if (__x.get_allocator() == __a)
	  {
	    if (__x._M_impl._M_map)
	      {
		_M_initialize_map(0);
		this->_M_impl._M_swap_data(__x._M_impl);
	      }
	  }
	else
	  {
	    _M_initialize_map(__n);
	  }
      }
#endif
# 539 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      ~_Deque_base() _GLIBCXX_NOEXCEPT;

    protected:
      typedef typename iterator::_Map_pointer _Map_pointer;

      //This struct encapsulates the implementation of the std::deque
      //standard container and at the same time makes use of the EBO
      //for empty allocators.
      struct _Deque_impl
      : public _Tp_alloc_type
      {
	_Map_pointer _M_map;
	size_t _M_map_size;
	iterator _M_start;
	iterator _M_finish;

	_Deque_impl()
	: _Tp_alloc_type(), _M_map(), _M_map_size(0),
	  _M_start(), _M_finish()
	{ }

	_Deque_impl(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
	: _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
	  _M_start(), _M_finish()
	{ }

#if __cplusplus >= 201103L
	_Deque_impl(_Deque_impl&&) = default;

	_Deque_impl(_Tp_alloc_type&& __a) noexcept
	: _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
	  _M_start(), _M_finish()
	{ }
#endif
# 574 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

	void _M_swap_data(_Deque_impl& __x) _GLIBCXX_NOEXCEPT
	{
	  using std::swap;
	  swap(this->_M_start, __x._M_start);
	  swap(this->_M_finish, __x._M_finish);
	  swap(this->_M_map, __x._M_map);
	  swap(this->_M_map_size, __x._M_map_size);
	}
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Ptr
      _M_allocate_node()
      { 
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
      {
	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
      }

      _Map_pointer
      _M_allocate_map(size_t __n)
      {
	_Map_alloc_type __map_alloc = _M_get_map_allocator();
	return _Map_alloc_traits::allocate(__map_alloc, __n);
      }

      void
      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
      {
	_Map_alloc_type __map_alloc = _M_get_map_allocator();
	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
      void _M_destroy_nodes(_Map_pointer __nstart,
			    _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT;
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;

#if __cplusplus >= 201103L
    private:
      _Deque_impl
      _M_move_impl()
      {
	if (!_M_impl._M_map)
	  return std::move(_M_impl);

	// Create a copy of the current allocator.
	_Tp_alloc_type __alloc{_M_get_Tp_allocator()};
	// Put that copy in a moved-from state.
	_Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};
	// Create an empty map that allocates using the moved-from allocator.
	_Deque_base __empty{__alloc};
	// Now safe to modify current allocator and perform non-throwing swaps.
	_Deque_impl __ret{std::move(_M_get_Tp_allocator())};
	_M_impl._M_swap_data(__ret);
	_M_impl._M_swap_data(__empty._M_impl);
	return __ret;
      }
#endif
# 655 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() _GLIBCXX_NOEXCEPT
    {
      if (this->_M_impl._M_map)
	{
	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
			   this->_M_impl._M_finish._M_node + 1);
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
	}
    }

  /**
   *  @brief Layout storage.
   *  @param  __num_elements  The count of T's for which to allocate space
   *                          at first.
   *  @return   Nothing.
   *
   *  The initial underlying memory layout is a bit complicated...
  */
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
				  + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
					   size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);

      // For "small" maps (needing less than _M_map_size nodes), allocation
      // starts in the middle elements and grows outwards.  So nstart may be
      // the beginning of _M_map, but for small maps it may be as far in as
      // _M_map+3.

      _Map_pointer __nstart = (this->_M_impl._M_map
			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Map_pointer __nfinish = __nstart + __num_nodes;

      __try
	{ _M_create_nodes(__nstart, __nfinish); }
      __catch(...)
	{
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
	  this->_M_impl._M_map = _Map_pointer();
	  this->_M_impl._M_map_size = 0;
	  __throw_exception_again;
	}

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
					+ __num_elements
					% __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
    {
      _Map_pointer __cur;
      __try
	{
	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
	    *__cur = this->_M_allocate_node();
	}
      __catch(...)
	{
	  _M_destroy_nodes(__nstart, __cur);
	  __throw_exception_again;
	}
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Map_pointer __nstart,
		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
    {
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
	_M_deallocate_node(*__n);
    }

  /**
   *  @brief  A standard container using fixed-size memory allocation and
   *  constant-time manipulation of elements at either end.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a>.
   *
   *  In previous HP/SGI versions of deque, there was an extra template
   *  parameter so users could control the node size.  This extension turned
   *  out to violate the C++ standard (it can be detected using template
   *  template parameters), and it was removed.
   *
   *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:
   *
   *  - Tp**        _M_map
   *  - size_t      _M_map_size
   *  - iterator    _M_start, _M_finish
   *
   *  map_size is at least 8.  %map is an array of map_size
   *  pointers-to-@a nodes.  (The name %map has nothing to do with the
   *  std::map class, and @b nodes should not be confused with
   *  std::list's usage of @a node.)
   *
   *  A @a node has no specific type name as such, but it is referred
   *  to as @a node in this file.  It is a simple array-of-Tp.  If Tp
   *  is very large, there will be one Tp element per node (i.e., an
   *  @a array of one).  For non-huge Tp's, node size is inversely
   *  related to Tp size: the larger the Tp, the fewer Tp's will fit
   *  in a node.  The goal here is to keep the total size of a node
   *  relatively small and constant over different Tp's, to improve
   *  allocator efficiency.
   *
   *  Not every pointer in the %map array will point to a node.  If
   *  the initial number of elements in the deque is small, the
   *  /middle/ %map pointers will be valid, and the ones at the edges
   *  will be unused.  This same situation will arise as the %map
   *  grows: available %map pointers, if any, will be on the ends.  As
   *  new nodes are created, only a subset of the %map's pointers need
   *  to be copied @a outward.
   *
   *  Class invariants:
   * - For any nonsingular iterator i:
   *    - i.node points to a member of the %map array.  (Yes, you read that
   *      correctly:  i.node does not actually point to a node.)  The member of
   *      the %map array is what actually points to the node.
   *    - i.first == *(i.node)    (This points to the node (first Tp element).)
   *    - i.last  == i.first + node_size
   *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:
   *      the implication of this is that i.cur is always a dereferenceable
   *      pointer, even if i is a past-the-end iterator.
   * - Start and Finish are always nonsingular iterators.  NOTE: this
   * means that an empty deque must have one node, a deque with <N
   * elements (where N is the node buffer size) must have one node, a
   * deque with N through (2N-1) elements must have two nodes, etc.
   * - For every node other than start.node and finish.node, every
   * element in the node is an initialized object.  If start.node ==
   * finish.node, then [start.cur, finish.cur) are initialized
   * objects, and the elements outside that range are uninitialized
   * storage.  Otherwise, [start.cur, start.last) and [finish.first,
   * finish.cur) are initialized objects, and [start.first, start.cur)
   * and [finish.cur, finish.last) are uninitialized storage.
   * - [%map, %map + map_size) is a valid, non-empty range.
   * - [start.node, finish.node] is a valid range contained within
   *   [%map, %map + map_size).
   * - A pointer in the range [%map, %map + map_size) points to an allocated
   *   node if and only if the pointer is in the range
   *   [start.node, finish.node].
   *
   *  Here's the magic:  nothing in deque is @b aware of the discontiguous
   *  storage!
   *
   *  The memory setup and layout occurs in the parent, _Base, and the iterator
   *  class is entirely responsible for @a leaping from one node to the next.
   *  All the implementation routines for deque itself work only through the
   *  start and finish iterators.  This keeps the routines simple and sane,
   *  and we can use other standard algorithms as well.
  */
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {
      // concept requirements
      typedef typename _Alloc::value_type        _Alloc_value_type;
      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)

      typedef _Deque_base<_Tp, _Alloc>			_Base;
      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
      typedef typename _Base::_Alloc_traits		_Alloc_traits;
      typedef typename _Base::_Map_pointer		_Map_pointer;

    public:
      typedef _Tp                                        value_type;
      typedef typename _Alloc_traits::pointer            pointer;
      typedef typename _Alloc_traits::const_pointer      const_pointer;
      typedef typename _Alloc_traits::reference          reference;
      typedef typename _Alloc_traits::const_reference    const_reference;
      typedef typename _Base::iterator                   iterator;
      typedef typename _Base::const_iterator             const_iterator;
      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;
      typedef std::reverse_iterator<iterator>            reverse_iterator;
      typedef size_t                             size_type;
      typedef ptrdiff_t                          difference_type;
      typedef _Alloc                             allocator_type;

    protected:
      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
      { return __deque_buf_size(sizeof(_Tp)); }

      // Functions controlling memory layout, and nothing else.
      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;

      /** 
       *  A total of four data members accumulated down the hierarchy.
       *  May be accessed via _M_impl.*
       */
      using _Base::_M_impl;

    public:
      // [23.2.1.1] construct/copy/destroy
      // (assign() and get_allocator() are also listed in this section)

      /**
       *  @brief  Creates a %deque with no elements.
       */
      deque() : _Base() { }

      /**
       *  @brief  Creates a %deque with no elements.
       *  @param  __a  An allocator object.
       */
      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }

#if __cplusplus >= 201103L
      /**
       *  @brief  Creates a %deque with default constructed elements.
       *  @param  __n  The number of elements to initially create.
       *
       *  This constructor fills the %deque with @a n default
       *  constructed elements.
       */
      explicit
      deque(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_default_initialize(); }

      /**
       *  @brief  Creates a %deque with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %deque with @a __n copies of @a __value.
       */
      deque(size_type __n, const value_type& __value,
	    const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
#else
# 918 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      /**
       *  @brief  Creates a %deque with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %deque with @a __n copies of @a __value.
       */
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
	    const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
#endif
# 932 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  @brief  %Deque copy constructor.
       *  @param  __x  A %deque of identical element and allocator types.
       *
       *  The newly-created %deque uses a copy of the allocation object used
       *  by @a __x.
       */
      deque(const deque& __x)
      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
	      __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(), 
				    this->_M_impl._M_start,
				    _M_get_Tp_allocator()); }

#if __cplusplus >= 201103L
      /**
       *  @brief  %Deque move constructor.
       *  @param  __x  A %deque of identical element and allocator types.
       *
       *  The newly-created %deque contains the exact contents of @a __x.
       *  The contents of @a __x are a valid, but unspecified %deque.
       */
      deque(deque&& __x)
      : _Base(std::move(__x)) { }

      /// Copy constructor with alternative allocator
      deque(const deque& __x, const allocator_type& __a)
      : _Base(__a, __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
				    this->_M_impl._M_start,
				    _M_get_Tp_allocator()); }

      /// Move constructor with alternative allocator
      deque(deque&& __x, const allocator_type& __a)
      : _Base(std::move(__x), __a, __x.size())
      {
	if (__x.get_allocator() != __a)
	  {
	    std::__uninitialized_move_a(__x.begin(), __x.end(),
					this->_M_impl._M_start,
					_M_get_Tp_allocator());
	    __x.clear();
	  }
      }

      /**
       *  @brief  Builds a %deque from an initializer list.
       *  @param  __l  An initializer_list.
       *  @param  __a  An allocator object.
       *
       *  Create a %deque consisting of copies of the elements in the
       *  initializer_list @a __l.
       *
       *  This will call the element type's copy constructor N times
       *  (where N is __l.size()) and do no memory reallocation.
       */
      deque(initializer_list<value_type> __l,
	    const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
	_M_range_initialize(__l.begin(), __l.end(),
			    random_access_iterator_tag());
      }
#endif
# 997 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  @brief  Builds a %deque from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __a  An allocator object.
       *
       *  Create a %deque consisting of copies of the elements from [__first,
       *  __last).
       *
       *  If the iterators are forward, bidirectional, or random-access, then
       *  this will call the elements' copy constructor N times (where N is
       *  distance(__first,__last)) and do no memory reallocation.  But if only
       *  input iterators are used, then this will do at most 2N calls to the
       *  copy constructor, and logN memory reallocations.
       */
#if __cplusplus >= 201103L
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        deque(_InputIterator __first, _InputIterator __last,
	      const allocator_type& __a = allocator_type())
	: _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
#else
# 1021 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
	      const allocator_type& __a = allocator_type())
	: _Base(__a)
        {
	  // Check whether it's an integral type.  If so, it's not an iterator.
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_initialize_dispatch(__first, __last, _Integral());
	}
#endif
# 1031 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       */
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }

      /**
       *  @brief  %Deque assignment operator.
       *  @param  __x  A %deque of identical element and allocator types.
       *
       *  All the elements of @a x are copied, but unlike the copy constructor,
       *  the allocator object is not copied.
       */
      deque&
      operator=(const deque& __x);

#if __cplusplus >= 201103L
      /**
       *  @brief  %Deque move assignment operator.
       *  @param  __x  A %deque of identical element and allocator types.
       *
       *  The contents of @a __x are moved into this deque (without copying,
       *  if the allocators permit it).
       *  @a __x is a valid, but unspecified %deque.
       */
      deque&
      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
      {
	constexpr bool __always_equal = _Alloc_traits::_S_always_equal();
	_M_move_assign1(std::move(__x),
		        integral_constant<bool, __always_equal>());
	return *this;
      }

      /**
       *  @brief  Assigns an initializer list to a %deque.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %deque with copies of the elements in the
       *  initializer_list @a __l.
       *
       *  Note that the assignment completely changes the %deque and that the
       *  resulting %deque's size is the same as the number of elements
       *  assigned.  Old data may be lost.
       */
      deque&
      operator=(initializer_list<value_type> __l)
      {
	this->assign(__l.begin(), __l.end());
	return *this;
      }
#endif
# 1086 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  @brief  Assigns a given value to a %deque.
       *  @param  __n  Number of elements to be assigned.
       *  @param  __val  Value to be assigned.
       *
       *  This function fills a %deque with @a n copies of the given
       *  value.  Note that the assignment completely changes the
       *  %deque and that the resulting %deque's size is the same as
       *  the number of elements assigned.  Old data may be lost.
       */
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }

      /**
       *  @brief  Assigns a range to a %deque.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function fills a %deque with copies of the elements in the
       *  range [__first,__last).
       *
       *  Note that the assignment completely changes the %deque and that the
       *  resulting %deque's size is the same as the number of elements
       *  assigned.  Old data may be lost.
       */
#if __cplusplus >= 201103L
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
#else
# 1120 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_assign_dispatch(__first, __last, _Integral());
	}
#endif
# 1128 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Assigns an initializer list to a %deque.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %deque with copies of the elements in the
       *  initializer_list @a __l.
       *
       *  Note that the assignment completely changes the %deque and that the
       *  resulting %deque's size is the same as the number of elements
       *  assigned.  Old data may be lost.
       */
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }
#endif
# 1145 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /// Get a copy of the memory allocation object.
      allocator_type
      get_allocator() const _GLIBCXX_NOEXCEPT
      { return _Base::get_allocator(); }

      // iterators
      /**
       *  Returns a read/write iterator that points to the first element in the
       *  %deque.  Iteration is done in ordinary element order.
       */
      iterator
      begin() _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_start; }

      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %deque.  Iteration is done in ordinary element order.
       */
      const_iterator
      begin() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_start; }

      /**
       *  Returns a read/write iterator that points one past the last
       *  element in the %deque.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      end() _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_finish; }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %deque.  Iteration is done in
       *  ordinary element order.
       */
      const_iterator
      end() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_finish; }

      /**
       *  Returns a read/write reverse iterator that points to the
       *  last element in the %deque.  Iteration is done in reverse
       *  element order.
       */
      reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last element in the %deque.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      rbegin() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read/write reverse iterator that points to one
       *  before the first element in the %deque.  Iteration is done
       *  in reverse element order.
       */
      reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first element in the %deque.  Iteration is
       *  done in reverse element order.
       */
      const_reverse_iterator
      rend() const _GLIBCXX_NOEXCEPT
      { return const_reverse_iterator(this->_M_impl._M_start); }

#if __cplusplus >= 201103L
      /**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %deque.  Iteration is done in ordinary element order.
       */
      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %deque.  Iteration is done in
       *  ordinary element order.
       */
      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last element in the %deque.  Iteration is done in
       *  reverse element order.
       */
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first element in the %deque.  Iteration is
       *  done in reverse element order.
       */
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }
#endif
# 1258 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      // [23.2.1.2] capacity
      /**  Returns the number of elements in the %deque.  */
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }

      /**  Returns the size() of the largest possible %deque.  */
      size_type
      max_size() const _GLIBCXX_NOEXCEPT
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }

#if __cplusplus >= 201103L
      /**
       *  @brief  Resizes the %deque to the specified number of elements.
       *  @param  __new_size  Number of elements the %deque should contain.
       *
       *  This function will %resize the %deque to the specified
       *  number of elements.  If the number is smaller than the
       *  %deque's current size the %deque is truncated, otherwise
       *  default constructed elements are appended.
       */
      void
      resize(size_type __new_size)
      {
	const size_type __len = size();
	if (__new_size > __len)
	  _M_default_append(__new_size - __len);
	else if (__new_size < __len)
	  _M_erase_at_end(this->_M_impl._M_start
			  + difference_type(__new_size));
      }

      /**
       *  @brief  Resizes the %deque to the specified number of elements.
       *  @param  __new_size  Number of elements the %deque should contain.
       *  @param  __x  Data with which new elements should be populated.
       *
       *  This function will %resize the %deque to the specified
       *  number of elements.  If the number is smaller than the
       *  %deque's current size the %deque is truncated, otherwise the
       *  %deque is extended and new elements are populated with given
       *  data.
       */
      void
      resize(size_type __new_size, const value_type& __x)
      {
	const size_type __len = size();
	if (__new_size > __len)
	  insert(this->_M_impl._M_finish, __new_size - __len, __x);
	else if (__new_size < __len)
	  _M_erase_at_end(this->_M_impl._M_start
			  + difference_type(__new_size));
      }
#else
# 1313 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      /**
       *  @brief  Resizes the %deque to the specified number of elements.
       *  @param  __new_size  Number of elements the %deque should contain.
       *  @param  __x  Data with which new elements should be populated.
       *
       *  This function will %resize the %deque to the specified
       *  number of elements.  If the number is smaller than the
       *  %deque's current size the %deque is truncated, otherwise the
       *  %deque is extended and new elements are populated with given
       *  data.
       */
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
	const size_type __len = size();
	if (__new_size > __len)
	  insert(this->_M_impl._M_finish, __new_size - __len, __x);
	else if (__new_size < __len)
	  _M_erase_at_end(this->_M_impl._M_start
			  + difference_type(__new_size));
      }
#endif
# 1335 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

#if __cplusplus >= 201103L
      /**  A non-binding request to reduce memory use.  */
      void
      shrink_to_fit() noexcept
      { _M_shrink_to_fit(); }
#endif
# 1342 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  Returns true if the %deque is empty.  (Thus begin() would
       *  equal end().)
       */
      bool
      empty() const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }

      // element access
      /**
       *  @brief Subscript access to the data contained in the %deque.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      reference
      operator[](size_type __n) _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_start[difference_type(__n)]; }

      /**
       *  @brief Subscript access to the data contained in the %deque.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      const_reference
      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:
      /// Safety check used only from at().
      void
      _M_range_check(size_type __n) const
      {
	if (__n >= this->size())
	  __throw_out_of_range_fmt(__N("deque::_M_range_check: __n "
				       "(which is %zu)>= this->size() "
				       "(which is %zu)"),
				   __n, this->size());
      }

    public:
      /**
       *  @brief  Provides access to the data contained in the %deque.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter
       *  is first checked that it is in the range of the deque.  The
       *  function throws out_of_range if the check fails.
       */
      reference
      at(size_type __n)
      {
	_M_range_check(__n);
	return (*this)[__n];
      }

      /**
       *  @brief  Provides access to the data contained in the %deque.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is first
       *  checked that it is in the range of the deque.  The function throws
       *  out_of_range if the check fails.
       */
      const_reference
      at(size_type __n) const
      {
	_M_range_check(__n);
	return (*this)[__n];
      }

      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %deque.
       */
      reference
      front() _GLIBCXX_NOEXCEPT
      { return *begin(); }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %deque.
       */
      const_reference
      front() const _GLIBCXX_NOEXCEPT
      { return *begin(); }

      /**
       *  Returns a read/write reference to the data at the last element of the
       *  %deque.
       */
      reference
      back() _GLIBCXX_NOEXCEPT
      {
	iterator __tmp = end();
	--__tmp;
	return *__tmp;
      }

      /**
       *  Returns a read-only (constant) reference to the data at the last
       *  element of the %deque.
       */
      const_reference
      back() const _GLIBCXX_NOEXCEPT
      {
	const_iterator __tmp = end();
	--__tmp;
	return *__tmp;
      }

      // [23.2.1.2] modifiers
      /**
       *  @brief  Add data to the front of the %deque.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the front of the %deque and assigns the given
       *  data to it.  Due to the nature of a %deque this operation
       *  can be done in constant time.
       */
      void
      push_front(const value_type& __x)
      {
	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
	  {
	    _Alloc_traits::construct(this->_M_impl,
	                             this->_M_impl._M_start._M_cur - 1,
	                             __x);
	    --this->_M_impl._M_start._M_cur;
	  }
	else
	  _M_push_front_aux(__x);
      }

#if __cplusplus >= 201103L
      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args);
#endif
# 1504 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  @brief  Add data to the end of the %deque.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %deque and assigns the given data
       *  to it.  Due to the nature of a %deque this operation can be
       *  done in constant time.
       */
      void
      push_back(const value_type& __x)
      {
	if (this->_M_impl._M_finish._M_cur
	    != this->_M_impl._M_finish._M_last - 1)
	  {
	    _Alloc_traits::construct(this->_M_impl,
	                             this->_M_impl._M_finish._M_cur, __x);
	    ++this->_M_impl._M_finish._M_cur;
	  }
	else
	  _M_push_back_aux(__x);
      }

#if __cplusplus >= 201103L
      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
#endif
# 1537 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  @brief  Removes first element.
       *
       *  This is a typical stack operation.  It shrinks the %deque by one.
       *
       *  Note that no data is returned, and if the first element's data is
       *  needed, it should be retrieved before pop_front() is called.
       */
      void
      pop_front() _GLIBCXX_NOEXCEPT
      {
	if (this->_M_impl._M_start._M_cur
	    != this->_M_impl._M_start._M_last - 1)
	  {
	    _Alloc_traits::destroy(this->_M_impl,
	                           this->_M_impl._M_start._M_cur);
	    ++this->_M_impl._M_start._M_cur;
	  }
	else
	  _M_pop_front_aux();
      }

      /**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation.  It shrinks the %deque by one.
       *
       *  Note that no data is returned, and if the last element's data is
       *  needed, it should be retrieved before pop_back() is called.
       */
      void
      pop_back() _GLIBCXX_NOEXCEPT
      {
	if (this->_M_impl._M_finish._M_cur
	    != this->_M_impl._M_finish._M_first)
	  {
	    --this->_M_impl._M_finish._M_cur;
	    _Alloc_traits::destroy(this->_M_impl,
	                           this->_M_impl._M_finish._M_cur);
	  }
	else
	  _M_pop_back_aux();
      }

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts an object in %deque before specified iterator.
       *  @param  __position  A const_iterator into the %deque.
       *  @param  __args  Arguments.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert an object of type T constructed
       *  with T(std::forward<Args>(args)...) before the specified location.
       */
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);

      /**
       *  @brief  Inserts given value into %deque before specified iterator.
       *  @param  __position  A const_iterator into the %deque.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before the
       *  specified location.
       */
      iterator
      insert(const_iterator __position, const value_type& __x);
#else
# 1608 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      /**
       *  @brief  Inserts given value into %deque before specified iterator.
       *  @param  __position  An iterator into the %deque.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before the
       *  specified location.
       */
      iterator
      insert(iterator __position, const value_type& __x);
#endif
# 1620 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts given rvalue into %deque before specified iterator.
       *  @param  __position  A const_iterator into the %deque.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given rvalue before the
       *  specified location.
       */
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }

      /**
       *  @brief  Inserts an initializer list into the %deque.
       *  @param  __p  An iterator into the %deque.
       *  @param  __l  An initializer_list.
       *
       *  This function will insert copies of the data in the
       *  initializer_list @a __l into the %deque before the location
       *  specified by @a __p.  This is known as <em>list insert</em>.
       */
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
#endif
# 1648 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts a number of copies of given data into the %deque.
       *  @param  __position  A const_iterator into the %deque.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a specified number of copies of the given
       *  data before the location specified by @a __position.
       */
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
	difference_type __offset = __position - cbegin();
	_M_fill_insert(__position._M_const_cast(), __n, __x);
	return begin() + __offset;
      }
#else
# 1668 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      /**
       *  @brief  Inserts a number of copies of given data into the %deque.
       *  @param  __position  An iterator into the %deque.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *
       *  This function will insert a specified number of copies of the given
       *  data before the location specified by @a __position.
       */
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
#endif
# 1681 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

#if __cplusplus >= 201103L
      /**
       *  @brief  Inserts a range into the %deque.
       *  @param  __position  A const_iterator into the %deque.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %deque before the location specified
       *  by @a __position.  This is known as <em>range insert</em>.
       */
      template<typename _InputIterator,
	       typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
	       _InputIterator __last)
        {
	  difference_type __offset = __position - cbegin();
	  _M_insert_dispatch(__position._M_const_cast(),
			     __first, __last, __false_type());
	  return begin() + __offset;
	}
#else
# 1706 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      /**
       *  @brief  Inserts a range into the %deque.
       *  @param  __position  An iterator into the %deque.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %deque before the location specified
       *  by @a __position.  This is known as <em>range insert</em>.
       */
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
	       _InputIterator __last)
        {
	  // Check whether it's an integral type.  If so, it's not an iterator.
	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
	  _M_insert_dispatch(__position, __first, __last, _Integral());
	}
#endif
# 1726 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      /**
       *  @brief  Remove element at given position.
       *  @param  __position  Iterator pointing to element to be erased.
       *  @return  An iterator pointing to the next element (or end()).
       *
       *  This function will erase the element at the given position and thus
       *  shorten the %deque by one.
       *
       *  The user is cautioned that
       *  this function only erases the element, and that if the element is
       *  itself a pointer, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       */
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __position)
#else
# 1744 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      erase(iterator __position)
#endif
# 1746 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      { return _M_erase(__position._M_const_cast()); }

      /**
       *  @brief  Remove a range of elements.
       *  @param  __first  Iterator pointing to the first element to be erased.
       *  @param  __last  Iterator pointing to one past the last element to be
       *                erased.
       *  @return  An iterator pointing to the element pointed to by @a last
       *           prior to erasing (or end()).
       *
       *  This function will erase the elements in the range
       *  [__first,__last) and shorten the %deque accordingly.
       *
       *  The user is cautioned that
       *  this function only erases the elements, and that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       */
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __first, const_iterator __last)
#else
# 1768 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      erase(iterator __first, iterator __last)
#endif
# 1770 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      /**
       *  @brief  Swaps data with another %deque.
       *  @param  __x  A %deque of the same element and allocator types.
       *
       *  This exchanges the elements between two deques in constant time.
       *  (Four pointers, so it should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(d1,d2) will feed to this function.
       */
      void
      swap(deque& __x)
#if __cplusplus >= 201103L
      noexcept(_Alloc_traits::_S_nothrow_swap())
#endif
# 1786 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      {
	_M_impl._M_swap_data(__x._M_impl);
	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
				  __x._M_get_Tp_allocator());
      }

      /**
       *  Erases all the elements.  Note that this function only erases the
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       */
      void
      clear() _GLIBCXX_NOEXCEPT
      { _M_erase_at_end(begin()); }

    protected:
      // Internal constructor functions follow.

      // called by the range constructor to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
	  _M_initialize_map(static_cast<size_type>(__n));
	  _M_fill_initialize(__x);
	}

      // called by the range constructor to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
			       __false_type)
        {
	  typedef typename std::iterator_traits<_InputIterator>::
	    iterator_category _IterCategory;
	  _M_range_initialize(__first, __last, _IterCategory());
	}

      // called by the second initialize_dispatch above
      //@{
      /**
       *  @brief Fills the deque with whatever is in [first,last).
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @return   Nothing.
       *
       *  If the iterators are actually forward iterators (or better), then the
       *  memory layout can be done all at once.  Else we move forward using
       *  push_back on each value from the iterator.
       */
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
			    std::input_iterator_tag);

      // called by the second initialize_dispatch above
      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
			    std::forward_iterator_tag);
      //@}

      /**
       *  @brief Fills the %deque with copies of value.
       *  @param  __value  Initial value.
       *  @return   Nothing.
       *  @pre _M_start and _M_finish have already been initialized,
       *  but none of the %deque's elements have yet been constructed.
       *
       *  This function is called only when the user provides an explicit size
       *  (with or without an explicit exemplar value).
       */
      void
      _M_fill_initialize(const value_type& __value);

#if __cplusplus >= 201103L
      // called by deque(n).
      void
      _M_default_initialize();
#endif
# 1870 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      // Internal assign functions follow.  The *_aux functions do the actual
      // assignment work for the range versions.

      // called by the range assign to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }

      // called by the range assign to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
			   __false_type)
        {
	  typedef typename std::iterator_traits<_InputIterator>::
	    iterator_category _IterCategory;
	  _M_assign_aux(__first, __last, _IterCategory());
	}

      // called by the second assign_dispatch above
      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
		      std::input_iterator_tag);

      // called by the second assign_dispatch above
      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
		      std::forward_iterator_tag)
        {
	  const size_type __len = std::distance(__first, __last);
	  if (__len > size())
	    {
	      _ForwardIterator __mid = __first;
	      std::advance(__mid, size());
	      std::copy(__first, __mid, begin());
	      insert(end(), __mid, __last);
	    }
	  else
	    _M_erase_at_end(std::copy(__first, __last, begin()));
	}

      // Called by assign(n,t), and the range assign when it turns out
      // to be the same thing.
      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
	if (__n > size())
	  {
	    std::fill(begin(), end(), __val);
	    insert(end(), __n - size(), __val);
	  }
	else
	  {
	    _M_erase_at_end(begin() + difference_type(__n));
	    std::fill(begin(), end(), __val);
	  }
      }

      //@{
      /// Helper functions for push_* and pop_*.
#if __cplusplus < 201103L
      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);
#else
# 1942 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
        void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
        void _M_push_front_aux(_Args&&... __args);
#endif
# 1948 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      void _M_pop_back_aux();

      void _M_pop_front_aux();
      //@}

      // Internal insert functions follow.  The *_aux functions do the actual
      // insertion work when all shortcuts fail.

      // called by the range insert to implement [23.1.1]/9

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 438. Ambiguity in the "do the right thing" clause
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
			   _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }

      // called by the range insert to implement [23.1.1]/9
      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
			   _InputIterator __first, _InputIterator __last,
			   __false_type)
        {
	  typedef typename std::iterator_traits<_InputIterator>::
	    iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
	}

      // called by the second insert_dispatch above
      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
			    _InputIterator __last, std::input_iterator_tag);

      // called by the second insert_dispatch above
      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
			    _ForwardIterator __last, std::forward_iterator_tag);

      // Called by insert(p,n,x), and the range insert when it turns out to be
      // the same thing.  Can use fill functions in optimal situations,
      // otherwise passes off to insert_aux(p,n,x).
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);

      // called by insert(p,x)
#if __cplusplus < 201103L
      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);
#else
# 2002 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
        iterator
        _M_insert_aux(iterator __pos, _Args&&... __args);
#endif
# 2006 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      // called by insert(p,n,x) via fill_insert
      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);

      // called by range_insert_aux for forward iterators
      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
		      _ForwardIterator __first, _ForwardIterator __last,
		      size_type __n);


      // Internal erase functions follow.

      void
      _M_destroy_data_aux(iterator __first, iterator __last);

      // Called by ~deque().
      // NB: Doesn't deallocate the nodes.
      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
		      const std::allocator<_Tp>&)
      {
	if (!__has_trivial_destructor(value_type))
	  _M_destroy_data_aux(__first, __last);
      }

      // Called by erase(q1, q2).
      void
      _M_erase_at_begin(iterator __pos)
      {
	_M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
	_M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
	this->_M_impl._M_start = __pos;
      }

      // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
      // _M_fill_assign, operator=.
      void
      _M_erase_at_end(iterator __pos)
      {
	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
	_M_destroy_nodes(__pos._M_node + 1,
			 this->_M_impl._M_finish._M_node + 1);
	this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);

#if __cplusplus >= 201103L
      // Called by resize(sz).
      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
#endif
# 2073 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3

      //@{
      /// Memory-handling helpers for the previous internal insert functions.
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
	const size_type __vacancies = this->_M_impl._M_start._M_cur
	                              - this->_M_impl._M_start._M_first;
	if (__n > __vacancies)
	  _M_new_elements_at_front(__n - __vacancies);
	return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
	const size_type __vacancies = (this->_M_impl._M_finish._M_last
				       - this->_M_impl._M_finish._M_cur) - 1;
	if (__n > __vacancies)
	  _M_new_elements_at_back(__n - __vacancies);
	return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
      //@}


      //@{
      /**
       *  @brief Memory-handling helpers for the major %map.
       *
       *  Makes sure the _M_map has space for new nodes.  Does not
       *  actually add the nodes.  Can invalidate _M_map pointers.
       *  (And consequently, %deque iterators.)
       */
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
	  _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
	if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
				       - this->_M_impl._M_map))
	  _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
      //@}

#if __cplusplus >= 201103L
      // Constant-time, nothrow move assignment when source object's memory
      // can be moved because the allocators are equal.
      void
      _M_move_assign1(deque&& __x, /* always equal: */ true_type) noexcept
      {
	this->_M_impl._M_swap_data(__x._M_impl);
	__x.clear();
	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }

      void
      _M_move_assign1(deque&& __x, /* always equal: */ false_type)
      {
	constexpr bool __move_storage =
	  _Alloc_traits::_S_propagate_on_move_assign();
	_M_move_assign2(std::move(__x),
			integral_constant<bool, __move_storage>());
      }

      // Destroy all elements and deallocate all memory, then replace
      // with elements created from __args.
      template<typename... _Args>
      void
      _M_replace_map(_Args&&... __args)
      {
	// Create new data first, so if allocation fails there are no effects.
	deque __newobj(std::forward<_Args>(__args)...);
	// Free existing storage using existing allocator.
	clear();
	_M_deallocate_node(*begin()._M_node); // one node left after clear()
	_M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
	this->_M_impl._M_map = nullptr;
	this->_M_impl._M_map_size = 0;
	// Take ownership of replacement memory.
	this->_M_impl._M_swap_data(__newobj._M_impl);
      }

      // Do move assignment when the allocator propagates.
      void
      _M_move_assign2(deque&& __x, /* propagate: */ true_type)
      {
	// Make a copy of the original allocator state.
	auto __alloc = __x._M_get_Tp_allocator();
	// The allocator propagates so storage can be moved from __x,
	// leaving __x in a valid empty state with a moved-from allocator.
	_M_replace_map(std::move(__x));
	// Move the corresponding allocator state too.
	_M_get_Tp_allocator() = std::move(__alloc);
      }

      // Do move assignment when it may not be possible to move source
      // object's memory, resulting in a linear-time operation.
      void
      _M_move_assign2(deque&& __x, /* propagate: */ false_type)
      {
	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
	  {
	    // The allocators are equal so storage can be moved from __x,
	    // leaving __x in a valid empty state with its current allocator.
	    _M_replace_map(std::move(__x), __x.get_allocator());
	  }
	else
	  {
	    // The rvalue's allocator cannot be moved and is not equal,
	    // so we need to individually move each element.
	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
			 std::__make_move_if_noexcept_iterator(__x.end()));
	    __x.clear();
	  }
      }
#endif
# 2204 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
    };


  /**
   *  @brief  Deque equality comparison.
   *  @param  __x  A %deque.
   *  @param  __y  A %deque of the same type as @a __x.
   *  @return  True iff the size and elements of the deques are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  deques.  Deques are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  */
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }

  /**
   *  @brief  Deque ordering relation.
   *  @param  __x  A %deque.
   *  @param  __y  A %deque of the same type as @a __x.
   *  @return  True iff @a x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  deques.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  */
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
	      const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
					  __y.begin(), __y.end()); }

  /// Based on operator==
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
	       const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
	      const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
	       const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }

  /// Based on operator<
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
	       const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }

  /// See std::deque::swap().
  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }

#undef _GLIBCXX_DEQUE_BUF_SIZE

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif /* _STL_DEQUE_H */
# 2282 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_deque.h" 3
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/range_access.h>
#endif /* expanded by -frewrite-includes */
# 65 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/deque.tcc>
#endif /* expanded by -frewrite-includes */
# 66 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 1 3
// Deque implementation (out of line) -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/deque.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{deque}
 */

#ifndef _DEQUE_TCC
#define _DEQUE_TCC 1

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_CONTAINER

#if __cplusplus >= 201103L
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_initialize()
    {
      _Map_pointer __cur;
      __try
        {
          for (__cur = this->_M_impl._M_start._M_node;
	       __cur < this->_M_impl._M_finish._M_node;
	       ++__cur)
            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
					   _M_get_Tp_allocator());
          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
					 this->_M_impl._M_finish._M_cur,
					 _M_get_Tp_allocator());
        }
      __catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
			_M_get_Tp_allocator());
          __throw_exception_again;
        }
    }
#endif
# 89 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      if (&__x != this)
	{
#if __cplusplus >= 201103L
	  if (_Alloc_traits::_S_propagate_on_copy_assign())
	    {
	      if (!_Alloc_traits::_S_always_equal()
	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
	        {
		  // Replacement allocator cannot free existing storage,
		  // so deallocate everything and take copy of __x's data.
		  _M_replace_map(__x, __x.get_allocator());
		  std::__alloc_on_copy(_M_get_Tp_allocator(),
				       __x._M_get_Tp_allocator());
		  return *this;
		}
	      std::__alloc_on_copy(_M_get_Tp_allocator(),
				   __x._M_get_Tp_allocator());
	    }
#endif
# 114 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
	  const size_type __len = size();
	  if (__len >= __x.size())
	    _M_erase_at_end(std::copy(__x.begin(), __x.end(),
				      this->_M_impl._M_start));
	  else
	    {
	      const_iterator __mid = __x.begin() + difference_type(__len);
	      std::copy(__x.begin(), __mid, this->_M_impl._M_start);
	      insert(this->_M_impl._M_finish, __mid, __x.end());
	    }
	}
      return *this;
    }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
	  {
	    _Alloc_traits::construct(this->_M_impl,
	                             this->_M_impl._M_start._M_cur - 1,
			             std::forward<_Args>(__args)...);
	    --this->_M_impl._M_start._M_cur;
	  }
	else
	  _M_push_front_aux(std::forward<_Args>(__args)...);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
	if (this->_M_impl._M_finish._M_cur
	    != this->_M_impl._M_finish._M_last - 1)
	  {
	    _Alloc_traits::construct(this->_M_impl,
	                             this->_M_impl._M_finish._M_cur,
			             std::forward<_Args>(__args)...);
	    ++this->_M_impl._M_finish._M_cur;
	  }
	else
	  _M_push_back_aux(std::forward<_Args>(__args)...);
      }
#endif
# 164 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
	if (__position._M_cur == this->_M_impl._M_start._M_cur)
	  {
	    emplace_front(std::forward<_Args>(__args)...);
	    return this->_M_impl._M_start;
	  }
	else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
	  {
	    emplace_back(std::forward<_Args>(__args)...);
	    iterator __tmp = this->_M_impl._M_finish;
	    --__tmp;
	    return __tmp;
	  }
	else
	  return _M_insert_aux(__position._M_const_cast(),
			       std::forward<_Args>(__args)...);
      }
#endif
# 189 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
#if __cplusplus >= 201103L
    insert(const_iterator __position, const value_type& __x)
#else
# 196 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
    insert(iterator __position, const value_type& __x)
#endif
# 198 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
	{
	  push_front(__x);
	  return this->_M_impl._M_start;
	}
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
	{
	  push_back(__x);
	  iterator __tmp = this->_M_impl._M_finish;
	  --__tmp;
	  return __tmp;
	}
      else
	return _M_insert_aux(__position._M_const_cast(), __x);
   }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
	{
	  if (__position != begin())
	    _GLIBCXX_MOVE_BACKWARD3(begin(), __position, __next);
	  pop_front();
	}
      else
	{
	  if (__next != end())
	    _GLIBCXX_MOVE3(__next, end(), __position);
	  pop_back();
	}
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first == __last)
	return __first;
      else if (__first == begin() && __last == end())
	{
	  clear();
	  return end();
	}
      else
	{
	  const difference_type __n = __last - __first;
	  const difference_type __elems_before = __first - begin();
	  if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
	    {
	      if (__first != begin())
		_GLIBCXX_MOVE_BACKWARD3(begin(), __first, __last);
	      _M_erase_at_begin(begin() + __n);
	    }
	  else
	    {
	      if (__last != end())
		_GLIBCXX_MOVE3(__last, end(), __first);
	      _M_erase_at_end(end() - __n);
	    }
	  return begin() + __elems_before;
	}
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
		    std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
	{
	  iterator __new_start = _M_reserve_elements_at_front(__n);
	  __try
	    {
	      std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
					  __x, _M_get_Tp_allocator());
	      this->_M_impl._M_start = __new_start;
	    }
	  __catch(...)
	    {
	      _M_destroy_nodes(__new_start._M_node,
			       this->_M_impl._M_start._M_node);
	      __throw_exception_again;
	    }
	}
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
	{
	  iterator __new_finish = _M_reserve_elements_at_back(__n);
	  __try
	    {
	      std::__uninitialized_fill_a(this->_M_impl._M_finish,
					  __new_finish, __x,
					  _M_get_Tp_allocator());
	      this->_M_impl._M_finish = __new_finish;
	    }
	  __catch(...)
	    {
	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
			       __new_finish._M_node + 1);
	      __throw_exception_again;
	    }
	}
      else
        _M_insert_aux(__pos, __n, __x);
    }

#if __cplusplus >= 201103L
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n)
	{
	  iterator __new_finish = _M_reserve_elements_at_back(__n);
	  __try
	    {
	      std::__uninitialized_default_a(this->_M_impl._M_finish,
					     __new_finish,
					     _M_get_Tp_allocator());
	      this->_M_impl._M_finish = __new_finish;
	    }
	  __catch(...)
	    {
	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
			       __new_finish._M_node + 1);
	      __throw_exception_again;
	    }
	}
    }

  template <typename _Tp, typename _Alloc>
    bool
    deque<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      const difference_type __front_capacity
	= (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
      if (__front_capacity == 0)
	return false;

      const difference_type __back_capacity
	= (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
      if (__front_capacity + __back_capacity < _S_buffer_size())
	return false;

      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
    }
#endif
# 371 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      __try
        {
          for (__cur = this->_M_impl._M_start._M_node;
	       __cur < this->_M_impl._M_finish._M_node;
	       ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
					__value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
				      this->_M_impl._M_finish._M_cur,
				      __value, _M_get_Tp_allocator());
        }
      __catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
			_M_get_Tp_allocator());
          __throw_exception_again;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        __try
          {
            for (; __first != __last; ++__first)
#if __cplusplus >= 201103L
	      emplace_back(*__first);
#else
# 411 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
              push_back(*__first);
#endif
# 413 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
          }
        __catch(...)
          {
            clear();
            __throw_exception_again;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        __try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
	      {
		_ForwardIterator __mid = __first;
		std::advance(__mid, _S_buffer_size());
		std::__uninitialized_copy_a(__first, __mid, *__cur_node,
					    _M_get_Tp_allocator());
		__first = __mid;
	      }
            std::__uninitialized_copy_a(__first, __last,
					this->_M_impl._M_finish._M_first,
					_M_get_Tp_allocator());
          }
        __catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
			  iterator(*__cur_node, __cur_node),
			  _M_get_Tp_allocator());
            __throw_exception_again;
          }
      }

  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.
  template<typename _Tp, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)
#else
# 465 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)
#endif
# 469 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
      {
	_M_reserve_map_at_back();
	*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
	__try
	  {
#if __cplusplus >= 201103L
	    _Alloc_traits::construct(this->_M_impl,
	                             this->_M_impl._M_finish._M_cur,
			             std::forward<_Args>(__args)...);
#else
# 479 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
#endif
# 481 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
						+ 1);
	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
	  }
	__catch(...)
	  {
	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
	    __throw_exception_again;
	  }
      }

  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_first.
  template<typename _Tp, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)
#else
# 500 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(const value_type& __t)
#endif
# 504 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
      {
	_M_reserve_map_at_front();
	*(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
	__try
	  {
	    this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
					       - 1);
	    this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
#if __cplusplus >= 201103L
	    _Alloc_traits::construct(this->_M_impl,
	                             this->_M_impl._M_start._M_cur,
			             std::forward<_Args>(__args)...);
#else
# 517 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
	    this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);
#endif
# 519 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
	  }
	__catch(...)
	  {
	    ++this->_M_impl._M_start;
	    _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
	    __throw_exception_again;
	  }
      }

  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_first.
  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
			     this->_M_impl._M_finish._M_cur);
    }

  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.
  // Note that if the deque has at least one element (a precondition for this
  // member function), and if
  //   _M_impl._M_start._M_cur == _M_impl._M_start._M_last,
  // then the deque must have at least two nodes.
  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
			     this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
	  {
	    iterator __new_start = _M_reserve_elements_at_front(__n);
	    __try
	      {
		std::__uninitialized_copy_a(__first, __last, __new_start,
					    _M_get_Tp_allocator());
		this->_M_impl._M_start = __new_start;
	      }
	    __catch(...)
	      {
		_M_destroy_nodes(__new_start._M_node,
				 this->_M_impl._M_start._M_node);
		__throw_exception_again;
	      }
	  }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
	  {
	    iterator __new_finish = _M_reserve_elements_at_back(__n);
	    __try
	      {
		std::__uninitialized_copy_a(__first, __last,
					    this->_M_impl._M_finish,
					    _M_get_Tp_allocator());
		this->_M_impl._M_finish = __new_finish;
	      }
	    __catch(...)
	      {
		_M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
				 __new_finish._M_node + 1);
		__throw_exception_again;
	      }
	  }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>
#if __cplusplus >= 201103L
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
	value_type __x_copy(std::forward<_Args>(__args)...); // XXX copy
#else
# 620 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
    typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, const value_type& __x)
      {
	value_type __x_copy = __x; // XXX copy
#endif
# 626 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
	difference_type __index = __pos - this->_M_impl._M_start;
	if (static_cast<size_type>(__index) < size() / 2)
	  {
	    push_front(_GLIBCXX_MOVE(front()));
	    iterator __front1 = this->_M_impl._M_start;
	    ++__front1;
	    iterator __front2 = __front1;
	    ++__front2;
	    __pos = this->_M_impl._M_start + __index;
	    iterator __pos1 = __pos;
	    ++__pos1;
	    _GLIBCXX_MOVE3(__front2, __pos1, __front1);
	  }
	else
	  {
	    push_back(_GLIBCXX_MOVE(back()));
	    iterator __back1 = this->_M_impl._M_finish;
	    --__back1;
	    iterator __back2 = __back1;
	    --__back2;
	    __pos = this->_M_impl._M_start + __index;
	    _GLIBCXX_MOVE_BACKWARD3(__pos, __back2, __back1);
	  }
	*__pos = _GLIBCXX_MOVE(__x_copy);
	return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
	{
	  iterator __new_start = _M_reserve_elements_at_front(__n);
	  iterator __old_start = this->_M_impl._M_start;
	  __pos = this->_M_impl._M_start + __elems_before;
	  __try
	    {
	      if (__elems_before >= difference_type(__n))
		{
		  iterator __start_n = (this->_M_impl._M_start
					+ difference_type(__n));
		  std::__uninitialized_move_a(this->_M_impl._M_start,
					      __start_n, __new_start,
					      _M_get_Tp_allocator());
		  this->_M_impl._M_start = __new_start;
		  _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
		  std::fill(__pos - difference_type(__n), __pos, __x_copy);
		}
	      else
		{
		  std::__uninitialized_move_fill(this->_M_impl._M_start,
						 __pos, __new_start,
						 this->_M_impl._M_start,
						 __x_copy,
						 _M_get_Tp_allocator());
		  this->_M_impl._M_start = __new_start;
		  std::fill(__old_start, __pos, __x_copy);
		}
	    }
	  __catch(...)
	    {
	      _M_destroy_nodes(__new_start._M_node,
			       this->_M_impl._M_start._M_node);
	      __throw_exception_again;
	    }
	}
      else
	{
	  iterator __new_finish = _M_reserve_elements_at_back(__n);
	  iterator __old_finish = this->_M_impl._M_finish;
	  const difference_type __elems_after =
	    difference_type(__length) - __elems_before;
	  __pos = this->_M_impl._M_finish - __elems_after;
	  __try
	    {
	      if (__elems_after > difference_type(__n))
		{
		  iterator __finish_n = (this->_M_impl._M_finish
					 - difference_type(__n));
		  std::__uninitialized_move_a(__finish_n,
					      this->_M_impl._M_finish,
					      this->_M_impl._M_finish,
					      _M_get_Tp_allocator());
		  this->_M_impl._M_finish = __new_finish;
		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
		  std::fill(__pos, __pos + difference_type(__n), __x_copy);
		}
	      else
		{
		  std::__uninitialized_fill_move(this->_M_impl._M_finish,
						 __pos + difference_type(__n),
						 __x_copy, __pos,
						 this->_M_impl._M_finish,
						 _M_get_Tp_allocator());
		  this->_M_impl._M_finish = __new_finish;
		  std::fill(__pos, __old_finish, __x_copy);
		}
	    }
	  __catch(...)
	    {
	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
			       __new_finish._M_node + 1);
	      __throw_exception_again;
	    }
	}
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
	  {
	    iterator __new_start = _M_reserve_elements_at_front(__n);
	    iterator __old_start = this->_M_impl._M_start;
	    __pos = this->_M_impl._M_start + __elemsbefore;
	    __try
	      {
		if (__elemsbefore >= difference_type(__n))
		  {
		    iterator __start_n = (this->_M_impl._M_start
					  + difference_type(__n));
		    std::__uninitialized_move_a(this->_M_impl._M_start,
						__start_n, __new_start,
						_M_get_Tp_allocator());
		    this->_M_impl._M_start = __new_start;
		    _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
		    std::copy(__first, __last, __pos - difference_type(__n));
		  }
		else
		  {
		    _ForwardIterator __mid = __first;
		    std::advance(__mid, difference_type(__n) - __elemsbefore);
		    std::__uninitialized_move_copy(this->_M_impl._M_start,
						   __pos, __first, __mid,
						   __new_start,
						   _M_get_Tp_allocator());
		    this->_M_impl._M_start = __new_start;
		    std::copy(__mid, __last, __old_start);
		  }
	      }
	    __catch(...)
	      {
		_M_destroy_nodes(__new_start._M_node,
				 this->_M_impl._M_start._M_node);
		__throw_exception_again;
	      }
	  }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          __try
            {
              if (__elemsafter > difference_type(__n))
		{
		  iterator __finish_n = (this->_M_impl._M_finish
					 - difference_type(__n));
		  std::__uninitialized_move_a(__finish_n,
					      this->_M_impl._M_finish,
					      this->_M_impl._M_finish,
					      _M_get_Tp_allocator());
		  this->_M_impl._M_finish = __new_finish;
		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
		  std::copy(__first, __last, __pos);
		}
              else
		{
		  _ForwardIterator __mid = __first;
		  std::advance(__mid, __elemsafter);
		  std::__uninitialized_copy_move(__mid, __last, __pos,
						 this->_M_impl._M_finish,
						 this->_M_impl._M_finish,
						 _M_get_Tp_allocator());
		  this->_M_impl._M_finish = __new_finish;
		  std::copy(__first, __mid, __pos);
		}
            }
          __catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
			       __new_finish._M_node + 1);
              __throw_exception_again;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
	    __node < __last._M_node; ++__node)
	 std::_Destroy(*__node, *__node + _S_buffer_size(),
		       _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
	 {
	   std::_Destroy(__first._M_cur, __first._M_last,
			 _M_get_Tp_allocator());
	   std::_Destroy(__last._M_first, __last._M_cur,
			 _M_get_Tp_allocator());
	 }
       else
	 std::_Destroy(__first._M_cur, __last._M_cur,
		       _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
	__throw_length_error(__N("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
				     / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      __try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      __catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          __throw_exception_again;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
	__throw_length_error(__N("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
				     / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      __try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      __catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          __throw_exception_again;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
	{
	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
					 - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
	  if (__new_nstart < this->_M_impl._M_start._M_node)
	    std::copy(this->_M_impl._M_start._M_node,
		      this->_M_impl._M_finish._M_node + 1,
		      __new_nstart);
	  else
	    std::copy_backward(this->_M_impl._M_start._M_node,
			       this->_M_impl._M_finish._M_node + 1,
			       __new_nstart + __old_num_nodes);
	}
      else
	{
	  size_type __new_map_size = this->_M_impl._M_map_size
	                             + std::max(this->_M_impl._M_map_size,
						__nodes_to_add) + 2;

	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
	                 + (__add_at_front ? __nodes_to_add : 0);
	  std::copy(this->_M_impl._M_start._M_node,
		    this->_M_impl._M_finish._M_node + 1,
		    __new_nstart);
	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

	  this->_M_impl._M_map = __new_map;
	  this->_M_impl._M_map_size = __new_map_size;
	}

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }

  // Overload for deque::iterators, exploiting the "segmented-iterator
  // optimization".
  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
	 const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
	std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
	{
	  std::fill(__first._M_cur, __first._M_last, __value);
	  std::fill(__last._M_first, __last._M_cur, __value);
	}
      else
	std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
	{
	  const difference_type __clen
	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
				       __result._M_last - __result._M_cur));
	  std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
	  __first += __clen;
	  __result += __clen;
	  __len -= __clen;
	}
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
	{
	  difference_type __llen = __last._M_cur - __last._M_first;
	  _Tp* __lend = __last._M_cur;

	  difference_type __rlen = __result._M_cur - __result._M_first;
	  _Tp* __rend = __result._M_cur;

	  if (!__llen)
	    {
	      __llen = _Self::_S_buffer_size();
	      __lend = *(__last._M_node - 1) + __llen;
	    }
	  if (!__rlen)
	    {
	      __rlen = _Self::_S_buffer_size();
	      __rend = *(__result._M_node - 1) + __rlen;
	    }

	  const difference_type __clen = std::min(__len,
						  std::min(__llen, __rlen));
	  std::copy_backward(__lend - __clen, __lend, __rend);
	  __last -= __clen;
	  __result -= __clen;
	  __len -= __clen;
	}
      return __result;
    }

#if __cplusplus >= 201103L
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
	{
	  const difference_type __clen
	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
				       __result._M_last - __result._M_cur));
	  std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
	  __first += __clen;
	  __result += __clen;
	  __len -= __clen;
	}
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
	{
	  difference_type __llen = __last._M_cur - __last._M_first;
	  _Tp* __lend = __last._M_cur;

	  difference_type __rlen = __result._M_cur - __result._M_first;
	  _Tp* __rend = __result._M_cur;

	  if (!__llen)
	    {
	      __llen = _Self::_S_buffer_size();
	      __lend = *(__last._M_node - 1) + __llen;
	    }
	  if (!__rlen)
	    {
	      __rlen = _Self::_S_buffer_size();
	      __rend = *(__result._M_node - 1) + __rlen;
	    }

	  const difference_type __clen = std::min(__len,
						  std::min(__llen, __rlen));
	  std::move_backward(__lend - __clen, __lend, __rend);
	  __last -= __clen;
	  __result -= __clen;
	  __len -= __clen;
	}
      return __result;
    }
#endif
# 1092 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3

_GLIBCXX_END_NAMESPACE_CONTAINER
} // namespace std

#endif
# 1097 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/deque.tcc" 3
# 67 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 2 3

#ifdef _GLIBCXX_DEBUG
#if 0 /* expanded by -frewrite-includes */
# include <debug/deque>
#endif /* expanded by -frewrite-includes */
# 69 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 70 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
#endif
# 71 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3

#ifdef _GLIBCXX_PROFILE
#if 0 /* expanded by -frewrite-includes */
# include <profile/deque>
#endif /* expanded by -frewrite-includes */
# 73 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 74 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
#endif
# 75 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3

#endif /* _GLIBCXX_DEQUE */
# 77 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/deque" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stack" 2 3
#if 0 /* expanded by -frewrite-includes */
#include <bits/stl_stack.h>
#endif /* expanded by -frewrite-includes */
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stack" 3
# 1 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 1 3
// Stack implementation -*- C++ -*-

// Copyright (C) 2001-2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file bits/stl_stack.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{stack}
 */

#ifndef _STL_STACK_H
#define _STL_STACK_H 1

#if 0 /* expanded by -frewrite-includes */
#include <bits/concept_check.h>
#endif /* expanded by -frewrite-includes */
# 59 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
#if 0 /* expanded by -frewrite-includes */
#include <debug/debug.h>
#endif /* expanded by -frewrite-includes */
# 60 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
# 61 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
#if __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
# include <bits/uses_allocator.h>
#endif /* expanded by -frewrite-includes */
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
# 63 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
#endif
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @brief  A standard container giving FILO behavior.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Sequence  Type of underlying sequence, defaults to deque<_Tp>.
   *
   *  Meets many of the requirements of a
   *  <a href="tables.html#65">container</a>,
   *  but does not define anything to do with iterators.  Very few of the
   *  other standard container interfaces are defined.
   *
   *  This is not a true container, but an @e adaptor.  It holds
   *  another container, and provides a wrapper interface to that
   *  container.  The wrapper is what enforces strict
   *  first-in-last-out %stack behavior.
   *
   *  The second template parameter defines the type of the underlying
   *  sequence/container.  It defaults to std::deque, but it can be
   *  any type that supports @c back, @c push_back, and @c pop_front,
   *  such as std::list, std::vector, or an appropriate user-defined
   *  type.
   *
   *  Members not found in @a normal containers are @c container_type,
   *  which is a typedef for the second Sequence parameter, and @c
   *  push, @c pop, and @c top, which are standard %stack/FILO
   *  operations.
  */
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class stack
    {
      // concept requirements
      typedef typename _Sequence::value_type _Sequence_value_type;
      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)
      __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type                value_type;
      typedef typename _Sequence::reference                 reference;
      typedef typename _Sequence::const_reference           const_reference;
      typedef typename _Sequence::size_type                 size_type;
      typedef          _Sequence                            container_type;

    protected:
      //  See queue::c for notes on this name.
      _Sequence c;

    public:
      // XXX removed old def ctor, added def arg to this one to match 14882
      /**
       *  @brief  Default constructor creates no elements.
       */
#if __cplusplus < 201103L
      explicit
      stack(const _Sequence& __c = _Sequence())
      : c(__c) { }
#else
# 136 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
      explicit
      stack(const _Sequence& __c)
      : c(__c) { }

      explicit
      stack(_Sequence&& __c = _Sequence())
      : c(std::move(__c)) { }
#endif
# 144 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3

      /**
       *  Returns true if the %stack is empty.
       */
      bool
      empty() const
      { return c.empty(); }

      /**  Returns the number of elements in the %stack.  */
      size_type
      size() const
      { return c.size(); }

      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %stack.
       */
      reference
      top()
      {
	__glibcxx_requires_nonempty();
	return c.back();
      }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %stack.
       */
      const_reference
      top() const
      {
	__glibcxx_requires_nonempty();
	return c.back();
      }

      /**
       *  @brief  Add data to the top of the %stack.
       *  @param  __x  Data to be added.
       *
       *  This is a typical %stack operation.  The function creates an
       *  element at the top of the %stack and assigns the given data
       *  to it.  The time complexity of the operation depends on the
       *  underlying sequence.
       */
      void
      push(const value_type& __x)
      { c.push_back(__x); }

#if __cplusplus >= 201103L
      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
	{ c.emplace_back(std::forward<_Args>(__args)...); }
#endif
# 202 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3

      /**
       *  @brief  Removes first element.
       *
       *  This is a typical %stack operation.  It shrinks the %stack
       *  by one.  The time complexity of the operation depends on the
       *  underlying sequence.
       *
       *  Note that no data is returned, and if the first element's
       *  data is needed, it should be retrieved before pop() is
       *  called.
       */
      void
      pop()
      {
	__glibcxx_requires_nonempty();
	c.pop_back();
      }

#if __cplusplus >= 201103L
      void
      swap(stack& __s)
      noexcept(noexcept(swap(c, __s.c)))
      {
	using std::swap;
	swap(c, __s.c);
      }
#endif
# 230 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
    };

  /**
   *  @brief  Stack equality comparison.
   *  @param  __x  A %stack.
   *  @param  __y  A %stack of the same type as @a __x.
   *  @return  True iff the size and elements of the stacks are equal.
   *
   *  This is an equivalence relation.  Complexity and semantics
   *  depend on the underlying sequence type, but the expected rules
   *  are: this relation is linear in the size of the sequences, and
   *  stacks are considered equivalent if their sequences compare
   *  equal.
  */
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }

  /**
   *  @brief  Stack ordering relation.
   *  @param  __x  A %stack.
   *  @param  __y  A %stack of the same type as @a x.
   *  @return  True iff @a x is lexicographically less than @a __y.
   *
   *  This is an total ordering relation.  Complexity and semantics
   *  depend on the underlying sequence type, but the expected rules
   *  are: this relation is linear in the size of the sequences, the
   *  elements must be comparable with @c <, and
   *  std::lexicographical_compare() is usually used to make the
   *  determination.
  */
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }

  /// Based on operator==
  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x == __y); }

  /// Based on operator<
  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __y < __x; }

  /// Based on operator<
  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__y < __x); }

  /// Based on operator<
  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x < __y); }

#if __cplusplus >= 201103L
  template<typename _Tp, typename _Seq>
    inline void
    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<stack<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };
#endif
# 302 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace

#endif /* _STL_STACK_H */
# 307 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/bits/stl_stack.h" 3
# 62 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stack" 2 3

#endif /* _GLIBCXX_STACK */
# 64 "/depot/qsc/QSCM/GCC/lib/gcc/x86_64-redhat-linux/5.2.0/../../../../include/c++/5.2.0/stack" 3
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include <limits.h>
#endif /* expanded by -frewrite-includes */
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include "hash.hh"
#endif /* expanded by -frewrite-includes */
# 11 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include "map.hh"
#endif /* expanded by -frewrite-includes */
# 12 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
#if 0 /* expanded by -frewrite-includes */
#include "comerror.h"
#endif /* expanded by -frewrite-includes */
# 13 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 14 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"

NAMESPACE_UPFIR_BEGIN

enum COVERAGE_OPTION {
    COV_PORT_STATE,
    COV_POWER_DOMAIN_SIM_STATE,
    COV_POWER_DOMAIN_POWER_STATE,
    COV_IMPLICIT_SUPPLY_SET_POWER_STATE,
    COV_EXPLICIT_SUPPLY_SET_POWER_STATE,
    COV_PSW_STATE,
    COV_ACK_PORT_STATE,
    COV_CTRL_PORT_STATE,
    COV_PST_STATE,
    COV_PST_TRANSITION,
    COV_SAVE_SIGNAL,
    COV_RESTORE_SIGNAL,
    COV_ISO_EN,
    COV_GROUP
};

class BiasBoundary;
class MacroModelInfo;
class StatePropagationInfo;
typedef std::map<unsigned int, std::string> UPFLINESCOPEMAP;
typedef std::map<std::string, LevelShifterStrategy*> LSMAP;
typedef std::map<std::string, RetentionStrategy*> RETMAP;
typedef std::map<std::string, RetentionStrategy*>::iterator RETMAPITER;
typedef std::map<unsigned int, UPFLINESCOPEMAP*> UPFFILESCOPEMAP;
typedef std::multimap<unsigned int, UpfNamedObj*> UPFLINEOBJMAP;
typedef std::map<unsigned int, UPFLINEOBJMAP*> UPFFILEOBJMAP;
typedef std::multimap<std::string, unsigned int> UPFFILENAMEINDEXMAP;
typedef std::pair<unsigned int, unsigned int> BBFILELINEPAIR;
typedef std::map<std::string, BBFILELINEPAIR > BBMODELINFOMAP;
typedef std::map<void *, BiasBoundary* > INSTANCE_BIAS_BOUNDARY_MAP;
typedef std::map<void *, void*> INSTANCEMAP;
typedef std::pair<std::string, std::string> MODEL_ELEM_PAIR;
typedef std::list<MODEL_ELEM_PAIR> MODEL_ELEM_PAIR_LIST;
typedef PtrMap<void*,UpfObjL*> DscopeSportTable;
typedef std::map<void*, StatePropagationInfo*> STATE_PROPAGATION_MAP;
typedef std::map<void*, StatePropagationInfo*>::iterator STATE_PROPAGATION_MAP_ITER;
typedef std::map<void*, StatePropagationInfo*>::const_iterator STATE_PROPAGATION_MAP_CONST_ITER;
unsigned int getFileLine();

class PowerScopeImpl;
class PowerStateTable;
class ContextResetGroupImpl;
class PowerNetworkImpl:public PowerNetwork
{
public:
    typedef PtrMap<void*, PowerScope* > PowerScopeTable;
    VCS_DECL_SERIALIZABLE(PowerNetworkImpl);
    bool isUfeFlow() const ;
    bool isUcpFlow();
    void setUcpFlow() { isUcpFlow_ = true; }
    bool isUc15Flow();
    bool isCurrentUpfFileEncrypted() {return _currentFileEncrypted; }
    void setCurrentUpfFileEncrypted(bool val) 
    {
        if (!_testDecryption) {
            _currentFileEncrypted = val;
            _encryptionStack.push(val); 
        } else {
            _currentFileEncrypted = 1;
        }
    }
    void resetCurrentUpfFileEncrypted() 
    {
        if (!_testDecryption) {
            _encryptionStack.pop(); 
            _currentFileEncrypted = _encryptionStack.top();
        }
    }
    void setTestDecryption() { _testDecryption = 1; }
    bool showEncryptedName() { return _showEncrypted; }
    void hideEncryptedName(bool val) { _showEncrypted = !val; }
    bool isSpiceBlackBox() const;
    void setModInline(void* inst);
    bool hasAnyPowerBBox() const { return hasAnyPowerBBox_;}
    void setHasAnyPowerBBox() { hasAnyPowerBBox_ = 1; }
    void setCoverageOption(unsigned int i = 0xffffffff) { coverage_options_ |= i; }
    void setUpfReader(UpfReaderIf* reader) { reader_ = reader; }
    void setUpfProduct(UpfProductInfo* product) { product_ = product; }
    UpfProductInfo* getProductInfo() { return product_; }
    FILE* generateReportWithBanner(const char* title, const char* description, const char* fileName, const char* mode="w+");
    bool getVoltageRangeForSupplyNet(SupplyNet* snet, float &min, float& max);
    void closeReport(FILE* fp);
    void serialize(ser::Archive&);
    ~PowerNetworkImpl();
    static PowerNetworkImpl* getInstance();
    static bool powerNetworkInitialized() { return powerNetwork_? true : false; }
    char* lookupNameDB(char* alias);
    char* lookupXmrInNameDB(const char* alias, int& type);
    bool isNlpKeyword(const char* symbol) {return nlpKeyWordsTable_->lookup(symbol)? true : false; }
    bool isNlpGenericName(const char* symbol) const
    {return nlpGenericNames_->lookup(symbol)? true : false; }
    bool checkReInitEnabledOnIp(void* ip, char* modelName);
    void makeReInitInfo(DesignScope* dScope, char* nbName);
    void makeDontReInitInfo(DesignScope* dScope, char* nbName);

    void setAnyRetCondPresent()  { isAnyRetCondPresent_ = true; }
    bool isAnyRetCondPresent() const
    { return isAnyRetCondPresent_; }
    void setAnyBCForIsoWithGenericPresent() { isAnyBCForIsoWithGenericPresent_ = true; }
    bool isAnyBCForIsoWithGenericPresent() { return isAnyBCForIsoWithGenericPresent_; }
    const char* getKindStr() const {return ppiKindP[classType_];}
    void save(const char*);
    void restore(const char*, bool isLoadingForIP = false);
    bool readRuntimeConfig(const char *upfFileName);
    bool readUpfFile(const char *upfFileName);
    bool saveCommandLog(const char* commandLog);
    bool readTopLevelUpfFile(const char* upfFileName);
    bool readTopLevelUpfFile(const char* upfFileName, bool isUpfFile = false);
    void applySimstateBehaviors();

    bool populateUPFIRfromPlatoSDM(void *, void *, void *, const char* reportsDir);

    //Plato Upf to SAN
    UpfSupplySource* createSupplySource(unsigned id, unsigned corrGrpId, unsigned eqSuppId,
            UpfResolveType, bool isPwr, bool isGnd, bool hasEqSupps);
    UpfRootSupplyDriver* createRootSupplyDriver(UpfSupplySource* ssrc, unsigned id, SupplyNet* net, UpfRootSupplyDriverType type);
    UpfRootSupplyDriver* createRootSupplyDriver(UpfSupplySource* ssrc, unsigned id, SupplyPort* net, UpfRootSupplyDriverType type);

    //End Plato Upf to SAN

    void setUpfRead(bool isUpfRead) { isUpfRead_ = isUpfRead; }
    bool isUpfRead() { return isUpfRead_; }
    void throwDneWarning (std::string elem, std::string policyname, std::string attribute, std::string policy, std::string dropped);
    PowerConfig* getPowerConfig() { return NULL; }

    bool readPowerConfigFile(const char *upfFileName);
    bool setToolDesignTop(const char *topModuleName, bool isVlog,
                          void *topInst, const char *origTop) ;
    void treatLevelSaveRestoreAsEdge(unsigned int levelAsEdge) { levelAsEdge_ = levelAsEdge; }

    lpmsg::LpMsgController* getLpMsgController() { return msgController_; }
    void setLpMsgController(lpmsg::LpMsgController* msgController) { msgController_ = msgController; }
    bool checkForNetTypeObj(DesignObject* dObj);
    void checkForNetTypePorts(DesignObject* dObj, ApplyDirectionType dir);
    void setIssueErrorForNetType(bool issueErrorForNetType) {
        issueErrorForNetType_ = issueErrorForNetType;
    }
    void addDLForLpObj(const char* objName, const unsigned int lineNo, const char* fileName,
                       const CharL* scopeL, const bool isVerilogHdl);
    LpSourceInfo* createLpSourceInfoObj(unsigned int file_line, void* obj);
    bool isDesignDebugEnabled() const { return isDesignDebugEnabled_; }
    bool isMixedHdl() const { return isMixedHdl_; }
    void setDesignDebugEnabled() {  isDesignDebugEnabled_ = 1; }
    void setIsMixedHdl() { isMixedHdl_ = 1; }
    bool isLevelSaveRestoreAsEdge() const { return levelAsEdge_; }
    void registerDesignAdapter(UpfDesignAdapter* da) { da_ = da; }
    void setVerboseMode(int mode) {verboseMode_ = mode;}
    void dumpUpfInTclFormat(FILE *) const ;
    int  getVerboseMode() {return verboseMode_;}
    bool hasBindCheckerCallback();
    bool isIsoNotClampedAssertion() { return isoNotClampedAssertion_; }
    virtual void setIsoNotClampedAsertion(bool b) { isoNotClampedAssertion_ = b; }
    PowerDomain *getTopPowerDomain();
    bool doSemanticCheck()const ;
    bool populateElementFromQueryObject();
    void markNoPinRetention();
    void populatePswImplicitSupplySet();
    const char* getDesignTop() const
    {return designTop_;}
    void setReportsDir(const char* reportsDir);
    const char* getReportsDir() const { return reportsDir_; }
    const char* getWorkDir() const { return workDir_; }
    SupplyPortLI getSupplyPads() const
    { return supplyNetAnalysis_->getSupplyPads(); }
    UpfClassType  getUpfClassType() const;
    NameFormat*   getNameFormat() const
    {return nameFormat_;}
    PowerDomainLI getPowerDomains() const
    {return PowerDomainLI(powerDomains_);}
    PowerSwitchLI getPowerSwitches() const
    {return PowerSwitchLI(powerSwitches_);}
    LevelShifterLI getLevelShifters() const
    {return LevelShifterLI(levelShifters_);}
    IsolationLI getIsolations() const
    {return IsolationLI(isolations_);}
    SRSNStrategyLI getSRSNStrategies() const
    {return SRSNStrategyLI(srsns_);}
    RetentionLI getRetentions() const
    {return RetentionLI(retentions_);}
    PowerStateTableLI getPowerStateTables() const
    {return PowerStateTableLI(powerStateTables_);}
    Hdl2UpfVctLI  getHdl2UpfVcts() const
    {return Hdl2UpfVctLI(hdl2UpfVcts_);}
    Upf2HdlVctLI  getUpf2HdlVcts() const
    {return Upf2HdlVctLI(upf2HdlVcts_);}
    BindCheckerLI getBindCheckers() const
    {return BindCheckerLI(bindCheckers_);}
    SaveUpfLI     getSaveUpfs() const
    {return SaveUpfLI(saveUpfs_);}
    LoadUpfLI     getLoadUpfs() const
    {return LoadUpfLI(loadUpfs_);}
    const char * getDesignTopName() const
    { return designTopName_; }
    void setDesignTopName(const char * topName);
    void addGoldenUpfTopLevelFile(const char* fileName);
    void setGoldenUpfFlow() { goldenUpfFlow_ = true; }
    bool isGoldenUpfFlow() const { return goldenUpfFlow_;}
    // DesignModel Related APIs
    void findDesignModels(const char* name, DesignModelL &models, bool ignoreTop = true);
    DesignModel* makeOrGetDesignModel(const char* module, void* hook, bool isGetOnly =false);
    DesignModel* makeOrGetDesignModel(const char* canonicalName, const char *lib, const char *entity, const char *arch);
    DesignModelTableLI getDesignModels() { return DesignModelTableLI(upfModels_); }

    void populateSetOfInputOutputPortsAndParamsInModel(DesignModel *model, charL & iPortsInModel,
                                                       charL & oPortsInModel, charL & ioPortsInModel,
                                                       charL & paramsInModel);

    PowerDomain*      findPowerDomain(const char *domainName, bool isTcl = false) const ;
    PowerDomain*      findPowerDomain(int id) const  { return powerDomainVec_.at(id); }
    PowerSwitch*      findPowerSwitch(int id) const  { return powerSwitchVec_.at(id); }
    IsolationStrategy*      findIsolationStrategy(int id) const { 
        fassert(id > 0, "Incorrect id passed to findIsolationStrategy");
        return (id < isolationStrategyCount_) ? isolationStrategyVec_.at(id) : NULL;
    }
    BindChecker*      findBindCheckerStrategy(int id) const { return bindCheckerStrategyVec_.at(id);}
    SRSNStrategy*      findSRSNStrategy(int id) const { return srsnStrategyVec_.at(id);}
    RetentionStrategy*      findRetention(int id) const { return retrntionPolicyVec_.at(id);}
    LevelShifterStrategy*   findLevelShifterStrategy(int id) const { return levelshifterStrategyVec_.at(id);}

    void      findPowerDomainByScope(const char *logicScope,PowerDomainL& pdl) const ;

    DomainMappingMgr* getMappingManager() const {fassert(0,"Undefined function getMappingManager() in flow"); return NULL;}
    bool noPowerModeValidation() const {fassert(0,"Undefined function noPowerModeValidation() in flow"); return true;}

    LevelShifterStrategy* findLevelShifter(const char *lsName) const ;

    IsolationStrategy* findIsolation(const char *isoName) const ;

    RetentionStrategy* findRetention(const char *retenName) const ;

    RetentionElements* findRetentionElements(const char *retenName) const ;
    RetentionElements* getAssociatedRetentionElementList(DesignQueryImpl* ptr);
    void addRetentionListElement(DesignQueryImpl* instance, RetentionElements* rlist);

    Hdl2UpfVct*       findHdl2UpfVct(const char *vctName) const {return 0;}

    Upf2HdlVct*       findUpf2HdlVct(const char *vctName) const {return 0;}

    SupplyNet*        findSupplyNet(const char *supplyNetName)const ;
    SupplyNet*        findSupplyNet(int snid) const;
    SupplyPort*       findSupplyPort(const char *supplyPortName)const ;
    PowerSwitch*      findPowerSwitch(const char *switchName, bool isTcl = false)const ;
    PowerStateTable*  findPowerStateTable(const char *tableName, bool isTcl = false)const ;
    PowerScope*       findPowerScope(const char* fullName) const;
    DesignObject*     findDesignObject(const char *fullName) const;
    SupplySetHandle*  findSupplySetHandle(const char *supplySetHandleName)const ;
    bool              checkForDesignTop() const;
    UpfObjLI            getSupplyPortsInScope(void* scopePtr);
    void              registerSupplyPortInScope(void* instPtr, SupplyPort *sport);
    DesignObject*     getVirtualPortInCurrentScope(const char *name) const {return 0;}
    static char*      normalize(char *);
    //All set functions
    void              setMonetFlow(bool flag);
    void              setHierModelConsistencyFlow (bool flag)      {hierModelConsistencyFlow_ = flag;}
    void              ignoreBboxMsgs (bool flag)                   {ignoreBboxMsgs_ = flag;}
    void              setHeteroFanoutSupport (bool flag)           { enableHeteroFanout_ = flag; }
    void              setDefaultAppliesToDontFilter (bool flag)           { isDefaultAppliesToDontFilter_ = flag; }
    RetentionMode*    getRetentionModeImpl();
    void              analyzeRetentionMode();
    void              applyRetentionMode();
    void              setMacroPerf ()                              { macroPerf_ = true; }
    void              setConservativeDiffSupplySupport (bool flag) { enableConservativeDiffSupply_ = flag; }
    void              setIgnoreCsnError(bool flag);
    void              setAllUpfError(bool flag);
    void              setInstSupportForIsoLsInMonetFlow(bool flag) { allowInstanceIsoLs_ = flag;}
    void              setAllUpfErrorProceed(bool flag);
    void              setAllowUpfLRMExtension(bool flag) { allowUpfLRMExtn_ = flag; }
    void              setEnableAppliesToDefaultOutputsOrBoth(bool flag) { enableAppliesToDefaultOutputsOrBoth_ = flag; }
    void              setEnableUpfPortabilityMsg (bool flag);
    void              setNpIsoGiven (bool flag) { setNpIsoGiven_   = flag; }
    void              setNpLsGiven (bool flag)  { setNpLsGiven_    = flag; }
    void              setCoaDisabled (bool flag)  { hasCoaDisabled_    = flag; }
    void              setNpSrsnGiven (bool flag) { setNpSrsnGiven_ = flag; }
    bool              setDesignTop(const char *top);
    void              setCurrentScope(const char *scope);
    void              pushCurrentScope(const char *prevScope);
    bool              resetScope(const char *scope);
    void              addPowerDomain(PowerDomain *pd, PowerScope *ps = NULL);
    void              addLevelShifter(LevelShifterStrategy *ls) {
        levelShifters_.append(ls);
    }
    void              addIsolation(IsolationStrategy *isolation) {
        isolations_.append(isolation);
    }
    void              deleteIsolation(IsolationStrategy* isolation) {
        isolations_.detach(isolation);
    }
    void addBindCheckerStrategy(BindChecker* bc);
    BindChecker* createBindCheckerObject(char* checkerInstance, int line, char* checkerModule, charL &targetPolicies);
    void        addSRSN(SRSNStrategy *srsn) {
        srsns_.append(srsn);
    }
    void              addRetention(RetentionStrategy *retention) {
        retentions_.append(retention);
    }
    void              deleteRetention(RetentionStrategy* retention) {
        retentions_.detach(retention);
    }
    void              addRetentionElement(RetentionElements *retention) {
        retentionsElements_.append(retention);
    }
    void              addSwitch(PowerSwitch *pSwitch) {
        powerSwitches_.append(pSwitch);
    }
    void              addPowerStateTable(PowerStateTable *pst) {
        cPowerScope_->addPowerStateTableInScope(pst);
        powerStateTables_.append(pst);
    }
    UpfObj* lookupUpfObject(void* instance, UpfClassType cType, const char* name, const char *fullName);
    void addPowerScope(PowerScope* ps) 
    { 
        powerScopeNameHashTable_.append(ps);
        this->instancePointerVsPowerScopeTable_[ps->getDesignObject()->getTargetInstance()] = ps;
    }
    PowerScopeTableLI getPowerScopes() { return PowerScopeTableLI(powerScopeNameHashTable_); }

    void addDesignObject (DesignObject *dobj) { designObjectNameHashTable_.append(dobj); }
    DesignObjectTableLI getDesignObjects() {return DesignObjectTableLI(designObjectNameHashTable_);}

    void setNameFormat(NameFormat *nf) {
        nameFormat_ = nf;
    }
    void setLowVoltageLevel(unsigned int level) {
        lowVoltageLevel_ = level;
    }
    unsigned int getLowVoltageLevel() {
        return lowVoltageLevel_;
    }
    int getActiveResetDuration() {
        return activeResetDuration_;
    }
    void setActiveResetDuration(int time) {
        activeResetDuration_ = time;
    }
    int getInactiveResetDuration() {
        return inactiveResetDuration_;
    }
    void setInactiveResetDuration(int time) {
        inactiveResetDuration_ = time;
    }
    void setHighVoltageLevel(unsigned int level) {
        highVoltageLevel_ = level;
    }
    unsigned int getHighVoltageLevel() {
        return highVoltageLevel_;
    }
    
    bool bcIsOldVhdlImplEnabled() { 
        return bcEnableOldVhdlImpl;
    }

    void setBcEnableOldVhdlImpl() {
         bcEnableOldVhdlImpl = true;
    }

    //void printCorrSupplyGroups();
    void populatePowerOptions() ;
    unsigned findPowerOption(const std::string & name);
    void*       getParentInstance(void* inst, UPFIR::DESIGN_TREE_TYPE designTreeType, bool& isVlog);
    bool        isUnderDesignTop(void *inst, bool isInstVlog);
    void        readMacroUpfs();
    //get functions for this class
    const char*       getCurrentScope()const ;
    const char*       getPreviousScope()const ;
    UpfObj*      findUpfObject(UpfClassType cType, const char* scope, const char* name, std::string& scopeName, std::string& objNm, bool bLookInSpice = false);
    static bool       isValidUpfIdentifier(const char *id, bool includeScope=false);
    static void findInstanceNamesOfModule(
        const char *modName,
        const char *currentScope,
        UPFIR::PowerDomain * domain,
        UPFIR::charL &hierDesignObjectL);
    char * getModuleName(void * inst, bool isVlog);
    static void findVerilogName ( void *inst, bool regexp, bool exact, bool ic, bool trans,bool nonLeaf, bool leaf_only, FindObjType type,UpfPortDirection dir, char *pattern, charL &nameList, charL &hireNamL, bool isVlog);
    int findHierObjectsInScope (void * scope, const std::string & scopeName, bool vlogScope, const std::string & token, int type, charL & tokenList, UpfObjL& upfObjList, bool lookupClassRef=false);
    bool                resolveWildcardClassRefs();
    bool                expandWildcardClassRefs(DesignObjectLI& dli, DesignObjectL& dobjL, FindObjType type, UpfObj* obj);
    void                expandWildcardsInClassRef(DesignElementType& dType, DesignObjectL& dobjL, bool vlogScope, FindObjType type, UpfObj* obj);
    char *getInstOfModuleDesignTop(const char* elem);
    static DesignObject*       checkDesignModel(const char* elem, DesignModel* designModel);
    DesignObject*       queryDesignElement(const char *elem, bool bLookInSpice = false, 
                                           DesignElementType* dType = NULL, bool giveError= true);
    void*  queryDesignInstance(const char* elem);
    DesignObject*       checkDesignElement(const char *elem,
                                           const char *scope, bool checkSignal = false,
                                           char *file = NULL, int line = 0,
                                           bool reportError = true,
                                           QueryCmdType cType = UNKNOWN_CMD,
                                           bool lookInSpice = false);
    static bool       checkNoDesignElement(const char *elem,
                                           const char *scope, bool checkSignal = false);

    void              setLpaBindTcl(const char* fileName) { if (fileName) lpaBindTcl_ = fileName; }
    const char*       getLpaBindTcl() const { return lpaBindTcl_.c_str();}
    void              setLpaBindFileList(const char* fileName) { if (fileName) lpaBindFileList_ = fileName; }
    const char*       getLpaBindFileList() const { return lpaBindFileList_.c_str(); }
    void              setUseUpfQueryData() { useUpfQueryData_ = 1; }
    bool              getUseUpfQueryData() { return useUpfQueryData_; }
    void              setMvAllowPgPinReconnection() { isMvAllowPgPinReconnect_ = 1; }
    bool              getMvAllowPgPinReconnection() { return isMvAllowPgPinReconnect_; }
    bool              isPstEmulationEnabled();
    const char*       getBaseDir() const;
    const char*       getFileName(unsigned int fileId) const;
    unsigned int      getFileId(const char* fileName, const char* scope) const;
    unsigned int      getCurrentFileId() const;
    const char *      getCurrentFileName() const;
    unsigned int      getCurrentLineNo() const;
    bool              appendElement(const char *elem);
    void              appendLsElement(std::string elem,LevelShifterStrategy*);
    bool              elementAlreadyAdded(std::string elem,std::string&,std::string&);
    bool              appendRetElement(std::string elem, RetentionStrategy*);
    virtual unsigned int getLineNo() const {return getCurrentLineNo();}
    virtual const char * getFileName() const {return
            getFileName(getCurrentFileId());}
    bool applyBind(const char*, InstanceNameL& targetInsts,
                   char *checkerModule, char *checkerInst,
                   NamePairL& portConnects, NamePairL& params,
                   bool isBindToElements);
    bool applyBind(UPFIR::BindChecker *bc);
    const char *getIncdirFile(const char *file);
    DesignObject*      getCScope() const {return cScope_;}
    DesignObject*      getPScope() const {return pScope_;}
    DesignObject*      getDTop() const {return dTop_;}
    int getTotalSupplyNetCount() {return supplyNetAnalysis_->getSupplyNetCount(); }
    int getTotalPowerSwitchCount();
    //void setCScope(char *sc, DesignElementType dt);
    void setCScope(DesignObject*);
    void setCPowerTopScope(PowerScope* ps) { cPowerTop_ = ps;}
    PowerScope* getCPowerTopScope() { return cPowerTop_ ;}
    void pushCScope(DesignObject*);
    void setLanguage(UpfHdlType hdl)
    {
        hdlType_ = hdl;
    }
    UpfHdlType getLanguage() {return hdlType_;}
    PowerFormatType getPowerFormat() {return UpfC;}
    bool hasVlogPad() const {return isVlogPad_;}
    void setVlogPad(bool b) {isVlogPad_ = b;}
    ScopeTable* getScopeTable() { return scopes_; }
    int registerScope(DesignObject* elem, const char* name);
    int registerScope(const char* scope, int ScopeId);
    void unregisterScope(int id,DesignObject* dobj);

    UpfDesignPort*  makeOrGetDesignPort(const char* name, const char* portName, const char* resolvedName, unsigned isVerilog, void* instance, int cellId, DesignScope* dscope, bool forSPA, ClampValueType clampVal = UpfClampUnspecifiedC);
    UpfDesignPortTableLI  getDesignPorts() { return  UpfDesignPortTableLI(designPorts_); }
    UpfDesignPort*  findDesignPort(int id) { return designPortVec_.at(id); }
    std::vector<UpfDesignPort*>::iterator getDesignPortsOrderBegin() { return designPortVecForOrder_.begin();}
    std::vector<UpfDesignPort*>::iterator getDesignPortsOrderEnd() { return designPortVecForOrder_.end();}
    void addPowerBoundaryElement(void* instance, PowerDomain* pd);
    PowerDomain* isPowerBoundaryElement(void* instance);
    PowerDomain* isSecondaryPowerBoundaryElement(void* instance);

    UpfDesignPort*  makeOrGetDesignPort(const char* name, const char* portName, unsigned isVerilog, void* instance, int cellId, DesignScope* dscope);
    const char* getVhdlDefName(DesignObject *dobj);

    DesignScope*  findDesignScope(int id);
    DesignScopeTablePI getDesignScopes() { return DesignScopeTablePI(designScopes_); }
    DesignScope* makeOrGetDesignScope(DesignObject* dobj);

    bool doSupplyNetAnalysis();
    void adjustRetentionStrategies();
    SupplyNetAnalysis* getSupplyNetAnalysis() { return supplyNetAnalysis_; }
    PowerScope* makeOrGetPowerScope(DesignObject *, DesignModel* dmod, bool isTop = false, bool isModel = false);
    PowerScopeLI         getPowerTops() const {return PowerScopeLI(topPowerScopesL);}
    bool  hasPowerScope (void* ip, char** psName) const;
    PowerScope*          getPowerScope (const char* psName) const;
    const char*          getScopeResolvedNameFromFullName (const char* psFullName);
    std::string&          getSNetResolvedNameFromFullName (SupplyNet* sNet);
    std::string          getSPortResolvedNameFromSPort(SupplyPort* sPort);
    std::string          getDomainFullResolvedNameFromPD(PowerDomain* pd);
    std::string          getPSNameFullToResolve(PowerScope* ps, std::string targetFullName);
    std::string          getSSHandleFullNameFromSSHandle(SupplySetHandle* ssHandle);
    void                 saveResolvedName(PowerScope* ps);
    bool                 addPowerTop(PowerScope* ps);    
    const std::string&   getSavedResolvedName(const std::string& psFullName);
    PowerScope*          getCurrentPowerScope() {return cPowerScope_;}
    PowerScopeLI         getPowerModels() {return PowerScopeLI(powerModelsL);}
    void addPowerModule(PowerScope *ps)
    {
        powerModelsL.append(ps);
    }

    //StatePropagation APIs
    bool doStatePropagationSemanticChecks() const;
    PowerScope*  getPowerScopeFromInstance(void* instance) const;
    bool getStatePropagationInApsAttrSpecified() const
    {
        return !(statePropagationMap_.empty());
    }
    void addStatePropagationInApsAttribute(void* instance, StatePropagationInfo* info)
    {
        statePropagationMap_[instance] = info;
    }
    void cacheStatePropagationInApsAttribute(PowerScope* instance);
    StatePropagationInfo* getStatePropagationInApsAttribute(void* instance) const;
        
    //LowerDomainBoundary APIs
    void addLowerDomainAttribute(DesignScope* dsc, bool val);
    DesignScopeLI getLowerDomainTrueList() {return DesignScopeLI(lowerDomainTrueList_);}
    DesignScopeLI getLowerDomainFalseList() {return DesignScopeLI(lowerDomainFalseList_);}

    //TerminalBoundary APIs
    void addTerminalBoundaryAttribute(DesignScope* dsc);
    DesignScopeLI getTerminalBoundaryList() {return DesignScopeLI(terminalBoundaryList_);}

    void setPBPOptEnabled() { isPBPOpt_ = true; }
    bool isPBPOptEnabled() { return isPBPOpt_; }
    void setLpAssertEnabled() { isLpAssertEnabled_ = true; }
    void setRetSupCorr() { isRetSupCorr_ = true; }
    bool isMonetFlow()        { return isMonetFlow_; }
    bool ignoreBboxMsgs()     { return ignoreBboxMsgs_;}
    bool isHierModelConsistencyFlow() {return hierModelConsistencyFlow_;}

    bool hasPolicyOnInterfModport() { return (this->hasPolicyOnInterfModport_); }
    void setHasPolicyOnInterfModport() { this->hasPolicyOnInterfModport_ = 1; }

    void setHasPathBasedPolicy() { hasPathBasedPolicy_ = 1; }
    bool hasPathBasedPolicy() { return hasPathBasedPolicy_; }
    void setHasFanoutPolicy() { hasFanoutPolicy_ = 1; }
    bool hasFanoutPolicy() { return hasFanoutPolicy_; }
    bool isHeteroFanoutEnabled () { return enableHeteroFanout_; }
    bool isDefaultAppliesToDontFilter () { return isDefaultAppliesToDontFilter_; }
    bool isConservativeDiffSupplyEnabled () { return enableConservativeDiffSupply_; }
    bool ignoreCsnError() { return ignoreCsnError_; }
    bool instanceSupportForIsoLsInMonetFlow() { return allowInstanceIsoLs_;}
    bool allUpfError() {return allUpfError_;}
    bool allUpfErrorProceed() {return allUpfErrorProceed_;}
    bool isUpfLRMExtensionAllowed() const { return allowUpfLRMExtn_; }
    bool isEnableAppliesToDefaultOutputsOrBoth() const { return enableAppliesToDefaultOutputsOrBoth_; }
    bool enableUpfPortabilityMsg() {return enableUpfPortabilityMsg_;}
    bool getNpIsoGiven() { return setNpIsoGiven_; }
    bool getNpLsGiven()  { return setNpLsGiven_; }
    bool getCoaDisabled ()  { return hasCoaDisabled_; }
    bool getNpSrsnGiven() { return setNpSrsnGiven_; }
    bool isLpAssertEnabled() { return isLpAssertEnabled_; }
    bool isRetSupCorr() { return isRetSupCorr_; }
    void setDbInfoPresent() {isDbInfoPresent_ = 1;}
    bool getDbInfoPresent()  const {return isDbInfoPresent_;}
    void setRtlPGMode() {isRtlPGMode_ = 1;}
    bool getRtlPGMode()  const {return isRtlPGMode_;}
    void setSSDefaultON() {isSSDefaultON_ = 1;}
    bool getSSDefaultON()  const {return isSSDefaultON_;}
    void setConfigValue(const std::string &, const std::string &);
    void setQueryLoggerValues(const char *, const char *, const char *);
    void setDumpUPF(const char *);
    ///-power=custom_assert in command line will set this flag for PowerNetwork
    void setCustomAssertTcl(const char* file);
    ///check whether -power=custom_assert present in command line
    const char* getCustomAssertTcl() { return customAssertFile_; }
    ///-power=srsn_outside_port in command line will set this flag for PowerNetwork
    void setSrsnOutsidePortInstrumentation() { srsnOutsidePort_ = true; }
    void setSrsnLocationSelfInstrumentation() { srsnLocationSelf_ = true; }
    ///check whether -power=srsn_outside_port present in command line
    bool getSrsnOutsidePortInstrumentation() { return srsnOutsidePort_; }
    bool getSrsnLocationSelfInstrumentation() { return srsnLocationSelf_; }
    void setUnconnectedBiasPinsOn() { unconnBiasPinsOn_ = true; }
    bool getUnconnectedBiasPinsOn() { return unconnBiasPinsOn_; }
    ///-power=poweropt in command line will set this flag for PowerNetwork
    void setPowerOptMode() { powerOptMode_ = true; }
    void setClampCheckOnEnable() { clampCheckOnEnable_ = true; }
    bool getClampCheckOnEnable() { return clampCheckOnEnable_; }
    void setClampCheckOnDisable() { clampCheckOnDisable_ = true; }
    bool getClampCheckOnDisable() { return clampCheckOnDisable_; }
    ///check whether -power=poweropt present in command line
    bool getPowerOptMode() { return powerOptMode_; }

    void setCheckPowerDownWrite() {checkPowerDownWrite_ = true;};
    bool  isCheckPowerDownWrite() { return checkPowerDownWrite_ ;} ;

    void setDiscretePortStates() {isDiscretePortStates_ = true;};
    void addMacroInfo(std::string &fileName, std::string &macroName,
                                                std::string &corr_type);
    const char *getMacroUpfFileName(std::string &macroName, MacroCorruptionType
                                                            &corr_type);
    void processMacroModelInfos();
    DesignModelLI getMacroModels() { return DesignModelLI(this->macroModels_);}
    bool  isDiscretePortStates() { return isDiscretePortStates_ ;} ;
    void setStrictDbMatch() { strictDbMatch_ = true; }
    bool isStrictDbMatch() { return strictDbMatch_; }

    bool hasUpfError();
    void setUpfError() { upfError_ = true; }
    UpfParsingMode getUpfParsingMode() { return parsingMode_; }
    void setUpfParsingMode(UpfParsingMode mode) { parsingMode_ = mode; }
    UpfParsingFileMode getUpfParsingFileMode() { return parsingFileMode_; }
    void setUpfParsingFileMode(UpfParsingFileMode mode) { parsingFileMode_ = mode; }
    void disableParsingNotice(bool disable) {disableParsingNotice_ = disable; }
    bool isParsingNoticeDisabled() {return disableParsingNotice_; }
    unsigned enableDesignRandomCorruption() { return corEn_; }
    void setDesignRandomCorruption(unsigned corEn) { corEn_ = corEn; }
    unsigned getRandomCorruptionSeed() { return randomSeed_; }
    void setRandomCorruptionSeed(unsigned seed) { randomSeed_ = seed; }
    CorruptionType getRandomCorruptionType() { return corType_; }
    void setRandomCorruptionType(CorruptionType corType) { corType_ = corType; }

    void setDesignReinit(bool reinit) { designReinit_ = reinit; }
    void setDesignDontReinit(bool reinit) { designReinit_ = reinit? false : true; }
    bool isDesignReinit() { return designReinit_; }
    void setDesignDisableCoa(bool b) { disableCoa_ = b; }
    bool isDesignDisableCoa() { return disableCoa_; }
    void setAssertionControl(AssertControlType b)  { assertControl_ = b; }
    AssertControlType getAssertionControl() const   { return assertControl_; }
    void setForceSemanticConfig(ForceSemanticType b)  { forceSemanticsConfigType_ = b; }
    ForceSemanticType getForceSemanticConfig() const   { return forceSemanticsConfigType_; }
    void setTreatUndrivenAsUndetermined(bool val) { treatUndrivenAsUndetermined_ = val; }
    bool isTreatUndrivenAsUndetermined() { return treatUndrivenAsUndetermined_; }
    void setTreatUndrivenSupplyNetAsUndetermined(bool val) { treatUndrivenSupplyNetAsUndetermined_ = val; }
    bool isTreatUndrivenSupplyNetAsUndetermined() { return treatUndrivenSupplyNetAsUndetermined_; }
    void setUnassociatedIsoOn(bool val) { isUnassociatedIsoOn_ = val; }
    bool isUnassociatedIsoOn() { return isUnassociatedIsoOn_; }
    void setPowerUpf2SvVct(Upf2SvInbuiltType vct) {pwrUpf2SvVct_ = vct; }
    Upf2SvInbuiltType getPowerUpf2SvVct() {return pwrUpf2SvVct_; }
    void setGroundUpf2SvVct(Upf2SvInbuiltType vct) {gndUpf2SvVct_ = vct; }
    Upf2SvInbuiltType getGroundUpf2SvVct() {return gndUpf2SvVct_; }
    void setPowerSv2UpfVct(Sv2UpfInbuiltType vct) {pwrSv2UpfVct_ = vct; }
    Sv2UpfInbuiltType getPowerSv2UpfVct() {return pwrSv2UpfVct_; }
    void setGroundSv2UpfVct(Sv2UpfInbuiltType vct) {gndSv2UpfVct_ = vct; }
    Sv2UpfInbuiltType getGroundSv2UpfVct() {return gndSv2UpfVct_; }
    void setPowerUpf2VhVct(Upf2VhInbuiltType vct) {pwrUpf2VhVct_ = vct; }
    Upf2VhInbuiltType getPowerUpf2VhVct() { return pwrUpf2VhVct_; }
    void setGroundUpf2VhVct(Upf2VhInbuiltType vct) {gndUpf2VhVct_ = vct; }
    Upf2VhInbuiltType getGroundUpf2VhVct() { return gndUpf2VhVct_; }
    void setPowerVh2UpfVct(Vh2UpfInbuiltType vct) {pwrVh2UpfVct_ = vct; }
    Vh2UpfInbuiltType getPowerVh2UpfVct() { return pwrVh2UpfVct_; }
    void setGroundVh2UpfVct(Vh2UpfInbuiltType vct) {gndVh2UpfVct_ = vct; }
    Vh2UpfInbuiltType getGroundVh2UpfVct() { return gndVh2UpfVct_; }
    bool isApfCompat() { return apfCompat_; }
    void setVhdlIntegerCorruptMode(const char* flag);
    int  getVhdlIntegerCorruptMode(void) { return vhdlIntegerCorrupt_;};
    void setApfCompat(bool apf) { apfCompat_ = apf; }
    void setNorIsolationEnabled(bool norIsolation) {norIsolation_ = norIsolation; }
    bool isNorIsolationEnabled() {return norIsolation_; }
    bool logicExprDrivesSupplyExpr() { return logicExprDrivesSupplyExpr_; }
    void setLogicExprDrivesSupplyExpr(bool b) { logicExprDrivesSupplyExpr_ = b; }
    bool voltageBasedSupplyOn() { return voltageBasedSupplyOn_; }
    void setVoltageBasedSupplyOn(bool b) { voltageBasedSupplyOn_ = b; }
    bool nameBasedSourceSink() { return nameBasedSourceSink_; }
    void setNameBasedSourceSink(bool b) { nameBasedSourceSink_ = b; }
    void setOverridePBPCorruption(int corrupt) {pbpCorrupt_ = corrupt; }
    int getOverridePBPCorruption() {return pbpCorrupt_; }
    void setBuffersAsGates(unsigned buff)  { buffersAsGates_ = 1; }
    unsigned buffersAsGates() { return buffersAsGates_; }
    void setSequentialBuffersAsPassTrough(unsigned b) { seqBuffersAsPassThrough_ = b; }
    unsigned sequentialBuffersAsPassTrough() { return seqBuffersAsPassThrough_; }
    void setConstantsInDomain(unsigned constants) { constantsInDomain_ = constants; }
    void setZebuLpFlow(bool val) { zebuLpFlow_ = val; }
    unsigned getZebuLpFlow() { return zebuLpFlow_; }
    void dumpUpfForZebu(const char* fileName = "zebu.upf");
    unsigned constantsInDomain() { return constantsInDomain_; }
    DesignObjectLI getAlwaysOnObjects() { return DesignObjectLI(alwaysOnObjs_); }
    void addDontTouchObject(DesignObject* dobj) { alwaysOnObjs_.append(dobj); }
    DesignObjectLI getResetWaiverObjects() { return DesignObjectLI(resetWaiverObjs_); }
    void addResetWaiverObject(DesignObject* dobj) { resetWaiverObjs_.append(dobj); }
    DesignObjectLI getIsoDisResetWaiverObjects() { return DesignObjectLI(isoDisResetWaiverObjs_); }
    void addIsoDisResetWaiverObjects(DesignObject* dobj) { isoDisResetWaiverObjs_.append(dobj); }
    DesignObjectLI getIsoDisClockWaiverObjects() { return DesignObjectLI(isoDisClockWaiverObjs_); }
    void addIsoDisClockWaiverObjects(DesignObject* dobj) { isoDisClockWaiverObjs_.append(dobj); }
    unsigned getClockCycleOnIsoDisable() { return clockCycleOnIsoDisable_; } 
    void setClockCycleOnIsoDisable(unsigned cycle) { clockCycleOnIsoDisable_ = cycle; }
    void addReInitInfo(ReInitInfo* obj) { reInitInfos_.append(obj); }
    ReInitInfoLI getReInitInfos() { return ReInitInfoLI(reInitInfos_); }
    void addDontReInitInfo(ReInitInfo* obj) { dontreInitInfos_.append(obj); }
    ReInitInfoLI getDontReInitInfos() { return ReInitInfoLI(dontreInitInfos_); }
    void addBBoxModel(const char* modname) { insideBBoxModels_.append(strdup(modname)); }
    charLI getInsideBBoxModels() { return charLI(insideBBoxModels_); }
    void setPartcompFlow(int flow) { partCompFlow_ = flow; }
    int  getPartcompFlow() {return partCompFlow_;}
    void setMixadAmsFlow(bool flag) { isMixadAmsFlow_ = flag; }
    bool isMixadAmsFlow() { return isMixadAmsFlow_; }
    void markDummyPowerTop() {hasDummyPowerTop_ = 1;}
    bool hasDummyDesignTop() const {return hasDummyPowerTop_ ;}
    void markPartialOnAsFullOn(bool fullOn) {partialOnAsFullOn_= fullOn;}
    bool isPartialOnFullOn() const {return partialOnAsFullOn_;}
    static bool isToolTop(const char* name) {
        return (toolTop_ && !strcmp(toolTop_, name));
    }
    char* getToolTop() { return toolTop_; }
    int getTotalPowerDomainCount() { return powerDomainCount_; }
    int getTotalIsolationsCount() { return isolationStrategyCount_; }
    int getTotalLevelShiftersCount() { return levelshifterStrategyCount_; }
    int getTotalRetentionCount() { return retCount_; }
    const char* getScopeAtLineNo(const char* fileName, unsigned int lineNo, const char* fileTopScope = NULL) const;
    const UpfNamedObj* getUpfObjAtLineNo(const char* fileName, unsigned int lineNo, const char* identifier, const char* fileTopScope = NULL) const;
    bool areSupplySetsEquivalent(UPFIR::SupplySetHandle* s1, UPFIR::SupplySetHandle* s2);
    static void setExitFunction(ExitFunctionCB exit) { exitFunc_ = exit; }
    static void upfCatchExitMsg(vcsMsgSeverity sev, const unsigned msgflags, const char* code, const char * msg, void *data);
    static void Rt_finish(vcsMsgSeverity sev, const unsigned msgflags, const char* code, const char * msg, void *data);
    static void upfCatchMsgNoExit(vcsMsgSeverity sev, const unsigned msgflags, const char* code, const char * msg, void *data);
    static void upfInitErrorMessaging();
    static void upfCleanupErrMessaging();
    static void upfInitRtErrorMessaging();
    static void upfCleanupRtErrMessaging();
    static void setVcsHome(const char* vcsHome);// { vcsHome_ = vcsHome; }
    void setVcsVerboseLevel(int level);

    UpfLogicPort* findLogicPort(const char* fullName) const {
        return logicPorts_.lookup(fullName);
    }
    void addLogicPort(UpfLogicPort* lp) {
        logicPorts_.append(lp);
    }

    // XoverGate Interface
    void addLSXoverGate(int id, int srcSSId, int destSSId, int strategyId, bool is3070);
    XoverGateLI getLSXoverGates() { return XoverGateLI(lsGatesL_); }
    SimModeType getSimulationMode() { return simMode_; }
    void setSimulationMode(SimModeType simMode) { simMode_ = simMode; }
    bool isDisableSRSN() const { return disableSRSN_; }
    void setDisableSRSN() {disableSRSN_ = true; }
    void setCovgEnableLpCg(bool opt) { covg_enable_lp_cg_ = opt; } //used at runtime for coverage
    bool isCovgEnableLpCg() const { return covg_enable_lp_cg_; }
    bool isLpCoverageEnabled() const { return (coverage_options_ & 0x3fff); }
    bool isPartialDeselect() const {return !(coverage_options_ == 0x3fff || coverage_options_ == 0x0000);}
    void setLpCoverageEnabled() {
        setPowerDomainCoverage();
        setPowerSwitchCoverage();
        setPowerStateTableStateCoverage();
        setSupplyPortStateCoverage();
        setSupplySetCoverage();
        setControlPortCoverage();
        setAckPortCoverage();
        setSaveSignalCoverage();
        setRestoreSignalCoverage();
        setIsoEnableCoverage();
        setGroupStateCoverage();
    }
    void setPowerSwitchCoverage() { coverage_options_ |= (1<<COV_PSW_STATE);
        setAckPortCoverage();
        setControlPortCoverage();
    }
    void unsetPowerSwitchCoverage() { coverage_options_ &= ~(1<<COV_PSW_STATE); }
    bool isPowerSwitchCoverage() {return coverage_options_ & (1<<COV_PSW_STATE);}
    void setPowerStateTableStateCoverage() {coverage_options_ |= (1<<COV_PST_STATE);}
    void unsetPowerStateTableStateCoverage() {coverage_options_ &= ~(1<<COV_PST_STATE);}
    bool isPowerStateTableStateCoverage() {return coverage_options_ & (1<<COV_PST_STATE);}

    void setPowerStateTableTransitionCoverage() {coverage_options_ |= (1<<COV_PST_TRANSITION);}
    void unsetPowerStateTableTransitionCoverage() {coverage_options_ &= ~(1<<COV_PST_TRANSITION);}
    bool isPowerStateTableTransitionCoverage() {return coverage_options_ & (1<<COV_PST_TRANSITION);}

    bool isPowerStateTableCoverage() {return isPowerStateTableStateCoverage();}
    void setPowerStateTableCoverage() {
        setPowerStateTableStateCoverage();
    }

    void setSupplyPortStateCoverage() {coverage_options_ |= (1<<COV_PORT_STATE);}
    void unsetSupplyPortStateCoverage() {coverage_options_ &= ~(1<<COV_PORT_STATE);}
    bool isSupplyPortStateCoverage() {return coverage_options_ & (1<<COV_PORT_STATE);}

    void setSupplySetCoverage() {
        setImplicitSupplySetPowerStateCoverage();
        setExplicitSupplySetPowerStateCoverage();
    }
    void unsetSupplySetCoverage() {
        unsetImplicitSupplySetPowerStateCoverage();
        unsetExplicitSupplySetPowerStateCoverage();
    }
    bool isSupplySetCoverage() {return isImplicitSupplySetPowerStateCoverage() || isExplicitSupplySetPowerStateCoverage();}

    void setExplicitSupplySetPowerStateCoverage() {coverage_options_ |= (1<<COV_EXPLICIT_SUPPLY_SET_POWER_STATE);}
    void unsetExplicitSupplySetPowerStateCoverage() {coverage_options_ &= ~(1<<COV_EXPLICIT_SUPPLY_SET_POWER_STATE);}
    bool isExplicitSupplySetPowerStateCoverage() {return coverage_options_ & (1<<COV_EXPLICIT_SUPPLY_SET_POWER_STATE);}

    void setImplicitSupplySetPowerStateCoverage() {coverage_options_ |= (1<<COV_IMPLICIT_SUPPLY_SET_POWER_STATE);}
    void unsetImplicitSupplySetPowerStateCoverage() {coverage_options_ &= ~(1<<COV_IMPLICIT_SUPPLY_SET_POWER_STATE);}
    bool isImplicitSupplySetPowerStateCoverage() {return coverage_options_ & (1<<COV_IMPLICIT_SUPPLY_SET_POWER_STATE);}

    bool isPgSim() const { return pgsim_; }
    void setPgSim(bool pgsim) { pgsim_ = pgsim; }

    bool isPowerDomainCoverage() { return isPowerDomainPowerStateCoverage() || isPowerDomainSimStateCoverage(); }
    void setPowerDomainCoverage() {
        setPowerDomainPowerStateCoverage();
        setPowerDomainSimStateCoverage();
    }
    void unsetPowerDomainCoverage() {
        unsetPowerDomainPowerStateCoverage();
        unsetPowerDomainSimStateCoverage();
    }

    void setPowerDomainPowerStateCoverage() {coverage_options_ |= (1 <<  COV_POWER_DOMAIN_POWER_STATE);}
    void unsetPowerDomainPowerStateCoverage() { coverage_options_ &= ~(1<< COV_POWER_DOMAIN_POWER_STATE);}
    bool isPowerDomainPowerStateCoverage() {return  coverage_options_ & (1<<COV_POWER_DOMAIN_POWER_STATE);}

    void setPowerDomainSimStateCoverage() {coverage_options_ |= (1 <<  COV_POWER_DOMAIN_SIM_STATE);}
    void unsetPowerDomainSimStateCoverage() { coverage_options_ &= ~(1<< COV_POWER_DOMAIN_SIM_STATE); }
    bool isPowerDomainSimStateCoverage() {return coverage_options_ & (1<<COV_POWER_DOMAIN_SIM_STATE); }
    bool currentSearchInsideBbox() const { return _currentSearchInsideBbox;}
    void setCurrentSearchInsideBbox(bool val) {_currentSearchInsideBbox = val;}


    void setControlPortCoverage() {coverage_options_ |= (1<<COV_CTRL_PORT_STATE);}
    void unsetControlPortCoverage() {coverage_options_ &= ~(1<<COV_CTRL_PORT_STATE);}
    bool getControlPortCoverage() {return coverage_options_ & (1<<COV_CTRL_PORT_STATE);}

    void setAckPortCoverage() {coverage_options_ |= (1<<COV_ACK_PORT_STATE);}
    void unsetAckPortCoverage() {coverage_options_ &= ~(1<<COV_ACK_PORT_STATE);}
    bool getAckPortCoverage() {return coverage_options_ & (1<<COV_ACK_PORT_STATE);}

    void setSaveSignalCoverage() {coverage_options_ |= (1<<COV_SAVE_SIGNAL);}
    void unsetSaveSignalCoverage() {coverage_options_ &= ~(1<<COV_SAVE_SIGNAL);}
    bool getSaveSignalCoverage() {return coverage_options_ & (1<<COV_SAVE_SIGNAL);}

    void setRestoreSignalCoverage() {coverage_options_ |= (1<<COV_RESTORE_SIGNAL);}
    void unsetRestoreSignalCoverage() {coverage_options_ &= ~(1<<COV_RESTORE_SIGNAL);}
    bool getRestoreSignalCoverage() {return coverage_options_ & (1<<COV_RESTORE_SIGNAL);;}

    void setIsoEnableCoverage() {coverage_options_ |= (1<<COV_ISO_EN);}
    void unsetIsoEnableCoverage() {coverage_options_ &= ~(1<<COV_ISO_EN);}
    bool getIsoEnableCoverage() {return coverage_options_ & (1<<COV_ISO_EN);}

    void setGroupStateCoverage() {coverage_options_ |= (1<<COV_GROUP);}
    void unsetGroupStateCoverage() {coverage_options_ &= ~(1<<COV_GROUP);}
    bool isGroupStateCoverage() {return coverage_options_ & (1<<COV_GROUP);}

    bool isCorrelatedGroupsDefined() { return ( correlatedGroupsDefined_ == 1); }
    void setCorrelatedGroupsDefined(bool correlatedGroupsDefined) { correlatedGroupsDefined_ = correlatedGroupsDefined ? 1 : 0; }
    bool isLeafScopeAsModel() { return (leafScopeAsModel_== 1); }
    void setLeafScopeAsModel(bool leafScopeAsModel) { leafScopeAsModel_= leafScopeAsModel? 1 : 0; }
    bool isHierPSTCheck() { return (hierPSTCheck_ == 1); }
    void setHierPSTCheck(bool hierPSTCheck) { hierPSTCheck_ = hierPSTCheck ? 1 : 0; }
    bool isUpfLint() { return (upfLint_ == 1); }
    void setUpfLint(bool upfLint) { upfLint_ = upfLint ? 1 : 0; }
    bool isPowerStateMerge() { return (powerStateMerge_ == 1); }
    void setPowerStateMerge(bool powerStateMerge) { powerStateMerge_ = powerStateMerge ? 1 : 0; }
    void recordScopeStartLineNo();
    bool isDollarPower2UpfFlow();
    void addBlackBoxModel(const char* model, unsigned int lineNo,
                          unsigned int fileId);
    void addXBashSyncronizerModel(const char* model, unsigned int lineNo,
                          unsigned int fileId);
    void markAsBlackBoxModels();
    void markAsXBashSynchronizers();
    void markSpiceModulesAsBlackBox();
    unsigned int      addUpfFileName(const char* name);
    bool isCurrentScopeBBox();
    // Retention generic bind checker api's
    void setRetGenericCheckerPresent()  { isRetGenericCheckerPresent_ = true; }
    bool isRetGenericCheckerPresent() const {
        return isRetGenericCheckerPresent_; }
    bool isCurrentScopeInsideBBox();
    bool isUPFHierNameinBBox(const char * name);

    const char* getDesignElementFullName(DesignElementTokenL* tokenL, bool getInstName=false, bool convertVhNameToUpper=true);
    const char* getDesignElementFullResolvedName(DesignElementTokenL* tokenL, bool getInstName=false);
    const char* getDesignElementFullTclName(DesignElementTokenL* tokenL, bool getInstName=false);
    const char* getDesignElementResidualName(DesignElementTokenL* tokenL);
    const char* getDesignElementTargetName(DesignElementTokenL* tokenL);
    const char* getDesignElementEncryptName(DesignElementTokenL* tokenL);
    DesignElementToken* createDesignElementToken(UpfTokenProp prop);
    bool hasPowerDomains() const { return !powerDomains_.isEmpty(); }
    void clearDomainBoundaryMap() { domainBoundaryMap_.detachItems(); secondaryDomainBoundaryMap_.detachItems(); }
    void setLowerDomainBoundaryData(bool val=false, const char*scope=NULL);
    LowerDomainBoundaryData* getLowerDomainBoundaryData() { return lowerDomainBoundaryData_; }
    bool isLowerDomainBoundaryEnabled() { return lowerDomainBoundaryData_->value_; }
    void initCdcInstanceDb();
    CdcInstanceDb* getCdcInstanceDb() { return cdcDb_; }
    bool isCdcCorruptionEnabled()
    { return cdcDb_ ? cdcDb_->isCdcCorruptionEnabled() : false; }
    bool hasAnyPowerDomainsAtOrBelowScope(DesignObject* dobj);
    void setNewRetentionFlow(bool b) { newRetFlow_ = b; }
    bool getNewRetentionFlow() { return newRetFlow_; }
    void setBiasBoundary(void *in, bool biasOn, int fileId, int lineNo);
    const char* getBiasBoundaryFileNameLineNo(void *instance, int &line);
    bool IsBiasBoundary(void *in) { return this->biasBoundaries_.find(in) != this->biasBoundaries_.end(); }
    bool biasBlockExists() { return !this->biasBoundaries_.empty(); }
    bool isBiasEnabled(void *in) ;
    void appendContextResetGroup (ContextResetGroup *ctxgrp) { this->contextResetGroups_.append(ctxgrp); this->isContextResetFlowEnabled_ = true; }
    bool populateTraceDownwardElements();
    void populateContextResetExclusionModels();
    void populateContextResetExclusionElements();
    void addContextResetExclusionElement(const char *s, bool isInstance, unsigned int fileId, unsigned line);
    ContextResetGroupLI getAllContextResetGroups() { return ContextResetGroupLI(this->contextResetGroups_); }
    UPFIR::DesignObjectLI getContextResetExclusionElements() { return UPFIR::DesignObjectLI(this->contextResetExcludedElems_); }
    bool isContextResetFlowEnabled() { return this->isContextResetFlowEnabled_; }
    void addContextResetExclusionModels(const char *model, const char *elem,
                                        unsigned int fileid, unsigned line);
    void clearTraceDownwardElements();
    ContextResetGroup * findContextResetGroup(const char *name);
    bool undrivenSuppliesOff() { return undrivenSuppliesOff_; }
    void setUndrivenSuppliesOff(bool b) { undrivenSuppliesOff_ = b; }
    void createScopeSrsn(PowerDomain* pd);
    void setPgForBlackBox();
    const char *getHWTopName() { return hwTopName_; }
    void setHWTopName(const char *hwTopName); 
    const char* getWrapperName() {return wrapperName_; }
    void setWrapperName(const char *wrapperName);
    void populateRetentionInfoToPidb() { return; }
    void              setCurrentFileId(unsigned int id);
    static void getCommandName(QueryCmdType cType, std::string& cmdName,  std::string& optName,
                                    std::string& objType, bool isLastToken=true);

    bool isInstanceEnableIsolsElem() {return upfIsolsAllowInstancesInElements_;}
    void resetInstanceEnableIsolsElem() {upfIsolsAllowInstancesInElements_ = false;}
    bool getDisableAppliestoWithElements() {return disableAppliestoWithElements_;}
    bool isAppliestoDefaultOutput() {return isAppliestoDefaultOutput_;}
    void setDisableAppliestoWithElements(bool val) {disableAppliestoWithElements_ = val;}
    void setAppliestoDefaultOutput(bool val) {isAppliestoDefaultOutput_ = val;}
    bool isVcsRunningRegression();
    PowerNetworkImpl();
    void addRuntimeSDA(const char *attr, const char *val);
    void printRuntimeSDA(FILE *fp);
    void printDontTouchInstances(std::ofstream& ofs, const char* instanceName);
    void dumpDontTouchInstances(std::ofstream& ofs);
    void dumpDontTouchModuleInstances(std::ofstream& ofs);
    std::string upfResolveTypeToString(UpfResolveType type) const;
    char* getStrFromHconName(char* hc);
    bool isPartialSinglePinRetention() {return isPartialSinglePinRetention_;}
    void setPartialSinglePinRetention (bool val) {isPartialSinglePinRetention_ = val;}
    bool isMacroPerfMode() { return macroPerf_; }
    void setMacroPerfMode() {macroPerf_ = true;}
    void escapeHierName(std::string* name, bool hasSupplyHandler) const;
    void unEscapeName(std::string & name);
    std::string getFullDecompileName(UPFIR::DesignObject* dObj) const;
    std::string stripPowerNetworkModelPrefix(const std::string& name) const;
    void removeDuplicatedSpaces(std::string* name) const;
    bool hasEscapedNamesOrChars(const std::string& name) const;
    const char* makeVolatileRTLDBName(const std::string& name,
        bool isImplicitName = false) const;
    double getRealCorruptionValue() { return realCorValue_; }
    void setRealCorruptionValue(double realCorValue) { realCorValue_ = realCorValue; }
    unsigned isDesignRealCorruptionEnabled() { return realCorEn_; }
    void setDesignRealCorruption(unsigned corEn) { realCorEn_ = corEn; }
    void setHasCompProfiler(bool val) { _hasCompProfiler = val ? 1 : 0; }
    bool hasCompProfiler() { return _hasCompProfiler? true : false; }
    virtual void setFastUpfObjLookup(bool val)  { _fastUpfLookup = val? 1: 0; }
    virtual bool fastUpfObjLookup()  { return _fastUpfLookup? true : false; }
    void setNlp2Compat() { nlp2Compat_ = 1; }
    bool isNlp2Compat();
    void setInitGlitchBc() { initGlitchBc_ = 1; }
    bool isInitGlitchBc() { return initGlitchBc_; }
    void setPlatoParser() {platoParser_ = 1; }
    bool isPlatoParser() { return platoParser_; }
    void setPlatoAnalysis() {platoAnalysis_ = 1; }
    bool isPlatoAnalysis() { return (platoAnalysis_ || (isPlatoParser() && getenv("SNPS_VCS_INTERNAL_ENABLE_UPF2UPFIR_SAN"))); }
    void setSdm2UpfirFlow() { isSdm2UpfirFlow_ = 1; }
    bool isSdm2UpfirFlow() {return isSdm2UpfirFlow_;}
    void setDelaySemanticsBc() { delaySemanticsBc_ = 1;}
    bool isDelaySemanticsBc() { return delaySemanticsBc_; }
    void createXoverToggleStrategies();
    void notifyNewUpfFileParsing(const char* upfFileName);
    const char* getGVar(const char* gvarName);
    BlackBoxModelLI getBlackBoxModels() { return BlackBoxModelLI(blackBoxModels_); }
    UpfFile* getUpfFileFromConfig() { return upfFile_; }
    void setUpfFileFromConfig(UpfFile* upfFile) { upfFile_ = upfFile; }
    void disableLpAssertEnabled() { isLpAssertEnabled_ = false; }
    void setPswControlPortCorruption() { isPswControlPortCorruption_ = true;}
    bool isPswControlPortCorruption() {return isPswControlPortCorruption_;}
    void setPswRelatedSupplyPrimary();
    bool isPswRelatedSupplyPrimary() {return isPswRelatedSupplyPrimary_;}
    bool doPlatoUpfToSan();
    void registerUninstantiatedModel(const char* modelName);
    bool getUninstantiatedModelsIter(std::list<std::string>::const_iterator& begin,
            std::list<std::string>::const_iterator& end);
    void setVhClkVlIsoCdcName(char *vlogClock,char *vlPnmClock) {(*vhClkVlIsoCdcNameMap_)[std::string(vlogClock)] = std::string(vlPnmClock);}
    VhVlCdcClkNameMap* getVhClkVlIsoCdcMap() { return vhClkVlIsoCdcNameMap_; }
    void setVlClkVhIsoCdcName(char *vlogClock,char *vlPnmClock) {(*vlClkVhIsoCdcNameMap_)[std::string(vlogClock)] = std::string(vlPnmClock);}
    VhVlCdcClkNameMap* getVlClkVhIsoCdcMap() { return vlClkVhIsoCdcNameMap_; }
    void setToggleReportEnabled() { isToggleReportEnabled_ = true;}
    bool isToggleReportEnabled() {return isToggleReportEnabled_;}
    void setAssertResetSequenceEnabled() { isAssertResetSequenceEnabled_= true;}
    bool isAssertResetSequenceEnabled() {return isAssertResetSequenceEnabled_;}

    int evalTclCmd(const char* cmd); 
private:
    unsigned int      getCoverageOption() { return coverage_options_; }
    void              clearElementTable();
    void              clearRetElementTable();
    void              print() const;
    void              populateNlpKeywords();
    void              clearNlpKeywords();
    void              populateNlpGenericNametable();
    void              clearNlpGenericNames();

    void              buildPowerDomainNameMap() const;

    void setLogFile(FILE* logFile);
    static unsigned int upfHashFunc(const char *name);
    static bool upfHashEqnFunc(const char *name1, const char *name2);

    void buildUpUpfObjMap();
    void buildUpUpfObjMapRecursive(PowerScope *ps);
    void AddUpfObj2Map(unsigned int fileId, unsigned int lineNo, UpfNamedObj* obj);
    ReInitInfo* findReInitInfo(DesignScope* dScope);
    ReInitInfo* findDontReInitInfo(DesignScope* dScope);
    bool isAutoComplete() { return isAutoComplete_; }
    void enableAutoComplete() { isAutoComplete_ = true; }
    void addDLForLpObj(PowerScope* ps, const char* objName,
                       const unsigned int lineNo, const char* fileName,
                       const CharL* scopeL,  const bool isVerilogHdl,
                       bool& isDriverAdded);
    void dumpUpfPowerDomainCmds(std::ofstream& ofs) const;
    void dumpSetPowerTopCmd(std::ofstream& ofs) const;
    bool checkPowerDomainForPowerTop(DesignObjectLI& dObjI, DesignObject* topObj);
private:
    INSTANCE_BIAS_BOUNDARY_MAP        biasBoundaries_;
    DesignScopeTableP  designScopes_;
    DesignObjectTableP *designObjects_;    
    std::map<unsigned ,DesignScope* > designScopesMap_;
    char               *designTop_;
    char               *workDir_;
    char               *reportsDir_;
    char         *hwTopName_;
    char         *wrapperName_;
    std::string        currentScope_;
    std::string        prevCurrentScope_;
    SupplyNetAnalysis* supplyNetAnalysis_;
    NameFormat         *nameFormat_;
    PowerScopeL        topPowerScopesL;
    PowerScopeL        powerModelsL;
    PowerDomainL       powerDomains_;
    LevelShifterL      levelShifters_;
    IsolationL         isolations_;
    SRSNStrategyL      srsns_;
    RetentionL         retentions_;
    RetentionElementsL retentionsElements_;
    PowerStateTableL   powerStateTables_;
    PowerScopeTableL   powerScopeNameHashTable_;
    std::map<void*, PowerScope*> instancePointerVsPowerScopeTable_;
    DesignObjectTableL designObjectNameHashTable_;
    Hdl2UpfVctL        hdl2UpfVcts_;
    Upf2HdlVctL        upf2HdlVcts_;
    BindCheckerL       bindCheckers_;
    SaveUpfL           saveUpfs_;
    LoadUpfL           loadUpfs_;
    PowerSwitchL       powerSwitches_;//This is all switches in PN
    DesignModelTableL     upfModels_; // This is for SimState Behavior For actual design Modules
    DesignObjectL     alwaysOnObjs_;
    DesignObjectL     resetWaiverObjs_;
    DesignObjectL     isoDisResetWaiverObjs_;
    DesignObjectL     isoDisClockWaiverObjs_;
    ReInitInfoL            reInitInfos_;
    ReInitInfoL            dontreInitInfos_;
    charL              insideBBoxModels_;
    ScopeTable*        scopes_;
    int                designPortCount_;
    int                powerSwitchCount_;
    int                powerDomainCount_;
    int                isolationStrategyCount_;
    int                srsnStrategyCount_;
    int                levelshifterStrategyCount_;
    int                retCount_;
    unsigned int       designScopeCount_;
    unsigned           clockCycleOnIsoDisable_;
    lpmsg::LpMsgController*    msgController_;
    std::vector<PowerDomain*>  powerDomainVec_;
    std::vector<PowerSwitch*>  powerSwitchVec_;
    std::vector<IsolationStrategy*>  isolationStrategyVec_;
    std::vector<BindChecker*>  bindCheckerStrategyVec_;
    std::vector<SRSNStrategy*>  srsnStrategyVec_;
    std::vector<RetentionStrategy*>  retrntionPolicyVec_;
    std::vector<LevelShifterStrategy*> levelshifterStrategyVec_;
    STATE_PROPAGATION_MAP statePropagationMap_;
    DscopeSportTable        *dScopeSupplyPortTable_;
    DesignScopeL lowerDomainTrueList_;
    DesignScopeL lowerDomainFalseList_;
    DesignScopeL terminalBoundaryList_;
    UpfDesignPortTableL       designPorts_;
    std::vector<UpfDesignPort*> designPortVecForOrder_;
    std::vector<UpfDesignPort*> designPortVec_;
    PtrMap<void*, PowerDomain*> domainBoundaryMap_;
    PtrMap<void*, PowerDomain*> secondaryDomainBoundaryMap_;
    PtrMap<void*, DesignObject*> designObjectsMap_;
    PtrMap<void*, RetentionElements*> retentionElementsMap_;
    UpfLogicPortTableL        logicPorts_;
    std::vector<char*> upfFileTable_;
    std::list<MacroModelInfo *> macroModelInfoList_;
    std::list<std::string>     uninstantiatedMods_;
    DesignModelL macroModels_;
    std::set<void*> ancestorDesignHash_;
    std::string baseDir_;
    std::string lpaBindTcl_;
    std::string lpaBindFileList_;
    //Testcase Log and Query - Begin
    std::string commandLog_;
    std::string collectLog_;
    std::string queryLog_;
    //Testcase Log and Query -End

    //Dump UPF
    std::string dumpPreUPF_;
    //End Dump UPF

    unsigned           randomSeed_;
    unsigned int isoNotClampedAssertion_:1;
    CorruptionType     corType_;
    unsigned int       levelAsEdge_ :1;
    unsigned int       buffersAsGates_ :1;
    unsigned int       zebuLpFlow_:1;
    unsigned int       seqBuffersAsPassThrough_:1;
    unsigned int       constantsInDomain_ :1;
    unsigned int       corEn_ :1;
    unsigned int       isUpfDesignTop_:1;
    unsigned int       isDbInfoPresent_:1;
    unsigned int       isRtlPGMode_:1;
    unsigned int       verboseMode_:3;
    unsigned int       currentFileId_:12;
    unsigned int       isVlogPad_:1;
    unsigned int       designReinit_:1;
    unsigned int       disableCoa_:1;
    unsigned int       partCompFlow_:3; //00-> non partcomp
    //01->FULL_DR
    //10->CHILD Design
    //11->CHILD PNM
    //100->CHILD TB
    unsigned int       hasDummyPowerTop_:1;
    unsigned int       pbpCorrupt_:2; //00 -> undefined
    //01 -> TRUE so corrupt everything
    //10 -> FALSE so dont corrupt anything
    //11 -> unused
    unsigned int       hasPolicyOnInterfModport_:1;
    unsigned int       hasFanoutPolicy_:1;
    unsigned int       hasPathBasedPolicy_:1;
    unsigned int       partialOnAsFullOn_:1;
    unsigned int       apfCompat_: 1;
    unsigned int       vhdlIntegerCorrupt_:2;
    unsigned int       norIsolation_: 1;
    unsigned int       logicExprDrivesSupplyExpr_: 1;
    unsigned int       voltageBasedSupplyOn_:1;
    unsigned int       nameBasedSourceSink_ : 1;
    unsigned int       isSSDefaultON_:1;
    unsigned int       correlatedGroupsDefined_:1;
    unsigned int       leafScopeAsModel_:1;
    unsigned int       hierPSTCheck_:1;
    unsigned int       upfLint_:1;
    unsigned int       powerStateMerge_:1;
    unsigned int       lpCov_:1;
    unsigned int       covg_enable_lp_cg_:1;
    unsigned int       pgsim_:1;
    unsigned int       disableSRSN_:1;
    unsigned int       treatUndrivenAsUndetermined_:1;
    unsigned int       treatUndrivenSupplyNetAsUndetermined_:1;
    unsigned int       isUnassociatedIsoOn_:1;
    unsigned int       isDesignDebugEnabled_:1;
    unsigned int       isMixedHdl_:1;
    unsigned int       srsnOutsidePort_:1;
    unsigned int       srsnLocationSelf_:1;
    unsigned int       unconnBiasPinsOn_:1;
    unsigned int       powerOptMode_:1;
    unsigned int       clampCheckOnEnable_:1;
    unsigned int       clampCheckOnDisable_:1;
    unsigned int       checkPowerDownWrite_:1;
    unsigned int       isDiscretePortStates_:1;
    unsigned int       lowVoltageLevel_;
    unsigned int       highVoltageLevel_;
    int                activeResetDuration_;
    int                inactiveResetDuration_;
    unsigned int       coverage_options_;
    unsigned int       newRetFlow_:1;
    HashTableP<char>   *elementTable_;
    RETMAP             retElemMap_;
    HashTableP<char>   *nlpKeyWordsTable_;
    HashTableP<char>   *nlpGenericNames_;
    mutable std::map<std::string, PowerDomain*>* _powerDomainNameMap;
    PowerScopeTable    *powerScopeTable_;
    DesignObject        *cScope_;
    PowerScope         *cPowerScope_;
    PowerScope         *cPowerTop_;
    DesignObject        *pScope_;
    DesignObject        *dTop_;
    UpfHdlType         hdlType_;
    AssertControlType  assertControl_;
    Upf2SvInbuiltType   pwrUpf2SvVct_;
    Upf2SvInbuiltType   gndUpf2SvVct_;
    Sv2UpfInbuiltType   pwrSv2UpfVct_;
    Sv2UpfInbuiltType   gndSv2UpfVct_;
    Upf2VhInbuiltType    pwrUpf2VhVct_;
    Upf2VhInbuiltType    gndUpf2VhVct_;
    Vh2UpfInbuiltType    pwrVh2UpfVct_;
    Vh2UpfInbuiltType    gndVh2UpfVct_;
    ForceSemanticType    forceSemanticsConfigType_;
    LowerDomainBoundaryData* lowerDomainBoundaryData_;
    CdcInstanceDb          *cdcDb_;
    bool            vcsRunningRegression_;
    bool            isUpfRead_;
    bool            isMonetFlow_;
    bool            hierModelConsistencyFlow_;
    bool            ignoreBboxMsgs_;
    bool            isMixadAmsFlow_;
    bool            enableConservativeDiffSupply_;
    bool            ignoreCsnError_;
    bool            allowInstanceIsoLs_;
    bool            allUpfError_;
    bool            allUpfErrorProceed_;
    bool            allowUpfLRMExtn_;
    bool            enableAppliesToDefaultOutputsOrBoth_;
    bool            enableUpfPortabilityMsg_;
    bool            setNpIsoGiven_;
    bool            setNpLsGiven_;
    bool            hasCoaDisabled_;
    bool            setNpSrsnGiven_;
    bool            isPBPOpt_;
    bool            isLpAssertEnabled_;
    bool            isRetSupCorr_;
    bool            isAnyRetCondPresent_;
    bool            isAnyBCForIsoWithGenericPresent_;
    bool            undrivenSuppliesOff_;
    bool            upfIsolsAllowInstancesInElements_;
    bool            disableAppliestoWithElements_;
    bool            isAppliestoDefaultOutput_;
    bool            goldenUpfFlow_;
    bool            isUcpFlow_;
    bool            bcEnableOldVhdlImpl;
    char*     designTopName_;
    //bool            isDbInfoPresent_;
    char*            customAssertFile_;
    bool             strictDbMatch_;
    bool             upfError_;
    UpfParsingMode   parsingMode_;
    UpfParsingFileMode parsingFileMode_;
    UpfReaderIf*     reader_;   // Upf Reader Pointer. This needs to be deleted by PowerNetwork
    UpfProductInfo*   product_;
    UpfFile*          upfFile_;
    SimModeType       simMode_;
    static UpfDesignAdapter*  da_;
    static bool disableParsingNotice_;
    static char        *toolTop_;
    static FILE* logFile_;
    static LifeGuard*         lg_;
    static ExitFunctionCB     exitFunc_;
    static char*              vcsHome_;
    static int       vcsVerboseLevel_;
    std::map<std::string, std::string> deletedScopeNameMap_;
    VhVlCdcClkNameMap *vhClkVlIsoCdcNameMap_;
    VhVlCdcClkNameMap *vlClkVhIsoCdcNameMap_;


    BlackBoxModelL   blackBoxModels_;
    BBMODELINFOMAP   blackBoxModelMap_;
    BBMODELINFOMAP   xbashModelMap_;

    static UpfClassType       classType_;
    static PowerNetworkImpl*  powerNetwork_; //This will hold top PN
    XoverGateL                lsGatesL_;
    bool                      isRetGenericCheckerPresent_;
    UPFFILESCOPEMAP           upfFileScopeMap_;
    LSMAP                     lsMap_;
    UPFFILEOBJMAP             upfFileObjMap_;
    UPFFILENAMEINDEXMAP       upfFileNameIndexMap_;
    bool                      issueErrorForNetType_;
    bool                      isAutoComplete_;
    unsigned int              _currentSearchInsideBbox:1;
    ContextResetGroupL contextResetGroups_;
    UPFIR::DesignObjectL contextResetExcludedElems_;
    BBMODELINFOMAP contextResetExcludedElemsInString_;
    BBMODELINFOMAP contextResetExcludedInstancesInString_;
    std::list<std::pair<MODEL_ELEM_PAIR, BBFILELINEPAIR> > contextResetExcludeModelElems_;
    bool isContextResetFlowEnabled_;
    void markModels(bool isBlackBox, BBMODELINFOMAP &blackBoxModelMap);
    MODEL_ELEM_PAIR_LIST runtimeSDAList_;
    bool            isPartialSinglePinRetention_;
    unsigned int    enableHeteroFanout_:1;
    unsigned int    isDefaultAppliesToDontFilter_:1;
    unsigned int    macroPerf_:1;
    unsigned int    _currentFileEncrypted:1;
    unsigned int    _showEncrypted:1;
    unsigned int    _testDecryption:1;
    std::stack<bool> _encryptionStack;
    double           realCorValue_;
    unsigned int       realCorEn_ :1;
    unsigned int       nlp2Compat_ :1;
    unsigned int       initGlitchBc_ :1;
    unsigned int       platoParser_:1;
    unsigned int       platoAnalysis_:1;
    unsigned int       isSdm2UpfirFlow_:1;
    unsigned int       delaySemanticsBc_:1;
    unsigned int       hasAnyPowerBBox_:1; // Flag to check if design has any module marked as black box to optimise design traversal
    unsigned int    _hasCompProfiler:1;
    unsigned int    _fastUpfLookup:1;
    unsigned int       useUpfQueryData_:1;
    unsigned int       isMvAllowPgPinReconnect_:1;
    unsigned int       isPswRelatedSupplyPrimary_:1; //Flag to check if primary should be used(related for ack port)
    unsigned int       isPswControlPortCorruption_:1; //Flag to check if implicit supply set for psw should be used
    unsigned int       isToggleReportEnabled_:1; 
    unsigned int       isAssertResetSequenceEnabled_:1; 

public:
    static void resetPowerNetwork();
    static void resetClassType();
    static void resetExitFunctionCB();
    static void resetLifeGuard();
    static void resetVcsHome();
    static void resetVcsVerboseLevel();
    static void resetVcsVerboseLevel_();
    static void resetLogFile();
    static void resetUpfDesignAdapter();
    static void resetToolTop();
    static void resetDisableParsingNotice();

    UpfDesignAdapter* getPowerNetworkDesignAdapter() { return da_; }
    static UpfDesignAdapter* getDesignAdapter() { return da_; }
    static LifeGuard*        getCurrentLifeGuard() { return lg_; }
    static void setLifeGuard(LifeGuard* lg) { lg_ = lg; }
    friend void PowerNetwork::cleanup();
    friend class DesignElementTOkenImpl; 
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, levelAsEdge_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isoNotClampedAssertion_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isUpfDesignTop_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, corEn_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, buffersAsGates_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, zebuLpFlow_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, seqBuffersAsPassThrough_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, constantsInDomain_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isVlogPad_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, designReinit_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, disableCoa_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, pbpCorrupt_, 2);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, partialOnAsFullOn_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, apfCompat_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, vhdlIntegerCorrupt_, 2);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, norIsolation_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, logicExprDrivesSupplyExpr_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, voltageBasedSupplyOn_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, treatUndrivenAsUndetermined_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, treatUndrivenSupplyNetAsUndetermined_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isUnassociatedIsoOn_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isDesignDebugEnabled_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isMixedHdl_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, nameBasedSourceSink_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isDbInfoPresent_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isRtlPGMode_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isSSDefaultON_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, pgsim_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, correlatedGroupsDefined_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, leafScopeAsModel_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, upfLint_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, lpCov_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, newRetFlow_, 1);
     VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, disableSRSN_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, srsnOutsidePort_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, srsnLocationSelf_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, unconnBiasPinsOn_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, powerOptMode_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, clampCheckOnEnable_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, clampCheckOnDisable_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, checkPowerDownWrite_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, _currentSearchInsideBbox, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, undrivenSuppliesOff_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, hasPolicyOnInterfModport_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, hasFanoutPolicy_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, hasPathBasedPolicy_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, enableHeteroFanout_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, _currentFileEncrypted, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, _showEncrypted, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, realCorEn_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, nlp2Compat_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, initGlitchBc_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isSdm2UpfirFlow_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, delaySemanticsBc_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, useUpfQueryData_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isMvAllowPgPinReconnect_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isPswRelatedSupplyPrimary_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isToggleReportEnabled_, 1);
    VCS_DECL_BITFIELD(PowerNetworkImpl, unsigned int, isAssertResetSequenceEnabled_, 1);
};

class PowerNetworkForIPPartitionImpl: public PowerNetworkForIPPartition
{
public:
    static PowerNetworkImpl* getPnmIpPtr() ;
    static void cleanup();

private:
    static PowerNetworkImpl* pnmIp_;
};

class NameFormatImpl:public NameFormat
{
public:
    VCS_DECL_SERIALIZABLE(NameFormatImpl);
    void serialize(ser::Archive&);
    NameFormatImpl(): isoPrefix_(NULL),isoSuffix_(NULL), lsPrefix_(NULL), lsSuffix_(NULL){;}
    NameFormatImpl(char *isoP, char *isoS, char *lsP, char *lsS);
    ~NameFormatImpl();
    const char* getKindStr() const {return ppiKindP[classType_];}
    UpfClassType getUpfClassType() const;
    const char* getFileName() const;
    unsigned int getLineNo() const;
    const char* getIsolationPrefix() const {return isoPrefix_;}
    const char* getIsolationSuffix() const {return isoSuffix_;}
    const char* getLevelShiftPrefix() const {return lsPrefix_;}
    const char* getLevelShiftSuffix() const {return lsSuffix_;}
private:
    char *isoPrefix_;
    char *isoSuffix_;
    char *lsPrefix_;
    char *lsSuffix_;
    static UpfClassType      classType_;
};

class BiasBoundary
{
public:
    BiasBoundary(void *instance, bool enabled, int fileid, int line);
    ~BiasBoundary() {};
    bool isEnabled() { return this->en_;}
    int getFileId() { return this->fileid_; }
    int getLineNo() { return this->line_; }
private:
    bool en_;
    int fileid_;
    int line_;
    void *inst_;
};

class ContextResetGroupImpl : public ContextResetGroup
{
public:
    VCS_DECL_SERIALIZABLE(ContextResetGroupImpl);
    void serialize(ser::Archive&);
    ContextResetGroupImpl(const char *name, unsigned int line, unsigned int file) ;
    ContextResetGroupImpl() {name_ = NULL;}
    ~ContextResetGroupImpl();
    const char* getName() const { return this->name_ ; }
    void appendTraceDownwardElement(DesignObject *obj) { this->traceDownwardElems_.append(obj); }
    void appendTraceDownwardElementasString (const char *s);
    bool populateTraceDownwardElements();
    DesignObjectLI getAllTraceDownwardElement() { return DesignObjectLI(this->traceDownwardElems_) ; }
    const char *getFileName() const { return NULL;}
    unsigned int getLineNo() const { return line_; }
    UpfClassType getUpfClassType() const { return classType_;}
    const char* getKindStr() const {return ppiKindP[classType_];}
private :
    char *name_;
    DesignObjectL traceDownwardElems_;
    charL  traceDownwardElemsInString_;
    unsigned int line_;
    unsigned int  file_;
    static UpfClassType classType_;
};


class MacroModelInfo:public virtual ser::Serializable
{
public :
    VCS_DECL_SERIALIZABLE(MacroModelInfo);
    void serialize(ser::Archive&);
    MacroModelInfo() { this->fileName_ = NULL; this->macroName_ = NULL; this->corr_type_ = FULL_UPF; }
//    UpfClassType getUpfClassType() const { return cUpfClassType; }
    MacroModelInfo(const char *fileName, const char *macroName,
                                        MacroCorruptionType corr_type) ;
    ~MacroModelInfo();
    const char *getMacroName() { return this->macroName_;}
    const char *getMacroUpfFileName() { return this->fileName_; }
    MacroCorruptionType getCorruptionType() { return this->corr_type_; }
private :
    char *fileName_;
    char *macroName_;
    MacroCorruptionType corr_type_;
};

class BlackBoxModelImpl : public BlackBoxModel
{
public:
    VCS_DECL_SERIALIZABLE(BlackBoxModelImpl);
    void serialize(ser::Archive&);
    BlackBoxModelImpl() {;}
    BlackBoxModelImpl(const char *name, unsigned int fileid, unsigned int lineNo);
    ~BlackBoxModelImpl() {;}
    const char* getKindStr() const {return ppiKindP[classType_];}
    UpfClassType getUpfClassType() const;
    const char* getFileName() const;
    unsigned int getLineNo() const;
    const char* getName() { return modelName_.c_str(); }
private:
    std::string modelName_;
    unsigned    file_line_;
    static UpfClassType classType_;
};

class UpfFileImpl : public UpfFile
{
public:
    UpfFileImpl(const char* upfFile, const char* suppFile, const char* scope, const char* target, bool strictChecks);
    ~UpfFileImpl() {}
    const char* getFileName() { return upfFile_.c_str(); }
    const char* getSupplementalFileName() { return sUpfFile_.c_str(); }
    const char* getScope() { return scope_.c_str(); }
    const char* getTarget() { return target_.c_str(); }
    bool strictChecks() { return strictChecks_; }
private:
    std::string upfFile_;
    std::string sUpfFile_;
    std::string scope_;
    std::string target_;
    bool        strictChecks_;
};

class StatePropagationInfo
{
public:
    //TODO: Used only in compile-time. Add serialize when needed.
    StatePropagationInfo(bool val, std::string name, bool is_verilog) :value_(val),
                           flagged_(false),
                           aps_found_(false),
                           is_verilog_(is_verilog),
                           file_line_(getFileLine()),
                           resolvedName_(name)
    {}
    ~StatePropagationInfo() {}

    bool isVerilog() { return is_verilog_; }
    bool getValue() { return value_; }
    void updateValue(bool val) { value_ = val; }
    
    bool isSupplySetStateSpecified() { return aps_found_; }
    void setSupplySetStateSpecified (bool val) {aps_found_ = val;}
    const char* getFileName() const
    {
        return PowerNetworkImpl::getInstance()->getFileName((file_line_ & 0xfff00000) >> 20);
    }
    unsigned int getLineNo() const { return file_line_ & 0x000fffff; }
    const char* getResolvedName() const { return resolvedName_.c_str(); }
    bool isAlreadyFlagged() const { return flagged_; }
    void setAlreadyFlagged() { flagged_ = true; }
private:
    bool value_; //attribute value
    bool flagged_; //check for repeat violations of UPF_IUESPA
    bool aps_found_; //check for repeat violations of UPF_IUESPA
    bool is_verilog_;
    unsigned int file_line_; 
    std::string resolvedName_;
};



void loadOrSaveStr(ser::Archive& ar, char *&str);
void loadOrSaveStrList(ser::Archive& ar, charL& strL);
char *createStrFromUpfLifeGuard(char *d, const char *s);
NAMESPACE_UPFIR_END
char *fixInstNameForLogicNet(const char *name);

#endif
# 1550 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/PowerNetwork.hh"
# 12 "./CpfPowerNetwork.hh" 2
#if 0 /* expanded by -frewrite-includes */
#include "CpfDomainMappingMgr.hh"
#endif /* expanded by -frewrite-includes */
# 12 "./CpfPowerNetwork.hh"
# 1 "./CpfDomainMappingMgr.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author : Rajaditya Mukherjee

#ifndef _CPFDOMAINMAPPINGMGR_HH_
#define _CPFDOMAINMAPPINGMGR_HH_
#if 0 /* expanded by -frewrite-includes */
#include "CpfDomainMappingObj.hh"
#endif /* expanded by -frewrite-includes */
# 10 "./CpfDomainMappingMgr.hh"
# 1 "./CpfDomainMappingObj.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author : Rajaditya Mukherjee

#ifndef _CPFDOMAINMAPPINGOBJ_HH_
#define _CPFDOMAINMAPPINGOBJ_HH_
using namespace UPFIR;

NAMESPACE_CPFIR_BEGIN

class CpfDomainMappingObjImpl : public UpfObj
{
public:
    VCS_DECL_SERIALIZABLE(CpfDomainMappingObjImpl);

    void                    addBlockLevelDomain     (int bdID )     { blockLevel_.push_back(bdID);      }
    void                    setTopLevelDomain       (int domID)     { topLevel_=domID;                  }
    void                    setGroupID              (int gpID)      { groupID_ = gpID;                  }
    int                     getTopLevelDomain       () const        { return topLevel_;                 }
    int                     getGroupID              () const        { return groupID_;                  }
    const std::vector<int>& getBlockLevelDomains    () const  { return blockLevel_;           }
    bool                    isTopLevel              ()              { return (topLevel_==0)?true:false; }
    //Will be defined in CC files
    CpfDomainMappingObjImpl();
    void serialize(ser::Archive&);
    void print();
    // ????
    UpfClassType getUpfClassType() const { return UpfNamedObjC; }
    unsigned int getLineNo()  const { return 0;}
    const char*  getFileName() const {return 0;}
    const char*  getKindStr() const {return 0 ;}
private :
    int                 topLevel_;
    std::vector<int>    blockLevel_;
    int                 groupID_;
};

NAMESPACE_CPFIR_END
#endif
# 43 "./CpfDomainMappingObj.hh"
# 11 "./CpfDomainMappingMgr.hh" 2
using namespace UPFIR;

NAMESPACE_CPFIR_BEGIN

class CpfDomainMappingMgrImpl : public DomainMappingMgr
{
public :
    VCS_DECL_SERIALIZABLE(CpfDomainMappingMgrImpl);
    void serialize(UPFIR::ser::Archive&);
    int  getTopLevelID   (int pid)
    {
        return (allDomains_.size() > (unsigned)pid) ? (allDomains_[pid]->getTopLevelDomain()) : 0;
    }
    const std::vector<int>& getBlockLevelIDs(int pid)
    {
        return (allDomains_.size() > (unsigned)pid) ? allDomains_[pid]->getBlockLevelDomains() : allDomains_[0]->getBlockLevelDomains();
    }
    int getProcessedCount()             { return allDomains_.size();}
    PowerDomainLI    getTopLevelIDs  ();
    CpfDomainMappingMgrImpl();
    bool makeEquivalent(int topPID,int blockPID);
    bool isEquivalent(int pid1,int pid2);
    void print();
    CpfDomainMappingObjImpl* getMappingObjByID(int id) {return allDomains_[id];}
    // ????
    UpfClassType getUpfClassType() const { return UpfNamedObjC; }
    unsigned int getLineNo()  const { return 0;}
    const char*  getFileName() const {return "Undefined File name";}
    const char*  getKindStr() const {return "Undefined";}

private :
    std::vector<CpfDomainMappingObjImpl*>   allDomains_;
    PowerDomainL                            allTopDomains_;
};

NAMESPACE_CPFIR_END

#endif
# 49 "./CpfDomainMappingMgr.hh"

# 13 "./CpfPowerNetwork.hh" 2
#define GET_CPF_LIFE_GUARD upfir::PowerNetworkImpl::getCurrentLifeGuard()

using namespace UPFIR;

NAMESPACE_CPFIR_BEGIN

class CpfPowerNetworkImpl: public UPFIR::PowerNetwork
{
public:
    //unimplimented UPF interfaces
    VCS_DECL_SERIALIZABLE(CpfPowerNetworkImpl);

    bool populateUPFIRfromPlatoSDM(void*, void*, void*, const char* reportsDir){return false;}
    //Plato Upf to SAN
    UpfSupplySource* createSupplySource(unsigned id, unsigned corrGrpId, unsigned eqSuppId,
            UpfResolveType, bool isPwr, bool isGnd, bool hasEqSupps) { return NULL; }
    UpfRootSupplyDriver* createRootSupplyDriver(UpfSupplySource* ssrc, unsigned id, SupplyNet* net, UpfRootSupplyDriverType type) { return NULL; }
    UpfRootSupplyDriver* createRootSupplyDriver(UpfSupplySource* ssrc, unsigned id, SupplyPort* net, UpfRootSupplyDriverType type) { return NULL; }

    //End Plato Upf to SAN

    void setInstSupportForIsoLsInMonetFlow(bool flag) {}
    bool instanceSupportForIsoLsInMonetFlow() {return false;};
    bool isUfeFlow() const { return false; }
    bool isUcpFlow() { return false; }
    bool isUc15Flow() { return false; }
    const char *getHWTopName() { return 0; }
    void setHWTopName(const char *hwTopName) {}
    const char* getWrapperName() {return 0; }
    void setWrapperName(const char *wrapperName) {}
    void setNewRetentionFlow(bool b) { newRetFlow_ = b; }
    bool getNewRetentionFlow() { return newRetFlow_; }
    void setCoverageOption(unsigned int i) { assert(0); }
    unsigned int getCoverageOption() { assert(0); return 0; }
    bool isPowerStateTableTransitionCoverage() {return false;}
    bool isPowerStateTableStateCoverage() {return false;}
    virtual bool isMonetFlow() {return false;}
    virtual bool ignoreBboxMsgs() {return false;}
    virtual bool isHierModelConsistencyFlow() {return false;}
    virtual bool isUpfLRMExtensionAllowed() const { return false; }
    virtual void setAllowUpfLRMExtension(bool flag) { assert(0); }
    virtual bool isEnableAppliesToDefaultOutputsOrBoth() const { return false; }
    virtual void setEnableAppliesToDefaultOutputsOrBoth(bool flag) { assert(0); }
    virtual bool isHeteroFanoutEnabled() {return false;}
    virtual bool isDefaultAppliesToDontFilter() {return false;}
    virtual bool isConservativeDiffSupplyEnabled() { return false; }
    bool isIsoNotClampedAssertion() { return false;}
    void setIsoNotClampedAsertion(bool b) {}
    virtual void setMonetFlow(bool flag) {assert(0);};
    virtual void ignoreBboxMsgs(bool flag) {assert(0);}
    virtual void setHierModelConsistencyFlow(bool flag) {assert(0);}
    FILE* generateReportWithBanner(const char*, const char*, const char*, const char*) {assert(0); return 0;}
    virtual bool ignoreCsnError() {assert(0); return false;}
    virtual void setIgnoreCsnError(bool flag) {assert(0);};
    virtual void setAllUpfError(bool flag) {assert(0);};
    virtual void setAllUpfErrorProceed(bool flag) {assert(0);};
    virtual bool allUpfError() {assert(0);return false;}
    virtual bool allUpfErrorProceed() {assert(0);return false;}
    void closeReport(FILE*) {assert(0); }
    UPFIR::UpfProductInfo* getProductInfo() {assert(0); return 0;}
    void setUpfProduct(upfir::UpfProductInfo*) {assert(0);}
    bool getVoltageRangeForSupplyNet(upfir::SupplyNet*, float&, float&)
    {assert(0); return false;}
    bool readUpfFile(const char *upfFileName) {assert(0); return false;}
    bool readTopLevelUpfFile(const char* upfFileName, bool isUpfFile) {assert(0); return false;}
    void applySimstateBehaviors() {assert(0); }
    bool readRuntimeConfig(const char *upfFileName) {assert(0); return false;}
    char* lookupNameDB(char* alias) {assert(0); return 0;}
    char* lookupXmrInNameDB(const char* alias, int& type) {assert(0); return 0;}
    bool readPowerConfigFile(const char *configFileName);
    void setUpfParsingMode(UpfParsingMode mode) {assert(0);}
    bool applyBind(UPFIR::BindChecker *bc)  {return false;}
    unsigned getRandomCorruptionSeed() { return 0;}
    void setRandomCorruptionSeed(unsigned) {assert(0);}
    CorruptionType getRandomCorruptionType() { return Corrupt_X_C;}
    void setRandomCorruptionType(CorruptionType corType) {assert(0);}
    unsigned enableDesignRandomCorruption() {return 0;}
    void setDesignRandomCorruption(unsigned corEn) {assert(0);}
    PowerConfig* getPowerConfig();
    lpmsg::LpMsgController* getLpMsgController() { return msgController_; }
    void setLpMsgController(lpmsg::LpMsgController* msgController) { msgController_ = msgController; }
    UPFIR::PowerDomain* isPowerBoundaryElement(void*) {return NULL;}
    void* getParentInstance(void* inst, UPFIR::DESIGN_TREE_TYPE designTreeType, bool& isVlog) {return NULL;}
    bool  isUnderDesignTop(void *inst, bool isInstVlog) { return false; }
    ReInitInfoLI getReInitInfos() {return ReInitInfoLI(reInitInfos_);}

    ReInitInfoLI getDontReInitInfos() {return ReInitInfoLI(dontreInitInfos_);}

    bool checkReInitEnabledOnIp(void* ip, char* modelName);

    void setDesignReinit(bool reinit) { designReinit_ = reinit;}
    void setDesignDontReinit(bool reinit) {designReinit_ = reinit ? false : true;}
    bool isDesignReinit() {return designReinit_;}
    void setDesignDisableCoa(bool b) { }
    bool isDesignDisableCoa() { return false; }

    void makeReInitInfo(DesignScope* dScope, char* nbName);
    void makeDontReInitInfo(DesignScope* dScope, char* nbName);
    void addReInitInfo(ReInitInfo* obj) { reInitInfos_.append(obj); }
    void addDontReInitInfo(ReInitInfo* obj) { dontreInitInfos_.append(obj); }
    ReInitInfo* findReInitInfo(DesignScope* dScope);
    ReInitInfo* findDontReInitInfo(DesignScope* dScope);

    void setAssertionControl(AssertControlType b) {assert(0);}
    AssertControlType getAssertionControl() const  {return AssertNoControlC;}
    void setForceSemanticConfig(ForceSemanticType b)  { assert(0); }
    ForceSemanticType getForceSemanticConfig() const   { return NoForceSemanticC; }
    bool checkForNetTypeObj(DesignObject* dObj) { return false; }
    void checkForNetTypePorts(DesignObject* d, ApplyDirectionType apd) {assert(0);}
    void addDLForLpObj(const char* objName, const unsigned int lineNo, const char* fileName, const CharL* scopeL, const bool isVerilogHdl) {assert(0); }
    void addDLForLpObj(PowerScope* ps, const char* objName, const unsigned int lineNo, const char* fileName, const CharL* scopeL, const bool isVerilogHdl, bool& isDriverAdded) {assert(0); }
    LpSourceInfo* createLpSourceInfoObj(unsigned int file_line, void* obj) {assert(0); return 0;}
    void createScopeSrsn(PowerDomain* pd) {assert(0);}
    void setPgForBlackBox() {assert(0);}
    void setBuffersAsGates(unsigned) {assert(0);}
    int getInactiveResetDuration() {assert(0); return 0;}
    int getActiveResetDuration() {assert(0); return 0;}
    void setZebuLpFlow(bool val) {}
    virtual unsigned getZebuLpFlow() { return 0; }
    void dumpUpfForZebu(const char* fileName) {}
    unsigned buffersAsGates() {assert(0); return 0;}
    void setSequentialBuffersAsPassTrough(unsigned) {assert(0);}
    unsigned sequentialBuffersAsPassTrough() {assert(0); return 0;}
    void setConstantsInDomain(unsigned) {assert(0);}
    unsigned constantsInDomain() {assert(0); return 0;}
    DesignObjectLI getAlwaysOnObjects() {assert(0); return 0;}
    void addDontTouchObject(DesignObject* dobj) {assert(0);}
    DesignObjectLI getResetWaiverObjects() {assert(0); return 0;}
    void addResetWaiverObject(DesignObject* dobj) {assert(0);}
    DesignObjectLI getIsoDisResetWaiverObjects() {assert(0); return 0;}
    void addIsoDisResetWaiverObjects(DesignObject* dobj) {assert(0);}
    DesignObjectLI getIsoDisClockWaiverObjects() {assert(0); return 0;}
    void addIsoDisClockWaiverObjects(DesignObject* dobj) {assert(0);}
    unsigned getClockCycleOnIsoDisable() {assert(0);} 
    void setClockCycleOnIsoDisable(unsigned cycle) {assert(0);}
    bool isTreatUndrivenAsUndetermined() {assert(0); return 0;}
    bool isTreatUndrivenSupplyNetAsUndetermined() {assert(0); return 0;}
    bool isUnassociatedIsoOn() {assert(0); return 0;}
    void treatLevelSaveRestoreAsEdge(unsigned int levelAsEdge) {assert(0);}
    bool isLevelSaveRestoreAsEdge() const {assert(0); return false;}
    void setUpfReader(UpfReaderIf *reader) {assert(0);}
    bool hasVlogPad() const {assert(0); return false;}
    void setVlogPad(bool ) {assert(0);}
    
    bool isInstanceEnableIsolsElem() {assert(0); return false;}
    void resetInstanceEnableIsolsElem() {assert(0);}   
 
    bool getDisableAppliestoWithElements() {assert(0); return false;}
    bool isAppliestoDefaultOutput() {assert(0); return false;}
    void setDisableAppliestoWithElements(bool val) {assert(0);}
    void setAppliestoDefaultOutput(bool val) {assert(0);}

    bool isMixedHdl() const { return isMixedHdl_; }
    void setIsMixedHdl() { isMixedHdl_ = 1; }

    bool isDesignDebugEnabled() const { return isDesignDebugEnabled_; }
    void setDesignDebugEnabled() {  isDesignDebugEnabled_ = 1; }

    SupplyPortLI getSupplyPads() const {assert(0); return 0;}
    void adjustRetentionStrategies() { assert(0); }
    bool doSupplyNetAnalysis() {assert(0); return false;}
    SupplyNetAnalysis* getSupplyNetAnalysis() {return supplyNetAnalysis_;}
    PowerStateTableLI getPowerStateTables() const {assert(0); return 0;}
    Hdl2UpfVctLI      getHdl2UpfVcts() const {assert(0); return 0;}
    Upf2HdlVctLI      getUpf2HdlVcts() const {assert(0); return 0;}
    BindCheckerLI     getBindCheckers() const {assert(0); return 0;}
    void findDesignModels(const char* name, DesignModelL &models, bool ignoreTop = true);
    DesignModel* makeOrGetDesignModel(const char* module, void* hook , bool isGetOnly = false);
    DesignModel* makeOrGetDesignModel(const char* canonicalName, const char *lib, const char *entity, const char *arch);
    DesignModelTableLI getDesignModels() { return DesignModelTableLI(upfModels_); }
    char* getModuleName( void * inst, bool isVlog);
    static void findVerilogName ( void *inst, bool regexp, bool exact, bool ic, bool trans,bool nonLeaf, bool leaf_only, FindObjType type,UpfPortDirection dir, char *pattern, charL &nameList, charL &hireNamL, bool isVlog);
    NameFormat*       getNameFormat() const {assert(0); return 0;}
    SaveUpfLI         getSaveUpfs() const {assert(0); return 0;}
    LoadUpfLI         getLoadUpfs() const {assert(0); return 0;}
    Hdl2UpfVct*       findHdl2UpfVct(const char *vctName) const {assert(0); return 0;}
    Upf2HdlVct*       findUpf2HdlVct(const char *vctName) const {assert(0); return 0;}
    void              setVerboseMode(int mode) {verboseMode_ = mode;}
    int  getVerboseMode() {return verboseMode_;}
    void              dumpUpfInTclFormat(FILE *) const {assert(0);}
    void              setLanguage(UpfHdlType hdl) {hdlType_ = hdl;}
    void buildEquiPotentialSupplyIfNotAlreadyDone() {assert(0);}
    PowerScopeLI         getPowerModels() {assert(0); return 0;}
    DesignScope* findDesignScope(int id) { assert(0); return 0;}
    UpfDesignPort*  makeOrGetDesignPort(const char* name, const char* portName, const char* resolvedName, unsigned isVerilog, void* instance, int cellId, DesignScope* dscope, bool forSPA = false, ClampValueType clampVal = UpfClampUnspecifiedC);
    UpfDesignPortTableLI  getDesignPorts();
    UpfDesignPort*  findDesignPort(int id);
    void setCustomAssertTcl(const char*) {assert(0);}
    const char* getCustomAssertTcl() {assert(0); return 0;}
    void setSrsnOutsidePortInstrumentation() {}
    void setSrsnLocationSelfInstrumentation() {}
    bool getSrsnOutsidePortInstrumentation() { return false; }
    bool getSrsnLocationSelfInstrumentation() { return false; }
    void setUnconnectedBiasPinsOn() {}
    bool getUnconnectedBiasPinsOn() { return false; }
    void setClampCheckOnEnable() {}
    bool getClampCheckOnEnable() { return false; }
    void setClampCheckOnDisable() {}
    bool getClampCheckOnDisable() { return false; }
    void setPowerOptMode() {}
    void appendContextResetGroup(ContextResetGroup *grp) {};
    bool populateTraceDownwardElements() {return false;}
    void populateContextResetExclusionModels() {}
    ContextResetGroupLI getAllContextResetGroups() { return 0; }
    UPFIR::DesignObjectLI getContextResetExclusionElements() { return 0; }
    void clearTraceDownwardElements() {}
    bool isContextResetFlowEnabled() { return false; }
    bool getPowerOptMode() { return false; }
    void setCheckPowerDownWrite() {}
    bool isCheckPowerDownWrite() { return false; }

    bool hasPolicyOnInterfModport() { return (false); }
    void setHasPolicyOnInterfModport() { }

    bool hasFanoutPolicy() { return false; }
    void setHasFanoutPolicy() {  }
    bool hasPathBasedPolicy() { return false; }
    void setHasPathBasedPolicy() {  }
    bool hasUpfError() {return parseError_;}
    void setUpfError() {parseError_ = true;}
    bool isPartialOnFullOn() const {return false;}
    void setLpAssertEnabled() {};
    void setRetSupCorr() {assert(0);}
    bool isLpAssertEnabled() {assert(0); return false;}
    void setPBPOptEnabled() {}
    bool isPBPOptEnabled() { return false; }
    void setStrictDbMatch() {};
    bool isStrictDbMatch() {assert(0); return false;}
    PowerStateTable*  findPowerStateTable(const char *tableName, bool isTcl = false)const {assert(0); return 0;}
    PowerScope* findPowerScope(const char* fullName) const {assert(0); return 0; }
    PowerScopeTableLI getPowerScopes() {assert(0); return 0;}
    PowerSwitch* findPowerSwitch (const char *switchName, bool isTcl = false) const {assert(0); return 0;}
    PowerSwitch* findPowerSwitch (int id) const {assert(0); return 0;}
    DesignObject* findDesignObject(const char*) const {return 0;}
   
    void buildEquiPotentialSupply(bool& isAlreadyDone) {assert(0);}
    void disableParsingNotice(bool disable) {assert(0);}
    bool isParsingNoticeDisabled() {assert(0); return false;}
    void setPartcompFlow(int) {};
    int  getPartcompFlow() {return 0;}
    bool isMixadAmsFlow() { return false; }
    void setMixadAmsFlow(bool flag) {};
    bool hasDummyDesignTop() const {assert(0); return false;}
    void setPowerUpf2SvVct(Upf2SvInbuiltType vct) {pwrUpf2SvVct_ = vct; }
    Upf2SvInbuiltType getPowerUpf2SvVct() {return UPF2SV_LOGIC; }
    void setGroundUpf2SvVct(Upf2SvInbuiltType vct) {gndUpf2SvVct_ = vct; }
    Upf2SvInbuiltType getGroundUpf2SvVct() {return UPF_GNDZERO2SV_LOGIC; }
    void setPowerSv2UpfVct(Sv2UpfInbuiltType vct) {assert(0);}
    Sv2UpfInbuiltType getPowerSv2UpfVct() {return SV_LOGIC2UPF;}
    void setGroundSv2UpfVct(Sv2UpfInbuiltType vct) {assert(0);}
    Sv2UpfInbuiltType getGroundSv2UpfVct() {return SV_LOGIC2UPF_GNDZERO;}
    void setPowerUpf2VhVct(Upf2VhInbuiltType vct) {assert(0);}
    Upf2VhInbuiltType getPowerUpf2VhVct()  {return UPF2VHDL_SL;}
    void setGroundUpf2VhVct(Upf2VhInbuiltType vct) {assert(0);}
    Upf2VhInbuiltType getGroundUpf2VhVct() {return UPF_GNDZERO2VHDL_SL;}
    void setPowerVh2UpfVct(Vh2UpfInbuiltType vct) {assert(0);}
    Vh2UpfInbuiltType getPowerVh2UpfVct() {return VHDL_SL2UPF;}
    void setGroundVh2UpfVct(Vh2UpfInbuiltType vct) {assert(0);}
    Vh2UpfInbuiltType getGroundVh2UpfVct() {return VHDL_SL2UPF_GNDZERO;}
    void setOverridePBPCorruption(int corrupt) {assert(0);}
    int getOverridePBPCorruption() {assert(0); return 0;}
    int getTotalSupplyNetCount() {return supplyNetAnalysis_->getSupplyNetCount(); }
    int getTotalPowerDomainCount() {return powerDomainIDVec_.size();}
    int getTotalRetentionCount() {return retentionIDVec_.size();}
    int getTotalPowerSwitchCount() {return 0;}
    int getTotalIsolationsCount() {return isolationStrategyVec_.size();}
    const char* getScopeAtLineNo(const char* fileName, unsigned int lineNo, const char* fileTopScope = NULL) const {assert(0); return 0;};
    const UpfNamedObj* getUpfObjAtLineNo(const char* fileName, unsigned int lineNo, const char* identifier, const char* fileTopScope = NULL) const {assert(0); return 0;};
    bool isNMVFlow() {assert(0); return false;}
    void setNMVFlow(bool flag)  {assert(0);}
    UpfHdlType getLanguage() {return hdlType_;}
    PowerFormatType getPowerFormat() {return CpfC;}
    bool areSupplySetsEquivalent(SupplySetHandle* sH1, SupplySetHandle* sH2);
    bool isApfCompat() {return false;}
    void setVhdlIntegerCorruptMode(const char* flag) {assert(0);};
    int  getVhdlIntegerCorruptMode(void) {return 0; assert(0);};
    void setApfCompat(bool apf) {assert(0);}
    bool isNorIsolationEnabled() { return false;}
    bool logicExprDrivesSupplyExpr() { return false;}
    void setLogicExprDrivesSupplyExpr(bool b) {assert(0);}
    bool voltageBasedSupplyOn() { return false;}
    void setVoltageBasedSupplyOn(bool b) {assert(0);}
    bool nameBasedSourceSink() {assert(0); return false;}
    void setNameBasedSourceSink(bool b) {assert(0);}
    void setDbInfoPresent() {assert(0);}
    bool getDbInfoPresent() const {assert(0); return false;}
    SupplySetHandle* findSupplySetHandle(const char *supplySetHandleName) const {assert(0); return 0;}
    // XoverGate Interface
    void addLSXoverGate(int id, int srcSSId, int destSSId, int strategyId, bool is3070) {assert(0); }
    XoverGateLI getLSXoverGates() { return 0; }
    void markNoPinRetention() {assert(0);}
    void populatePswImplicitSupplySet() {assert(0);}
    void setSSDefaultON() {assert(0);}
    bool getSSDefaultON() const {assert(0); return false;}
    SimModeType getSimulationMode() {return SIM_NORMAL; }
    bool isBlueLane() const {assert(0); return false;}
    void setBlueLane(bool b) {assert(0);}
    bool isDisableSRSN() const {assert(0); return false; }
    void setDisableSRSN() {assert(0);}
    bool isLpCoverageEnabled() const {return false;}
    bool isPartialDeselect() const {return false;}
    bool isDefaultSupplySetCoverage() {return false;}
    bool isPowerStateTableCoverage() {return false;}
    bool isSupplySetCoverage() {return false;}
    bool isPowerSwitchCoverage() {return false;}
    bool isSupplyPortStateCoverage() {return false;}
    void setLpCoverageEnabled() {  assert(0); }
    void setSupplySetCoverage () {}
    void setExplicitSupplySetPowerStateCoverage () {}
    void setImplicitSupplySetPowerStateCoverage () {}
    void setPowerSwitchCoverage () {}
    void setPowerStateTableCoverage () {}
    void setPowerStateTableStateCoverage () {}
    void setPowerStateTableTransitionCoverage () {}
    void setSaveSignalCoverage () {}
    void setRestoreSignalCoverage () {}
    void setIsoEnableCoverage () {}
    void setGroupStateCoverage () {}
    void recordScopeStartLineNo() {assert(0);}
    void addBlackBoxModel(const char* model, unsigned int lineNo,
                          unsigned int fileId) {assert(0); return; }
    void markAsBlackBoxModels() {assert(0); return; }
    void markAsXBashSynchronizers() {assert(0); return; }
    void markSpiceModulesAsBlackBox() {assert(0); return; }
    void setAnyBCForIsoWithGenericPresent() { assert(0); return; }
    bool isAnyBCForIsoWithGenericPresent() { assert(0); return false; }
    void setRetGenericCheckerPresent()  {   return; }
    bool isRetGenericCheckerPresent() const { return false; }
    bool getControlPortCoverage() { return false; }
    bool getAckPortCoverage() { return false; }
    bool getSaveSignalCoverage() { return false; }
    bool getRestoreSignalCoverage() { return false; }
    bool getIsoEnableCoverage() { return false; }
    bool isGroupStateCoverage() { return false; }

    bool isPowerDomainCoverage() { return false; }
    bool isPowerDomainSimStateCoverage() { return false; }
    void setPowerDomainCoverage() {}
    void setPowerDomainSimStateCoverage() {}
    void setPowerDomainPowerStateCoverage() {}
    void setSupplyPortStateCoverage() {}

    bool isAutoComplete() {return isAutoComplete_;}
    void enableAutoComplete() { isAutoComplete_ = true; }
    void setBiasBoundary(void *in, bool b, int fileid, int lineno) {}
    const char* getBiasBoundaryFileNameLineNo(void *instance, int &line) { return NULL;}
    bool IsBiasBoundary(void *in) { return false; }
    bool biasBlockExists() { return false; }
    bool isBiasEnabled(void *in) { return false;}
    void processMacroModelInfos() { }
    DesignModelLI getMacroModels() { return 0; }
    const char *getMacroUpfFileName(std::string &n, UPFIR::MacroCorruptionType &m) { return NULL; }
    void printRuntimeSDA(FILE *fp) {assert(0); return;}
    bool isPartialSinglePinRetention() { return false;}
    void setPartialSinglePinRetention(bool val) { assert(0);} 
    bool isMacroPerfMode() { return false;}
    void setMacroPerfMode() { assert(0);}
    double getRealCorruptionValue() { return 0;}
    void setRealCorruptionValue(double realCorValue) {assert(0);}
    unsigned isDesignRealCorruptionEnabled() {return 0;}
    void setDesignRealCorruption(unsigned corEn) {assert(0);}
    void setNlp2Compat() {assert(0);}
    bool isNlp2Compat() {return false;}
    void setInitGlitchBc() {assert(0);}
    bool isInitGlitchBc() {return false;}
    void setPlatoParser() {assert(0);}
    bool isPlatoParser() {return false;}
    void setPlatoAnalysis() {assert(0);}
    void setUpfRead(bool isUpfRead) {assert(0);}
    bool isPlatoAnalysis() {return false;}
    void setSdm2UpfirFlow() {assert(0);}
    bool isSdm2UpfirFlow() {return false;}
    void setPswControlPortCorruption() { assert(0);}
    bool isPswControlPortCorruption() {return false;}
    void setPswRelatedSupplyPrimary() { assert(0);}
    bool isPswRelatedSupplyPrimary() {return false;}
    void setDelaySemanticsBc() { delaySemanticsBc_ = true; }
    bool isDelaySemanticsBc() {return delaySemanticsBc_; }
    void createXoverToggleStrategies() {assert(0);}
    void notifyNewUpfFileParsing(const char* upfFileName) {assert(0);}
    void disableLpAssertEnabled() {};
    void registerUninstantiatedModel(const char* modelName) {assert(0);}
    virtual void setVhClkVlIsoCdcName(char* vlogClk,char *vlogPnmClk) { assert(0); }
    virtual UPFIR::VhVlCdcClkNameMap* getVhClkVlIsoCdcMap() { return NULL; }
    virtual void setVlClkVhIsoCdcName(char* vlogClk,char *vlogPnmClk) { assert(0); }
    virtual UPFIR::VhVlCdcClkNameMap* getVlClkVhIsoCdcMap() { return NULL; }
    bool getUninstantiatedModelsIter(std::list<std::string>::const_iterator& begin,
            std::list<std::string>::const_iterator& end) {return false;}
    void setToggleReportEnabled() { }
    bool isToggleReportEnabled() {return false;}
    void setAssertResetSequenceEnabled() { }
    bool isAssertResetSequenceEnabled() {return false;}

public:
    //implemented CPF interfaces

    void serialize(ser::Archive&);
    ~CpfPowerNetworkImpl();
    static CpfPowerNetworkImpl* getInstance();
    void save(const char*);
    void restore(const char* file, bool isLoadingForIP =false);
    void Cleanup();
    UpfClassType  getUpfClassType() const {return PowerNetworkC;}
    DomainMappingMgr* getMappingManager() const {return DomainMappingMgrObj_; }
    const char* getKindStr() const {return 0;}
    const char *getCurrentScope() const
    { return currPowerScope_ ? currPowerScope_->getFullName() : 0; }
    DesignObject *getCScope() const
    { return currPowerScope_ ? currPowerScope_->getDesignObject() : 0; }
    char getHierarchySeparator() const {return hierarchySep_;}
    void  setHierarchySeparator(char sep) {hierarchySep_ = sep;}
    //void setCpfLifeGuard(LifeGuard    *lg) { lg_ = lg;}
    //LifeGuard *getCpfLifeGuard() { return lg_; }

    ///This is to set tool design top. User must set top module name as
    ///UPF file might not specify design top. All upf command have scope
    ///& scope again depends on top.
    bool setToolDesignTop(const char *topModuleName, bool isVlog,
                          void *topInst, const char *designTopMod) ;
    void registerDesignAdapter(UpfDesignAdapter *adapter) {da_ = adapter;}
    void setLogFile(FILE* logFile) {logFile_ = logFile;}
    FILE *getLogFile() {return logFile_;}
    void addPowerDomain(UPFIR::PowerDomain *pd);
    void addIsolation(IsolationStrategy *isolation);
    void addRetention(UPFIR::RetentionStrategy *rs);
    void addBindCheckerStrategy(BindChecker* bc);
    BindChecker* createBindCheckerObject(char* checkerInstance, int line, char* checkerModule, charL &targetPolicies) { assert(0); return 0; }
    void addSupplyNet(UPFIR::SupplyNet *sn);
    ///Current top design used for upf specification. It could be set by
    ///set_design_top command or default design top set by tool if
    ///set_design_top has not been specified in upf file.
    const char* getDesignTop() const ;
    const char* getWorkDir() const;
    const char* getDesignTopModel() const ;
    DesignObject*      getDTop() const ;
    PowerDomainLI getPowerDomains() const ;
    IsolationLI getIsolations() const {return IsolationLI(isolations_);}
    RetentionLI getRetentions() const {return RetentionLI(retentionList_);}
    PowerSwitchLI getPowerSwitches() const ;
    void setReportsDir(const char* reportsDir);
    const char* getReportsDir() const { return reportsDir_; }
    LevelShifterLI getLevelShifters() const {
        assert(0);
        return NULL;
    }   
    DesignScopeTablePI getTerminalBoundaryScopes() {
        assert(0);
        return NULL;
    }
    PowerDomain*      findPowerDomain(const char *domainName, bool isTcl = false) const ;
    PowerDomain*      findPowerDomain(int) const ;
    IsolationStrategy*      findIsolationStrategy(int) const ;
    BindChecker*        findBindCheckerStrategy(int) const ;
    SRSNStrategy*      findSRSNStrategy(int) const ;
    SRSNStrategyLI      getSRSNStrategies(void) const ;
    LevelShifterStrategy*   findLevelShifterStrategy(int) const ;
    RetentionStrategy*   findRetention(int) const ;
    SupplyNet*        findSupplyNet(const char *supplyNetName) const ;
    SupplyNet*        findSupplyNet(int snid) const ;
    SupplyPort*       findSupplyPort(const char *supplyPortName) const ;
    IsolationStrategy* findIsolation (const char *isoPolName) const ;
    UpfObjLI            getSupplyPortsInScope(void* scopePtr);
    void              registerSupplyPortInScope(void* ptr, SupplyPort *sport) { return; }
    bool              doSemanticCheck() const ;
    const char*       getFileName(unsigned int fileId) const
    {return fileName_;}
    unsigned int      getCurrentFileId() const
    {return 0;}
    unsigned int      getCurrentLineNo() const
    {return lineNo_;}
    bool                getCoaDisabled () { return false; };
    void                setCoaDisabled (bool r) { };
    DesignObject  *getVirtualPortInCurrentScope(const char *name) const;
    bool isNlpGenericName(const char* symbol) const {return false;}
    void print() const ;
    bool populateElementFromQueryObject();
    bool mergePowerModes();
    void setNoPowerModeValidation() {noPowerMode_ = true;}
    bool noPowerModeValidation() const {return noPowerMode_;}
    PowerScopeLI         getPowerTops() const;
    bool addPowerTop(PowerScope *ps);
    bool hasPowerScope(void* ip, char** psName) const ;
    ScopeTable* getScopeTable() {return scopes_;}
    int registerScope(DesignObject* elem, const char* scope) ;
    int registerScope(const char* scope, int ScopeId) ;
    void unregisterScope(int id,DesignObject *dobj = 0) ;
    DesignScopeTablePI getDesignScopes() ;
    DesignScope* makeOrGetDesignScope(DesignObject* dobj) ;
    void setAnyRetCondPresent()  {}
    bool isAnyRetCondPresent () const {return false;}
    char* getToolTop() { assert(0); return 0; }

    //CPF specific functions
    void pushScope(PowerScope *ps);
    PowerScope *popScope();
    PowerScope *getCurrentPowerScope() const;
    void replaceSeparatorBySlash(std::string &str, char sep);
    PowerScope *getPreviousPowerScope() ;
    void replaceCpfHierSepBySlash(std::string &str);
    DesignObject *checkDesignElement(const char *elem,
                                     const char *scope, bool checkSignal = false,
                                     char *file = NULL, int line = 0,
                                     bool reportError = true, QueryCmdType cType=UNKNOWN_CMD, bool lookInSpice = false);
    DesignObject *queryDesignElement(const char *elem, bool bLookInSpice = false, DesignElementType* dtype = NULL, bool giveError=true);
    int findHierObjectsInScope (void * scope, const std::string & scopeName, bool vlogScope, const std::string & token, int type, charL & tokenList, UpfObjL& upfObjList, bool lookupClassRef = false);
    char *findInstanceNameOfModule(const char *modName);
    bool resolveWildcardClassRefs();
    bool expandWildcardClassRefs(UPFIR::DesignObjectLI& dli, DesignObjectL& dobjL, UPFIR::FindObjType type, UpfObj* obj);
    bool isDomainMapable(PowerDomain* top,PowerDomain* block) ;
    bool doDomainMapping(std::string top,std::string block);
    void pushUnresolvedDesign(PowerDesign *pd);
    PowerDesign *popUnresolvedDesign();
    PowerDesign *getCurrentUnresolvedDesign() const;
    PowerDesign *findPowerDesign(const char *designName)
    {
        return powerDesignMap_.lookup(designName);
    }
    void addPowerDesign(PowerDesign *pd)
    {
        powerDesignMap_.append(pd);
    }
    void addAllowUpdatesOnly() {allowUpdatesOnly_ = 1;}
    void removeAllowUpdatesOnly() {allowUpdatesOnly_ = 0;}
    int  allowUpdatesOnly() {return allowUpdatesOnly_;}
    void setFileName(const char *f) {fileName_ = f;}
    void setLineNo(unsigned l) {lineNo_ = l;}
    void populatePowerOptions() ;
    unsigned findPowerOption(const std::string & name);
    const char* getDesignElementFullName(UPFIR::DesignElementTokenL* tokenL, bool getInstName=false, bool convertVhNameToUpper=true);
    const char* getDesignElementFullResolvedName(UPFIR::DesignElementTokenL* tokenL, bool getInstName=false);
    const char* getDesignElementFullTclName(UPFIR::DesignElementTokenL* tokenL, bool getInstName=false);
    const char* getDesignElementResidualName(UPFIR::DesignElementTokenL* tokenL);
    const char* getDesignElementTargetName(UPFIR::DesignElementTokenL* tokenL);
    const char* getDesignElementEncryptName(UPFIR::DesignElementTokenL* tokenL);
    DesignElementToken* createDesignElementToken(UPFIR::UpfTokenProp prop);
    UpfDesignAdapter* getPowerNetworkDesignAdapter() { return da_; }
    bool hasPowerDomains() const { return !powerDomainList_.isEmpty(); }
    void clearDomainBoundaryMap() { assert(0); }
    void setLowerDomainBoundaryData(bool val=false, const char* scope=NULL) { assert(0); }
    LowerDomainBoundaryData* getLowerDomainBoundaryData() { assert(0); return NULL; }
    bool isLowerDomainBoundaryEnabled() { return false; }
    void setEnableUpfPortabilityMsg(bool flag) {}
    bool enableUpfPortabilityMsg()       {return false;}
    //DesignScopeLI getLowerDomainTrueList() { return NULL; } 
    //DesignScopeLI getLowerDomainFalseList(){ return NULL; }
    DesignScopeLI getLowerDomainTrueList() { return NULL; } 
    DesignScopeLI getLowerDomainFalseList(){ return NULL; }
    DesignScopeLI getTerminalBoundaryList(){ return NULL; }
    bool hasAnyPowerDomainsAtOrBelowScope(UPFIR::DesignObject* dobj) { assert(0); return false; }
    bool isPgSim() const { assert(0); return false; }
    void setPgSim(bool b) { assert(0); }
    bool undrivenSuppliesOff() { return false; }
    void setUndrivenSuppliesOff(bool b) { }
    void setVcsVerboseLevel(int level) { }

    void saveResolvedName(PowerScope* ps) { fassert(0, "This is not allowed for cpf"); }
    const std::string& getSavedResolvedName(const std::string& psFullName) { fassert(0, "This is not alowed for cpf"); 
        static std::string emptyString; return emptyString; }
    char* generateFullName(const char *name);
    virtual std::vector<UpfDesignPort*>::iterator getDesignPortsOrderBegin() {assert(0);std::vector<UpfDesignPort*> dummy;return dummy.begin();}
    virtual std::vector<UpfDesignPort*>::iterator getDesignPortsOrderEnd() {{assert(0);std::vector<UpfDesignPort*> dummy;return dummy.begin();}};

    void populateRetentionInfoToPidb();
    std::string upfResolveTypeToString(UPFIR:: UpfResolveType type) const {
        fatal("resolve type not supported in CPF"); return "";
    }
    void escapeHierName(std::string* name, bool hasSupplyHandler) const {
        fatal("cannot be called in CPF.");
    }
    std::string getFullDecompileName(UPFIR::DesignObject* dObj) const {
        fatal("cannot be called in CPF.");
        return "";
    }
    std::string stripPowerNetworkModelPrefix(const std::string& name) const {
        fatal("cannot be called in CPF.");
        return "";
    }
    void removeDuplicatedSpaces(std::string* name) const {
        fatal("cannot be called in CPF.");
    }
    bool hasEscapedNamesOrChars(const std::string& name) const {
        fatal("cannot be called in CPF.");
        return false;
    }
    char* getStrFromHconName(char* hc) { assert(0); return NULL; }

    const char* makeVolatileRTLDBName(const std::string& name,
        bool isImplicitName = false) const {
        fatal("cannot be called in CPF.");
        return NULL;
    }
    void  setHeteroFanoutSupport (bool flag) { }
    void  setDefaultAppliesToDontFilter (bool flag) { }
    RetentionMode* getRetentionModeImpl() {
        fatal("cannot be called in CPF.");
        return NULL;
    }
    void  analyzeRetentionMode() {
        fatal("cannot be called in CPF.");
    }
    void  applyRetentionMode() {
        fatal("cannot be called in CPF.");
    }
    PowerDomain*    getTopPowerDomain() { assert(0); return NULL; }
    const char* getGVar(const char* gvarName)
    {
        fatal("cannot be called in CPF");
        return NULL;
    }
    BlackBoxModelLI getBlackBoxModels() { 
        fatal("cannot be called in CPF");
        return NULL; 
    }
    UpfFile* getUpfFileFromConfig() {
        fatal("cannot be called in CPF");
        return NULL; 
    }
    void setUseUpfQueryData() { fatal("cannot be called in CPF"); } 
    bool getUseUpfQueryData() { fatal("cannot be called in CPF"); return false; } 
    void setMvAllowPgPinReconnection() { fatal("cannot be called in CPF"); } 
    bool getMvAllowPgPinReconnection() { fatal("cannot be called in CPF"); return false; } 

private:
    CpfPowerNetworkImpl();

private:
    //serializable data menbers
    UpfHdlType                              hdlType_;
    Upf2SvInbuiltType                       pwrUpf2SvVct_;
    Upf2SvInbuiltType                       gndUpf2SvVct_;
    char                                  * designTop_;
    ScopeTable                            * scopes_;
    PowerScopeL                             topPowerScopes_;
    //non-serializable data menbers
    static CpfPowerNetworkImpl            * powerNetwork_;
    static UpfDesignAdapter                      * da_;
    FILE                                  * logFile_;
    char                                  * designTopModel_;
    DesignObject                          * designTopDobj_;
    lpmsg::LpMsgController                * msgController_;
    PowerScopeL                             powerScopes_;
    PowerScope                            * currPowerScope_;
    char                                    hierarchySep_;
    //temporary data, created during read-only CPF parsing
    PowerDesignL                            designList_;
    HashTableL<PowerDesign>                 powerDesignMap_;
    //containers for all power objects
    PowerDomainL                            powerDomainList_;
    RetentionL                              retentionList_;
    std::vector<PowerDomain *>              powerDomainIDVec_;
    IsolationL                              isolations_;
    std::vector<IsolationStrategy*>         isolationStrategyVec_;
    SupplyNetAnalysis                     * supplyNetAnalysis_;
    DesignScopeTableP                       designScopes_;
    UpfDesignPortTableL                     designPorts_;
    std::vector<UpfDesignPort*>             designPortVec_;
    std::vector<UPFIR::RetentionStrategy*>  retentionIDVec_;
    ReInitInfoL                             reInitInfos_;
    ReInitInfoL                             dontreInitInfos_;
    DesignModelTableL                       upfModels_; // modules for reinit
    //temporary filename and lineno
    const char                            * fileName_;
    unsigned                                lineNo_;
    bool                                    parseError_;
    //serializable bit-fields
    unsigned int                            designReinit_:1;
    //non-serializable bit-fields
    unsigned int                            verboseMode_:3;
    unsigned int                            allowUpdatesOnly_:1;
    unsigned int                            isMixedHdl_:1;
    DomainMappingMgr*                       DomainMappingMgrObj_;
    bool                                    noPowerMode_;
    unsigned int                            isDesignDebugEnabled_:1;
    bool                                    isAutoComplete_;
    unsigned int                            newRetFlow_:1;
    unsigned int                            delaySemanticsBc_:1;
    char                                  * reportsDir_;
public:
    VCS_DECL_BITFIELD(CpfPowerNetworkImpl, unsigned int, isMixedHdl_, 1);
    VCS_DECL_BITFIELD(CpfPowerNetworkImpl, unsigned int, designReinit_, 1);
    VCS_DECL_BITFIELD(CpfPowerNetworkImpl, unsigned int, isDesignDebugEnabled_, 1);
    VCS_DECL_BITFIELD(CpfPowerNetworkImpl, unsigned int, newRetFlow_, 1);
    VCS_DECL_BITFIELD(CpfPowerNetworkImpl, unsigned int, delaySemanticsBc_, 1);

};


NAMESPACE_CPFIR_END

#endif
# 703 "./CpfPowerNetwork.hh"
# 14 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "CpfPowerDomain.hh"
#endif /* expanded by -frewrite-includes */
# 14 "CpfRetentionStrategy.cc"
# 1 "./CpfPowerDomain.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author : Rajaditya Mukherjee
#ifndef _CPFPOWERDOMAIN_HH_
#define _CPFPOWERDOMAIN_HH_

#if 0 /* expanded by -frewrite-includes */
#include "UpfCommandInterface.hh"
#endif /* expanded by -frewrite-includes */
# 10 "./CpfPowerDomain.hh"
# 11 "./CpfPowerDomain.hh"
#if 0 /* expanded by -frewrite-includes */
#include "UpfTypeDefImpl.hh"
#endif /* expanded by -frewrite-includes */
# 11 "./CpfPowerDomain.hh"
# 12 "./CpfPowerDomain.hh"
#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 12 "./CpfPowerDomain.hh"
# 13 "./CpfPowerDomain.hh"
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 13 "./CpfPowerDomain.hh"
# 14 "./CpfPowerDomain.hh"
#if 0 /* expanded by -frewrite-includes */
#include <utility>
#endif /* expanded by -frewrite-includes */
# 14 "./CpfPowerDomain.hh"
# 15 "./CpfPowerDomain.hh"

NAMESPACE_CPFIR_BEGIN

class CpfPowerDesignImpl;

class CpfActiveStateConditionImpl : public UPFIR::ActiveStateCondition 
{
public :
    UPFIR::NominalCondition* getNominalCond() const {return nominalCond_;} 
    UPFIR::BoolExpr*         getExpression() const {return expression_;}
    void setNominalCond(UPFIR::NominalCondition* nc) {nominalCond_ = nc;}
    void setExpression (UPFIR::BoolExpr* bs)         {expression_ = bs;}

    CpfActiveStateConditionImpl(UPFIR::NominalCondition* nc,
                                UPFIR::BoolExpr * bs);
    CpfActiveStateConditionImpl();
    ~CpfActiveStateConditionImpl();
    VCS_DECL_SERIALIZABLE(CpfActiveStateConditionImpl);
    void serialize(UPFIR::ser::Archive&);
    const char *            getName             () const { return "";}
    const char *            getFullName         () const { return "";}
    const char *            getFileName         () const { return fileName_;}
    unsigned int            getLineNo           () const { return lineNo_;}
    UPFIR::UpfClassType     getUpfClassType     () const { return UPFIR::UpfNamedObjC;}
    const char *            getKindStr          () const { return 0;}


     //debug function
    void  print() const;
private :
    UPFIR::NominalCondition*   nominalCond_;
    UPFIR::BoolExpr*           expression_;  
    char                     * fileName_;
    unsigned                   lineNo_;

};


class CpfPowerDomainImpl: public UPFIR::PowerDomain
{

public:
    CpfPowerDomainImpl(const std::string                 & name,
                       const std::list<std::string>      & instances,
                       const std::list<std::string>      & boundaryPorts,
                       const std::list<std::string>      & excludePorts,
                       bool                                isDefault,
                       const std::string                 & shutoffCondition,
                       bool                                isExternalControlledShutoff,
                       const std::list<std::string>      & baseDomains,
                       const std::list<std::pair<std::string, std::string> >  & activeStateConditions,
                       const char                        * fileName,
                       unsigned                            lineNo);
    CpfPowerDomainImpl();
    ~CpfPowerDomainImpl();
    VCS_DECL_SERIALIZABLE(CpfPowerDomainImpl);
    void serialize(UPFIR::ser::Archive&);
    bool isEncrypted() const { return false; }

    //Add the PowerDomain Constructor ------- Cpf_PowerDomainImpl()

    UPFIR::PowerDomainLI          getBaseDomains() const { return UPFIR::PowerDomainLI(baseDomains_);}
    UPFIR::UpfDesignPortLI        getBoundaryPorts() const { return UPFIR::UpfDesignPortLI(boundaryPorts_);}
    UPFIR::ActiveStateCondLI     getActiveStateConds() const { return UPFIR::ActiveStateCondLI(activeStateConditions_);}
    UPFIR::DesignObjectLI         getElements() const   { return UPFIR::DesignObjectLI(instances_);} //Common to Both UPF and CPF Concrete
    UPFIR::SupplyNetLI         getEquivPwrNets() const { return UPFIR::SupplyNetLI(equivalentPwrNets_);}
    UPFIR::SupplyNetLI         getEquivGndNets()  const { return UPFIR::SupplyNetLI(equivalentGndNets_);}
    UPFIR::PowerSwitchLI       getSwitches() const { return UPFIR::PowerSwitchLI(pwrSwitches_);}
    bool                  getIsDefault           ( )     const { return isDefault_ ;}
    UPFIR::BoolExpr*              getShutoffCondition    ( )     const { return shutoffCondition_ ;}
    bool                 getIsExternalShutoff   ( )     const { return isExternalShutoff_ ;}
    UPFIR::BoolExpr*              getDefaultIsoCondition ( )     const { return defaultIsoCondition_ ;}
    UPFIR::BoolExpr*             getDefaultRestoreEdge  ( )    const { return defaultRestoreEdge_ ;}
    UPFIR::BoolExpr*             getDefaultSaveEdge     ( )     const { return defaultSaveEdge_ ;}
    UPFIR::BoolExpr*            getDefaultRestoreLevel ( )     const { return defaultRestoreLevel_ ;}
    UPFIR::BoolExpr*               getDefaultSaveLevel    ( )     const { return defaultSaveLevel_ ;}
    UPFIR::PowerUpStatesCpf    getPowerUpState        ( )     const { return powerUpState_ ;}
    UPFIR::SupplyNet*          getPowerNet              ( )  const { return primaryPwrNet_;} //Common to Both UPF and CPF Concrete
    UPFIR::SupplyNet*             getGroundNet           ( )  const { return primaryGndNet_;} //Common to Both UPF and CPF Concrete
    UPFIR::SupplyNet*          getImmediatePowerNet     ( )  const { fassert(0, " Can not be called for CPF"); return NULL; }
    UPFIR::SupplyNet*          getImmediateGroundNet    ( )  const { fassert (0, "Can not be called for CPF"); return NULL; }
    UPFIR::DesignElementTokenL* getTokenL() { fassert(0, "getTokenL can not be called from cpfPOwerDomain"); return NULL; }
    UPFIR::DesignElementTokenLI getTokenLI() { fassert(0, "getTokenLI can not be called from cpfPOwerDomain"); return 0; }
    virtual bool                  isEmpty() const { assert(0); return false; }
    void setIsDefault           (bool isDefault            )     { isDefault_ = isDefault ;}
    void setShutoffCondition    (UPFIR::BoolExpr*    expr         )     { shutoffCondition_ = expr ;}
    void setIsExternalShutoff   (bool isExternalShutoff    )     { isExternalShutoff_ = isExternalShutoff ;}
    void setDefaultIsoCondition (UPFIR::BoolExpr* expr            )     { defaultIsoCondition_ = expr ;}
    void setDefaultSaveEdge     (UPFIR::BoolExpr* expr            )     { defaultSaveEdge_ = expr ;}
    void setDefaultRestoreLevel (UPFIR::BoolExpr* expr            )     { defaultRestoreLevel_ = expr ;}
    void markAllImplicitSuppliesBlackBox() { fassert(0, "This function should not be called from CPF"); }
    void setDefaultSaveLevel    (UPFIR::BoolExpr* expr            )     { defaultSaveLevel_ = expr ;}
    void setPowerUpState        (UPFIR::PowerUpStatesCpf powerUpState    )     { powerUpState_ = powerUpState ;}
    void setDefaultRestoreEdge  (UPFIR::BoolExpr* expr            )     { defaultRestoreEdge_ = expr ;}
    void setPrimaryPwrNet       (UPFIR::SupplyNet* net               )     { primaryPwrNet_ = net ;}
    void setPrimaryGndNet       (UPFIR::SupplyNet *net               )     { primaryGndNet_ = net; }
    void setIsControlledFromUpperLevelEquivDomain()                                         { isControlledFromTop_ = true; }
    bool getIsControlledFromUpperLevelEquivDomain () const                                        { return isControlledFromTop_;}
    upfir::UpfClassType getUpfClassType() const {return UPFIR::PowerDomainC;}
    bool isValidNominalCondition(UPFIR::NominalCondition *nc, const char *fileName, unsigned lineNo);
    bool hasRetentions() const { return !(assocRetentionStrategy_.isEmpty()); }
    UPFIR::RetentionStrategy* findRetention(const char*);
    UPFIR::RetentionLI getRetentions() const                                 {return RetentionLI(assocRetentionStrategy_);}
    void deleteRetention(RetentionStrategy *ret) { }

    void addRetention(UPFIR::RetentionStrategy *retention)                   {assocRetentionStrategy_ .append(retention);             }
    /* This will crash assert all the ov functions for UPF.
    This is required for Inheritence*/

    int getId()    {return id_;}
    void setId(int id) {id_ = id;}
    //int getId()                                                     {fassert(0,"Undefined Function getId()"); return NULL;}
    void updateSimState(power_state_simstate simstate) {simState_ = simstate;}
    void updatePrimaryPowerNet(supply_net_type power)  {power_ = power;}
    void updatePrimaryGroundNet(supply_net_type ground) {ground_ = ground;}
    power_state_simstate getSimState() {return simState_;}
    supply_net_type getPrimaryPowerNet() {return power_;}
    supply_net_type getPrimaryGroundNet() {return ground_;}
    unsigned getRandomCorruptionSeed() {return 0;}
    void setRandomCorruptionSeed(unsigned) {}
    CorruptionType getRandomCorruptionType() {return Corrupt_X_C;}
    void setRandomCorruptionType(CorruptionType corType) {}
    void setOffState()       {hasOffState_ = true;}
    bool hasOffState() const {return hasOffState_;}
    void setBiasEnabled(bool b) { }
    bool isBiasEnabled() { return false;}
    void setBiasState(BiasState b) {  }
    BiasState getBiasState() { return BIAS_UNSET; }

    UPFIR::SupplyNet* getPwellNet() { return NULL; }
    UPFIR::SupplyNet* getNwellNet() { return NULL; }
    UPFIR::SupplyNet* getDeepPwellNet() { return NULL; }
    UPFIR::SupplyNet* getDeepNwellNet() { return NULL; }

    UPFIR::DesignObjectLI        getDontIsolateElements() const             {fassert(0,"Undefined Function getDontIsolateElements()"); return NULL;}
    void        appendDontIsolateElement(UPFIR::DesignObject* elem)         {fassert(0,"Undefined Function appendDontIsolateElement()");}
    UPFIR::DesignObjectLI        getDontLevelShiftElements() const         {fassert(0,"Undefined Function getDontLevelShiftElements()"); return NULL;}
    void        appendDontLevelShiftElement(UPFIR::DesignObject* elem)     {fassert(0,"Undefined Function appendDontLevelShiftElement()");}
    const char*          getPdElementScope() const                 {fassert(0,"Undefined Function getPdElementScope()"); return NULL;}
    const char*          getRealLogicScope() const                 {fassert(0,"Undefined Function getRealLogicScope()"); return NULL;}
    const char*         getPdLogicScope() const                     {fassert(0,"Undefined Function getPdLogicScope()"); return NULL;};
    UPFIR::SupplyNetLI   getSupplyNets() const                             {fassert(0,"Undefined Function getSupplyNets()"); return NULL;};
    UPFIR::SupplyPortLI  getSupplyPorts() const                             {fassert(0,"Undefined Function getSupplyPorts()"); return NULL;};
    UPFIR::SupplySetHandle* getPrimarySupply() {return supplySetHandle_;}
    UPFIR::SupplySetHandle* getDefaultIsoSupply()                         {fassert(0,"Undefined Function getDefaultIsoSupply()"); return NULL;}
    UPFIR::SupplySetHandle* getDefaultRetSupply()                         {fassert(0,"Undefined Function getDefaultRetSupply()"); return NULL;}
    UPFIR::LevelShifterLI getLevelShifters() const                         {fassert(0,"Undefined Function getLevelShifters()"); return NULL;};
    UPFIR::IsolationLI getIsolations() const {fassert(0,"Undefined Function getIsolations()"); return NULL;};
    bool isIncludeScope() const                                     {fassert(0,"Undefined Function isIncludeScope()"); return NULL;}
    UPFIR::SupplyPort* findSupplyPort(const char* name) const             {fassert(0,"Undefined Function findSupplyPort()"); return NULL;}
    UPFIR::LevelShifterStrategy* createDefaultLevelShifterStrategy()         {fassert(0,"Undefined Function createDefaultLevelShifterStrategy()"); return NULL;}
    bool isVerilogScope() const                             {return true;} //KSJ Needs to be fixed.        {fassert(0,"Undefined Function isVerilogScope()"); return NULL;}

    UPFIR::DesignObject* addImplicitVL(char *name, void *instP);
    UPFIR::DesignObjectLI getImplicitVLElements() const { return DesignObjectLI(implicitVLs_); }

    void setHasVhElements(bool b) {hasVhElements_ = b; }
    bool hasVhElements() const {return hasVhElements_; }

    void* getTargetScope() const                                     {fassert(0,"Undefined Function getTargetScope()"); return NULL;}
    bool hasCorruptOnActivityState()                       {return false;}
    bool hasCorruptOnChangeState()                         {return false;}
    bool hasCorruptOnSequentialActivityState()             {return false;}
    bool hasCorruptOnSequentialChangeState()               {return false;}
    unsigned isRandomCorruptionEnabled()                   {return 0;}
    void setRandomCorruption(unsigned)                             {fassert(0,"Undefined Function setRandomCorruption()"); }
    unsigned isDomainDisableCoa()                          {return 0;}
    void setDomainDisableCoa()                             {fassert(0,"Undefined Function setRandomCorruption()"); }
    ReinitType getReinit()                                         { return UnmarkedReinitC ;}
    void setReinit(bool)                                             {}
    void setDontReinit(bool)                                         {fassert(0,"Undefined Function setDontReinit()"); }
    void addControlSignalInfo(const char *signalName,UPFIR::DesignElementTokenL *tokl, FlopCtrlSigType sigType, bool sense,
            int flatIndex, const char *fileName, unsigned int lineNo, bool isVhld) { assert(0);}
    std::list<ControlSignalInfo *> *getControlSignalInfo() { return 0;}
    std::list<ControlSignalInfo *> *getVhdlControlSignalInfo() { return 0;}
    UPFIR::IsolationStrategy* findIsolation(const char*) const             {fassert(0,"Undefined Function findIsolation()"); return NULL;}
    UPFIR::SupplyNet* findSupplyNet(const char*) const                     {fassert(0,"Undefined Function findSupplyNet()"); return NULL;}
    bool isSimulationOnly() const                        {return false;}
    void createDefultSupplySets ()                                 {fassert(0,"Undefined Function createDefultSupplySets()"); }
    void setSimstate(UPFIR::UpfSimstate* sim) {simstate_ = sim;}
    UPFIR::UpfSimstate* getSimstate() const {return simstate_;}
    void setAssertionControl(AssertControlType b) { assertControl_ = b; }
    AssertControlType getAssertionControl() const  { return assertControl_; }
    UPFIR::PowerScope* getPowerScope() const                                 {fassert(0,"Undefined Function getPowerScope()"); return NULL;}
    void setPowerScope(UPFIR::PowerScope* ps)                             {fassert(0,"Undefined Function setPowerScope()"); }
    void setUpfCorruptForMrm(void*)                                 {fassert(0,"Undefined Function setUpfCorruptForMrm()"); }
    void* getUpfCorruptForMrm()                                     {fassert(0,"Undefined Function getUpfCorruptForMrm()"); return NULL;}
    void  createStateMachine()                                      {fassert(0,"Undefined Function createStateMachine()"); }
    UPFIR::StateMachine* getStateMachine()                          {fassert(0,"Undefined Function getStateMachine()"); return NULL;}
    void addController(void*) {assert(0);}
    void* getController() {assert(0); return 0;}
    void addControllerName(const char*) {assert(0);}
    const char* getControllerName() {assert(0); return 0;}
    void addBindChecker(upfir::BindChecker*) {assert(0);}
    bool hasBindChecker() {assert(0); return false;}
    upfir::BindCheckerLI getBindCheckers() {assert(0); return 0;}
    void destroyNonGenericBindCheckers() {assert(0);}
    upfir::SupplySetHandleTableLI customSupplies() {assert(0); return 0;}
    upfir::SupplySetHandleTableLI getCustomSupplies() {assert(0); return 0;}
    bool hasSetDomainPriSupply() {return false;}
    void dumpUpfPowerDomainCmd(std::ofstream&) const {assert(0); return;}

    void setPdSupplyPwrFile(const char* fileName){assert(0);}
    void setPdSupplyGndFile(const char* fileName){assert(0);}
    void setPdSupplyPwrLine(unsigned int lineNo) {assert(0);}
    void setPdSupplyGndLine(unsigned int lineNo) {assert(0);}
    const char* getPdSupplyPwrFile() {return 0;}
    unsigned int getPdSupplyPwrLine() {return 0;}
    const char* getPdSupplyGndFile() {return 0;}
    unsigned int getPdSupplyGndLine() {return 0;}
    bool isLDBTransition() {assert(0); return false;}
    void setLDBTransition(bool val) {assert(0);}
    bool getLDBVal() {assert(0); return false;}
    //This is for messaginf infra :
    lpmsg::LpMsgSeverity getMsgSeverity() {fassert(0,"Undefined Function getMsgSeverity()"); return lpmsg::InfoC;}
    void setMsgSeverity(lpmsg::LpMsgSeverity sev) {fassert(0,"Undefined Function setMsgSeverity()"); }
    bool          getMsgEnabled() {fassert(0,"Undefined Function getMsgEnabled()"); return false;}
    void          setMsgEnabled(bool en) {fassert(0,"Undefined Function setMsgEnabled()"); }
    upfir::IsolationStrategy  *getDefaultInputIso() const {fassert(0,"Undefined Function getDefaultInputIso()"); return 0;}
    upfir::IsolationStrategy  *getDefaultOutputIso() const {fassert(0,"Undefined Function getDefaultOutputIso()"); return 0;}
    /* Crash Asserions for UPF ENDS here */

    unsigned int getLineNo() const {return lineNo_;}
    const char* getFileName() const {return fileName_;}
    const char* getKindStr() const {return 0;}
    const char* getName() const {return name_;}
    const char* getFullName() const {return name_;}
    const char* getTclFullName() {return name_;}
    void addPowerNetInParseInfo (std::string pns) { parsePowerInfo_->setPNet(pns);}
    void addGroundNetInParseInfo (std::string gns) { parsePowerInfo_->setGNet(gns);}
    /* Contains stuff that will be defined in CC files*/

    void addInstance(UPFIR::DesignObject* designObjName);
    void addInstance(UPFIR::DesignQueryImpl* designObjName);
    void addBaseDomain(UPFIR::PowerDomain* baseDomainName);
    void addBoundaryPort (UPFIR::UpfDesignPort* port);
    void addEqPwrNet (UPFIR::SupplyNet* pwrNet);
    void addEqGndNet (UPFIR::SupplyNet* gndNet);
    bool addPowerSwitch (UPFIR::PowerSwitch* psw);
    bool validateBaseDomPswSupplyMatch(UPFIR::PowerSwitch* psw);

    void setHasTimingChecks() {}
    bool hasTimingChecks() {
        fassert(0, "Function NYI");
        return false;
    }

    //debug function
    void  print() const;
    //utility function
    bool deepCopySingleInCurrentScope();
    bool populateElementFromQueryObject();
    bool elaborateInCurrentScope();
    bool resolveCrossRefsInCurrentScope();

    double getRealCorruptionValue() {return 0;}
    void setRealCorruptionValue(double realCorType) {}
    unsigned isRealCorruptionEnabled()  {return 0;}
    void setRealCorruption(unsigned)    {fassert(0,"Undefined Function setRealCorruption()"); }
    

private: //undefined
    CpfPowerDomainImpl(const CpfPowerDomainImpl &);
    CpfPowerDomainImpl & operator=(const CpfPowerDomainImpl &);
    std::list<ControlSignalInfo *> *controlSignalList_;

private:
    class ParseOnlyDesignInfo
    {
    public:
        ParseOnlyDesignInfo(const std::string & shutoffCond,
                            const std::list<std::string> & instances,
                            const std::list<std::string> & bPorts,
                            const std::list<std::string> & excludePorts,
                            const std::list<std::string> & activeCondExpr) :
            shutoffCondition_(shutoffCond), instances_(instances),
            boundaryPorts_(bPorts), excludePorts_(excludePorts),
            activeCondExpr_(activeCondExpr) { }
        const std::string & getShutoffCond() const
        {return shutoffCondition_;}
        const std::list<std::string> & getInstances() const
        {return instances_;}
        const std::list<std::string> & getBoundaryPorts() const
        {return boundaryPorts_;}
        const std::list<std::string> & getExcludePorts() const
        {return excludePorts_;}
        const std::list<std::string> & getActiveCondExpr() const
        {return activeCondExpr_;}
    private:
        ParseOnlyDesignInfo();//undefined
        std::string shutoffCondition_;
        std::list<std::string> instances_;
        std::list<std::string> boundaryPorts_;
        std::list<std::string> excludePorts_;
        std::list<std::string> activeCondExpr_; // Expression portion of active state conditions
    };
    class ParseOnlyPowerInfo
    {
    public:
        ParseOnlyPowerInfo(const std::list<std::string> & baseDomains,
        const std::list<std::string> & activeCondNominal) :
            baseDomains_ (baseDomains),primaryPNet_(""),primaryGNet_(""),
            activeCondNominal_(activeCondNominal) {}
        const std::list<std::string> & getBaseDomains() const
        {return baseDomains_;}
        const std::string & getPNet() const
        {return primaryPNet_;}
        const std::string & getGNet() const
        {return primaryGNet_;}
        void  setPNet(const std::string & pn)
        {primaryPNet_=pn;}
        void  setGNet(const std::string & gn)
        {primaryGNet_=gn;}
        const std::list<std::string> & getActiveCondNominal() const
        {return activeCondNominal_;}
    private:
        ParseOnlyPowerInfo();//undefined
        std::list<std::string> baseDomains_;
        std::string primaryPNet_;
        std::string primaryGNet_;
        std::list<std::string> activeCondNominal_; // Nominal condition portion of active sate conditions 
    };

    char *                                 name_;
    bool                                   isDefault_;
    UPFIR::BoolExpr*                       shutoffCondition_;
    bool                                   isExternalShutoff_;
    UPFIR::BoolExpr*                       defaultIsoCondition_;
    UPFIR::BoolExpr*                       defaultRestoreEdge_;
    UPFIR::BoolExpr*                       defaultSaveEdge_;
    UPFIR::BoolExpr*                       defaultRestoreLevel_;
    UPFIR::BoolExpr*                       defaultSaveLevel_;
    UPFIR::PowerUpStatesCpf                powerUpState_;
    AssertControlType                      assertControl_;
    UPFIR::PowerDomainL                    baseDomains_;
    UPFIR::DesignObjectL                   instances_;
    UPFIR::DesignObjectL                   implicitVLs_;
    UPFIR::UpfDesignPortL                  boundaryPorts_;
    UPFIR::RetentionL                      assocRetentionStrategy_;
    UPFIR::ActiveStateCondL                activeStateConditions_;
    UPFIR::SupplyNet*                      primaryPwrNet_;
    UPFIR::SupplyNet*                      primaryGndNet_;
    UPFIR::SupplyNetL                      equivalentPwrNets_;
    UPFIR::SupplyNetL                      equivalentGndNets_;
    UPFIR::PowerSwitchL                    pwrSwitches_;
    UPFIR::UpfSimstate*                    simstate_;
    char *                                 fileName_;
    unsigned                               lineNo_;
    int                                    id_;
    UPFIR::SupplySetHandle *               supplySetHandle_;
    UPFIR::NominalCondL                    validnc_;
    bool                                   hasOffState_;
    bool                                   isControlledFromTop_;
    //temp query elem for wilcard handle
    UPFIR::DesignQueryImplL                wcInstances_;
    //temp parse only data storage
    ParseOnlyDesignInfo                  * parseInfo_;
    ParseOnlyPowerInfo                   * parsePowerInfo_;
    //runtime data
    power_state_simstate                   simState_;
    supply_net_type                        power_;
    supply_net_type                        ground_;

    unsigned int hasVhElements_:1,
             isSimulationOnly_:1,
             forRent_: 29;

    VCS_DECL_BITFIELD(CpfPowerDomainImpl, unsigned int, hasVhElements_,1 );
    VCS_DECL_BITFIELD(CpfPowerDomainImpl, unsigned int, isSimulationOnly_,1 );
};

class CpfSimstateImpl:public UpfSimstate
{
private:
    const char* simstateVar_;
    PowerDomain* pd_;
    //    PowerStateTable *pst_;
    static UpfClassType      classType_;

public:
    VCS_DECL_SERIALIZABLE(CpfSimstateImpl);
    void serialize(ser::Archive&);
    CpfSimstateImpl() : simstateVar_(NULL), pd_(NULL) {}
    CpfSimstateImpl(const char* name, PowerDomain *pd);
    //      CpfSimstateImpl(const char* name, PowerStateTable *pst);

    const char*         getFullName() const {return simstateVar_;}

    const char*         getName() const {return simstateVar_;}

    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    PowerDomain*  getDomain() const {return pd_;}
    PowerStateTable*  getPST() const {return NULL;}
    UpfGroup*     getUpfGroup() const {return NULL;}

    UpfClassType getUpfClassType() const
    {
        if (pd_)
            return PowerStateSimstateC;
        //    if (pst_)
        //       return CurrentPowerStateC;
        return classType_;
    }

    const char* getFileName() const {
        return pd_->getFileName();
    }
    unsigned int getLineNo() const { return pd_->getLineNo(); }
    ~CpfSimstateImpl();
};

NAMESPACE_CPFIR_END

#endif
# 429 "./CpfPowerDomain.hh"
# 15 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "CpfPowerDesign.hh"
#endif /* expanded by -frewrite-includes */
# 15 "CpfRetentionStrategy.cc"
# 1 "./CpfPowerDesign.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.
// Author : Rajaditya Mukherjee
#ifndef _CPF_POWER_DESIGN_HH_
#define _CPF_POWER_DESIGN_HH_

NAMESPACE_CPFIR_BEGIN

class CpfVirtualPort
{
public:
    CpfVirtualPort(const char *name);
    char *getName() const {return name_;}
    void setDesignObject(UPFIR::DesignObject *dobj) {dobj_ = dobj;}
    UPFIR::DesignObject *getDesignObject() const {return dobj_;}
    ~CpfVirtualPort();
private:
    CpfVirtualPort(); //undefined
private:
    char                          *name_;
    UPFIR::DesignObject           *dobj_;
};

typedef HashTableL<CpfVirtualPort> CpfVirtualPortTable;
typedef HashTableLI<CpfVirtualPort> CpfVirtualPortTableI;

class CpfPowerDesignImpl : public UPFIR::PowerDesign
{
public:
    CpfPowerDesignImpl(const char *name, const std::list<std::string> & ports, bool honorBoundaryPorts);
    CpfPowerDesignImpl();
    ~CpfPowerDesignImpl();
    VCS_DECL_SERIALIZABLE(CpfPowerDesignImpl);
    void serialize(UPFIR::ser::Archive&);
    virtual bool isEncrypted() const { return false; }
    //get functions
    UPFIR::PowerScopeLI  getChildPowerScopes() const {return powerScopes_;}
    UPFIR::PowerDomainTableLI getPowerDomains() const {return powerDomains_;}
    UPFIR::PowerSwitchTableLI getPowerSwitches() const {return pwrSwitchs_;}
    UPFIR::RetentionStrategyTableLI getRetentionStrategies() const {return retentionStrategies_;}
    UPFIR::SupplyNetTableLI getSupplyNets() const {return supplyNets_;}
    UPFIR::NominalCondTableLI getNominalConditions() const {return nominalConds_;}
    UPFIR::PowerModeTableLI getPowerModes() const {return powerModes_;}
    UPFIR::SetSimControlLI  getSetSimControl() const {return UPFIR::SetSimControlLI(setSimControl_);}
    bool hasPowerModes() const {return getPowerModes()();}
    UPFIR::IsolationTableLI getIsolationRules() const {return isolationRules_;}
    bool getDefaultDomainAlreadyPresent() const {return defDomainSet_;}
    const UPFIR::PowerMode *getDefaultPowerMode() const {return defaultMode_;}
    UPFIR::PowerDomain * findPowerDomain(const char* simpleName) const
    { return powerDomains_.lookup(simpleName); }
    UPFIR::RetentionStrategy * findRetentionStrategy(const char* simpleName) const
    { return retentionStrategies_.lookup(simpleName); }
    UPFIR::PowerSwitch * findPowerSwitch(const char* simpleName) const
    { return pwrSwitchs_.lookup(simpleName); }
    UPFIR::SupplyNet   * findSupplyNet(const char* simpleName) const
    { return supplyNets_.lookup(simpleName); }
    UPFIR::NominalCondition *findNominalCondition(const char* simpleName) const
    { return nominalConds_.lookup(simpleName); }
    UPFIR::PowerMode *findPowerMode(const char* simpleName) const
    { return powerModes_.lookup(simpleName); }
    UPFIR::IsolationStrategy *findIsolationRule(const char* simpleName) const
    { return isolationRules_.lookup(simpleName); }
    const char *getName() const {return name_;}
    const char *getFullName() const {return name_;}
    UPFIR::UpfClassType getUpfClassType() const {return UPFIR::PowerScopeC;}
    const char*   getKindStr() const {return 0;}
    unsigned int getLineNo() const {return 0;}
    const char* getFileName() const {return NULL;}
    UPFIR::PowerScope *getLastPowerScope() const {return powerScopes_.getLast();}
    bool isMacroModel() const {return false;}
    char getHierarchySeparator() const {return hierarchySep_;}
    CpfVirtualPort *getVirtualPort(const char *name)
    {return ports_.lookup(name);}
    //set/add functions
    void  addPowerScope(UPFIR::PowerScope* ps) {powerScopes_.append(ps);}
    void  addPowerDomain(UPFIR::PowerDomain* pd) {powerDomains_.append(pd);}
    void  addPowerSwitch(UPFIR::PowerSwitch* psw) {pwrSwitchs_.append(psw);}
    void  addRetentionStrategy(UPFIR::RetentionStrategy* rs) {retentionStrategies_.append(rs);}
    void  addSupplyNet(UPFIR::SupplyNet *sn) {supplyNets_.append(sn);}
    void  addNominalCondition(UPFIR::NominalCondition *nc) {nominalConds_.append(nc);}
    void  addPowerMode(UPFIR::PowerMode *pm) {powerModes_.append(pm);}
    void  addIsolationRule(UPFIR::IsolationStrategy *pm) {isolationRules_.append(pm);}
    void  addSetSimControl(UPFIR::SetSimControl *sc) {setSimControl_.append(sc);}
    void  setDefaultDomainAlreadyPresent() {defDomainSet_ = true;}
    void  setHierarchySeparator(char sep) {hierarchySep_ = sep;}
    void  setDefaultPowerMode(UPFIR::PowerMode *pm) {defaultMode_ = pm;}
    //debug function
    void  print() const;
    //utility function
    bool deepCopySingleInCurrentScope();
    void populateElementFromQueryObject();
    bool populateDesignObjectsForPorts();
    bool mergePowerModes(const char *scopeName);

private: //undefined
    CpfPowerDesignImpl(const CpfPowerDesignImpl &);
    CpfPowerDesignImpl & operator=(const CpfPowerDesignImpl &);
private:
    UPFIR::PowerScopeL                              powerScopes_;
    UPFIR::PowerDomainTableL                        powerDomains_;
    UPFIR::PowerSwitchTableL                        pwrSwitchs_;
    UPFIR::SupplyNetTableL                          supplyNets_;
    UPFIR::NominalCondTableL                        nominalConds_;
    UPFIR::PowerModeTableL                          powerModes_;
    UPFIR::RetentionStrategyTableL                  retentionStrategies_;
    UPFIR::IsolationTableL                          isolationRules_;
    char                                          * name_;
    bool                                            defDomainSet_;
    char                                            hierarchySep_;
    CpfVirtualPortTable                             ports_;
    bool                                            honorBoundaryPorts_;
    UPFIR::PowerMode                              * defaultMode_;
    UPFIR::SetSimControlL                           setSimControl_;
};

NAMESPACE_CPFIR_END

#endif
# 122 "./CpfPowerDesign.hh"
# 16 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "DesignObject.hh"
#endif /* expanded by -frewrite-includes */
# 16 "CpfRetentionStrategy.cc"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignObject.hh" 1
// SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work
// of Synopsys, Inc., and is fully protected under copyright and trade
// secret laws. You may not view, use, disclose, copy, or distribute
// this file or any information contained herein except pursuant to a
// valid written license from Synopsys.

///@file DesignObject.hh
///This file will provide the interface to DesignObject

#ifndef  __DESIGNOBJECT_HH__
#define  __DESIGNOBJECT_HH__

NAMESPACE_UPFIR_BEGIN

class DesignObjectImpl : public DesignObject
{
private :
    char * name_;
    char* mangledName_;
    unsigned scopeId_;
    DesignElementType dType_;
    bool valid_;
    unsigned isVerilog_;
    unsigned int dobjId_;
    static unsigned int dobjCount_;
private :
    DesignObjectImpl();
    DesignObjectImpl (const char *n, DesignElementType d);
    DesignObjectImpl (const char *n, const char* res, DesignElementType d);
public :
    VCS_DECL_SERIALIZABLE(DesignObjectImpl);
    void serialize(ser::Archive&);
    static DesignObjectImpl* createDesignObject(DesignElementType d);
    static DesignObjectImpl* createDesignObject(const char* elem, DesignElementType d) { return new DesignObjectImpl(elem, d);}
    ~DesignObjectImpl();
    DesignObjectImpl(char*n); 
    const char *getName() const { return name_; }
    const char *getName(bool convertVhNameToUpper);
    const char *getFullName() const {return name_;}
    char *getSimpleName (bool isResolved=true, bool stripEscape=false)  const;
    const char* getResolvedName() const { return dType_.resolvedName_; }
    const char* getResolvedNameRT() const { return dType_.resolvedNameRT_; }
    const char* getTargetName(bool resolved = false);
    std::string getInstanceNameTcl(bool checkInstance=true);
    DesignObject* getInstanceDesignObject();
    DesignObject* getParentDesignObject();
    int getPrefixPathLen ()  const;
    const char*   getKindStr() const {return ppiKindP[UpfElementC];}
    bool isVerilog () const {return isVerilog_; }
    DesignElementType getElementType() const {return dType_;}
    void setName(char *name) {name_ = name;}
    char* getMangledName() const {return mangledName_;}
    void setMangledName(const char* name);
    void setElemType(DesignElementType dt) { dType_ = dt;}
    UpfClassType getUpfClassType() const {return UpfElementC;}
    void* getTargetInstance() const { return dType_.instance_;}
    bool  isValid() const {return valid_;}
    bool isInsideBBox();

    unsigned int getLineNo() const {return 0;}
    const char* getFileName() const {return NULL;}
    bool isInstance() const {return (dType_.DESIGN_INSTANCE != 0);}
    void *getInstance() const {return dType_.instance_;}
    void *getElabInstance() const {return dType_.elabInstance_;}
    ApplyDirectionType getApplyDirectionType () const ;
    bool isUpfGenericClock() const {return false;}
    bool isUpfGenericData()const  {return false;}
    bool isUpfGenericAsyncLoad() const {return false;}
    bool isUpfGenericOutput() const {return false;}
    unsigned getScopeId() const { return scopeId_; }
    void setScopeId(unsigned id) { fassert(id, msg("non-zero scope id expected")); scopeId_ = id; }
    DesignElementTokenLI getTokenLI() {return DesignElementTokenLI(*(dType_.tokenL_));}
    DesignElementTokenL *getTokenL() {return (dType_.tokenL_);}
    void updateScopePointer(void* scope) { dType_.instance_ = scope;}
    void markInValid() {valid_ = false;}
    bool isAutoBlackBox(); 
    unsigned int getDobjId() { return dobjId_; }
    bool isUserSpecified() { return (dType_.USER_SPECIFIED != 0); }
    void setUserSpecified(bool b) { dType_.USER_SPECIFIED = b? 1: 0; }
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_SIGNAL , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_I_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_O_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_IO_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_INSTANCE , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_GATE_INSTANCE , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_MOD_INSTANCE , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_UDP_INSTANCE , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_TOP_MODULE , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, GENERATE_OR_BLOCK , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, PROCESS , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_NOT_SUPPORTED , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, IS_VERILOG , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, CELL_MAPPED , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, DESIGN_MODEL , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, UPF_LOGIC_NET , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, UPF_LOGIC_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, BLACK_BOX_TYPE,   dType_, BLACK_BOX , 2); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, WHITE_BOX , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, SPICE_I_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, SPICE_O_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, SPICE_IO_PORT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, WILDCARD_CLASSREF , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, INSIDE_CELL_DB , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, AT_CELL_DB , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, AT_MACRO_CELL_DB , 1);
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, OUT_OF_POWER_TOP , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, IS_ENCRYPT , 1); 
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, USER_SPECIFIED , 1);
    VCS_DECL_STRUCT_BITFIELD(DesignObjectImpl, unsigned int, dType_, cellId , 1);

};

NAMESPACE_UPFIR_END
#endif
# 116 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignObject.hh"
# 17 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "DesignQueryImpl.hh"
#endif /* expanded by -frewrite-includes */
# 17 "CpfRetentionStrategy.cc"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignQueryImpl.hh" 1
/***************************************************************************
  SYNOPSYS CONFIDENTIAL -- This is an unpublished, proprietary work of
  Synopsys, Inc., and is fully protected under copyright and trade secret
  laws. You may not view, use, disclose, copy, or distribute this file or
  any information contained herein except pursuant to a valid written
  license from Synopsys.
  Copyright: Synopsys @ 2010. All rights reserved.
 ***************************************************************************/
/***************************************************************************
Author:
Purpose:
****************************************************************************/
#ifndef __DESIGNQUERYIMPL_HH__
#define __DESIGNQUERYIMPL_HH__

NAMESPACE_UPFIR_BEGIN

DesignObject * getDesignObjInstance(DesignObject * dObj, QueryCmdType cType);

class DesignQueryImpl
{
public:
    DesignQueryImpl(const char *elem, QueryCmdType cType,
                    unsigned file, unsigned line);
    ~DesignQueryImpl();

    //get API
    const DesignObjectL &getObjectList() const {return _dObjList;}
    const DesignScopeL &getObjectScopeList() const {return _dScopeList;}
    const UpfObjL& getUpfObjectList() const { return _upfObjList; }
    //const charL &getObjectListStr() const {return _dObjListStr;}
    bool  getValidObjectList(DesignObjectL &, bool skipCellDBObjs=true) const;
    bool          isObjCreated() const {return _objCreated;}
    DesignObject *getExactDesignObject() const;
    const char   *getFileName() const;
    unsigned int  getLineNo() const;
    static bool   isWildCard(const char *);
    bool isAutoBlackBox() { return _isAutoBlackBox; }
    void setAutoBlackBox() { _isAutoBlackBox = true; }


private:
    bool expandObjStr(const char *scope, const char *elem,
                      int fType, QueryCmdType cType, bool isWC,
                      std::string& origElem);

    bool createExpandedObj(QueryCmdType cType);
    void addToScopeList(DesignObject* dObj, QueryCmdType cType);

private: //Non implemented function
    DesignQueryImpl();
    DesignQueryImpl(const DesignQueryImpl &);
    DesignQueryImpl & operator =(const DesignQueryImpl &);

private:
    charL          _dObjListStr;
    DesignObjectL  _dObjList;
    DesignScopeL   _dScopeList;
    UpfObjL        _upfObjList;
    bool           _exact;
    bool           _objCreated;
    unsigned       _file;
    unsigned       _line;
    bool           _isAutoBlackBox;
};

class DesignQueryMgr
{
public:
    static DesignQueryMgr *Instance();
    void   clear();
    bool   checkDesignObject(DesignObjectImpl *& dObj,
                             QueryCmdType        cType,
                             bool                exact,
                             const char         *fileName,
                             unsigned int        lineNo);

    static void resetInstance(void);
private:
    DesignQueryMgr() {};
    HashTableL<DesignObject> _exactObjTable[UNKNOWN_CMD];
    HashTableL<DesignObject> _expanObjTable[UNKNOWN_CMD];
    static DesignQueryMgr   *_instance;

private: //Non implemented function
    DesignQueryMgr(const DesignQueryMgr &);
    DesignQueryMgr & operator =(const DesignQueryMgr &);
};

NAMESPACE_UPFIR_END

#endif
# 93 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignQueryImpl.hh"
# 18 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "UpfExpressionParser.hh"
#endif /* expanded by -frewrite-includes */
# 18 "CpfRetentionStrategy.cc"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfreaderif/UpfExpressionParser.hh" 1
#ifndef __UPF_EXPRESSION_PARSER_HH__
#define __UPF_EXPRESSION_PARSER_HH__

extern char *globalExprBuffer;
extern char *globalExprBufferPtr;
extern bool parsingSupplyExpr;

extern int yyparse();


NAMESPACE_UPFIR_BEGIN

extern BoolExpr *upfFinalExpr;

extern getUpfPortByName globalGetPortFn;
extern UpfObj *globalCurrentObj;

bool checkRange(BoolExpr *minE, BoolExpr *maxE, const char * lhsStr, const char * rhsStr);
bool checkRange(double minVal, double maxVal, const char * commandName, const char * lhsStr, const char * rhsStr);
BoolExpr* makeExprId(char *id);
BoolExpr* makeExpression(UpfOpType oper, BoolExpr *exprR, BoolExpr *exprL=0);
BoolExpr* createExprFromString(const char* expr, getUpfPortByName getPortFn,
                               UpfObj* parentObj, const char * cmdStr = "",
                               bool convertDotToFwdSlash=true);
BoolExpr* makeConcatExpression(BoolExprL *exprL);
BoolExpr* makeConst(char *id, BoolExprL *volts);
BoolExpr* makeConst(double val);
BoolExpr* makeConst(char *id, int v);

// Functions related to -supply_expr
BoolExpr* makeSupplyConstant(char* state, BoolExprL *volts);
BoolExpr* makeSupplyNetFunction(char* name);
BoolExpr* makeSupplyExpression(UpfOpType oper, BoolExpr* supplyVal, BoolExpr* supply);

// Functions related to -logic_expr for group
BoolExpr* makeGroupObjectExpr(char *id);
BoolExpr* makeGroupStateExpr(char *id, BoolExpr*);

NAMESPACE_UPFIR_END

#endif
# 42 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfreaderif/UpfExpressionParser.hh"
# 19 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "DesignPort.hh"
#endif /* expanded by -frewrite-includes */
# 19 "CpfRetentionStrategy.cc"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh" 1
#ifndef __UPF_DESIGN_PORT_HH__
#define __UPF_DESIGN_PORT_HH__

#if 0 /* expanded by -frewrite-includes */
#include "UpfCommandInterface.hh"
#endif /* expanded by -frewrite-includes */
# 4 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh"
# 5 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh"
#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 5 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh"
# 6 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh"
#if 0 /* expanded by -frewrite-includes */
#include <vector>
#endif /* expanded by -frewrite-includes */
# 6 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh"
# 7 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh"


NAMESPACE_UPFIR_BEGIN
class UpfDesignPortImpl : public UpfDesignPort
{
public:
    UpfDesignPortImpl(const char* name, const char* portName, const char* resolvedName, unsigned isVerilog, void* instance, int cellId, DesignScope* dscope);
    UpfDesignPortImpl();
    VCS_DECL_SERIALIZABLE(UpfDesignPortImpl);
    bool isEncrypted() const { return false; }
    void serialize(ser::Archive&);
    UpfClassType getUpfClassType() const {return DesignPortC;}
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    const char* getFileName() const {
        unsigned int fl = getFileLineForSRSNSPA();
        return PowerNetworkImpl::getInstance()
               ->getFileName((fl & 0xfff00000) >> 20);
    }
    unsigned int getLineNo() const { 
        unsigned int fl = getFileLineForSRSNSPA();
        return fl  & 0x000fffff; 
    }
    unsigned int getFileLineForSRSNSPA() const;
    const char* getName() const { return name_.c_str(); }
    const char* getResolvedName() { return resolvedName_.c_str(); }
    const char* getPortName() { return portName_.c_str(); }
    DesignElementTokenL* getTokenL();
    DesignElementTokenLI getTokenLI(){ return DesignElementTokenLI(*(this->getTokenL())); }
    void* getHook() { return hook_; }
    void setHook(void* hook) { hook_ = hook; }
    DesignScope* getDesignScope() { return dscope_; }
    void setDesignScope(DesignScope* ds) { dscope_ = ds; }
    SupplyNet*  getRelatedPowerNet() { return relatedPower_ ? relatedPower_->getPowerNet() : NULL; }
    SupplyNet*  getRelatedGroundNet() { return relatedGround_ ? relatedGround_->getGroundNet() : NULL; }
    void setRelatedPowerNet(SRSNStrategy* snet);
    void setRelatedGroundNet(SRSNStrategy* snet);
    SRSNStrategy* getSrsnStrategy() { return relatedPower_ ? relatedPower_ : relatedGround_; } 
    SupplySetHandle*  getRelatedSupply();
    SupplySetHandle*  getDriverSupply() { return driverSupply_ ? static_cast<SupplySetHandle*>(driverSupply_->getUpfObjHandle()):0; }
    SupplySetHandle*  getReceiverSupply() { return receiverSupply_ ? static_cast<SupplySetHandle*>(receiverSupply_->getUpfObjHandle()):0; }
    SupplySetHandle*  getSrcSinkSupply() { return srcSinkSupply_ ? static_cast<SupplySetHandle*>(srcSinkSupply_->getUpfObjHandle()):0; }
    SupplySetHandle*  getRepeaterSupply() { return repeaterSupply_ ? static_cast<SupplySetHandle*>(repeaterSupply_->getUpfObjHandle()):0; }
    bool getRelatedSupplyDefaultPrimary();
    //void setRelatedSupply(SupplySetHandle* ssh);
    void setDriverSupply(SupplySetHandle* ssh);
    void setReceiverSupply(SupplySetHandle* ssh);
    void setRepeaterSupply(SupplySetHandle* ssh);
    void setSrcSinkSupply(SupplySetHandle* ssh);
    void setRelatedSupplyDefaultPrimary(bool rSDP);
    UpfDesignDirection getDirection() { return dir_; }
    void setDirection(UpfDesignDirection dir) { dir_ = dir; }
    unsigned isVerilog() { return isVerilog_; }
    int getId() { return id_; }
    int getCellId() { return cellId_; }
    int getSrsnStrategyIndex() { return srsnStraIndex_; }
    void setSrsnStrategyIndex(int idx);
    int getSpaStrategyIndex() { return spaStraIndex_; }
    void setSpaStrategyIndex(int idx);
    void* getInstance() { return instance_; }
    void markChipBoundaryPort() { isChipBoundaryPort_ = 1; }
    void markSvInterfaceModportPort() { isSvInterfaceModportPort_ = 1; }
    void markBBPort() { isBlackBoxPort_ = 1; }
    void markDontTouchPort() { isDontTouchPort_ = 1; }
    void markDomainBoundaryPort() { isDomainBoundaryPort_ = 1; }
    void markCellBoundaryPort() { isCellBoundaryPort_ = 1; }
    void markHasIsoSourceAttribute() { hasIsoSourceAttr_ = 1; }
    void markHasIsoSinkAttribute() { hasIsoSinkAttr_ = 1; }

    unsigned isChipBoundaryPort() { return isChipBoundaryPort_; }
    unsigned isSvInterfaceModportPort() { return isSvInterfaceModportPort_; }
    unsigned isBlackBoxPort() { return isBlackBoxPort_; }
    unsigned isDontTouchPort() { return isDontTouchPort_; }
    unsigned isDomainBoundaryPort() { return isDomainBoundaryPort_; }
    unsigned isCellBoundaryPort() { return isCellBoundaryPort_; }
    unsigned hasIsoSourceAttribute() { return hasIsoSourceAttr_; }
    unsigned hasIsoSinkAttribute() { return hasIsoSinkAttr_; }

    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, isVerilog_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, isChipBoundaryPort_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, isBlackBoxPort_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, isDomainBoundaryPort_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, isCellBoundaryPort_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, isSvInterfaceModportPort_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, hasIsoSourceAttr_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, hasIsoSinkAttr_, 1);
    VCS_DECL_BITFIELD(UpfDesignPortImpl, unsigned, isRelatedDefaultPrimary_, 1);

    static int getTotalDesignPortCount() { return count_; }

    // XoverGate Interface
    void addVhdlXoverGate(int gateId);
    XoverGateLI getVhdlXoverGates() { return XoverGateLI(vhGatesL_); }

    virtual ~UpfDesignPortImpl();
    void setPortAttribute(PortAttribute *a) {portAttr_ = a;}
    PortAttribute*  getPortAttribute() const {return portAttr_;}
    void setSupplyNetPair(SupplyNetPair* pair) { spair_ = pair; }
    SupplyNetPair* getSupplyNetPair() { return spair_; }
    void setRepeaterSupplyNetPair(SupplyNetPair* pair);
    SupplyNetPair* getRepeaterSupplyNetPair() { return rspair_ ? static_cast<SupplyNetPair*>(rspair_->getUpfObjHandle()):0; }
    std::string  getBBAttribute (std::string & attributeName);
    void         populateBBAttribute (std::map<std::string, std::string> &attrMap);
    void         populateIsoBBAttribute (std::map<std::string, std::vector<std::string> > &attrMap);
    void         setBBAttribute (std::string & attributeName, std::string & attributeVal);
    void         setIsoBBAttribute (std::string & attributeName, std::string & attributeVal);
    static void resetCount(void);
    LpSourceInfoLI getDriverList() const { return LpSourceInfoLI(driverList_); }
    unsigned int relatedPwrLineNo() const;
    unsigned int relatedGndLineNo() const;
    const char* relatedPwrFileName() const;
    const char* relatedGndFileName() const;
    const char* driverSupplyFileName() const;
    const char* receiverSupplyFileName() const;
    const char* srcSinkSupplyFileName() const;
    const char* repeaterSupplyFileName() const;
    unsigned int driverSupplyLineNo() const;
    unsigned int receiverSupplyLineNo() const;
    unsigned int srcSinkSupplyLineNo() const;
    unsigned int repeaterSupplyLineNo() const;

    ClampValueType getClampValue() const {return clampValue_;}
    void setClampValue(ClampValueType v) {clampValue_ = v;}

protected:
    unsigned int getFileLine();

private:
    std::string name_;
    std::string resolvedName_;
    std::string portName_;
    void*       hook_;
    void*       instance_;
    DesignScope* dscope_;
    SRSNStrategy*  relatedPower_;
    SRSNStrategy*  relatedGround_;
    LpSourceInfo*    driverSupply_;
    LpSourceInfo*    receiverSupply_;
    LpSourceInfo*    srcSinkSupply_;
    LpSourceInfo*    repeaterSupply_;
    UpfDesignDirection dir_;
    ClampValueType     clampValue_;
    XoverGateL         vhGatesL_;
    int         id_;
    int         cellId_;
    int         srsnStraIndex_;
    int         spaStraIndex_;
    unsigned    isVerilog_ : 1,
                isChipBoundaryPort_ : 1,
                isBlackBoxPort_ : 1,
                isDontTouchPort_ : 1,
                isDomainBoundaryPort_ : 1,
                isCellBoundaryPort_ : 1,
                isSvInterfaceModportPort_ : 1,
                hasIsoSourceAttr_ : 1,
                hasIsoSinkAttr_ : 1,
                isRelatedDefaultPrimary_ : 1;
    static int count_;
    PortAttribute* portAttr_;
    SupplyNetPair* spair_;
    LpSourceInfo* rspair_;
    LpSourceInfoL  driverList_;
    std::map<std::string, std::string> _attrMap;
    std::map<std::string, std::vector<std::string> > _isoAttrMap;
    unsigned int file_line;
    DesignElementTokenL *tokenL_;
};

class UpfLogicPortImpl : public UpfLogicPort,public UpfEncryptedObj
{
public:
    VCS_DECL_SERIALIZABLE(UpfLogicPortImpl);
    void serialize(ser::Archive&);
    UpfLogicPortImpl();
    UpfLogicPortImpl( const char* fullName, const char* simpleName, const char* resolvedName, UpfPortDirection dir, PowerScope * );
    ~UpfLogicPortImpl();
    const char* getName() const { return encryptName(name_.c_str()); }
    const char* getPortName() const { return encryptName(portName_.c_str()); }
    const char* getResolvedName() const { return encryptName(resolvedName_.c_str()); }
    UpfPortDirection getDirection() const { return dir_; }
    UpfLogicNet* getInsideNet();
    UpfLogicNet* getOutsideNet();
    void setInsideLogicNet(UpfLogicNet * net);
    void setInsideDesignNet(DesignObject * net);
    void setOutsideLogicNet(UpfLogicNet * net);
    void setOutsideDesignNet(DesignObject * net);
    DesignObject* getDesignInstance() { return instance_; }
    const char* getFileName() const {
        return PowerNetworkImpl::getInstance()
               ->getFileName((file_line & 0xfff00000) >> 20);
    }
    unsigned int getLineNo() const { return file_line & 0x000fffff; }
    unsigned getConnectionFileLineId() const { return connectionFileLine_; }
    void  setConnectionFileLineId(unsigned id) { connectionFileLine_ = id; }
    UpfClassType  getUpfClassType() const { return LogicPortC; }
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    void markImplemented() {isImplemenetd_ = true;}
    bool isImplemented() {return isImplemenetd_;}
    PowerScope *getPowerScope() {return logicScope_;}
    bool needReconnect() const { return reconnect_; }
    void setNeedReconnect() { reconnect_ = true; }
    DesignElementTokenL* getTokenL();
    DesignElementTokenLI getTokenLI() { return DesignElementTokenLI(*(this->getTokenL())); }
    void setTargetModName(std::string modName) { targetModName_ = modName; }
   const char* getTargetModName() const { return targetModName_.c_str(); } 
private:
    std::string name_;
    std::string portName_;
    std::string resolvedName_;
    DesignObject* instance_;
    UpfObj*      insideNet_;
    UpfObj*      outsideNet_;
    UpfPortDirection dir_;
    PowerScope *logicScope_;
    bool isImplemenetd_;
    unsigned int file_line;
    unsigned int connectionFileLine_;
    bool reconnect_;
    std::string targetModName_;
    DesignElementTokenL *tokenL_;
};

class UpfLogicNetImpl : public UpfLogicNet,public UpfEncryptedObj
{
public:
    VCS_DECL_SERIALIZABLE(UpfLogicNetImpl);
    void serialize(ser::Archive&);
    UpfLogicNetImpl();
    UpfLogicNetImpl(const char* fullName, const char* simpleNet, const char* resolvedName, PowerScope *);
    ~UpfLogicNetImpl();
    const char* getName() const { return encryptName(name_.c_str()); }
    const char* getNetName() const { return encryptName(netName_.c_str()); }
    const char* getResolvedName() const { return encryptName(resolvedName_.c_str()); }
    DesignObject* getDesignInstance() { return instance_; }
    void addConnectedLogicPort(UpfLogicPort * port) { connectedLogicPorts_.append(port); }
    void removeConnectedLogicPort(const UpfLogicPort * port);
    void addConnectedDesignPort(DesignObject * port) { connectedDesignPorts_.append(port); }
    UpfLogicPortLI getConnectedLogicPorts() { return UpfLogicPortLI(connectedLogicPorts_); }
    DesignObjectLI getConnectedDesignPorts() { return DesignObjectLI(connectedDesignPorts_); }
    const char* getFileName() const {
        return PowerNetworkImpl::getInstance()
               ->getFileName((file_line & 0xfff00000) >> 20);
    }
    unsigned int getLineNo() const { return file_line & 0x000fffff; }
    UpfClassType  getUpfClassType() const { return LogicNetC; }
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    void markImplemented() {isImplemenetd_ = true;}
    bool isImplemented() {return isImplemenetd_;}
    PowerScope *getPowerScope() {return logicScope_;}
    void addToLoadList();
    void addToDriverList();
    void detachDriverLoads();
    DesignElementTokenL* getTokenL();
    DesignElementTokenLI getTokenLI() { return DesignElementTokenLI(*(this->getTokenL())); }
    LpSourceInfoLI getLoadList() const   { return  LpSourceInfoLI(loadList_); }
    LpSourceInfoLI getDriverList() const { return LpSourceInfoLI(driverList_); }
    void setOwnerModName(std::string modName) { ownerModName_ = modName; }
    const char* getOwnerModName() const { return ownerModName_.c_str(); } 

private:
    std::string name_;
    std::string netName_;
    std::string resolvedName_;
    DesignObject* instance_;
    UpfLogicPortL connectedLogicPorts_;
    DesignObjectL  connectedDesignPorts_;
    PowerScope *logicScope_;
    bool isImplemenetd_;
    unsigned int file_line;
    LpSourceInfoL  driverList_;
    LpSourceInfoL  loadList_;
    std::string ownerModName_;
    DesignElementTokenL *tokenL_;
};
NAMESPACE_UPFIR_END
#endif
# 282 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/DesignPort.hh"
# 20 "CpfRetentionStrategy.cc" 2
#if 0 /* expanded by -frewrite-includes */
#include "UpfModel.hh"
#endif /* expanded by -frewrite-includes */
# 20 "CpfRetentionStrategy.cc"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh" 1
#ifndef __UPF_MODEL_HH__
#define __UPF_MODEL_HH__

#if 0 /* expanded by -frewrite-includes */
#include "UpfCommandInterface.hh"
#endif /* expanded by -frewrite-includes */
# 4 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
# 5 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
#if 0 /* expanded by -frewrite-includes */
#include "UpfTypeDefImpl.hh"
#endif /* expanded by -frewrite-includes */
# 5 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
# 6 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
#if 0 /* expanded by -frewrite-includes */
#include "PowerNetwork.hh"
#endif /* expanded by -frewrite-includes */
# 6 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
# 7 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
#if 0 /* expanded by -frewrite-includes */
#include "IsolationStrategy.hh"
#endif /* expanded by -frewrite-includes */
# 7 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
# 1 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/IsolationStrategy.hh" 1
#ifndef _ISOLATION_HH_
#define _ISOLATION_HH_
NAMESPACE_UPFIR_BEGIN

class IsolationStrategyImpl : public IsolationStrategy,public UpfEncryptedObj
{
public:
    VCS_DECL_SERIALIZABLE(IsolationStrategyImpl);
    virtual char* computePNMSignature();
    void deleteUpfStr(char* str) { getUpfLifeGuard()->destroyVolatileStr(str); }
    virtual unsigned getPNMCheckSum() const { return pnmCheckSum_; }
    virtual void setPNMCheckSum(unsigned cc) { pnmCheckSum_ = cc; }
    void setAppliesToSpecified(bool b) { _appliesToSpecifed = true; } 
    bool getAppliesToSpecifed() { return _appliesToSpecifed; }
    void serialize(ser::Archive&);
    IsolationStrategyImpl() ;
    IsolationStrategyImpl(char *scope, char *isoName, char * domain,
            DesignQueryImplL &elems, DesignQueryImplL &excludeElems,
                          unsigned int lineNo);
    ~IsolationStrategyImpl();
    UpfClassType  getUpfClassType() const;
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    lpmsg::LpMsgSeverity getMsgSeverity() {return msgSeverity_;}
    void setMsgSeverity(lpmsg::LpMsgSeverity sev) {msgSeverity_ = sev;}
    bool          getMsgEnabled() {return msgEnabled_;}
    void          setMsgEnabled(bool en) {msgEnabled_ = en;}
    const char* getName() const;
    const char* getFullName() const {return isolationName_;}
    const char *getDomain() const {return domain_;}
    const char* getScope() const {return isoScope_;}

    //container for iso enable, clamp value, iso sense.
    IsolationCellFuncLI getCellFunctions() const {return signals_;}
    IsolationCellFunc *getCellFunctionAtIdx(unsigned int isoId) const
    { return (isoId < signalCount_) ? signalVec_.at(isoId) : 0; }
    unsigned int getSignalCount() const { return signalCount_; }
    void addIsoCellFunc(IsolationCellFunc *f);

    //Multiple supply set. implicit supply set is present at 0th index.
    IsolationCellSupplyLI getCellSupplies() const {return supplies_;}
    IsolationCellSupply *getCellSupplyAtIdx(unsigned int id) const
    { return (id < supplyCount_) ? supplyVec_.at(id) : 0; }
    unsigned int getSupplyCount() const { return supplyCount_; }
    void addIsoCellSupply(IsolationCellSupply *s);
    DesignObjectLI getElements() const {return DesignObjectLI(elements_);}
    DesignQueryImplLI getQueryElements() const { return DesignQueryImplLI(queryElements_); }
    DesignObjectLI getExcludeElements() const {return DesignObjectLI(excludeElements_);}
    DesignQueryImplLI getQueryExcludeElements() const { return DesignQueryImplLI(queryExcludeElements_); }
    ApplyDirectionType getDirection()  const {return direction_;}
    SupplySetHandle * getSourceSupplySet() const {return source_;}
    SupplySetHandle * getSinkSupplySet() const {return sink_;}
    bool isNoIsolation() const { return isNoIsolation_;}
    bool isIsoCtrlInfoSpecified() const { return isoCtrlInfoSpecified_;}
    bool isInsideBbox() const {return insideBbox_;}
    bool isAutoBbox() const {return autoBbox_;} 
    bool isIsoSupplySpecified() const { return isIsoSupplySpecified_;}
    bool isNorIsolationEnabled() const { return norIsolation_;}
    bool isCdcCorruptionEnabled() const { return cdcCorruption_;}
    void appendQueryElement(DesignQueryImpl*e) { queryElements_.append(e);}
    void appendQueryExcludeElement(DesignQueryImpl*e) { queryExcludeElements_.append(e);}
    void appendElement(DesignObject *e) { elements_.append(e);}
    void appendExcludeElement(DesignObject *e) { excludeElements_.append(e);}
    LocationType getLocation() const { return location_;}
    void getLocationStr(char* policyLocation);
    NameFormat* getNameFormat() const {return nameFormat_;}
    const char* getIsoPrefix() const ;
    const char* getIsoSuffix() const ;
    const char *getEnableSignalName();

    ClampValueType getClampValue() const
    { fassert(0,"correct function is iso->getCellFunctions()()->getClampValue()"); return AnyC;}

    void setSourceSupplySet( SupplySetHandle *sSet) {
        source_ = sSet;
    }

    void setSinkSupplySet( SupplySetHandle *sSet) {
        sink_ = sSet;
    }

    void setDirection(ApplyDirectionType dir) {
        direction_ = dir;
    }

    void setIsoCtrlInfoSpecified(bool b) {
        isoCtrlInfoSpecified_ = b;
    }

    void setInsideBbox() {
        insideBbox_ = true;
    }

    void setAutoBbox();
    void markAllCellSuppliesAutoBlackBox();
    void setIsImplicitSuppliesUnused(bool val);

    void setIsIsoSupplySpecified() {
        isIsoSupplySpecified_ = true;
    }

    void setIsNoIsolation(bool noIso) {
        isNoIsolation_ = noIso;
    }

    void setNorIsolationEnabled(bool norIsolation) {
        norIsolation_ = norIsolation;
    }

    void setCdcCorruptionEnabled(bool cdcCorruption) {
        cdcCorruption_ = cdcCorruption;
    }

    void setLocation(LocationType loc) {
        location_ = loc;
    }
    unsigned int getFileLine() const { return file_line; }
    virtual const char* getFileName() const {
        return PowerNetworkImpl::getInstance()
               ->getFileName((file_line & 0xfff00000) >> 20);
    }
    virtual unsigned int getLineNo() const { return file_line & 0x000fffff; }
    static int getTotalIsolationStrategyCount() { return isolationCount_; }
    static void resetIsolationCount();
    static void resetClassType();

    bool doSemanticCheck()const ;
    void replaceElementList(DesignObjectL& dobjL);
    void replaceExcludeElementList(DesignObjectL& dobjL);
    void populateElementFromQueryObject();

    void setAutoPower() { autoPower_ = true;}
    bool isAutoPower() { return autoPower_; }

    void setMappedIso() {mappedIso_ = true;}
    bool isMappedIso() {return mappedIso_;}

    bool isVerilogScope() {return isVerilogScope_;}
    void setVerilogScope(bool b) {isVerilogScope_ = b;}
    // below function checks whether its enable or PG nets are in VHDL
    // scope so that if its instantiated in verilog module
    // Cross Module ref error will come

    bool hasVHDLComponents ();
    void setTargetScope(void *s) {targetScope_ = s;}
    void *getTargetScope() { return targetScope_;}
    void setGenericCheckerInstName(char *s); 
    char *getGenericCheckerInstName() { return genCheckerInstName_;}
    void setAllDone(bool b) { allDone_ = b;}
    bool getAllDone() { return allDone_;}
    void setAlreadyImplementedPolicy(unsigned b) { isImplemented_ = b; }
    unsigned isAlreadyImplemented() { return isImplemented_; }
    unsigned int getId() { return id;}
    void setId (unsigned int i ) { id = i;}
    unsigned int getScopeId() { return scopeId_;}
    void setScopeId (unsigned int i ) { scopeId_ = i;}
    void appendIsoCellFunc(IsolationCellFunc *f) {signals_.append(f);}
    unsigned isDiffSupplyOnly() { return isDiffSupplyOnly_; }
    void setDiffSupplyOnly(unsigned b ) { isDiffSupplyOnly_ = b; }
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, isVerilogScope_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, isImplemented_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, isNoIsolation_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, norIsolation_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, cdcCorruption_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, isDiffSupplyOnly_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, allDone_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, hasBindChecker_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, autoPower_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, mappedIso_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, insideBbox_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, autoBbox_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, isXoverTogglePolicy_, 1);
    VCS_DECL_BITFIELD(IsolationStrategyImpl, unsigned, isEmptyIsoSupplySetSpecified_, 1);

    //added for CPF.
    BoolExpr* getIsolationCondition() const { fassert(0,"Undefined Function getIsolationCondition()"); return 0; }
    PowerDomainLI getFromPowerDomainList() const { fassert(0,"Undefined Function getFromPowerDomainList()"); return 0; }
    PowerDomainLI getToPowerDomainList() const { fassert(0,"Undefined Function getToPowerDomainList()"); return 0; }
    UPFIR::PowerDomain * getSecondaryDomain() const {fassert(0, "Undefined Function getSecondaryDomain()"); return 0;}
    void setSecondaryDomain(UPFIR::PowerDomain * domain) {fassert(0, "Undefined Function setSecondaryDomain()");}
    void print() const { }

    // XoverGate Interface
    void addVhdlXoverGate(int gateId, int srcPdId, int sinkPdId);
    void addMetaInstance(MetaInstance * mInst);
    XoverGateLI getVhdlXoverGates() { return XoverGateLI(vhGatesL_); }
    MetaInstanceLI getMetaInstances() { return MetaInstanceLI(metaInstancesL_); }

    void addToIsoSinkDomain(char* parentInst,const char* nodeName,std::vector<int> sinkDomains); 
    IsoSinkDomainsDBLI getIsoSinkDOmains() {return IsoSinkDomainsDBLI(isoSinkDomains_); }
    void addIsoDBCell(char* dbInst) { 
        char* instName = getUpfLifeGuard()->createVolatileStr(strlen(dbInst) + 1);
        strcpy(instName,dbInst);
        isoDBCells_.push_back(instName);
    }
    std::vector<char*> &getIsoDBCells() { return isoDBCells_;}
    /* ------------------------------------------------------- */
    /* ------------------- BIND Checker Interface ------------ */
    /* ------------------------------------------------------- */
    void addController(void* m);
    void* getController();
    void addControllerName(const char* name);
    const char* getControllerName();
    void destroyNonGenericBindCheckers();
    ///Add a bind checker object to the container
    void addBindChecker(BindChecker* bc);
    ///check whether there is any single bindchecker object
    bool hasBindChecker();
    ///get all bind checker objects
    BindCheckerLI getBindCheckers();
    /* ------------------------------------------------------- */
    void setXoverTogglePolicy() { isXoverTogglePolicy_ = true; }
    bool isXoverTogglePolicy() { return isXoverTogglePolicy_; }
    void setEmptyIsoSupplySet() { isEmptyIsoSupplySetSpecified_ = true; }
    bool isEmptyIsoSupplySet() const { return isEmptyIsoSupplySetSpecified_; }

private:
    bool                                _appliesToSpecifed;
    char                                *isolationName_;
    char                                *domain_;
    std::vector<SupplySetHandle*>        supplySetVec_;
    mutable DesignObjectL                elements_;
    DesignQueryImplL                     queryElements_;
    DesignObjectL                        excludeElements_;
    DesignQueryImplL                     queryExcludeElements_;
    ApplyDirectionType                   direction_;
    SupplySetHandle                     *source_;
    SupplySetHandle                     *sink_;
    LocationType                         location_;
    char                                *isoScope_;
    NameFormat                          *nameFormat_;
    IsolationCellFuncL                   signals_;
    std::vector<IsolationCellFunc*>      signalVec_;
    unsigned int                         signalCount_;
    IsolationCellSupplyL                 supplies_;
    std::vector<IsolationCellSupply*>    supplyVec_;
    unsigned int                         supplyCount_;
    XoverGateL                           vhGatesL_;
    MetaInstanceL                        metaInstancesL_;
    lpmsg::LpMsgSeverity                 msgSeverity_;
    unsigned int                         file_line;
    unsigned int                         id;
    unsigned int                         scopeId_;
    static int                           isolationCount_;
    ///Slist of bind checkers
    BindCheckerL        bindCheckers_;
    void*             nlpController_;
    char*               nlpControllerName_;
    IsoSinkDomainsDBL                    isoSinkDomains_;
    std::vector<char*>                   isoDBCells_;


    unsigned pnmCheckSum_;
    unsigned isVerilogScope_  : 1,
             isImplemented_ : 1,
             isNoIsolation_ : 1,
             norIsolation_ : 1,
             cdcCorruption_ : 1,
             isDiffSupplyOnly_ : 1,
             hasBindChecker_ : 1,
             autoPower_ : 1,
             mappedIso_ : 1,
             allDone_ : 1,
             msgEnabled_ :1 ,
             isoCtrlInfoSpecified_ : 1,
             insideBbox_           : 1,
             autoBbox_ :1,
             isIsoSupplySpecified_ : 1,
             isXoverTogglePolicy_ : 1,
             isEmptyIsoSupplySetSpecified_ : 1;   
    static UpfClassType      classType_;
    void *targetScope_;
    char *genCheckerInstName_;
};

class IsolationCellFuncImpl : public IsolationCellFunc,public UpfEncryptedObj
{
public:
    VCS_DECL_SERIALIZABLE(IsolationCellFuncImpl);
    IsolationCellFuncImpl();
    IsolationCellFuncImpl(UpfObj*, const char *sigName);
    virtual ~IsolationCellFuncImpl();

    void serialize(ser::Archive&);

    virtual char* computePNMSignature();
    void deleteUpfStr(char* str) { getUpfLifeGuard()->destroyVolatileStr(str); }
    const char* getName() const { return encryptName(isoEnableSimpleName_); }
    const char* getFullName() const;
    const char* getIsoEnableName() const { return getFullName(); }
    const char* getIsoEnableSimpleName() const { return getName(); }
    UpfObj* getIsoEnable() const  {return isoEnable_;}
    IsolationSenseType getIsolationSense() const {return isolationSense_;}
    ClampValueType getClampValue() const {return clampValue_;}

    void setIsoEnable(UpfObj* obj, const char *name);
    void setClampValue(ClampValueType v) {clampValue_ = v;}
    void setSense(IsolationSenseType s) {isolationSense_ = s;}
    const char* getFileName() const {
        return PowerNetworkImpl::getInstance()
               ->getFileName((file_line & 0xfff00000) >> 20);
    }
    unsigned int getLineNo() const { return file_line & 0x000fffff; }
    UpfClassType getUpfClassType() const;
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    void addToLoadList();
    LpSourceInfoLI getLoadList() const {
        return LpSourceInfoLI(loadList_);
    }
    DesignElementTokenL* getTokenL();
    DesignElementTokenLI getTokenLI() { return DesignElementTokenLI(*(this->getTokenL())); }
private:
    void detachLoads();
private:
    UpfObj                 *isoEnable_;
    char                   *isoEnableSimpleName_;
    IsolationSenseType      isolationSense_;
    ClampValueType          clampValue_;
    unsigned int            file_line;
    LpSourceInfoL           loadList_;

    static UpfClassType     classType_;
};

class IsolationCellSupplyImpl : public IsolationCellSupply,public UpfEncryptedObj
{
public:
    VCS_DECL_SERIALIZABLE(IsolationCellSupplyImpl);
    IsolationCellSupplyImpl();
    IsolationCellSupplyImpl(SupplySetHandle *handle);
    virtual ~IsolationCellSupplyImpl();

    void serialize(ser::Archive&);

    const char* getName() const { return 0; }
    const char* getFullName() const;
    SupplySetHandle *getSupplySetHandle() const { return supplySetHandle_; }
    SupplyNet * getPowerNet() const;
    SupplyNet * getGroundNet() const;
    SupplyNet * getPwellNet() const;
    SupplyNet * getNwellNet() const;
    SupplyNet * getDeepNwellNet() const;
    SupplyNet * getDeepPwellNet() const;
    void setPowerNet( SupplyNet *net) { isoPowerNet_ = net; }
    void setGroundNet( SupplyNet *net) { isoGndNet_ = net; }

    const char* getFileName() const {
        return PowerNetworkImpl::getInstance()
               ->getFileName((file_line & 0xfff00000) >> 20);
    }
    unsigned int getLineNo() const { return file_line & 0x000fffff; }
    UpfClassType getUpfClassType() const { return classType_; }
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    void markAllSuppliesAutoBlackBox();
    void setIsImplicitSuppliesUnused(bool val) { 
        supplySetHandle_->setIsImplicitUnused(true); 
    }

private:
    SupplySetHandle                 *supplySetHandle_;
    SupplyNet                       *isoPowerNet_;
    SupplyNet                       *isoGndNet_;
    unsigned int                     file_line;
    static UpfClassType              classType_;
};

class IsoSinkDomainsDBImpl : public IsoSinkDomainsDB
{
public:
    VCS_DECL_SERIALIZABLE(IsoSinkDomainsDBImpl);
    IsoSinkDomainsDBImpl(char* parentInst,const char* nodeName);
    IsoSinkDomainsDBImpl();
    virtual ~IsoSinkDomainsDBImpl();
    char* getParentInst() { return parentInst_;}
    char* getNodeName() {return nodeName_;}
    void addToSinkDomainList(int p) {sinkDomainL_.push_back(p);}
    std::vector<int>& getSinkDomainsList() { return sinkDomainL_; }
    const char* getFileName() const {
        return NULL;
    }
    unsigned int getLineNo() const { return 0; }
    UpfClassType getUpfClassType() const { return classType_; }
    const char*   getKindStr() const {return NULL;}
    void serialize(ser::Archive&);

private:
    char* parentInst_;
    char* nodeName_;
    std::vector<int> sinkDomainL_;
    static UpfClassType              classType_;
};



NAMESPACE_UPFIR_END

#endif //_ISOLATION_HH_
# 397 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/IsolationStrategy.hh"
# 8 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh" 2

#if 0 /* expanded by -frewrite-includes */
#include <string>
#endif /* expanded by -frewrite-includes */
# 9 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
# 10 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
NAMESPACE_UPFIR_BEGIN

class DesignModelImpl : public DesignModel {
public:
    DesignModelImpl(const char * module, void* hook, unsigned int fileLine);
    DesignModelImpl(const char* canonicalName, const char* lib, const char* entity,
                    const char* arch, unsigned int fileLine);
    DesignModelImpl();
    VCS_DECL_SERIALIZABLE(DesignModelImpl);
    void serialize(ser::Archive&);
    UpfClassType getUpfClassType() const {return DesignModelC;}
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    unsigned int getLineNo() const {
        return file_line & 0x000fffff;
    }
    const char* getFileName() const {
        return PowerNetworkImpl::getInstance()->getFileName((file_line & 0xfff00000) >> 20);
    }
    const char* getName() const { return canonicalName_.c_str(); }
    const char* getFullName() const { return canonicalName_.c_str(); }
    void* getHook() { return hook_; }
    void setHook(void* hook) { hook_ = hook; }
    unsigned  getSimStateBehavior() { return simStateEnabled_; }
    void  setLeafCell() { isLeaf_ = 1; }
    unsigned  isLeafCell() { return isLeaf_; }
    void  setMacroCell() { isMacro_ = 1; }
    unsigned  isMacroCell() { return isMacro_; }
    charLI getDontTouchNodes() { return charLI(nodes_); }
    void setDontTouchNode(const char* node);
    void replaceDontTouchNode(charL& resolvedDontTouchNode);
    void  setSimStateBehavior(const char* lib, bool enable);
    unsigned isVerilog() { return isVerilog_; }
    void setIsVerilog (bool b) { isVerilog_ = b;}
    void setModelDontTouch() { isModelDontTouch_ = 1; }
    void setModelDisableCoa() { isDisableCoa_ = 1; }
    void setModelReinit(bool reinit, bool transitive);
    void setModelDontReinit(bool reinit, bool transitive);
    bool isRuntimeConfigurationEnabled() { return isRuntimeConfigurationEnabled_; }
    ReinitType getModelReinit() { return reinit_; }
    void setReinitNamedBlock(const char* elem);
    void setOrigReinitNamedBlock(const char* elem);
    void setDontReinitNamedBlock(const char* elem);
    bool hasReinitNamedBlocks() { return  hasReinitNamedBlocks_; }
    bool hasOrigReinitNamedBlocks() { return  hasOrigReinitNamedBlocks_; }
    bool hasDontReinitNamedBlocks() { return  hasDontReinitNamedBlocks_; }
    CharLI getReinitNamedBlocks() { return  charLI(reinitNb_); }
    CharLI getOrigReinitNamedBlocks() { return  charLI(origreinitNb_); }
    CharLI getDontReinitNamedBlocks() { return  charLI(dontReinitNb_); }
    unsigned hasDontTouchNodes() { return hasDontTouchNodes_; }
    unsigned isModelDontTouch() { return isModelDontTouch_; }
    unsigned isModelDisableCoa() { return isDisableCoa_; }
    unsigned isSimStateBehaviorDefined() { return simStateInitialized_; }
    const char* getDbLibrary() { return dbLib_.c_str(); }
    const char* getLibraryName() { return lib_.c_str(); }
    const char* getEntityName() { return entity_.c_str(); }
    const char* getArchName() { return arch_.c_str(); }
    void setSRPG() {hasSRPGSeqElement_ = true;}
    unsigned hasSRPGSequentialElement() {return hasSRPGSeqElement_;}
    unsigned isRandomCorruptionEnabled() { return corEn_; }
    void setRandomCorruption(unsigned corEn) { corEn_ = corEn; }
    void setPowerUpf2SvVct(Upf2SvInbuiltType vct) {pwrUpf2SvVct_ = vct; }
    Upf2SvInbuiltType getPowerUpf2SvVct() {return pwrUpf2SvVct_; }
    void setGroundUpf2SvVct(Upf2SvInbuiltType vct) {gndUpf2SvVct_ = vct; }
    Upf2SvInbuiltType getGroundUpf2SvVct() {return gndUpf2SvVct_; }
    void setPowerSv2UpfVct(Sv2UpfInbuiltType vct) {pwrSv2UpfVct_ = vct; }
    Sv2UpfInbuiltType getPowerSv2UpfVct() {return pwrSv2UpfVct_; }
    void setGroundSv2UpfVct(Sv2UpfInbuiltType vct) {gndSv2UpfVct_ = vct; }
    Sv2UpfInbuiltType getGroundSv2UpfVct() {return gndSv2UpfVct_; }
    void setVoltageAwareCheckerMod(bool b) { bVoltageAwareCheckerMod_ = b; }
    bool isVoltageAwareCheckerMod() { return bVoltageAwareCheckerMod_; }
    void setAsBlackBox() { isBlackBox_ = true; }
    bool isBlackBox() { return isBlackBox_; }
    void setAsInsideBlackBox() { isInsideBlackBox_ = true; }
    bool isInsideBlackBox() { return isInsideBlackBox_; }

    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, simStateEnabled_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, simStateInitialized_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, isLeaf_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, isMacro_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, hasDontTouchNodes_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, hasReinitNamedBlocks_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, hasOrigReinitNamedBlocks_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, hasDontReinitNamedBlocks_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, isRuntimeConfigurationEnabled_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, isModelDontTouch_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, isDisableCoa_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, isVerilog_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, hasSRPGSeqElement_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, corEn_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, bVoltageAwareCheckerMod_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, isInsideBlackBox_,1);
    /*VCS_DECL_BITFIELD(DesignModelImpl, unsigned, pwrUpf2SvVct_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, gndUpf2SvVct_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, pwrSv2UpfVct_, 1);
    VCS_DECL_BITFIELD(DesignModelImpl, unsigned, gndSv2UpfVct_, 1);*/
    ~DesignModelImpl();
private:
    charL         reinitNb_;
    charL         origreinitNb_;
    charL         dontReinitNb_;
    charL         nodes_;
    std::string   canonicalName_;
    std::string   lib_;
    std::string   entity_;
    std::string   arch_;
    void*         hook_;
    std::string   dbLib_;
    unsigned int file_line;
    ReinitType    reinit_;
    Upf2SvInbuiltType   pwrUpf2SvVct_;
    Upf2SvInbuiltType   gndUpf2SvVct_;
    Sv2UpfInbuiltType   pwrSv2UpfVct_;
    Sv2UpfInbuiltType   gndSv2UpfVct_;
    unsigned      simStateEnabled_ : 1;
    unsigned      simStateInitialized_ : 1;
    unsigned      isLeaf_ : 1;
    unsigned      isMacro_ : 1;
    unsigned      isModelDontTouch_ : 1;
    unsigned      isRuntimeConfigurationEnabled_ : 1;
    unsigned      hasDontTouchNodes_ : 1;
    unsigned      hasReinitNamedBlocks_ : 1;
    unsigned      hasOrigReinitNamedBlocks_ : 1;
    unsigned      hasDontReinitNamedBlocks_ : 1;
    unsigned      hasSRPGSeqElement_ : 1;
    unsigned      isVerilog_ : 1;
    unsigned      corEn_ : 1;
    unsigned      bVoltageAwareCheckerMod_ : 1;
    unsigned      isInsideBlackBox_ : 1;
    unsigned      isBlackBox_ : 1;
    unsigned      isDisableCoa_ : 1;
};
class DesignScopeImpl : public DesignScope
{
public:
    VCS_DECL_SERIALIZABLE(DesignScopeImpl);
    DesignScopeImpl(DesignObject* dobj, unsigned int id);
    DesignScopeImpl();
    ~DesignScopeImpl();
    void serialize(ser::Archive& ar);
    UpfClassType getUpfClassType() const {return DesignScopeC;}
    const char*   getKindStr() const {return ppiKindP[getUpfClassType()];}
    unsigned int getLineNo() const {
        return file_line_ & 0x000fffff;
    }
    const char* getFileName() const {
        return PowerNetworkImpl::getInstance()->getFileName((file_line_ & 0xfff00000) >> 20);
    }
    const char* getMasterModName() { return masterModuleName_; }
    DesignObject* getDesignObject() { return dobj_; }
    void setDesignObject(DesignObject* dobj) { dobj_ = dobj; }
    unsigned int getId() { return id_; }
    unsigned isVerilog() { return dobj_->isVerilog(); }
    const void* getInstance() const { return dobj_->getTargetInstance(); }
    void* getHook() { return hook_; }
    void setHook(void* hook) { hook_ = hook; }
    SupplyNet* getRelatedPowerNet() { return relatedPower_ ? relatedPower_->getPowerNet() : NULL; }
    SupplyNet* getRelatedGroundNet() { return relatedGround_ ? relatedGround_->getGroundNet() : NULL; }
    const char* getRelatedPowerFile() {return relatedPower_ ? relatedPower_->getFileName() : NULL;}
    int getRelatedPowerLine() {return relatedPower_ ? relatedPower_->getLineNo() : 0;}
    const char* getRelatedGroundFile() {return relatedGround_ ? relatedGround_->getFileName() : NULL;}
    int getRelatedGroundLine() {return relatedPower_ ? relatedPower_->getLineNo() : 0;}
    void setRelatedPowerNet(SRSNStrategy* srsn) { relatedPower_ = srsn; }
    void setRelatedGroundNet(SRSNStrategy* srsn) { relatedGround_ = srsn; }
    SRSNStrategy* getSrsnStrategy() { return relatedPower_ ? relatedPower_ : relatedGround_; }
    SupplySetHandle*  getRelatedSupplyInputs () { return relatedSupplyInputs_ ? static_cast<SupplySetHandle*>(relatedSupplyInputs_->getUpfObjHandle()):0; }
    const char* getRelatedSupplyInputsFile() {return relatedSupplyInputs_ ? relatedSupplyInputs_->getFileName() : 0;}
    int getRelatedSupplyInputsLine() {return relatedSupplyInputs_ ? relatedSupplyInputs_->getLineNo() : 0;}
    SupplySetHandle*  getRelatedSupplyOutputs() { return relatedSupplyOutputs_ ? static_cast<SupplySetHandle*>(relatedSupplyOutputs_->getUpfObjHandle()):0; }
    const char* getRelatedSupplyOutputsFile() {return relatedSupplyOutputs_ ? relatedSupplyOutputs_->getFileName() : 0;}
    int getRelatedSupplyOutputsLine() {return relatedSupplyOutputs_ ? relatedSupplyOutputs_->getLineNo() : 0;}
    SupplySetHandle*  getDriverSupplyInputs () { return driverSupplyInputs_ ? static_cast<SupplySetHandle*>(driverSupplyInputs_->getUpfObjHandle()):0; }
    const char* getDriverSupplyInputsFile() {return driverSupplyInputs_ ? driverSupplyInputs_->getFileName() : 0;}
    int getDriverSupplyInputsLine() {return driverSupplyInputs_ ? driverSupplyInputs_->getLineNo() : 0;}
    SupplySetHandle*  getReceiverSupplyInputs () { return receiverSupplyInputs_ ? static_cast<SupplySetHandle*>(receiverSupplyInputs_->getUpfObjHandle()):0; }
    const char* getReceiverSupplyInputsFile() {return receiverSupplyInputs_ ? receiverSupplyInputs_->getFileName() : 0;}
    int getReceiverSupplyInputsLine() {return receiverSupplyInputs_ ? receiverSupplyInputs_->getLineNo() : 0;}
    SupplySetHandle*  getDriverSupplyOutputs () { return driverSupplyOutputs_ ? static_cast<SupplySetHandle*>(driverSupplyOutputs_->getUpfObjHandle()):0; }
    const char* getDriverSupplyOutputsFile() {return driverSupplyOutputs_ ? driverSupplyOutputs_->getFileName() : 0;}
    int getDriverSupplyOutputsLine() {return driverSupplyOutputs_ ? driverSupplyOutputs_->getLineNo() : 0;}
    SupplySetHandle*  getReceiverSupplyOutputs () { return receiverSupplyOutputs_ ? static_cast<SupplySetHandle*>(receiverSupplyOutputs_->getUpfObjHandle()):0; }
    const char* getReceiverSupplyOutputsFile() {return receiverSupplyOutputs_ ? receiverSupplyOutputs_->getFileName() : 0;}
    int getReceiverSupplyOutputsLine() {return receiverSupplyOutputs_ ? receiverSupplyOutputs_->getLineNo() : 0;}
    SupplySetHandle*  getSrcSupply () { return srcSupply_ ? static_cast<SupplySetHandle*>(srcSupply_->getUpfObjHandle()):0; }
    const char* getSrcSupplyFile() {return srcSupply_ ? srcSupply_->getFileName() : 0;}
    const char* getSinkSupplyFile() {return sinkSupply_ ? srcSupply_->getFileName() : 0;}
    int getSrcSupplyLine() {return srcSupply_ ? srcSupply_->getLineNo() : 0;}
    int getSinkSupplyLine() {return sinkSupply_ ? srcSupply_->getLineNo() : 0;}
    SupplySetHandle*  getRepeaterSupply () { return repeaterSupply_ ? static_cast<SupplySetHandle*>(repeaterSupply_->getUpfObjHandle()):0; }
    const char* getRepeaterSupplyFile() {return repeaterSupply_ ? repeaterSupply_->getFileName() : 0;}
    int getRepeaterSupplyLine() {return repeaterSupply_ ? repeaterSupply_->getLineNo() : 0;}
    UpfDesignDirection getRepeaterAppliesTo() { return repeaterAppliesTo_; }
    SupplySetHandle*  getSinkSupply () { return sinkSupply_ ? static_cast<SupplySetHandle*>(sinkSupply_->getUpfObjHandle()):0; }
    bool getRelatedSupplyDefaultPrimaryInputs();
    bool getRelatedSupplyDefaultPrimaryOutputs();
    void setRepeaterAppliesTo(UpfDesignDirection dir) { repeaterAppliesTo_ = dir; }
    void setRelatedSupplyInputs (SupplySetHandle* ssh);
    void setRelatedSupplyOutputs(SupplySetHandle* ssh);
    void setDriverSupplyInputs (SupplySetHandle* ssh);
    void setDriverSupplyOutputs(SupplySetHandle* ssh);
    void setReceiverSupplyInputs (SupplySetHandle* ssh);
    void setReceiverSupplyOutputs(SupplySetHandle* ssh);
    void setSrcSupply(SupplySetHandle* ssh);
    void setRepeaterSupply(SupplySetHandle* ssh);
    void setSinkSupply(SupplySetHandle* ssh);
    void setRelatedSupplyDefaultPrimary(bool rSDP, const char * appliesTo);
    bool isTerminalBoundary() { return isTerminalBoundary_; }
    void setTerminalBoundary(bool b) { isTerminalBoundary_ = b; }
    bool isIsoTerminalBoundary() { return isIsoTerminalBoundary_; }
    void setIsoTerminalBoundary(bool b) { isIsoTerminalBoundary_ = b; }
    void setDesignTop() { isDesignTop_ = 1; }
    unsigned isDesignTop() { return isDesignTop_; }
    unsigned isRandomCorruptionEnabled() { return corEn_; }
    void setRandomCorruption(unsigned corEn) { corEn_ = corEn; }
    unsigned isAlwaysOn() { return isAlwaysOn_; }
    ReinitType getReinit() { return reinit_; }
    void setReinit(bool reinit, bool transitive);
    void setDontReinit(bool reinit, bool transitive);
    bool isRuntimeConfigurationEnabled() { return isRuntimeConfigurationEnabled_; }
    void setDontTouch() { isAlwaysOn_ = 1; }
    int getCellId() { return cellId_; }
    bool setLowerDomainBoundary(bool val);
    bool setLowerDomainBoundaryOnDesignScope(bool val);
    bool isLowerDomainBoundarySet(){return isLowerDomainBoundaryAttributeSet_;}
    int getLowerDomainBoundaryAttribute(){return lowerDomainBoundary_;}
    int getSrsnStrategyIndex() { return srsnStraIndex_; }
    void setSrsnStrategyIndex(int idx);
    int getSpaStrategyIndex() { return spaStraIndex_; }
    void setSpaStrategyIndex(int idx);
    unsigned int getFileLineForSRSNSPA() const { return file_line_; }
    void setFileLineForSRSNSPA(unsigned int fileId, unsigned int lineNo) {
        file_line_ = (fileId << 20) | lineNo;
    }
    void setScopeLDBData(bool val = false, const char* scope = NULL);
    LowerDomainBoundaryData* getScopeLDBData() {return scopeLDBData_;}
    // XoverGate Interface
    void addVhdlXoverGate(int gateId);
    void addVhdlXoverGateInputs(int gateId);
    void addVhdlXoverGateOutputs(int gateId);
    XoverGateLI getVhdlXoverGates() { return XoverGateLI(vhGatesL_); }
    XoverGateLI getVhdlXoverGatesInputs() { return XoverGateLI(vhGatesInputsL_); }
    XoverGateLI getVhdlXoverGatesOutputs() { return XoverGateLI(vhGatesOutputsL_); }
    void setSupplyNetPair(SupplyNetPair* pair) { spair_ = pair; }
    void setRepeaterSupplyNetPair(SupplyNetPair* pair);
    SupplyNetPair* getRepeaterSupplyNetPair() { return rspair_ ? static_cast<SupplyNetPair*>(rspair_->getUpfObjHandle()):0; }
    SupplyNetPair* getSupplyNetPair() { return spair_; }
   

    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isDesignTop_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isRuntimeConfigurationEnabled_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isIsoTerminalBoundary_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, corEn_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isRelatedDefaultPrimaryInputs_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isRelatedDefaultPrimaryOutputs_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isAlwaysOn_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isLowerDomainBoundaryAttributeSet_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, lowerDomainBoundary_, 1);
    VCS_DECL_BITFIELD(DesignScopeImpl, unsigned, isTerminalBoundary_, 1);

protected:
    unsigned int getFileLine() ;

private:
    DesignObject* dobj_;
    SRSNStrategy*    relatedPower_;
    SRSNStrategy*    relatedGround_;
    LpSourceInfo*    relatedSupplyInputs_;
    LpSourceInfo*    relatedSupplyOutputs_;
    LpSourceInfo*    driverSupplyInputs_;
    LpSourceInfo*    driverSupplyOutputs_;
    LpSourceInfo*    receiverSupplyInputs_;
    LpSourceInfo*    receiverSupplyOutputs_;
    LpSourceInfo*    repeaterSupply_;
    UpfDesignDirection  repeaterAppliesTo_;
    LpSourceInfo*    srcSupply_;
    LpSourceInfo*    sinkSupply_;
    SupplyNetPair*      spair_;
    LpSourceInfo*      rspair_;
    XoverGateL          vhGatesL_;
    XoverGateL          vhGatesInputsL_;
    XoverGateL          vhGatesOutputsL_;
    ReinitType    reinit_;
    LowerDomainBoundaryData* scopeLDBData_;
    void*         hook_;
    char* masterModuleName_;
    unsigned int  id_;
    int           cellId_;
    int           srsnStraIndex_;
    int           spaStraIndex_;
    unsigned      isDesignTop_ : 1,
                  corEn_ : 1,
                  isRuntimeConfigurationEnabled_:1,
                  isIsoTerminalBoundary_ : 1,
                  isRelatedDefaultPrimaryInputs_ : 1,
                  isRelatedDefaultPrimaryOutputs_ : 1,
                  isAlwaysOn_ : 1,
                  isLowerDomainBoundaryAttributeSet_: 1,
                  lowerDomainBoundary_: 1,
                  isTerminalBoundary_ : 1;
    unsigned int  file_line_;
};

NAMESPACE_UPFIR_END

#endif
# 314 "/remote/vgrnd13/bpham/VCS/lp-src/upf/upfir/UpfModel.hh"
# 21 "CpfRetentionStrategy.cc" 2


NAMESPACE_CPFIR_BEGIN

CpfRetentionStrategyImpl::CpfRetentionStrategyImpl(
    const std::string & name,
    const std::string & assocDomain,
    const std::string & saveLevel,
    const std::string & restoreLevel,
    const std::string & saveEdge,
    const std::string & restoreEdge,
    const std::string & savePreCond,
    const std::string & restorePreCond,
    const std::string & retTargetType,
    const std::list<std::string> & instanceList,
    const std::list<std::string> & excludeInstanceList,
    const char                        * fileName,
    unsigned                            lineNo)
{
    retName_ = (char*)GET_CPF_LIFE_GUARD->createVolatileStr(strlen(name.c_str())+1);
    strcpy(retName_, name.c_str());
    powerDomain_ = 0;
    saveLevel_ = 0;
    restoreLevel_ = 0;
    saveEdge_ = 0;
    restoreEdge_ = 0;
    savePreCond_ = 0;
    restorePreCond_ = 0;
    parseInfo_ = new ParseOnlyDesignInfo(saveLevel,restoreLevel,saveEdge,restoreEdge,savePreCond,restorePreCond,instanceList,excludeInstanceList);
    parsePowerInfo_ = new ParseOnlyPowerInfo(assocDomain);
    retTargetType_ = CpfRetentionStrategyImpl::convertStringToRetTargetTypeEnum(retTargetType);
    fileName_ = (char*)GET_CPF_LIFE_GUARD->createVolatileStr(strlen(fileName)+1);
    strcpy(fileName_, fileName);
    lineNo_ = lineNo;
    id_ =0;
}

CpfRetentionStrategyImpl::CpfRetentionStrategyImpl()
{
    retName_ =0;
    powerDomain_ = 0;
    saveLevel_ = 0;
    restoreLevel_ = 0;
    saveEdge_ = 0;
    restoreEdge_ = 0;
    savePreCond_ = 0;
    restorePreCond_ = 0;
    parseInfo_ = 0;
    parsePowerInfo_ = 0;
    retTargetType_ = UPFIR::Flop;
    fileName_ =0;
    lineNo_ = 0;
    id_ =0;
}

CpfRetentionStrategyImpl::~CpfRetentionStrategyImpl()
{
    if (retName_) {
        GET_CPF_LIFE_GUARD->destroyVolatileStr(retName_);
    }
    if (parseInfo_) {
        delete parseInfo_;
    }
    if (parsePowerInfo_) {
        delete parsePowerInfo_;
    }
    if (fileName_) {
        GET_CPF_LIFE_GUARD->destroyVolatileStr(fileName_);
    }
}


VCS_IMPL_SERIALIZABLE(CpfRetentionStrategyImpl, 1);

void CpfRetentionStrategyImpl::serialize(UPFIR::ser::Archive& ar)
{
    ar & retName_;
    ar & powerDomain_;
    ar & saveLevel_;
    ar & restoreLevel_;
    ar & vcs::generic::serialization::Enum<UPFIR::CpfRetTarget>(retTargetType_);
    ar & saveEdge_;
    ar & restoreEdge_;
    ar & savePreCond_;
    ar & restorePreCond_;
    ar & instanceList_;
    ar & excludeInstanceList_;
    ar & id_;
}

void CpfRetentionStrategyImpl::print() const
{
    std::string instances("{");
    UPFIR::DesignObjectLI dobjLi(instanceList_);
    UPFIR::DesignObject *dobj;
    while ((dobj = dobjLi++)) {
        instances += dobj->getName();
        instances += " ";
    }
    instances += "}";

    std::string exclInstances("{");
    UPFIR::DesignObjectLI dobjLi1(excludeInstanceList_);
    while ((dobj = dobjLi1++)) {
        exclInstances += dobj->getName();
        exclInstances += " ";
    }
    exclInstances += "}";

    std::cout << "create_state_retention_rule -name " << retName_
              << (powerDomain_? " -powerdomain " : "")
              << (powerDomain_ ? powerDomain_->getName() :"")
              << (!instanceList_.isEmpty() ? " -instances " : "")
              << (!instanceList_.isEmpty() ? instances : "")
              << (!excludeInstanceList_.isEmpty() ? " -exclude_instances " : "")
              << (!excludeInstanceList_.isEmpty() ? exclInstances : "")
              << (saveEdge_ ? "-save_edge " : "")
              << (saveEdge_ ? saveEdge_->getBooleanString() : "")
              << (restoreEdge_ ? "-restore_edge " : "")
              << (restoreEdge_ ?restoreEdge_ ->getBooleanString() : "")
              << (saveLevel_ ? "-save_level " : "")
              << (saveLevel_?saveLevel_ ->getBooleanString() : "")
              << (restoreLevel_ ? "-restore_level " : "")
              << (restoreLevel_ ?restoreLevel_ ->getBooleanString() : "")
              << (savePreCond_ ? "-save_precondition " : "")
              << (savePreCond_ ?savePreCond_ ->getBooleanString() : "")
              << (restorePreCond_ ? "-restore_precondition " : "")
              << (restorePreCond_ ?restorePreCond_ ->getBooleanString() : "")
              << std::endl;

}


UPFIR::CpfRetTarget CpfRetentionStrategyImpl::convertStringToRetTargetTypeEnum(std::string strType)
{
    if(!strType.compare("flop"))
        return UPFIR::Flop;
    else if(!strType.compare("latch"))
        return UPFIR::Latch;
    else
        return UPFIR::Both;
}

bool CpfRetentionStrategyImpl::deepCopySingleInCurrentScope()
{
    CPFIR::CpfPowerNetworkImpl *pn = CPFIR::CpfPowerNetworkImpl::getInstance();
    UPFIR::PowerScope *currScope = pn->getCurrentPowerScope();
    //Do a deep copy of local members
    CpfRetentionStrategyImpl* newCopy = new CpfRetentionStrategyImpl();
    newCopy->retName_ = (char*)GET_CPF_LIFE_GUARD->createVolatileStr(strlen(retName_)+1);
    strcpy(newCopy->retName_, retName_);
    newCopy->powerDomain_ = powerDomain_;
    newCopy->saveEdge_ = saveEdge_;
    newCopy->restoreEdge_ = restoreEdge_;
    newCopy->saveLevel_ = saveLevel_;
    newCopy->restoreLevel_ = restoreLevel_;
    newCopy->savePreCond_ = savePreCond_;
    newCopy->restorePreCond_ = restorePreCond_;
    newCopy->fileName_ = (char*)GET_CPF_LIFE_GUARD->createVolatileStr(strlen(fileName_)+1);
    strcpy(newCopy->fileName_, fileName_);
    newCopy->lineNo_ = lineNo_;
    if (parseInfo_) {
        newCopy->parseInfo_ = new ParseOnlyDesignInfo(*parseInfo_);
    }
    if (parsePowerInfo_) {
        newCopy->parsePowerInfo_ = new ParseOnlyPowerInfo(*parsePowerInfo_);
    }
    //Elaborate scope info on to the local members
    if (!newCopy->elaborateInCurrentScope() || pn->hasUpfError()) {
        delete newCopy;
        return false;
    }
    //register the current object to the currect powerdesign
    currScope->getPowerDesign()->addRetentionStrategy(newCopy);
    return true;
}


bool CpfRetentionStrategyImpl::elaborateInCurrentScope()
{
    CPFIR::CpfPowerNetworkImpl *pn = CPFIR::CpfPowerNetworkImpl::getInstance();
    UPFIR::PowerScope *currScope = pn->getCurrentPowerScope();
    QueryCmdType cmdType = UPFIR::RETENTION;

    if (this->getRetentionTargetType() == UPFIR::Flop)
    {
        cmdType = UPFIR::RETENTION_FLOP;
    }
    else if (this->getRetentionTargetType() == UPFIR::Latch)
    {
        cmdType = UPFIR::RETENTION_LATCH;
    }

    //Elaborating current retention name
    std::string retName(currScope->getName());
    retName += "/";
    retName += retName_;
    GET_CPF_LIFE_GUARD->destroyVolatileStr(retName_);
    retName_ = (char*)GET_CPF_LIFE_GUARD->createVolatileStr(strlen(retName.c_str())+1);
    strcpy(retName_, retName.c_str());

    if (!parseInfo_) {
        return true;
    }

    pn->addRetention(this);

    if (!(parseInfo_->getSaveLevel().empty())) {
        saveLevel_ = UPFIR::createExprFromString(parseInfo_->getSaveLevel().c_str(),0,0);
        if(!saveLevel_)
            return false;
    }

    if (!(parseInfo_->getRestoreLevel().empty())) {
        restoreLevel_ = UPFIR::createExprFromString(parseInfo_->getRestoreLevel().c_str(),0,0);
        if(!restoreLevel_)
            return false;
    }

    if (!(parseInfo_->getRestoreEdge().empty())) {
        restoreEdge_ = UPFIR::createExprFromString(parseInfo_->getRestoreEdge().c_str(),0,0);
        if(!restoreEdge_)
            return false;
    }

    if (!(parseInfo_->getSaveEdge().empty())) {
        saveEdge_ = UPFIR::createExprFromString(parseInfo_->getSaveEdge().c_str(),0,0);
        if(!saveEdge_)
            return false;
    }

    if (!(parseInfo_->getSavePreCond().empty())) {
        savePreCond_ = UPFIR::createExprFromString(parseInfo_->getSavePreCond().c_str(),0,0);
        if(!savePreCond_)
            return false;
    }

    if (!(parseInfo_->getRestorePreCond().empty())) {
        restorePreCond_ = UPFIR::createExprFromString(parseInfo_->getRestorePreCond().c_str(),0,0);
        if(!restorePreCond_)
            return false;
    }

    UPFIR::DesignQueryImplL queryElemL;
    UPFIR::DesignElementType dType;
    memset(&dType,0,sizeof(UPFIR::DesignElementType));

    std::list<std::string>::const_iterator elemIter = parseInfo_->getInstances().begin();
    std::list<std::string>::const_iterator elemIterEnd = parseInfo_->getInstances().end();

    for ( ; elemIter != elemIterEnd ; elemIter++)
    {
        const char *elem = (*elemIter).c_str();
        UPFIR::DesignQueryImpl *qEle = new UPFIR::DesignQueryImpl(elem,
                                                                  cmdType, 0, lineNo_);
        queryElemL.append(qEle);

        UPFIR::DesignObject *dObj = qEle->getExactDesignObject();
        if (dObj) {
            UPFIR::DesignElementType dType = dObj->getElementType();
            if (!(dType.DESIGN_MOD_INSTANCE ||  dType.DESIGN_TOP_MODULE  ||  dType.DESIGN_SIGNAL ))
            {
                vcsMsgReport2("CPF_DOTE", fileName_, lineNo_, 0, 0,
                              dObj->getName(), "Instance");
                if(!queryElemL.isEmpty()) queryElemL.detachItems();
                return false;
            }
        }
    }

    if (!queryElemL.isEmpty()) {
        UPFIR::DesignQueryImpl *qel = 0;
        while ((qel = queryElemL.detachFirst())) {
            addElements(qel);
        }
    }

    elemIter = parseInfo_->getExclusionInstances().begin();
    elemIterEnd = parseInfo_->getExclusionInstances().end();

    for ( ; elemIter != elemIterEnd ; elemIter++)
    {
        const char *elem = (*elemIter).c_str();
        UPFIR::DesignQueryImpl *qEle = new UPFIR::DesignQueryImpl(elem,
                                                                  UPFIR::RETENTION_EXCLUDE, 0, lineNo_);
        queryElemL.append(qEle);

        UPFIR::DesignObject *dObj = qEle->getExactDesignObject();
        if (dObj) {
            UPFIR::DesignElementType dType = dObj->getElementType();
            if (!(dType.DESIGN_MOD_INSTANCE ||  dType.DESIGN_TOP_MODULE  ||  dType.DESIGN_SIGNAL ))
            {
                vcsMsgReport2("CPF_DOTE", fileName_, lineNo_, 0, 0,
                              dObj->getName(), " Exclusion Instance");
                if(!queryElemL.isEmpty()) queryElemL.detachItems();
                return false;
            }
        }
    }

    if (!queryElemL.isEmpty()) {
        UPFIR::DesignQueryImpl *qel = 0;
        while ((qel = queryElemL.detachFirst())) {
            addExcludeElements(qel);
        }
    }

    return true;
}


bool CpfRetentionStrategyImpl::resolveCrossRefsInCurrentScope()
{
    if (!parsePowerInfo_) {
        return true;
    }

    CPFIR::CpfPowerNetworkImpl *pn = CPFIR::CpfPowerNetworkImpl::getInstance();
    UPFIR::PowerScope *currScope = pn->getCurrentPowerScope();
    std::string scopeName(currScope->getName());

    if(!((parsePowerInfo_->getAssocPowerDomain()).empty()))
    {
        std::string assocDomainName(scopeName);
        assocDomainName += "/";
        assocDomainName += (parsePowerInfo_->getAssocPowerDomain());
        PowerDomain* pd = (currScope->getPowerDesign())->findPowerDomain(assocDomainName.c_str());
        if (!pd) {
            vcsMsgReport2("CPF_PONF", fileName_, lineNo_, 0, 0,
                          "Power Domain",assocDomainName.c_str() );
            return false;
        }
        this->setAssocPowerDomain(pd);
        (static_cast<CpfPowerDomainImpl*>(pd))->addRetention(this);
    }

    delete parsePowerInfo_;
    parsePowerInfo_ = 0;
    return true;
}

bool CpfRetentionStrategyImpl::populateElementFromQueryObject()
{
    //populate instances for PD
    if (!wcInstances_.isEmpty()) {
        DesignQueryImplLI queryeli(wcInstances_);
        DesignQueryImpl  *queryElem;
        while ((queryElem = queryeli++)) {
            queryElem->getValidObjectList(instanceList_);
            delete queryElem;
        }
        wcInstances_.detachItems();
    }

    if (!wcExclInstances_.isEmpty()) {
        DesignQueryImplLI queryeli(wcExclInstances_);
        DesignQueryImpl  *queryElem;
        while ((queryElem = queryeli++)) {
            queryElem->getValidObjectList(excludeInstanceList_);
            delete queryElem;
        }
        wcExclInstances_.detachItems();
    }

    return true;

}

bool CpfRetentionStrategyImpl::isExcludeElement(void *inst)
{
    UPFIR::DesignObjectLI nli (excludeInstanceList_);
    UPFIR::DesignObject *u;

    while ((u = nli++))
    {
        if (inst == u->getTargetInstance() && (u->isInstance()))
        {
            return true;
        }
    }
    return false;
}

NAMESPACE_CPFIR_END


